{"docstore/metadata": {"a2db4d93-478d-41f9-854e-ac00ecdc385e": {"doc_hash": "7c3336deba83c9e086d6832ea1a6d37fbcb134c6aeb33e39c0bc53b69a950b5a"}, "8dc8bd56-044a-49fb-b25f-fa4a962f22d7": {"doc_hash": "6f5aa154506f6645687ca785865fb4b07a561e50d2cba81056a2bb46b9a99788"}, "952ee93d-bd91-4bde-a0bc-9b8cdd0a6a21": {"doc_hash": "92feb74c6079b21c407d9cb8537e9f1934db3739999440d84384f8e918c4e47b"}, "232065f1-a3f6-4a17-8141-6c5b1bc76815": {"doc_hash": "e8850e62cc2159ffb2c0d2a74e65eeb5511171738ccfd7310728c73f00c74981"}, "02937c03-d483-4c9c-a72a-d6fb5c404d07": {"doc_hash": "58f72bc95acabfe4cae8b518a40376063b1be4798cf6732eabf5d00d2e0ee0c1"}, "bd6f9dea-4c77-4eab-b10a-48786c0ae72e": {"doc_hash": "c710de21d73c28eced8fe21deeb624961571402ec4458fe41cb6af32b6cee867"}, "73f06905-736f-400e-9ee7-3b2fd11b4a67": {"doc_hash": "890581928b8f3a88b8866a16f4895e99a906b9912126ba7b1cdb608457a3ce1a"}, "0e2e156c-cf58-408b-ba54-48e464653d7e": {"doc_hash": "897be8783a10554ae022f6dd1bc7dc85fae237458914bc531cd1dc5eeb1aec76"}, "05a5ab7b-df62-46b4-b820-b52b9a506faf": {"doc_hash": "de2923166c5de30bfc0193e929ab08e65a19abb509dd8b0a12ee0292306113e7"}, "280e6d87-8024-421d-9fcc-03f568fc6f58": {"doc_hash": "9e5fea98bbba5194e411e2051308f431fde2c0b3f60b3b3019654f68de7d381a"}, "349c5ccd-be65-415c-aac4-f3b81836c034": {"doc_hash": "0e11427cf9eb404f3740c586be16a3dbea2c518544d97aa0b93695ae3352a87f"}, "a34828f0-90e0-4b3d-8c46-30c6ad528e36": {"doc_hash": "372ab55a63d13c5e6f9771a548bb3473e92ae67ac9bff0f464852a90c1138752"}, "9c63ba09-c6c5-43e0-b331-933214fc3cae": {"doc_hash": "d627b7844457fb9967d4f78d4c2c894603c2286b3fb32c9ef160799d78d24222"}, "6ed63bc5-b14b-4535-92a1-f9b2f6ecdc62": {"doc_hash": "c456d66c95de246b33ef5e2a68903f8d27048b2a09be2df55cce16b94e7c7e18"}, "66b0032c-dda4-4450-aeb9-f62f1f9b938f": {"doc_hash": "3602ed0797ca3d8489cd88f337719161c5c3f610e270b2a4072f3fa71bcb9bf7"}, "f874ffd9-0acf-4695-9401-58d482ee6018": {"doc_hash": "7cc1d9d9afd442a0b66ae954e8959e472a60d9ee9f996dfecb15cd89050e8242"}, "349d3747-7a1d-4840-a597-0a2a21fa6449": {"doc_hash": "3f4e01ae3aec762992f3bc85a9d317a236f33eefda2b3b0ced42f92431abeb5e"}, "9964a53e-7ff8-4752-9d1c-d74f09e0d40c": {"doc_hash": "ff1fc2859fccabf57cf36768ec56efcc56d7c60f035ef6c443afea48a9ac041e"}, "6dd1ced5-a7fa-4142-b75c-92c5143bd86f": {"doc_hash": "aab2150b218d7248a9d2ceab3e9074682902845b990f0f986561a64528a13709"}, "27b92255-346f-4de7-aa0a-a9fd7f7c633b": {"doc_hash": "e781e65cb9290b35a64056b1d6c75fa9324b43249be260d962866ed683f7b836"}, "e02854ae-4f52-44e1-87c6-73c27a837178": {"doc_hash": "47a9560da6a65546165e34fda2bc3e541add1c1e2902e4f58b0504b0522cc617"}, "9d0829cc-d899-4ccb-8000-ac4a50ad7342": {"doc_hash": "fbaffad9b286a985cdfe79cd859e43fac184b04a990a7c4287aaa84543ee611f"}, "2e694b4f-c6e0-4619-869e-7aca237cec54": {"doc_hash": "35b582212611ccda69cc74c50358dff4ea022a2bc98a811f3f4bca5c1c6fbb9d"}, "72acecb6-1edc-427a-9ba0-610d001f4b23": {"doc_hash": "a1cd9b29ed64ddf790157a2a810bbe4ef99fe444824075bbb668cf3d1d987cc9"}, "caee6ebc-b481-4dde-89ef-7e7f158d3fae": {"doc_hash": "ba492e4f3e7533258e15ae1e19987b9aaa71f284857fc8021417cbad03092b55"}, "232dc53c-2bd6-4f60-92dd-44d316e90306": {"doc_hash": "3b45cafebab5660a1b8e35b7d0199a660323d2a72995c9bdfed0b81a28ce5d22"}, "622463d1-cc6d-4f08-9c2e-1d2f6eec2ea0": {"doc_hash": "1b696f3bb25404eb58595f88589a0a672d2c2f30e85c4b5e930633b8fb3394b4"}, "6331a59d-9d97-4288-be16-f28988c47506": {"doc_hash": "0d93be48d54d47be8cd2cd6580044f0de94b3819a35499d1ca946216e5b71474"}, "e53be7b2-5055-4061-8c85-210d78e48729": {"doc_hash": "15bc19a460422e63289c0fc4cd5abdab29b7ae35dfea0976380df5b80fc1822e"}, "e99575af-57cb-4406-8f22-93dac41bfd37": {"doc_hash": "5628f27b6883aba9f9e8d6251bb47e47c00b5d2bc592ec4c150f2b6088d9aa71"}, "b712d817-9524-4a3b-b00e-b751757d35f7": {"doc_hash": "5cc9f9cd0c5afe0cd308b54c1d85e857af395518107d05ae75dd363a40b5ade4"}, "f19ab415-43f2-47a9-ac55-3705725e715e": {"doc_hash": "ece7cc1d0da5ecedab3f91d6a4e36ae5c0c7617fe168bdb7af27bef460781613"}, "ae6c0af1-6f7d-4cfb-91a0-8b798f64f72f": {"doc_hash": "a091ed626267390c6bf089e699f1f69824960ebdee9cd3d0ec5ba0409213dc0d"}, "ddcbb2df-e69e-472b-ac44-e45e716b423b": {"doc_hash": "cd34045c130ba83394f07101f034d2c81b1c6742f9eae08af9ad3a40d1bb9364"}, "9626834a-7ec0-4ff7-b408-cc2b9df00afe": {"doc_hash": "55d782ab4e8e647bd07e0ce892e0bac2cdf2e96ff8f4417229f8424a3bdb4622"}, "a96ae932-9cad-4c1c-b0a6-dde0d450a046": {"doc_hash": "735817bc81894bdc5fb6bdd73a72dded7d3b22d56f3f27c5ce2e85567a00fcba"}, "922b5fa2-966a-4464-8b48-35980117e8de": {"doc_hash": "8015dd36e9238b92ab2da1800b3aeb3499e079722e8fbe8662243daf672074ee"}, "2c8cfafe-c1c4-417b-8eb3-68ae79f08e37": {"doc_hash": "a28e7cb35c64bcd3a55913f1b61bdf0db685da4027d767a2204f3e7e0fa5e65e"}, "8a3ed58e-2270-4c57-960d-03a06fd9b79d": {"doc_hash": "800b1c916d6aed081ec233ef5e9435d5ab66ccb228855cc498a31a25d4aee0d4"}, "fa1c0804-2a72-4f94-875f-2485552dbece": {"doc_hash": "4c23c640109b4ce610146be066728a8198ec1f65cf0a46ec76d1c9839983089b"}, "e625acf1-80ad-4342-b6a9-cde1f645fec6": {"doc_hash": "7e6fa245f065731afc0be1c08f8559e1e13f81b87e30b2bc1f46fa5c73c7dc92"}, "b58e0d57-6645-494f-a6f1-cc7684bca9cc": {"doc_hash": "f1b9b50ba513c05d458fd44ba10cff81867bc198eb8edb15dd0ee555510a1e65"}, "d28a7d48-2c1d-40fa-8990-f7da8a58c3da": {"doc_hash": "311ef080b88c540c127b48f7ccc61f89556140e258cfa864c096864c23335d13"}, "5e2072c3-6e6a-4afa-819c-364c7665357d": {"doc_hash": "e9410ef18c20ea4041a102ffbc785ac715f51256be8a59772f0b6d2870424f57"}, "50bb25ee-21b5-4213-ba28-abd90a245f53": {"doc_hash": "d39f26d4fdc124a17d0ce260067fcad17182030829d8afded76127bef54a5769"}, "523b30e3-cb4e-494b-8558-3a7b07c869d5": {"doc_hash": "5cb28119d7cdee7a2402071348156ebc31ce5a7b4e687b6c36b1c5f444dfe99d"}, "1a990ac3-9da6-4789-a63a-ed581e847763": {"doc_hash": "6f7bb4559369fa275e10a80af90a5ccb6b3deec5cbdc74a1235389d917fc5ed5"}, "f1ffc41d-678e-42b1-aa62-3f6d32228432": {"doc_hash": "9144d43a170e3498c7b394a04a369bd769edf7342fbcde6806bc2522d6a228e5"}, "ccda122c-aa3d-4d08-9b8f-246967a2c446": {"doc_hash": "8e04e279945ca4a9b14bb51afcb360bfa741a801b998f42524738d514e24edbc"}, "73d4a547-88d3-4f62-bab2-798e8ad5e6ab": {"doc_hash": "bbcbe159b507fdda37736dd8bec17b0f36e824af45af7e9ae777f9e2e8a4cb49"}, "d4cb8c25-0f06-4de5-adf1-5864939a8d3b": {"doc_hash": "cbdbfedd8ffb3d19dce080ab511930a2bd071ad29f9aebae1b2f4eda7361338e"}, "c845bf66-3df8-44bb-ac85-aad40ec857e7": {"doc_hash": "8113e6bba959e3dcd848edc6c37b9587a91248a3eb665cc80ee06a9fbe2c37d8"}, "35f5435e-26e4-408b-9e1f-9874883976cd": {"doc_hash": "0ec81b7b2900cac07a2092a4312cac802674cef4fb3b53268efdc986061d1601"}, "189c959f-21a0-411a-8822-c690149e39f5": {"doc_hash": "b4a6151d33ef63522be7c08e4ffb3d1cf253303934c0ef530fb2f443beb4ea15"}, "533a93e7-2c1c-4376-a941-c32c38681f22": {"doc_hash": "6f26a2ba45e9fb62dd9f1aa17337199f5c75dc408776520e4e7589edb7c3ae72"}, "6595748e-04ff-41dc-bcdf-4b9e36cf5699": {"doc_hash": "3a3c30c03a93bceeac78cf6a3301a284b428f4a9178a2700c48978c2e434eedd"}, "bf0f477f-4a62-4d5f-95c6-fdc9edb0cc78": {"doc_hash": "ea316daf717cf51c8d31ac504e26cffc597fc264098fc5ae696e971ecb434fa9"}, "0a49f0b6-51f4-4555-99d2-24137357f1b6": {"doc_hash": "b2952e93e422a58fc3983e770c0abc50376f209caee7e2e64f10b2f8fec2436b"}, "34465ecd-8913-434c-8be0-e4c1b65b2a75": {"doc_hash": "fb4a994a671db24141742fcae85a16e2767c264023859b80fbdeda0790966ae2"}, "a239da65-05bb-49b9-beec-d51e3e3c7395": {"doc_hash": "c9214f0ca862d046a05a80d34b79c37c2464342f6fa453dd342ef35f7e201c10"}, "2c47d2df-6c85-4802-a38c-9c572c76fa83": {"doc_hash": "06523aadadc979705d6e33d3bc449340bd87eab90682edd7b75cdbce3971b020"}, "68e1127f-f84b-42e9-9258-a851fa1516ef": {"doc_hash": "b7d2a88e06ca6aead355b181e690bb5110c7b72fd629a0adec92f4f2da8e4270"}, "ca8c6ee5-bf3a-490e-a3e7-34126f2fc8ab": {"doc_hash": "ba7a2bfd4f5b2249294a0da097b14d09ea183a9919db3e54212df90e1dd63935"}, "69a57614-0ca3-44b1-9f67-2409f49eb6a7": {"doc_hash": "2e4f97d3f051d0ad181237b22a41e90dd2e8d58a2ef3d9fd0820f43e7b29b0d0"}, "c5a5c615-fac9-491a-9ece-b5e969194d82": {"doc_hash": "29d6f9400bc4930805e918531254ef7ef992de7ac47321cf256c6b31c4196b24"}, "08208372-cd7c-4db2-a519-6dc03512194d": {"doc_hash": "6adf58fd0dfbe6f0a4c0e9470bc2ac2fdd3682d133d05765d17170dd09b6ec2c"}, "281e3127-67ab-41ab-b5f7-9c48c65162c1": {"doc_hash": "91b56a0125f409cb995ce6317a26a961a91d4d907c783f096f82058056eb9a41"}, "7ddca281-74e0-4c7c-a2de-9c4449b3438d": {"doc_hash": "2f4b8dc17161ce48ebb0a70bb213947d347e4274edd25b8b6de1546a0990807e"}, "5618bcb4-80d2-4104-ad2b-9e75e4f046b1": {"doc_hash": "59c2186ea941c0d67667165d4b0769adc0d686333431984783702175fa779d3f"}, "51ba3307-62f5-4b77-806b-8e4c6e180f53": {"doc_hash": "ddacbc042b081257e01a1ce4b345efe7306ffc4ea5ec6a20a03728468d0880e7"}, "b7a83828-1427-47ce-a20a-b560dca3e044": {"doc_hash": "a455b08140aa30e03389d3c66b113de950274f8abfc4460f9bb5015ee747e65a"}, "7872acfe-007f-4273-b1a1-3fe33f08d1f6": {"doc_hash": "ffcf5f07c200852284566db2ce9c2bfcc94b878f1dfe6dd1d34832536840d59a"}, "ff27599b-23cf-4963-b2d7-3553d3595860": {"doc_hash": "b67367fc69cead0abc647b7ca91ae759ccb6677a8aae3b276a22e97067c936c9"}, "e05ae904-cc42-49f9-bdd5-6e28cc8751da": {"doc_hash": "bccc37b5f13e8f70ae50796383b090ac92ade12f453d9fc230ca814440530e03"}, "fb8666aa-68b2-4740-990a-c24c3b784ce5": {"doc_hash": "38aac8971720cdf74fe55e4fc315973646db7b5fb36ab1bfc6bcc890712404d4"}, "6e40463b-368d-4853-8fcb-6df7e5914ceb": {"doc_hash": "00b6fd706eee074bf1ed20abef4dc5bc34028a5fc40f1c7c7b8fc7621a6c18c0"}, "3bdd36fd-ccd3-4755-850c-5fd72f861a2f": {"doc_hash": "cd6b53dfc8fbe78906d3f6e379dde3ad192a0abc282fe2f556fb4b294a3be94e"}, "28919f1f-3595-4e98-b8ab-7dbbaae0fa22": {"doc_hash": "9d005428c69f5cf00a5600819dc8bcffec0952983be04e86255c8095ffdd99b6"}, "9ce3c2f0-bdbd-43d3-925b-fad2c9aa7ace": {"doc_hash": "833a949a0acee9e31a0c83082d09a0891f4d96819f24f8f1baa1b456c65a8671"}, "93d4ca37-5017-4348-be98-ebe10d582e9f": {"doc_hash": "8291d2d0ace5700b42f9d7a499593a14dcb33f2f2944b7695ea8a1616ca75415"}, "b6197718-3cf7-48db-9f9d-62eb36c6bc20": {"doc_hash": "fc5bc33a52452a9eb908d115ded49781ccb94188f19e5610a995e47afaff8484"}, "3fb0ddf7-6a63-4976-99d5-81d9621597c1": {"doc_hash": "bc77d9332b85973da1e806b00a73d9222e30482fc5bbc1e0117d0a9b6089d987"}, "c09b1d2f-7f14-4521-b3ad-e7471ad0dd36": {"doc_hash": "42517fd9d89714b2a123a00418e658a7a04766bbec2a29618ad9cbd6e6f7c711"}, "6d9e6084-2972-4740-947d-5b36fe422083": {"doc_hash": "0825472c6b57270f839f86d4574069bc112cd3e8f8c3406ecb0913672066a131"}, "abfb034e-651b-45f4-8fab-7267be82bcf1": {"doc_hash": "36dae84836347ebb8a91abc260ff064a27603f9f4e867dd0f0423d6baf5ce8e6"}, "1174e43b-3329-46cb-8d85-7b9dfc209417": {"doc_hash": "8d37a00820aadd2ac508c4e4f28e3c6c67d1e13ef1e13541378ff184c4387da9"}, "5f4d4dd8-3f82-49d4-a9d4-4245e9aef5fa": {"doc_hash": "e3904bd7492d23d3a7c95c031becca2cb4238a88599149a079df6bd832da55c7"}, "12336e89-94f4-4180-a1ae-086828f185a4": {"doc_hash": "8408a0699c9c6f0ad366f77c411cb1528c7705994b775bfd1f36b7063b68e652"}, "f39f1ba9-af4f-4f73-b490-69afe35ef99f": {"doc_hash": "a07fae2f59a2f4fe550b872019b8caa21556093070dbfe91960c89f783d7c64d"}, "3b525e1d-3416-4264-9c02-a335d7b49007": {"doc_hash": "b446288eace6947449f63ae0e873aaa89c2917dd1b34c69e6183713fe59f0381"}, "45aedabb-c4b2-4ef7-8b0a-c10f987a43d1": {"doc_hash": "7e950a1ee51a6b8f88d8137fd6368d599c76fc11ad6044d480901b7a4c5c8194"}, "abb5ea2a-4e8c-4dd1-bc2f-4eaccf5ffec5": {"doc_hash": "1874f1550abc2bf87a735b7a67b9932b10f710b9118b4d484a0aa3335dfdaa32"}, "70573e35-163a-4d4f-8f1c-5d088cb7fa3b": {"doc_hash": "e5953d5dad1e9849eb21aa8622076454802d96fc0e41df757ca694130a8fad19"}, "beac6bf0-8894-4bf2-9ad5-e4ae79f4bfe9": {"doc_hash": "4a2f467e911ff23f74a59797517093b84b1fecaae184fd6a3d39ae75aaece3e0"}, "997643ee-a5e1-4bd3-9465-be4e95d351fa": {"doc_hash": "1d8d549e7b0f7fc7f5ed668af43d5f36071f8415b9719be3ec3eeb880b5bd2a8"}, "4b6ddc48-0b24-4555-ae21-794c5ef13dfa": {"doc_hash": "e9a37ec7847b7cd153c5ded246278654c57dcbe54c62bc0477d3df306de9d90d"}, "b40427ce-ffda-49ba-99ef-ff7b699644d9": {"doc_hash": "5370819a9cbac20db0062bac8b1be64c1308d7573dcdb0c52bba4423e8bc305f"}, "789bbe72-695f-4ab7-a047-91b1a91020b9": {"doc_hash": "90f775f20c554d284db217e1a3e89f62d71a7f33773d165321cdfb190abfa4f4"}, "c4fdb178-1cca-4c50-b976-15466b8649be": {"doc_hash": "011fe93cf74f788389f221f91f9c3887653cf1e7c010b673d438884755e051d8"}, "d37a99f3-3d38-46b3-98ff-8734a0d3758d": {"doc_hash": "eadd52072b2e54654436182e2065f2356fb78a2edc632ffb64ee70aa51c0bbc4"}, "91f74a62-d09e-4bde-8919-5cb0c5f2f401": {"doc_hash": "06e80ccd8b450a9aaafa78f0af4290be9a791edb042a8cc27a93312561a06090"}, "40de10e3-6785-4418-8a1d-66efe1708d49": {"doc_hash": "e4208e90fe9612a650dd4e931b0c0ae754d158ca5d5415b8c8c6d75a4d5d4412"}, "55b7f496-d32a-48ac-ba72-0ecbe2425a93": {"doc_hash": "42342909ea79753050e46c724e3853775dd288fe73ecb77307dea195546115a8"}, "135ced2b-7734-4e79-a134-6a5c526654d4": {"doc_hash": "5fe923f9bbdcb30e1c354c653f3f45272628796d17124125b25ad0084308bd6f"}, "5435a1a2-7192-432b-b4ed-e9603f82db25": {"doc_hash": "559bd102d4402ab501742304dfe1241c9264c95b06c8a9b4ca405f43603d1ee4"}, "353e16a3-1f1e-4de7-93b0-295a7501dcae": {"doc_hash": "fd949b1f56acd9277a2b43adc895a732041cc00d7c3589f417fd32cf25145a38"}, "67851e26-1fe8-4a23-a5ad-a072309149c7": {"doc_hash": "37465d52f59c3c2359074451f65a3f8b647e3c4a6911bfcaa195b31278074692"}, "9eefa56a-d096-4c61-b870-33b40d351081": {"doc_hash": "68c6c8e74d02e7b7be50784d547915661bda03a66a3c3e69013db762c4d962ba"}, "78a7a7fd-edff-4fc9-bc68-19e1ea95de6b": {"doc_hash": "fa66a5cb164ef53ab5419a0655a1696e9e64ea6299a52bfca5267b8174a8d66e"}, "f3f87614-a692-431f-b14b-2c0f136c393e": {"doc_hash": "dcb0f27b0b82f6b53c8498978a9ed5fe60b8790cbce62f3390e647e5e18e53f4"}, "b0875d76-5f8c-4c10-bc6b-259626110b5c": {"doc_hash": "f02ddc42db6db556cdf6fc25fb26fd46b69f8ca38a8622e58a25f37c5fa82295"}, "8032eb24-a928-4a50-940f-6b069e371d10": {"doc_hash": "c3c3781ed04e8eab77324c07ce3b97d4df532af21516b279fbc323ee4e93a3f0"}, "537f5bd2-52bc-40ca-a657-ba9333b24e68": {"doc_hash": "3ba1b605df3a3ca937a505d48b114090a260ceb05f7835960962930226be9989"}, "1cc53043-6816-4f92-94ac-c33e6557d5a1": {"doc_hash": "6709d091dd9ae52def39922d4f5be2f3bd530c62eec4d0ec72803dbc9fefd76d"}, "c55c34c3-e6ef-4739-9a77-f67c17e518a3": {"doc_hash": "90f0785d482cb74eaadb46241ec5dbebb8cd28327ee0b9fa889e1a0bfff548fd"}, "5abacb1e-7d91-4f45-a11f-d53520734126": {"doc_hash": "32f1f9289d61bf9267aa82371578e0a69f20fd12029ed259bb572114532e2a1b"}, "4f8da87b-526b-4e1b-b2fe-d970dcdfb0c6": {"doc_hash": "c9e306d093cd20c2a071bbfdce9218ffed48b38a6bfa8e93b582611dc064a2ff"}, "8c3b7ec7-1664-4ba8-8e8c-0c016009374f": {"doc_hash": "f18d46bd333d9d71e708154aa6a124bf81b67487b33eb5059375ab5a28763369"}, "4a007a7f-6fcd-4dfe-a989-5c771a8a210d": {"doc_hash": "ad4cffd5b12fe9af712764d3ca467cc070485589d8debf70db79d1b3da1462ad"}, "0ed6055e-bf8e-4ef2-9a91-41ff2aec3f5f": {"doc_hash": "7eda7f8e48f1d37f1ad7196a5f69f46597868e3d483ce8dda257eecf63b747f6"}, "96a33f52-6618-4e83-b15d-f5957fc589a4": {"doc_hash": "bded9d33dcb7558b130c4d610fead22a26701d0b6c7ac268565146d673326f23"}, "50ed038a-0870-4d16-bc9f-85882ad5c8dc": {"doc_hash": "90cb3bcfd4257fb39397a5beac0ce824c63f9e7fb1dc0b156ac94bc8e07223d5"}, "2b2352f0-6ea1-4f21-aa4e-04dd85602588": {"doc_hash": "610bf4eb7341d7148fb42663e8b330c6e500483a280ed89db3548166509e68a6"}, "30dd2b9e-59f1-4566-8c0d-f315121f2ff4": {"doc_hash": "76f5549f040e4cf11a527ce040efbbfc1e7134f47800e1e00b42090be93300b8"}, "b60a689d-eb34-4479-8c6d-c27e5f749093": {"doc_hash": "8c99eec057f9af190ab2d9f0d81cb3c3f639cae58b21c059bd067ff37266a5c1"}, "c7ba0c9d-097a-4ebb-81fd-7a0f08961be4": {"doc_hash": "f6fd88b2086ab8ad379b399ee685f2fdc0f4aada032b548645f5dcee45b5f42c"}, "645cd72d-1260-48b2-b59c-6147aa7bcefd": {"doc_hash": "179acf80373bff6d4b860e30f2689349b8ffa74188118f4d1d23c63d518acf38"}, "42ef401a-78b2-4987-b2fd-bc119f22e3f3": {"doc_hash": "76acf4b07922ee7abc76f0c2b7836e12b4fcf67290c5922910e3426663350898"}, "877a72d0-8837-4d99-a084-82b699287a67": {"doc_hash": "7f1e259bdb1aaf275724aaa85fd9fdf15b298f92b5ef8f990c6837a4a8008445"}, "59fd747a-c9c5-415b-a5b8-6457ac98725c": {"doc_hash": "4944ee9a81c0eaed7ebb4dc8220a0bd0ed37ec5a14e89d7e88291b94f2b708e7"}, "fb053df3-85cf-48a9-bbec-f049fc152d44": {"doc_hash": "10590e21e6c8b091f817c02b9959f6c14feec1ec186dca0889426e3b4bebcd6f"}, "a2c1328c-a9db-4207-8f2d-561d5011b572": {"doc_hash": "e0ac7b6178751548614483d5e3472c949aa462a2b560e6dfcc252d7dab4b181b"}, "b1767e86-a268-4b07-9b70-ee033ed855b7": {"doc_hash": "70643912a38bd54657cd00f0b7e0174c61043f99241b75f20f7fee18dbace87f"}, "5f4bffd3-06c2-4ee7-a0b0-54c559512ed9": {"doc_hash": "f0832cb3712ca32870833b83e7d8158e4e729d800f4e8f959573b22fa005d484"}, "babd0ef2-9432-4135-8f59-5d8a89e8611d": {"doc_hash": "809dbec6d88c30951da04d6888a89395d1cc76fe50bdd254978268259910cb83"}, "ba308d1d-77f8-4dca-80d4-94675cec276d": {"doc_hash": "6ebd2a24b6299a047898b8d9f506a801993e8171a2d67ed8bc806fb3c555aadf"}, "80febbc7-352c-420d-87e3-2e19efe3f38b": {"doc_hash": "dc42184307e080f8d8c8c4dba6666f304bec55aa58f5627dc7ddefb9d0a34cff"}, "69445a51-5d9d-4d92-9fe3-7ffe76401202": {"doc_hash": "1b1afe7624b78f5922f63f7b2aae4cf28ff7b8363663c6ff2e56f8d7516f723c"}, "a252aec2-a725-4e95-bbad-b953fcf3f470": {"doc_hash": "f06cf023ad10607bdc9c1b28f7b7e282cf0c9232d3c82e9eaaa8dbf34a9d1352"}, "0995cfe8-9e82-417c-ba4f-2b505793b352": {"doc_hash": "24e3806221866fd42554dd7e05a8e48368f387c95bd5548b00ec2581c4a428a0"}, "5aec5961-e2a0-4a30-8daf-1fed7a635e4a": {"doc_hash": "3ee9b717f0cd891361d009544401197f4d81623baf331f57f7690f7cdd82d536"}, "d69535b8-b87d-4f21-89f0-2a26d55fafcd": {"doc_hash": "ce94f32600f9b0224ab110a13d112a3be647387afd4ddeafe40a8cb379a01b8e"}, "96588231-34a5-49fc-b60d-f0fe6135f399": {"doc_hash": "1fe74a1e5d3d373a7bc4e0b4dc42fa341edd697eb98f6f587cc29ba53a6dabb4"}, "ba996f5e-6a85-42d3-a901-fad454dd4aea": {"doc_hash": "fd7a2e10afa2fcd3f90f6ae6aaf4f9297c5d1cc1ffbc84c1c9e197ad7e88e6a8"}, "6c1b3640-93eb-4419-933d-755210ada7f4": {"doc_hash": "34a45ad95ee00469ba9e9ced530d1935616943694fb31757faf2665dcfd9c156"}, "ec150734-214d-4e9e-bc23-895c24ae0bbe": {"doc_hash": "f5b304fc95a8ab3225b643345e4c249740682bc9e6c762902087e58aeecc37ff"}, "9bcb6bf7-7609-400e-9903-d242f0c9b400": {"doc_hash": "320c728c0ebe1d50e327f69084bf5519735bd3652296e0166ec6a80b3d9092ff"}, "9c7934fd-5c88-4ff3-b3fc-ada19b41324a": {"doc_hash": "b2627c1547f4ce6c630d9b557e1556201472e6431b5282fb6dd6aeff496b91e7"}, "f40fa376-ef7b-4b64-a694-401b88edf31e": {"doc_hash": "c26bb410db0abb6cf49b177fdf602b9e0e79def8426388188aa8bf2e059eaaec"}, "890e4e38-63f2-445f-9c85-196ece481298": {"doc_hash": "12a532971737453b7432d0d88123c34c5f5dbd32347002812ae9409c024fbcf0"}, "0d38786b-6717-45b0-a497-064c63502de4": {"doc_hash": "72ad390751626e04159302a8a1bb1f37ecd26afc90d72e975de0432e87dc023e"}, "d1763d60-67ff-4468-bba1-c16b77796cb9": {"doc_hash": "f8582d6211acc2554e034a485b10114f2fbede428e84d30946b6d50d6545bf70"}, "381db9ef-1c7e-48b6-9f7f-3c80da0f89cb": {"doc_hash": "2f08c363ba905d813f78eff297f1fa5390137b73f6ca762764edcc60c5ee5977"}, "4fb60b55-e742-439a-b320-584325c8629f": {"doc_hash": "6c7f56c8f7cb838e0246843422c2e34daffd9ec224b65edde75e04b4ab9eca88"}, "ed4d4ec8-b06b-4468-bd9f-4617e9ef5457": {"doc_hash": "ae704d879f4cc12684700f8c7615bb0f404a6f0a2e40be0d1530911cb3e6c9ec"}, "4109bae4-5420-4489-9112-a657642c0cdd": {"doc_hash": "f38bc49532003430d3d0182b3f79e067cd4c7533e6457d4a778143aa85101f2c"}, "4f4179e9-e10a-4c11-b7e7-0f278fd73a4d": {"doc_hash": "f2deccb3272b1a3db73ccf1c505247790ff4b208dac5483ce4fbc04a44211ed6"}, "40d362c3-46ab-4b0a-8a4c-32276ad1ae41": {"doc_hash": "3e64c6ff9e7cdff18fe09d3b4fb590e2feab112d9446375378f0af89fa31cc26"}, "4b29b19e-f806-4f51-b1bf-a1810ff2c1d0": {"doc_hash": "ca284cd4987667ad69164d9868f50562c7ef39ab9448af1e3d5e3e509b9ccba6"}, "94869302-2194-47e9-884e-cd32d683a854": {"doc_hash": "a0befab452f9003a980232da98592d79ed7436863fb46ad41907af60bb370091"}, "41e91be3-333a-4e46-8d0b-660d272132bd": {"doc_hash": "b37b2c27a317914640d2906d93bff35a5742c479d47648997872becb2b0bebe4"}, "192b0cf2-4162-41b9-aad8-99645bc337c0": {"doc_hash": "cc12a6c331f774b507596a5d57283761fa560b29b7da7f9d3b58d874398a95cc"}, "f1a5a5d7-0144-4b6d-8c83-fba4109e613b": {"doc_hash": "003bd35fba795e650fab9edb668c5553341a406be0cb7a5ce560e79a9fa739e2"}, "b0c9a07e-1d32-417a-b31a-4e1d71f17124": {"doc_hash": "d1ac6682cad64feb73b23012c044883cffdfbed770a16927ec4f3bb683089a4c"}, "319ab550-079a-48c5-bccc-0537747da450": {"doc_hash": "d1ae00d3efa2e3d78161f6e95dd944c64adde4e9551b503fcd3a9ddbb3194032"}, "52b8fc11-6573-46fc-b500-044077840daf": {"doc_hash": "dd2d385c9edb6c819463f0a73d1d47a7bd915b44aa303ebb90810079d721dc4b"}, "907c8a0e-89f4-4fd2-9140-4e6477a4bca6": {"doc_hash": "7de87cabd5d68839af65e037f567c3b5beafd9e2d50906280fd9e50c76e26455"}, "243e6d62-f1b3-4a21-8f25-c7b69c9d3675": {"doc_hash": "4c082185f14ff14e615d7236fdb30eea3da581ad1b5137f56858532f57470926"}, "4384ed07-1b67-4025-8809-07d3a03dde04": {"doc_hash": "598e081451befdf1d94c8e394fd6521fe0345ef9e948fc69bfadcc1cb52e3cc2"}, "e660c20d-1c2d-4d14-ad0c-5da0fd198711": {"doc_hash": "8e0c2ddd38167000f182ffded4266433fe5a91f7c6c840a29e8ee8eb04f9cf6f"}, "241fef15-a22e-4bef-b628-5db30369c15e": {"doc_hash": "c2b76862421869fddf78c6b886f62d35442abc3e1b83b26f1c2694f15132767a"}, "19952d28-562d-4bad-8415-0b682240d1b3": {"doc_hash": "a532d70605d0ab52634e68ac1f335c8d00e5ffe662f37556102ab314a3cbd9c4"}, "a09f3677-6c4b-4e3d-a2e6-94660c7a40b9": {"doc_hash": "aef6e9d07c714e973b11c46348fe0b55e27731e821ab775708017fa1d8abbbb2"}, "675d5242-18ac-4d68-9b5f-e50ed7537571": {"doc_hash": "ce5b2fc4a46dacef894880b875f44364b299a494c3019fd0ece6cc048ee1f8ed"}, "8763dfff-1300-4ae4-809b-8c79dda2853d": {"doc_hash": "e631379e094985f9221418ae96df9bea90f12b271d552d9e476a9089e0a0a976"}, "c3234f86-a66c-42f3-aa26-28806439a34f": {"doc_hash": "e354d4f6256a2779d12ec4be0a93278b765637c2ee03e64768d437d77b54186d"}, "872e2a71-b8da-405a-ae5e-8fce5146b5b4": {"doc_hash": "16120897c94eafa68425062c54973aafa68629270fcd7275446fa6f3eb809354"}, "d6690399-8d4d-4c0c-9218-c6f59defe403": {"doc_hash": "59b6aed9e165ca36b2aa3a31835d166b39bc16b9e3015863453509c0c82a5a6d"}, "76ac472a-532c-4781-9367-24153497750a": {"doc_hash": "cdbdf28a339abe91d1ae3dcb7fb41e1de82fe71885f9e8bd15b734b449615093"}, "ba66fc38-9864-4479-80a8-74f974d2bb6d": {"doc_hash": "db867547d22b31656aa1a1a7f61efd6f1bb8cef036b119831d345bf5ca846627"}, "d50bd706-4d5b-402d-9957-a64b602e9f2e": {"doc_hash": "d26da4ed625893088e17c3049dd79b7d435979d0b2da6335bd03157e9482ca06"}, "02ba2420-4cd0-4e95-9db3-5a58b76afdfe": {"doc_hash": "9ba630c884a5676c7687853f0c55d4ed165fe024b24e79da037e2c1638325cbc"}, "593adb84-6605-4d25-aca9-977e60b714ae": {"doc_hash": "24574cef37093d520fac4ce54dbd9fae718ebc9320d1f4f423d1dfb8818b2452"}, "dfd3266d-954b-4afb-9436-5d447e330411": {"doc_hash": "15fab55ac3e0421f6c2a3d843fb55202e92f14a2ea5e34dd0738cd9d07a860c7"}, "d4edde6c-d111-4ce2-8bbe-c518d7604a67": {"doc_hash": "de1042a82fba126838c9604b4adaef6800812cf5288c555c6211df8de1aa418f"}, "a7d7aea5-c2fd-4870-8997-9bd621db7cf7": {"doc_hash": "d48404ff04ecb08970e492916fae186b8c440bb0fcd7a30ff06ab1f1a91c7705"}, "d9b27440-4bd2-4bcb-bd3a-ae83d25f9064": {"doc_hash": "112071f56633dda45336fbe0aada26c224b05bb0fd889d0d171ca19a362ef25d"}, "38271f51-2742-425d-a117-6e1b0eeec411": {"doc_hash": "d035efc3567252141d29bfb6431f89ef74dc938b7c309778f937ac1a019b4e8b"}, "fc86198a-d1d9-44d1-abec-e7c14fd9737f": {"doc_hash": "2152199bd5558462133a010cd2c93c2eef8075136fde7d3cc64b9281be88b1e9"}, "83903220-9ce7-4cc1-af3b-a9ad74c529cf": {"doc_hash": "bf239a37cc2bcf6789d7bfabb76dfa6c709afe91f03543f3abbcfc93a43f7ca2"}, "cee7fcd4-5a32-411d-9567-d78c007e3d4e": {"doc_hash": "4d8bd2b18e142c658777dbeafdf6acf8cc9bd3580dcb06f483e370f69c263189"}, "196c5a6c-b58d-40aa-8c95-cc1f1970662e": {"doc_hash": "0bd826ea8cb7d8ff44161d7e8037f1fd8ad6c2cc60669b15bc68058eb24fad00"}, "b9ff4a66-9c57-49a4-b7f2-eaf03145b21e": {"doc_hash": "8a9e0048657af72c11d34954b0345535db3ae5916969d58afde35f3ba92f2668"}, "3dc4a125-9893-4b81-913b-5ba33dd0f0d8": {"doc_hash": "b4d51911025e42439780e1232282e38dbf98a2ad80e556e9749f82010d194eaf"}, "bda1d698-b8a8-400c-b41a-918ebef0aa44": {"doc_hash": "6d6b155901f48a120877e3411a41bab864598b4ab62fd3f134b23655aba4f3e7"}, "824f46c9-0480-46e9-a3b5-ac0bd1401e19": {"doc_hash": "9388563d2516465d8b436fc517430a9fc8ab62a467d14ace1054d50dca9b5bf1"}, "9ea0a5a8-e437-4b5e-a367-9ed4f3337afc": {"doc_hash": "1844fea349509b256a6f6d4c6177cc4f4c037f72a243415d3fbb43b08f08b5c0"}, "2b4782fa-0412-40b1-97ca-d7ffd3255c8c": {"doc_hash": "dead45527ace6bd380895f67a1f83a8d79a906ea521bccc1c0698120712af71a"}, "9d832c29-abd2-46d8-8da9-b5dd8286f820": {"doc_hash": "fd6e39917ab484aba3228ad953cd79719905ef86166dfacf29eb464a1e32627e"}, "c46cec8d-4b18-4203-a747-6b28921794d1": {"doc_hash": "abfcd0bd4eaaa2fcfbd8a69565a3fd87a6f145562e806457a74634b452d50845"}, "fc46fc03-c8b5-4ea5-a581-e160d813ee4e": {"doc_hash": "5a11f9301016a14d4cf5aed3437b757e9290477e56be022b84336d49cd3dfd6b"}, "81111b16-ea16-46d9-95ee-6c58fb31d87d": {"doc_hash": "707ef9f19fa88ec582c8a4e146d6f573c980b7682fea54b77003bd26e6fba100"}, "aa507997-3a52-4a68-8d43-756cfdae3136": {"doc_hash": "ab44693d166b01b0f1a0058d7543123a5a8269b88454cd211d5f82ec20afe06a"}, "07583cca-8eba-46d0-91ea-605ede74dc22": {"doc_hash": "3f917d2f6f2a158021719f9cdbe0c20702f1784bc55b923bf230cfccd4552c4f"}, "cbd1f69f-5c10-4508-8501-24f8291c2b05": {"doc_hash": "e8e3fe633136a863150f6850c4604745f98956522d39f1cf0766089792d4bb24"}, "10b301a8-7223-492f-887e-f759a8a1cc2c": {"doc_hash": "f1bb2784972bab316f4bae44aeddcd9d067f99067ff34048cb5d9823d09c5c33"}, "041234c7-1600-4b73-a5d4-e867956ebf0c": {"doc_hash": "5302ad95d4043c9237100f1f57933aa0a8d3e3d74c9f602d45a2d711950f5dae"}, "3380cc2e-3df7-42ac-833a-e6bf296728eb": {"doc_hash": "65da04da4b1c43351faa73241a92dd0e3421bf87e5c8ce6f7e0bd39489b1dbb6"}, "02d76795-eaba-4ed1-8bf2-659f7aa6326a": {"doc_hash": "4fb828d6e17635d1ffd2a7958445b17c99e8d02faea47de46ef7d68b79c0409e"}, "e5c6a075-379f-4d9d-9775-8f84a43b7ea5": {"doc_hash": "77a23ed423967d704d6ef04f25464d27a314b20b6a5e234f97935bb7e1749b86"}, "74dadc59-b66e-4757-89f8-686ec1c3708d": {"doc_hash": "3fb81218b52d1a1c813d3657a7a5882b344ff28246cb610c5452ca2934410a44"}, "35b781d6-2922-439a-b102-34fff1377e4d": {"doc_hash": "163cebdb6115f019bf6849c1776e8bb029a2447d7438db78ced834ac7f62d831"}, "a4fcc676-0028-458e-9b6f-7220d5062a60": {"doc_hash": "16e932f70aa764f2998311d1d44cad0092f94a8b361a6b85500cd6eb3a20f0c0"}, "cdf87a20-a1eb-41b6-b552-2f7ceba552d3": {"doc_hash": "e91858bdc48242b642437b2c49e5cf52896ac8ebbd365f30633e231e52ba9810"}, "be32b414-a3a0-4d5e-8dcb-55a866f60059": {"doc_hash": "5139e78eb6a7e2202655b62529187c6c1b9da6a883cf1fb94ac5e1ae1b935edf"}, "34e4a08c-4117-4939-8dfc-111168e33bf6": {"doc_hash": "80074abbdca188b6cb12eecf88b307dad4ed08bb10619b90d7d6ac1b31918de8"}, "435a0a43-2c54-4ce1-8da1-20f39b410155": {"doc_hash": "2f29b5a22e2436332892ff830cd196d9dca20669ebdc6ce722d6258ed756a59e"}, "38ccf581-9aa9-41f6-b4bf-703151dcd81b": {"doc_hash": "d8d96c0248827e8111b1fe88f4869a9d3a048d5eb2a9c26bae2048167e95962e"}, "99233656-309f-4cd2-bafe-c7ef630e8b40": {"doc_hash": "3f2a90e453a5c1ed9aebc47270d3d54d4866a2b4883aea10c2214525d0aeb7a2"}, "2607745b-1b5f-45d2-b723-325b9926861c": {"doc_hash": "d8eb5ba1df563b99bb85c6b7c0a48dbd3394389499510fb40c620e51170f1185"}, "a1865110-e92f-4490-a66c-41a5986d2898": {"doc_hash": "64dc447296dd3a8074cf813b52796a19a33ddf6bc4b93afdaa9ad3011603b5af"}, "1fca6e8d-3298-4c5a-b651-df9b9fcae83f": {"doc_hash": "005e892081f28d6f1292c810be3ae38fda3a608111a234e4aba87e3458b12720"}, "e5254c1f-3c1c-4538-84b4-76ca69262ea5": {"doc_hash": "880cef35f5bd65829f1a05976ed6cefaed95c36590be97345969733ce9e5e611"}, "b3483f2a-ff89-438e-997c-40309420a7b2": {"doc_hash": "98697c55a0028f7b37d1e0bc46de126db8687f54d1154195c4316d2eca5ae998"}, "90f14eae-babe-4be2-b2d0-215aab0df56f": {"doc_hash": "20489de8a7122b9844202290a513045322609560c7d68eda4c24e99db3fbe7de"}, "a04f63cf-9288-41f4-8ce3-8a092591324a": {"doc_hash": "7d058d5d09c407b2277c7502cd4fa0dd3809a6021611858a640f05e27ffb5dfd"}, "ceeb34e3-8a46-4760-9118-85ed595600b6": {"doc_hash": "55e4ba61a77482a97a685dc77454eab68ef4c068b8d0ebe67f0f0702e3137768"}, "ed270ae0-a880-405a-a730-219188cbca54": {"doc_hash": "6abae6d643190cfa421ee384d7cf50372028dfcd4a2d6c6355166c2f11017409"}, "d5543c12-2d1e-463d-88ed-36e6af8b561d": {"doc_hash": "d712b82e32194c748579443a195c33f33d0fb84f3bb771fddaf1c583c47e7491"}, "19a8eec9-d533-4f3b-bffc-f47beb61826b": {"doc_hash": "c32cee9885151196c72fb59af200db1a6145b53f5364c783e27db7048e964db2"}, "09899ee6-ddbb-4bcd-aa31-a0b53b2f273a": {"doc_hash": "3f17349b8335f3ab9e0500c4e494e22aa4ff72524f557283293eef529b32460b"}, "f151602c-c8b5-4949-abfe-b1a67a978a85": {"doc_hash": "3e62bcaa9700d5050886acacca787bc8b4488f6ec3ae4415f981ce8a69d21885"}, "5062b202-8316-440a-a29b-c4abfa743f10": {"doc_hash": "199536a61ba3e351d8ce73edb25293e031a67c2cc0da0f15979aee42ea2821df"}, "89d1c93c-42c3-4ad5-9495-82074de0cb15": {"doc_hash": "d0a9de001b7d58c7433694819dd89233321fad6c52716e9b8df3194b06098e7c"}, "266c220d-5bfc-4fc1-ba02-e69b6c11407f": {"doc_hash": "b500f551025b839feff4393d35a1b51e61598cd8a11d7f2756bc51b47193e78f"}, "bc6c6470-df6e-4cfa-bab0-da0083584302": {"doc_hash": "54dc03a0e65d9071084cf3f52b86f8f812a2eceafc15151a9dce1beaa7cb660a"}, "240cb13e-531d-4556-a481-50d5f4388db2": {"doc_hash": "c4538d70c0ddbb220b460f1230a52422e70f9f4c02967fc3b5f38ce744f394a5"}, "061ce2ad-d8cd-4ad1-9879-bab439d81063": {"doc_hash": "aeeb6c200115bad2d119358d057427b4fa5f2dab3f77caebff46993bd8dd24a8"}, "f45d38b7-9cad-49b8-8f66-ac61a426e089": {"doc_hash": "95020ac5b2aefb028fdd9ae1bed2302441b349afa623ec9a0a82f76646157433"}, "d6bf58e6-7ec4-4f9e-9e53-0bb53d80f9f1": {"doc_hash": "7b2f293a15deaba7dcd03f06b50a9b3388fe90f40886e36542e1b4047485b9cd"}, "e78df40e-b437-40f5-ac1d-b3d5bb686836": {"doc_hash": "d411a09c45216b3549e7188ad9973fc52aeac2fe3edd6c06c67ab456dcd1c7db"}, "12766e2d-8679-4d0d-8ba3-87b81b03e9c1": {"doc_hash": "94550d2d41893ffc5ade845faad0a960cb24de087755256604356fb66f888e20"}, "6c91912b-c304-4570-9039-90bb8c4af655": {"doc_hash": "7ef5cb631002840e69709682795c2126568cbf1cd71beb9d86d8560bf29f6299"}, "24df013c-53c9-4e76-835a-e247653e0040": {"doc_hash": "f8809a40921a156c6581c7afbe319d400da4dc6cf2bafe7fbeaeff978050b9f2"}, "fbcf3197-ec43-49df-bdb9-da8bd4f0b84e": {"doc_hash": "c08630f3b0ac73b8947d2b814dada304bd25e592b9f42b198428a0513b5ffe8c"}, "f8d051eb-a52e-4301-9610-273fff258116": {"doc_hash": "fdac458904716064ec5b01684f132a13b58ce36aa5a0959d313ede6a0e184646"}, "e42c8f67-6977-4b71-adb3-63f6109bdcee": {"doc_hash": "eced25e49268e5c24a53e6c1bfd4309d25d9be3945313ac77ddfcda3ebe097d0"}, "539997ac-9c57-4cf3-87ab-74294fb67884": {"doc_hash": "058641a5c8e54a4c1320d4288196676e88ae3ef65280f97089e37a7e021f86f1"}, "185c1d10-b04f-4d71-88c6-7408f190ebed": {"doc_hash": "67e9c5ded8c61fa033534310523213303e0fb38032ac78fc90edb5f7e395c9ee"}, "41de17aa-b73a-428e-8755-2efe6c2c2524": {"doc_hash": "5ceaefb7ae2943e380b5903e579abdeac80b94fbad5cd9173d0bd8585587efa7"}, "34124fcf-ca8e-4bb2-984e-f6e5fb7ced8b": {"doc_hash": "9c7fd1706f7229223f9571107aaa558054c3a7252c1f4b05139dd40b750bb463"}, "10287aef-2f93-481d-8d5a-a45274a24250": {"doc_hash": "b694e5742fa83b26a5d921850457d639a3d278a98e349898fb326889a0f1d6c6"}, "396640b7-5f35-48ac-8531-5a49f1ebbcc1": {"doc_hash": "50eb2ebab1edc146b1b420cbac0d9c8a5a8832221ccff675af26ce4b3c9e7d6a"}, "091bbe47-8f5b-45cf-acac-a10c6a12bb7b": {"doc_hash": "b04d3c6ac77de0ec64c9bf6685017b9c0d89779997c76a5fd505875e3adc9eca"}, "d552c078-f6fd-4294-b114-4b86eccd9e6d": {"doc_hash": "53f72a7369decb5d9c603b770a6219237cd0dc43f536645286df634ac6ad82dc"}, "9d15e4be-2e23-486b-8e44-136e91a97119": {"doc_hash": "fa6952e0145e080524b21000f27cbe15a89f1148ee20133756d34563dcaa7b1e"}, "6dac1576-1ecc-4ea4-a1c3-9065d0c10895": {"doc_hash": "8cd98b01b0bde7f920b44cbe297e5faf0dd4ead50ee4e2ae43b1467c0258f879"}, "6a64407e-9e4b-4ca9-89f2-faf9e39247e7": {"doc_hash": "192a46fe7754b5d132d143c4fb16fbde1b00ba99ebed10686bdfb839157a7f08"}, "caaeb8c4-c002-4c5c-a41b-7a8e847eb4f4": {"doc_hash": "10b1809e00e41683e2cb93f2b88471dfd4633e16f9cefc6686b6c6b52e9135e2"}, "bcf99c2a-821c-48ec-81b0-283134061b35": {"doc_hash": "82072b03c7b6d5f3680cd153d3dbb22285ca24f47e5b164c15d31a838769ce30"}, "bef06ef2-33b1-40f9-9df1-538af5ab966c": {"doc_hash": "05f2abf6784a43ca20c50f1f515490a43b6b8d25ddd6511bcacc766f52068871"}, "db4b78bc-f3c3-4780-ab9e-61ab3bf79244": {"doc_hash": "0083d4d50f71f655fe2cdc38eb95896f576c34255d6367d318fc15777563f17d"}, "d689753f-fbc6-4ab1-8c57-b37788e2df6e": {"doc_hash": "8bc5bdf84fab10a28e525ab157198a6624f02a915e200bb8d6b9c6d5cdcc9ced"}, "085adcb2-f37e-48e8-96b0-6bfb2c583dad": {"doc_hash": "602a064042fb22c145872a06a6f8277451b3cf03fdbdb4e48460a780b9882443"}, "334a12ca-9753-4128-9b57-8cccf66151ca": {"doc_hash": "a13ff38fa7646db3e0ea15bd5703bff2a5e1f60a6ca5e1f59c5bb9c5328d369c"}, "5b233062-a8b0-4c9b-ad55-a676c80f7a5c": {"doc_hash": "c15a39ed8e44396af88ec419f6351e8869340003c8f6a7e36669069c0de32c78"}, "2a48d728-a618-4aa9-9959-0f78dbb2236d": {"doc_hash": "bc15793cefa5823bbb583264d0a0a991326a90e24f25b89164e0b07f64953c5f"}, "134108e7-cdd1-4af1-b202-286245d077f0": {"doc_hash": "d1751e1bbd619229107f39035af3080631c3d87cad810371d06ff475d5295381"}, "fe625d73-7564-41c2-9bbc-b6e914111614": {"doc_hash": "8736e506cb084a1387f738926c000b4ab5ac6ce9b8bd55e61324c096030c77f2"}, "4d94470b-04a1-4a72-b061-02d6558ddfb7": {"doc_hash": "5bde58b81bc0d983e1e8b62ad772d14a1a2319afe7d4fe07693b038e35a59f61"}, "9f4c3767-0be7-43da-b55f-541289d4fb6c": {"doc_hash": "aa7874028056755965898d3a9b289c72d705d2957445fbe1fd531d27fa03e4ab"}, "fa53c742-95cf-4549-8f19-11201e2fbbaa": {"doc_hash": "3a3341c98246a050df8a5732ab7ae95131ba1ea73a2927552f07133ab8a41975"}, "dab9955d-687d-4514-ac65-6c91ad86ea79": {"doc_hash": "bf41afdcf94f48f2f147c04f4ffd291bc9a74b8e0a7a9309402f9e7702ac8edd"}, "7c66f775-1ee4-4327-ba02-da2e48218d8e": {"doc_hash": "0be488e4a5adfa0b76f6b08c0308b75a59c4512e126e5d8b03bd8e9205589559"}, "eb202163-0c21-41fb-8e30-94dbcbc831d8": {"doc_hash": "b2d2d74e896a12bb3c6420361ed3e563f3821359d05a5ccf60641c3f39c8a260"}, "bfc18b3b-e790-429a-8f95-6635e3b25080": {"doc_hash": "3096f588e991177b09c4f667af0981fa7ad210d22553d31eda063ec5f4ca8c31"}, "f7b7586f-b152-44a7-96c9-ee2cc5fdc651": {"doc_hash": "f0cb04f1729250c7ae8ead5db95b32d608fd18a4429914eff96bd12eedc8965a"}, "1ef9a1c4-a40f-4201-be50-b5c4755e91b3": {"doc_hash": "dca1b797a8cec668b638e8d0a852fbba199c7f478b6b66a750158e58d26b3fdd"}, "ad4a45de-d538-49d9-b300-4086bd0b251d": {"doc_hash": "a627f5c3ce6b48c7e67e417885acaf31fb4b64a6e5bbfbcc618d43957eefb5f0"}, "3a30299b-82bd-4428-8f87-6cf1ac23551d": {"doc_hash": "0bd9285aeb54d2eb32b777cd3295f9d6661e56f2ec0d6fda7a9b00330a2446e8"}, "1895e169-d872-404c-a964-9a03051776da": {"doc_hash": "772f4c0dff5a36c6c76a5f10d61ba9650068fe1e584026589a835d16a5bef2f7"}, "58ec49ee-fcbe-4443-8b6d-94cfd9215cb2": {"doc_hash": "32004571858d2b59e3fdb3f6f1a4076d77f0cbb8444cae4b2ad6f4512145c364"}, "b91112f1-9f78-4fd9-8b6e-98a8fbd279dd": {"doc_hash": "7bd22808888122db87734cef29f9cf57f4a42981ccff35414c0f2d8a9a235468"}, "b91a2124-5798-41d4-bf74-bf6074f9212f": {"doc_hash": "26213119c7dd2d0bb86e216af3ec37641bb851ae23e9271fa108a873dcdbde12"}, "87365a1c-0d72-4971-86d5-960c205dfd9d": {"doc_hash": "8250fe75d87c5c29dbc0b3ca739fed5fc34503ed31d3a0596957f0978f3ff15a"}, "acf92a72-dfde-4e95-9d27-bd6836eadf55": {"doc_hash": "8977187990ffe74e14c9d96bec5237d9c4065e4ffa543f30ae2725a93fb5dfed"}, "189460e0-def7-497d-b0ca-ea6c0845d9fd": {"doc_hash": "9030620e3a653cc3776ba6899321ad0a3df402d5cfb3a58268182bb30fd15f9f"}, "418b398e-9332-42ad-b5f5-88591506a5a3": {"doc_hash": "a8d7bca25a1cd46d7effbbfafa1637bfa89247fc5142d7e1412136f2362f076d"}, "10033000-44b0-48ec-a1bc-4c773ad4a084": {"doc_hash": "57ba553d9bebaa6ccf9537bef1ec4535d4c113083f30f3a64ca1fd668a2c28b2"}, "57c3c531-0ecc-4fc0-b759-cfe7226b4d1d": {"doc_hash": "eebb31cfb999836bb35cefc836e8ffb07ba994377d84c035280bad7c14ec7670"}, "bf82ace2-24fa-45f2-aafe-7efee4de651b": {"doc_hash": "7702e9cbbdcbf726668b20efa74fb498efd024c4f101bc6d329c7757c6b37380"}, "14dccfa6-6fe6-4163-881b-b3c52b467a51": {"doc_hash": "47a75c2f66a317781bd1b51a09a436aea95da9178f272bbb6d5a531b12258349"}, "c354ed06-79de-48e9-be58-189f1ebd6829": {"doc_hash": "e45f558ad6517c0a900997e9df507a297e2e2b1f95c6c440596131a1e1d8c3ba"}, "6e54c8f0-cd49-4df9-90e3-0e36405d62c8": {"doc_hash": "17f81124dd979e86725e416f0de8b246bb650bcdba024b95230eb358884d1932"}, "8f702ea6-b9ab-496a-96ec-ab1b4c378368": {"doc_hash": "12247465d4b517b50d7a7f9ce44451855a3ec7b777ddd3fdcc3ec1b9e660c94e"}, "992befe9-33c0-4af0-a6a9-86853b1e2cb3": {"doc_hash": "8c70a0903065218ac99251adf43c80117a4a77b61c7e9e2d8238f83c299e3120"}, "ad578334-4944-4530-83d1-dc0e7c306be4": {"doc_hash": "2ef8a0b683388293d5adfb2f4a1cc371137707810d0046f0ef02053b3a5c83e9"}, "24f01d5f-2a25-456e-9f4b-5fde6bbe9cca": {"doc_hash": "59d029370294957dc7b0cfb4e81137cd41458e48525ccd812c7681d3d00212a4"}, "965f9e90-5887-44a8-a0cf-20cd75eae70e": {"doc_hash": "c8aafa230033cc8068cb7265f1b7061cbf68c22aa9d96caf3ee09b666c2f42e5"}, "70c84b6f-59db-4f1a-978b-7d6c07d4d66a": {"doc_hash": "c04f1889c2d0d2259603b6655d22a4149ee1d15ef95dbc88cada89391bac7d57"}, "a454ddd4-84d7-4e5d-99e2-85cf6eeb71ae": {"doc_hash": "60e1c36068989ada774574ab099e154b3429ad5f489cb41e176a4b2ded07532d"}, "3cba10fa-f633-4574-9a54-a98c500e64e0": {"doc_hash": "95e3b7f7efe42cc7a0157b3b647e756ba3de307d0459b7711a8450ae737c6fb4"}, "175fc67e-412d-4486-8a6f-5e18d2e8faec": {"doc_hash": "04aad70fbe4a58bcfe85d89803ecd5427f257f2c54613a754297d16a3f217ba2"}, "d3306d79-7b5d-4985-8532-bfe3150e0606": {"doc_hash": "f123b96b571eedf2ca4dc4a101e8624577395b5ee706ce79919d050f62eb48e4"}, "ecbd0405-8f15-4e5c-9ba6-f9906fcf3e2d": {"doc_hash": "5836573b172a839046305f566e270f76adc39e4c9c701e84c75ee83eeaf39fc8"}, "547e7a0f-353a-4706-861a-c24355877ef3": {"doc_hash": "f8a459c0beb6650beb760e44d218499224d8825b0d3db931219f7bd7dfc83181"}, "dc510195-132a-4ca3-8514-ae846fdeecd3": {"doc_hash": "5e1d912002bf8fff518362e6587aeed30fb4d5fd91ad3c75c1bd46ae8b38de4f"}, "25209498-d560-4b3a-a897-f5947df42ec4": {"doc_hash": "8acf34085440ce1e660fc54f80425db9d743e918e4670b2debae11d25fdd2417"}, "79dabdb7-139f-4855-bf15-c9db505e8ae1": {"doc_hash": "b57f50cb2685dd8dcf6fbeebbaff088b56287e428870f043fc34f54210ddb950"}, "8c8957d2-2c18-4a02-baa8-a8935ea42182": {"doc_hash": "744b09a22be0724d0a09408ae0dd6873e035f16712d79a91f7da4e286ef8c6f9"}, "c11d0396-18cf-4af9-a917-a264aa6df6fe": {"doc_hash": "a8416b849f159c3cbcc592215269a2366b837476c3d8d14f8da941dcb2b7b4e2"}, "b18860e3-544e-4388-8a7a-57c645aae78b": {"doc_hash": "a51ab9db21ca049fa7bb242dd80a4c706da8911e82fb4efcbe8bbed75d26929a"}, "37709af3-dd92-4d78-b156-a0766c989ea3": {"doc_hash": "4819aa97b07264784968702b7dfcde09115a0b768056a27bc5ccf7e0b945f3e6"}, "3b2b7b59-b63c-4e3a-a486-c00047389367": {"doc_hash": "3028f2df0267d9191fbb38aca587072265179ef2f158b86a28b1a6a5343533c6"}, "30b79dd9-8ee4-4f30-9045-fda6ce7040e5": {"doc_hash": "98126e95bcb66c056450fd6713518b8aa75c47d799b861476d8086394e6d7871"}, "4c274c06-e3c0-4179-9e65-30dfa366065f": {"doc_hash": "2c0df146130d4bf951cb6798ec27ea689ee8ba3107bc69290391e95d8bf26a3b"}, "b1c3bcf2-903a-48f2-8837-d7d7b9992cf2": {"doc_hash": "664bc42875a9c101b3dd12df2b0bde350ed98b756bf220f0531aba5a60ccab0e"}, "647ac531-c623-473b-a720-2856398b7779": {"doc_hash": "f70a7c51d2b74d7fe354debc9198aca8108bfcccb0be39e87d5c3b8e9710bfa7"}, "fd9c03cc-c7ea-4945-8eed-785ed15a3711": {"doc_hash": "26150c3eb930bc1546de289623f43c214a47c42dc79d611a787b566b0b2a5796"}, "78e95bdf-6fac-43b1-8adf-7b7efcac6873": {"doc_hash": "d7baf329b3cb73a149d6ca0330991aea8fc316e1f4260032c8275d528fe2ab8d"}, "c9ca773d-9df5-4a37-9b18-377337502b0e": {"doc_hash": "dbe95eb0f44b865021d3a5e52dadcc714ae2421bdafc17a6dbb89c1ad74a45da"}, "025227a1-94de-48fa-a762-a01f9ce77a93": {"doc_hash": "e476b6f7a45ab863c80cc514074475f7bd7a2733df7efb74cd4529e2694380e7"}, "85de1bb9-1add-4fe9-9f4c-4b8a02b3ed8b": {"doc_hash": "3282b9f9f85e4ee3601611aa129dd6b23b0c9477b08d98b6f51a3568668034ea"}, "1db1e1bb-bca2-4dcd-86a9-86c0e39b6245": {"doc_hash": "6ad6b61a87191bfbd0f582a66e9861485bef425876e55e2910916a40ab5a7532"}, "b7933e28-cebb-4152-b3fc-5d1a27bfb448": {"doc_hash": "a5de456bb8d7c508f5bafc406eea0c4795c2777fa0dc40e275468cf41fef965b"}, "f21cd616-6c28-4c77-8d53-99708b56184a": {"doc_hash": "f897a06452e0057b463b95e8301e659b72e21787a099670463b1c1b6e269ee8c"}, "5c789962-3d32-448b-82f0-3a27a51d5f7a": {"doc_hash": "173021fe82cfd805c3d22ed428d00dde4a75cceb36e1213d862187bb4e88d77c"}, "6069de7a-f371-4112-ba0e-3ff092ef1557": {"doc_hash": "1fbf4cd62f07754a639487f6e2e9db112ab0c3972244a45ef431c2e6a319d6ef"}, "c838a348-c060-4fde-aa7f-3d163561eeaa": {"doc_hash": "94c4d42f546a5f43bc668c306c1878db341b0a144acfec78594459a41e956073"}, "284b48ad-53ec-4183-87ca-b7c6697a3be4": {"doc_hash": "1cb30ad7b2bda23d3e6b963e22a687c959542ab91ecfa9d47e6765ff642c1c1e"}, "8892484d-8100-4f1c-9cdb-a08d46f9e4f1": {"doc_hash": "b170aa1e906c6e68a226021fdb6a3ddc36b3d1796ca5fd26792efa9fd07ee4e3"}, "c3b52c9e-8c5a-4157-90ee-5997f9b95329": {"doc_hash": "e0447eaa39fa7efdb65aeac864254910fca68dfe834283013104a45df1baf7a3"}, "0a39bd57-4692-43b2-abae-79a39122d3f8": {"doc_hash": "2f236a48fa3062be0c4b1ed35677c80b27732717d4b094c2afb37ffe875e0542"}, "23289a7d-aa14-4d51-88ff-15291ffd2bfb": {"doc_hash": "3a2f8ec716a8184446d07eaacc0e294c3ed1e2f0b32fac193e60163efef58f6f"}, "8191ca02-d0ad-4c53-bdeb-5c38e73e8466": {"doc_hash": "c3d6860e8529a5e0cca607ceb09eb0153558874f7dd4e5065995e5f7c6433828"}, "558347ef-c01f-4909-b2b7-7823a5046394": {"doc_hash": "a3f9e7ffb537bdc07f13d745fe3d370a9cd52b0a9a561640ec7ec73f277c77f7"}, "6a421505-d263-4981-9dc9-19a964ad0549": {"doc_hash": "17122fc80db1c53a1033e4e261518523a84dcca96ccb0aac0d520826331307b4"}, "73b19d30-d135-4480-aa40-ca7841fd77f5": {"doc_hash": "93f1c65523836fcf367943c4e748e1c87f8194b6843492533c1058b357767d38"}, "7f52a7c2-671d-48b0-ae94-6ba21626c8a7": {"doc_hash": "6846862576ba32219510acf1ad631ab295ce111955a4a36f2f3bd5b2e4c8dc77"}, "3f79da35-8cec-48a2-ba96-d398881f3028": {"doc_hash": "9e7d70743b774aea4b3dfc73643ff575d4aee0f4c007fca36dfcd4472110cc31"}, "9ee39cab-1571-4edf-ab54-dae165ddbe15": {"doc_hash": "4e6d90ac2a4d74b2b0dc9cd9acaa72a0882472aa422f4b4df27ad884b70bc072"}, "201475b7-8ee0-4428-aa50-5d0f393797c6": {"doc_hash": "4cd1b465522c7c59a85b5560384b58d9ea87b134ceec921c33262d13737f4e87"}, "39d624de-728b-4f94-af9b-cdb3f55f5164": {"doc_hash": "db5dc2bdb49ff6cfef5492f2a06731144b7ba14904397b8b6dc2e55e7a001053"}, "1c7bbad0-7e6d-49d4-b7f3-1ade925dba64": {"doc_hash": "9d827ed0bf50620e286e63d9b0af5dd77c6b8f9e35a5a82db976df10c23030ca"}, "58863ca4-96e9-476f-bad3-dc0c33e274e1": {"doc_hash": "db03be5d4f43efbeaa0e678fb1c5c3051223f23ccd7dc3037aea0c8086aee157"}, "d9d58a4e-7f1d-49c2-a867-b7f61e4117eb": {"doc_hash": "2e4ea6913fd95564b6dc39a1155edd33c45c48adaa60e0510546f879de6ddfe5"}, "03d70e88-b874-47d4-a3f3-5f4da48ca3b9": {"doc_hash": "2a27294f36f9cf41cb47bc83495e058fcb4fbbd37f6bc947edfcc0d8b7f0ef68"}, "8093e99a-f11a-44c2-b001-7e3bf2adeb12": {"doc_hash": "fa18826f62564ad54898c1f148dc79df55a8d3d5a35e635f473ca06d7f332bdb"}, "2965e681-5294-45f8-9dba-570bb184d1f3": {"doc_hash": "5154e679cc4d0aa70e6ccc950ce8d322cee08399e5dcf376ee30ad1237d34e3e"}, "11550390-0ff4-45c9-a627-433d6fc841eb": {"doc_hash": "52c057ae21383031644013458f7361ecadcd094d249d7e73c9bc5626c910599a"}, "2eed722b-6fa6-49f6-9a14-b47a57e77e6d": {"doc_hash": "17387e5fef76f6378069942df3d8038f32b6c70a3db24eed9ff2e13255b5ebb7"}, "3a6594b0-73c6-497b-a8d0-e51ee6c21e08": {"doc_hash": "c88f753b5706c9883e045773854095736e718d4e85a39d9859995388f2fa03d4"}, "e11ffff3-34e0-46e7-b77f-2db36ad95198": {"doc_hash": "b3b6fba3041ca4da1c9a69f99757dcd6900949932948bfa77d8b447cd8bd8ddc"}, "b32f7654-af3d-469f-be55-7b3b96100a65": {"doc_hash": "23860c3990bc67dced5da49fd93d3754f248c607139ad017d97d94fb4fbb3bb2"}, "24665681-a5ce-42e4-90de-41acc954664b": {"doc_hash": "8ac99abec660c535bd316e7efeba5c30bfd5977b711bcfff5034e7e2811d462b"}, "768ef977-89ca-42db-b4f1-b711f6e53789": {"doc_hash": "7add91d5f5b9b451ccfc85fafbe574d6d6c60f390fb1d3af9b641992ac9c7b74"}, "10d6f798-87da-43a5-82d4-594ea0a7aa8d": {"doc_hash": "e4101a0b3a5b39a438599f08c9574cedd56e96fe5783464e196427deadd0c00e"}, "b1011d14-f38d-4a84-a75e-a918e03b3c29": {"doc_hash": "c1566c8554d64e440d4f486649ae20d312e55d04c5a9207410027b51821f5dd1"}, "2e841ef2-1686-45bb-a3e4-00beeb73dabb": {"doc_hash": "770096459318f9eb2f5358afd3078f6c7b7ecfe9ac131338546089d5aace324d"}, "5c8957ae-04b9-442d-9e75-9b0d46be6559": {"doc_hash": "73955af3e5b82ee5de80c2bad5ff93fdffe91d81a433d47c519f3acce442f99e"}, "94e01a32-60ac-4c2d-8e75-d5f580606e79": {"doc_hash": "834e026d0eb0a2eea51ad44a5de557c2694e1a2de794a55d55b6a8d98ac6c220"}, "ff738cc9-e1eb-481d-ae88-5c195909e1d0": {"doc_hash": "71aea9ac6a5f78d5b2788d6447331e77b44e4436a4b1d073b06e6b2c00063153"}, "6f61f3ac-bbfb-4c0e-b3b1-09c833651488": {"doc_hash": "3830601cd784f30401b73d35a0a1ec9f7170b24b8c4ddda5b58d28823902e70d"}, "63fc7223-2611-40b3-b057-48d65a5ce209": {"doc_hash": "d96a01785ccdeb8fb4c60ab8d00874513304895771e1d4ab619ece53ff61f82d"}, "3410287e-5432-4e8a-87a5-bdb86ce996af": {"doc_hash": "36d054f00dce5e863392c132c97b37b31a3848c7906d909430f43c31d7848a76"}, "f434ef29-1cc4-438a-b9e9-04095722a3c3": {"doc_hash": "29f6d08c668153446f4de68584820eab8574bed7f8652671e122d8c36b77b86d"}, "1b9c5276-3fb5-440b-8ca5-c07fa335a947": {"doc_hash": "694ec3c5e66eac1dc081d5dc56108ccaa056c9b9dcd382a8e445c769cf06c005"}, "586d0e29-2b0a-4e29-ace1-3a4ff4efd3e3": {"doc_hash": "a92c79eab5c87b0b5f968b69780ddd59b6f413d9dceaeb01f8814c9190bd4910"}, "afb10792-2a35-45dc-b1ff-1f17d9e9aa05": {"doc_hash": "9e4a458cb0626a3bab4545f5cee203ce70b200636406ca18337b82c410ed57bb"}, "8e8de8cb-6c28-4757-bbf1-e5a516b37557": {"doc_hash": "466bc1bef10d4e09e73691b0618b705c5dc24b47f4fca4182623c12f8ce43897"}, "28da8162-e475-44e4-8c9b-818e82110e29": {"doc_hash": "7ef42c5414c5e2a8ebda9f6d2fd37155262a3920ae3b2cbaa64f0defec0491a3"}, "5d3cb99a-13a2-41bb-9858-d6558cd6f7b5": {"doc_hash": "02de25e4f24ab900351a6b33af577c39b0a6483e0d051bde4b90925bbfe8f51e"}, "6ba22e10-5130-48a3-8382-ffa3b4183f8d": {"doc_hash": "a49fe9ab7824d0d0a6ab633ec38339328ee009ad9f36cae73d632df146e3b92b"}, "9a497bb9-67e0-408b-8a34-e7d90186c013": {"doc_hash": "836beefc7617ea97854518476f47563acdddff91cfae56c343a05a6d5c570e74"}, "b14f7317-923e-49d7-be78-93f242f633b7": {"doc_hash": "c423f77e4512e95f6055bdf336cd993424460f0676d4402f560e2b2c5bb95c6f"}, "9e2e516b-7663-4157-a66c-329857b98c54": {"doc_hash": "1888aa80d81428e6221dd5f9bc377a8576c88388287e338e221579adde7908bb"}, "57eed4ef-46a8-4529-946c-33b2f715007f": {"doc_hash": "786bc5f036c4bef4f6ad0754b973c22e4f542af6d511c05ef1db973bde1ee2ff"}, "58ae8eff-e07e-4182-92c0-e735a9214716": {"doc_hash": "9d92457e908dee234b7efd47acb2508474de9c76487ebd21c2dc5884098853a7"}, "ebb87e1d-b348-4724-9c59-6a3f1cca192d": {"doc_hash": "abef31b2e32838dd5f6a66259e9628a929857f70a6f41f8cd53c66ebb566832b"}, "6b2daf9a-78e6-446a-ad10-c2f90c707359": {"doc_hash": "4faae7437c5a48fb99934f82f648c41eaa468e4295e46dbd2961f96fa9a06480"}, "428a7937-94f8-4d6d-8b7e-6f42e1f28e4a": {"doc_hash": "877a7362a6214ba3bce3766c9f85c359d4a0591826a111999304f84554467a0d"}, "51c950c0-87bf-483b-813c-baf18aae64bb": {"doc_hash": "d0bf05096e9628328b195cc077613ebc217d3e7371c5c83d0bd2b2b0901ec2dd"}, "b88b54bb-fe09-40ba-8dde-8d0488fb72ef": {"doc_hash": "8e4d6f22a513bda6ae3314e5794662fe12e2f18d10a9e0a639fadb92084affde"}, "47ef91a7-6d1e-461e-8165-ad1a7205a51b": {"doc_hash": "cbc9687ed3025df4f64a69cf666b3e53fb1036abdb63104f2cde7dcdbbdc960a"}, "2ea28d4e-1fab-42b3-b955-bc1372db5765": {"doc_hash": "5c5698a77c5ce50a9f9a7c418b4864fdab94b73f8a42da548a5dedf3c56f4289"}, "560c344c-79e1-4c51-98b7-0172112ae634": {"doc_hash": "d0cc891babf73df4b02c0dbe218ae790d0b46f506cc21d2d443e846cdc1fd4c6"}, "d026852c-013b-4190-8ec6-458a73a17d0a": {"doc_hash": "22c60f4e86a77e3b49cb72d4499f447ac1a7a89e4d3b013ed01c09b1d478664d"}, "1e534c83-92da-446e-9c7d-7bbe7f33a937": {"doc_hash": "af36be58858afe620ce13ffd4b39edd03debd013e41d435a62546725c06c2262"}, "bf137ce9-4cf3-419d-b94f-33e4b186206d": {"doc_hash": "8add4b92919c60ce7c7080199039f44d39fa17bfbf37f21aec725cd9d62b90a4"}, "03794dd0-d752-4151-8131-25803d72a3b8": {"doc_hash": "a0a04e3d6813448eafb9f1a1979a57b1de7acc70d8185c3ddcbe40226bab6fa1"}, "7401088e-99ad-4c5a-9fda-59f09addd904": {"doc_hash": "dec0bcbd70b7dc2fe967afb9116ca9a2ea6ae625c25330bd87bbfd8a59cfd7b7"}, "7d3c3325-db24-4420-b640-6766d5540665": {"doc_hash": "74c979f59f687aa49685a138592825bb6143be0264566337e519e4c61877cc69"}, "8ed20a7e-0d0b-44d0-8adf-ee32a8b43c63": {"doc_hash": "1f564695b203d0684c169bd5db254d57f7a063c85c33cb01f1306111cf0af677"}, "012e421b-45fb-48c5-a98c-6bf83cf82e00": {"doc_hash": "56948c9c6e009e3a0dac1e8e4f297ba4306a7df0c247ce7b90d7dd49da10cc74"}, "fe63311a-faeb-428d-83fe-d15d1084df34": {"doc_hash": "3f08577440a93f416d420b5f8a520ca949e17af806aa4f42deda6ac2ca1526f6"}, "6c2e0e83-9cc0-467a-b5e8-35ba35eb3e2a": {"doc_hash": "e7b9af43155b545e6ba718fe58e7f4c1b95117f01b24f289d7f8b22dcc278c84"}, "4bd165db-6de7-48f5-90d7-a35585bb153b": {"doc_hash": "b09602033a6987724967f91f09b83507bc491ee40d57540dccf2dbe8e92a34e9"}, "69bb24f0-3ff8-44a6-a84d-b1c5275e3445": {"doc_hash": "8cb5f1a9fd4d651ff94302a982584467852132fee054fa3356340c70cd216360"}, "d9c2edc6-f2af-44cf-abba-6bf7ed0e38a3": {"doc_hash": "9447919e7e87ff5c6fa7f5821e866648874a2fe0c1fec712faf08d5b653bf89f"}, "202abd6c-d6bb-45f2-865d-35ab4039e251": {"doc_hash": "b7208463fc3b4c6c99f4c07745398b3c510a6c77e87a80a447eefaa06350f18b"}, "53f4eaca-59fe-43a5-929f-d38d27a7a4a0": {"doc_hash": "d3d02e3373dd35c42f23893c883908a88b21470ae4f4926982dfb2cc60f76e8e"}, "e351551e-68bd-40c0-af02-87294f4fdeaa": {"doc_hash": "d19fd43035085fc1b8af1e3441d5ba0c7281d8f00bacd99a210447c72603f399"}, "6d02caea-439a-459a-a693-a491bccfc6b6": {"doc_hash": "dfe0270a564449e2c543b5c9f562bf4bc873ea497a055d830d7100fdf4f71ccd"}, "c2f41606-0ecc-48d6-b0a0-175e07b78aa8": {"doc_hash": "bc6ce989fe51ebfa298416de0bf5640796fdd6943622198354095a197d8b15ac"}}, "docstore/data": {"8dc8bd56-044a-49fb-b25f-fa4a962f22d7": {"__data__": {"text": "Gareth James \u2022 Daniela Witten \u2022\nTrevor Hastie \u2022 Robert Tibshirani\nAn Introduction to Statistical\nLearning\nwith Applications in R\nSecond Edition\n123 First Printing: August 4, 2021\nTo our parents:\nAlison and Michael James\nChiara Nappi and Edward Witten\nValerie and Patrick Hastie\nVera and Sami Tibshirani\nand to our families:\nMichael, Daniel, and Catherine\nTessa, Theo, Otto, and Ari\nSamantha, Timothy, and Lynda\nCharlie, Ryan, Julie, and Cheryl\nPreface\nStatistical learning refers to a set of tools for making sense of complex\ndatasets. In recent years, we have seen a staggering increase in the scale and\nscope of data collection across virtually all areas of science and industry.\nAs a result, statistical learning has become a critical toolkit for anyone who\nwishes to understand data \u2014 and as more and more of today\u2019s jobs involve\ndata, this means that statistical learning is fast becoming a critical toolkit\nfor everyone.\nOne of the first books on statistical learning \u2014 The Elements of Statistical\nLearning (ESL, by Hastie, Tibshirani, and Friedman) \u2014 was published\nin 2001, with a second edition in 2009. ESL has become a popular text not\nonly in statistics but also in related fields. One of the reasons for ESL\u2019s\npopularity is its relatively accessible style. But ESL is best-suited for individuals\nwith advanced training in the mathematical sciences.\nAn Introduction to Statistical Learning (ISL) arose from the clear need\nfor a broader and less technical treatment of the key topics in statistical\nlearning. The intention behind ISL is to concentrate more on the applications\nof the methods and less on the mathematical details. Beginning with\nChapter 2, each chapter in ISL contains a lab illustrating how to implement\nthe statistical learning methods seen in that chapter using the popular statistical\nsoftware package R. These labs provide the reader with valuable\nhands-on experience.\nISL is appropriate for advanced undergraduates or master\u2019s students in\nStatistics or related quantitative fields, or for individuals in other disciplines\nwho wish to use statistical learning tools to analyze their data. It can be\nused as a textbook for a course spanning two semesters.\nvii\nThe first edition of ISL covered a number of important topics, including\nsparse methods for classification and regression, decision trees, boosting,\nsupport vector machines, and clustering. Since it was published in 2013, it\nhas become a mainstay of undergraduate and graduate classrooms across\nthe United States and worldwide, as well as a key reference book for data\nscientists.\nIn this second edition of ISL, we have greatly expanded the set of topics\ncovered. In particular, the second edition includes new chapters on deep\nlearning (Chapter 10), survival analysis (Chapter 11), and multiple testing\n(Chapter 13).We have also substantially expanded some chapters that were\npart of the first edition: among other updates, we now include treatments\nof naive Bayes and generalized linear models in Chapter 4, Bayesian additive\nregression trees in Chapter 8, and matrix completion in Chapter 12.\nFurthermore, we have updated the R code throughout the labs to ensure\nthat the results that they produce agree with recent R releases.\nWe are grateful to these readers for providing valuable comments on the\nfirst edition of this book: Pallavi Basu, Alexandra Chouldechova, Patrick\nDanaher, Will Fithian, Luella Fu, Sam Gross, Max Grazier G\u2019Sell, Courtney\nPaulson, Xinghao Qiao, Elisa Sheng, Noah Simon, Kean Ming Tan,\nXin Lu Tan. We thank these readers for helpful input on the second edition\nof this book: Alan Agresti, Iain Carmichael, Yiqun Chen, Erin Craig,\nDaisy Ding, Lucy Gao, Ismael Lemhadri, Bryan Martin, Anna Neufeld, Geoff\nTims, Carsten Voelkmann, Steve Yadlowsky, and James Zou.", "doc_id": "8dc8bd56-044a-49fb-b25f-fa4a962f22d7", "embedding": null, "doc_hash": "6f5aa154506f6645687ca785865fb4b07a561e50d2cba81056a2bb46b9a99788", "extra_info": null, "node_info": {"start": 0, "end": 3777, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "3": "952ee93d-bd91-4bde-a0bc-9b8cdd0a6a21"}}, "__type__": "1"}, "952ee93d-bd91-4bde-a0bc-9b8cdd0a6a21": {"__data__": {"text": "Carsten Voelkmann, Steve Yadlowsky, and James Zou. We also\nthank Anna Neufeld for her assistance in reformatting the R code throughout\nthis book. We are immensely grateful to Balasubramanian \u201cNaras\u201d\nNarasimhan for his assistance on both editions of this textbook.\nIt has been an honor and a privilege for us to see the considerable impact\nthat the first edition of ISL has had on the way in which statistical learning\nis practiced, both in and out of the academic setting.We hope that this new\nedition will continue to give today\u2019s and tomorrow\u2019s applied statisticians\nand data scientists the tools they need for success in a data-driven world.\nIt\u2019s tough to make predictions, especially about the future.\n-Yogi Berra\nviii Preface\nContents\nPreface vii\n1 Introduction 1\n2 Statistical Learning 15\n2.1 What Is Statistical Learning? . . . . . . . . . . . . . . . . . 15\n2.1.1 Why Estimate f? . . . . . . . . . . . . . . . . . . . 17\n2.1.2 How Do We Estimate f? . . . . . . . . . . . . . . . 21\n2.1.3 The Trade-Off Between Prediction Accuracy\nand Model Interpretability . . . . . . . . . . . . . . 24\n2.1.4 Supervised Versus Unsupervised Learning . . . . . 26\n2.1.5 Regression Versus Classification Problems . . . . . 28\n2.2 Assessing Model Accuracy . . . . . . . . . . . . . . . . . . 29\n2.2.1 Measuring the Quality of Fit . . . . . . . . . . . . 29\n2.2.2 The Bias-Variance Trade-Off . . . . . . . . . . . . . 33\n2.2.3 The Classification Setting . . . . . . . . . . . . . . 37\n2.3 Lab: Introduction to R . . . . . . . . . . . . . . . . . . . . 42\n2.3.1 Basic Commands . . . . . . . . . . . . . . . . . . . 43\n2.3.2 Graphics . . . . . . . . . . . . . . . . . . . . . . . . 45\n2.3.3 Indexing Data . . . . . . . . . . . . . . . . . . . . . 47\n2.3.4 Loading Data . . . . . . . . . . . . . . . . . . . . . 48\n2.3.5 Additional Graphical and Numerical Summaries . . 50\n2.4 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52\n3 Linear Regression 59\n3.1 Simple Linear Regression . . . . . . . . . . . . . . . . . . . 60\n3.1.1 Estimating the Coefficients . . . . . . . . . . . . . 61\n3.1.2 Assessing the Accuracy of the Coefficient\nEstimates . . . . . . . . . . . . . . . . . . . . . . . 63\n3.1.3 Assessing the Accuracy of the Model . . . . . . . . 68\n3.2 Multiple Linear Regression . . . . . . . . . . . . . . . . . . 71\n3.2.1 Estimating the Regression Coefficients . . . . . . . 72\n3.2.2 Some Important Questions . . . . . . . . . . . . . . 75\n3.3 Other Considerations in the Regression Model . . . . . . . 83\nix\n3.3.1 Qualitative Predictors . . . . . . . . . . . . . . . . 83\n3.3.2 Extensions of the Linear Model . . . . . . . . . . . 87\n3.3.3 Potential Problems . . . . . . . . . . . . . . . . . . 92\n3.4 The Marketing Plan . . . . . . .", "doc_id": "952ee93d-bd91-4bde-a0bc-9b8cdd0a6a21", "embedding": null, "doc_hash": "92feb74c6079b21c407d9cb8537e9f1934db3739999440d84384f8e918c4e47b", "extra_info": null, "node_info": {"start": 3734, "end": 6478, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "8dc8bd56-044a-49fb-b25f-fa4a962f22d7", "3": "232065f1-a3f6-4a17-8141-6c5b1bc76815"}}, "__type__": "1"}, "232065f1-a3f6-4a17-8141-6c5b1bc76815": {"__data__": {"text": ". . . . 92\n3.4 The Marketing Plan . . . . . . . . . . . . . . . . . . . . . . 103\n3.5 Comparison of Linear Regression with K-Nearest\nNeighbors . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105\n3.6 Lab: Linear Regression . . . . . . . . . . . . . . . . . . . . 110\n3.6.1 Libraries . . . . . . . . . . . . . . . . . . . . . . . . 110\n3.6.2 Simple Linear Regression . . . . . . . . . . . . . . . 111\n3.6.3 Multiple Linear Regression . . . . . . . . . . . . . . 114\n3.6.4 Interaction Terms . . . . . . . . . . . . . . . . . . . 116\n3.6.5 Non-linear Transformations of the Predictors . . . 116\n3.6.6 Qualitative Predictors . . . . . . . . . . . . . . . . 119\n3.6.7 Writing Functions . . . . . . . . . . . . . . . . . . . 120\n3.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121\n4 Classification 129\n4.1 An Overview of Classification . . . . . . . . . . . . . . . . . 130\n4.2 Why Not Linear Regression? . . . . . . . . . . . . . . . . . 131\n4.3 Logistic Regression . . . . . . . . . . . . . . . . . . . . . . 133\n4.3.1 The Logistic Model . . . . . . . . . . . . . . . . . . 133\n4.3.2 Estimating the Regression Coefficients . . . . . . . 135\n4.3.3 Making Predictions . . . . . . . . . . . . . . . . . . 136\n4.3.4 Multiple Logistic Regression . . . . . . . . . . . . . 137\n4.3.5 Multinomial Logistic Regression . . . . . . . . . . . 140\n4.4 Generative Models for Classification . . . . . . . . . . . . . 141\n4.4.1 Linear Discriminant Analysis for p = 1 . . . . . . . 142\n4.4.2 Linear Discriminant Analysis for p >1 . . . . . . . 145\n4.4.3 Quadratic Discriminant Analysis . . . . . . . . . . 152\n4.4.4 Naive Bayes . . . . . . . . . . . . . . . . . . . . . . 153\n4.5 A Comparison of Classification Methods . . . . . . . . . . 158\n4.5.1 An Analytical Comparison . . . . . . . . . . . . . . 158\n4.5.2 An Empirical Comparison . . . . . . . . . . . . . . 161\n4.6 Generalized Linear Models . . . . . . . . . . . . . . . . . . 164\n4.6.1 Linear Regression on the Bikeshare Data . . . . . . 164\n4.6.2 Poisson Regression on the Bikeshare Data . . . . . 167\n4.6.3 Generalized Linear Models in Greater Generality . 170\n4.7 Lab: Classification Methods . . . . . . . . . . . . . . . . . . 171\n4.7.1 The Stock Market Data . . . . . . . . . . . . . . . 171\n4.7.2 Logistic Regression . . . . . . . . . . . . . . . . . . 172\n4.7.3 Linear Discriminant Analysis . . . . . . . . . . . . 177\n4.7.4 Quadratic Discriminant Analysis . . . . . . . . . . 179\n4.7.5 Naive Bayes . . . . . . . . . . . . . . .", "doc_id": "232065f1-a3f6-4a17-8141-6c5b1bc76815", "embedding": null, "doc_hash": "e8850e62cc2159ffb2c0d2a74e65eeb5511171738ccfd7310728c73f00c74981", "extra_info": null, "node_info": {"start": 6490, "end": 8991, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "952ee93d-bd91-4bde-a0bc-9b8cdd0a6a21", "3": "02937c03-d483-4c9c-a72a-d6fb5c404d07"}}, "__type__": "1"}, "02937c03-d483-4c9c-a72a-d6fb5c404d07": {"__data__": {"text": "Naive Bayes . . . . . . . . . . . . . . . . . . . . . . 180\n4.7.6 K-Nearest Neighbors . . . . . . . . . . . . . . . . . 181\n4.7.7 Poisson Regression . . . . . . . . . . . . . . . . . . 185\nx CONTENTS\nCONTENTS xi\n4.8 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189\n5 Resampling Methods 197\n5.1 Cross-Validation . . . . . . . . . . . . . . . . . . . . . . . . 198\n5.1.1 The Validation Set Approach . . . . . . . . . . . . 198\n5.1.2 Leave-One-Out Cross-Validation . . . . . . . . . . 200\n5.1.3 k-Fold Cross-Validation . . . . . . . . . . . . . . . 203\n5.1.4 Bias-Variance Trade-Off for k-Fold\nCross-Validation . . . . . . . . . . . . . . . . . . . 205\n5.1.5 Cross-Validation on Classification Problems . . . . 206\n5.2 The Bootstrap . . . . . . . . . . . . . . . . . . . . . . . . . 209\n5.3 Lab: Cross-Validation and the Bootstrap . . . . . . . . . . 212\n5.3.1 The Validation Set Approach . . . . . . . . . . . . 213\n5.3.2 Leave-One-Out Cross-Validation . . . . . . . . . . 214\n5.3.3 k-Fold Cross-Validation . . . . . . . . . . . . . . . 215\n5.3.4 The Bootstrap . . . . . . . . . . . . . . . . . . . . 216\n5.4 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219\n6 Linear Model Selection and Regularization 225\n6.1 Subset Selection . . . . . . . . . . . . . . . . . . . . . . . . 227\n6.1.1 Best Subset Selection . . . . . . . . . . . . . . . . . 227\n6.1.2 Stepwise Selection . . . . . . . . . . . . . . . . . . 229\n6.1.3 Choosing the Optimal Model . . . . . . . . . . . . 232\n6.2 Shrinkage Methods . . . . . . . . . . . . . . . . . . . . . . 237\n6.2.1 Ridge Regression . . . . . . . . . . . . . . . . . . . 237\n6.2.2 The Lasso . . . . . . . . . . . . . . . . . . . . . . . 241\n6.2.3 Selecting the Tuning Parameter . . . . . . . . . . . 250\n6.3 Dimension Reduction Methods . . . . . . . . . . . . . . . . 251\n6.3.1 Principal Components Regression . . . . . . . . . . 252\n6.3.2 Partial Least Squares . . . . . . . . . . . . . . . . . 259\n6.4 Considerations in High Dimensions . . . . . . . . . . . . . 261\n6.4.1 High-Dimensional Data . . . . . . . . . . . . . . . . 261\n6.4.2 What Goes Wrong in High Dimensions? . . . . . . 262\n6.4.3 Regression in High Dimensions . . . . . . . . . . . 264\n6.4.4 Interpreting Results in High Dimensions . . . . . . 266\n6.5 Lab: Linear Models and Regularization Methods . . . . . . 267\n6.5.1 Subset Selection Methods . . . . . . . . . . . . . . 267\n6.5.2 Ridge Regression and the", "doc_id": "02937c03-d483-4c9c-a72a-d6fb5c404d07", "embedding": null, "doc_hash": "58f72bc95acabfe4cae8b518a40376063b1be4798cf6732eabf5d00d2e0ee0c1", "extra_info": null, "node_info": {"start": 9000, "end": 11444, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "232065f1-a3f6-4a17-8141-6c5b1bc76815", "3": "bd6f9dea-4c77-4eab-b10a-48786c0ae72e"}}, "__type__": "1"}, "bd6f9dea-4c77-4eab-b10a-48786c0ae72e": {"__data__": {"text": ". . . . . . . 267\n6.5.2 Ridge Regression and the Lasso . . . . . . . . . . . 274\n6.5.3 PCR and PLS Regression . . . . . . . . . . . . . . 279\n6.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282\n7 Moving Beyond Linearity 289\n7.1 Polynomial Regression . . . . . . . . . . . . . . . . . . . . . 290\n7.2 Step Functions . . . . . . . . . . . . . . . . . . . . . . . . . 292\n7.3 Basis Functions . . . . . . . . . . . . . . . . . . . . . . . . 294\n7.4 Regression Splines . . . . . . . . . . . . . . . . . . . . . . . 295\n7.4.1 Piecewise Polynomials . . . . . . . . . . . . . . . . 295\n7.4.2 Constraints and Splines . . . . . . . . . . . . . . . 295\n7.4.3 The Spline Basis Representation . . . . . . . . . . 297\n7.4.4 Choosing the Number and Locations\nof the Knots . . . . . . . . . . . . . . . . . . . . . . 298\n7.4.5 Comparison to Polynomial Regression . . . . . . . 300\n7.5 Smoothing Splines . . . . . . . . . . . . . . . . . . . . . . . 301\n7.5.1 An Overview of Smoothing Splines . . . . . . . . . 301\n7.5.2 Choosing the Smoothing Parameter \u03bb . . . . . . . 302\n7.6 Local Regression . . . . . . . . . . . . . . . . . . . . . . . . 304\n7.7 Generalized Additive Models . . . . . . . . . . . . . . . . . 306\n7.7.1 GAMs for Regression Problems . . . . . . . . . . . 307\n7.7.2 GAMs for Classification Problems . . . . . . . . . . 310\n7.8 Lab: Non-linear Modeling . . . . . . . . . . . . . . . . . . . 311\n7.8.1 Polynomial Regression and Step Functions . . . . . 312\n7.8.2 Splines . . . . . . . . . . . . . . . . . . . . . . . . . 317\n7.8.3 GAMs . . . . . . . . . . . . . . . . . . . . . . . . . 318\n7.9 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321\n8 Tree-Based Methods 327\n8.1 The Basics of Decision Trees . . . . . . . . . . . . . . . . . 327\n8.1.1 Regression Trees . . . . . . . . . . . . . . . . . . . 328\n8.1.2 Classification Trees . . . . . . . . . . . . . . . . . . 335\n8.1.3 Trees Versus Linear Models . . . . . . . . . . . . . 338\n8.1.4 Advantages and Disadvantages of Trees . . . . . . 339\n8.2 Bagging, Random Forests, Boosting, and Bayesian Additive\nRegression Trees . . . . . . . . . . . . . . . . . . . . . . . . 340\n8.2.1 Bagging . . . . . . . . . . . . . . . . . . . . . . . . 340\n8.2.2 Random Forests . . . . . . . . . . . . . . . . . . . . 343\n8.2.3 Boosting . . . . . . . . . . . . . . . . . . . . . . . .", "doc_id": "bd6f9dea-4c77-4eab-b10a-48786c0ae72e", "embedding": null, "doc_hash": "c710de21d73c28eced8fe21deeb624961571402ec4458fe41cb6af32b6cee867", "extra_info": null, "node_info": {"start": 11433, "end": 13792, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "02937c03-d483-4c9c-a72a-d6fb5c404d07", "3": "73f06905-736f-400e-9ee7-3b2fd11b4a67"}}, "__type__": "1"}, "73f06905-736f-400e-9ee7-3b2fd11b4a67": {"__data__": {"text": ". . . . . . . . . . . . . . . . . . . . 345\n8.2.4 Bayesian Additive Regression Trees . . . . . . . . . 348\n8.2.5 Summary of Tree Ensemble Methods . . . . . . . . 351\n8.3 Lab: Decision Trees . . . . . . . . . . . . . . . . . . . . . . 353\n8.3.1 Fitting Classification Trees . . . . . . . . . . . . . . 353\n8.3.2 Fitting Regression Trees . . . . . . . . . . . . . . . 356\n8.3.3 Bagging and Random Forests . . . . . . . . . . . . 357\n8.3.4 Boosting . . . . . . . . . . . . . . . . . . . . . . . . 359\n8.3.5 Bayesian Additive Regression Trees . . . . . . . . . 360\n8.4 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\n9 Support Vector Machines 367\n9.1 Maximal Margin Classifier . . . . . . . . . . . . . . . . . . 368\n9.1.1 What Is a Hyperplane? . . . . . . . . . . . . . . . . 368\n9.1.2 Classification Using a Separating Hyperplane . . . 369\nxii CONTENTS\nCONTENTS xiii\n9.1.3 The Maximal Margin Classifier . . . . . . . . . . . 371\n9.1.4 Construction of the Maximal Margin Classifier . . 372\n9.1.5 The Non-separable Case . . . . . . . . . . . . . . . 373\n9.2 Support Vector Classifiers . . . . . . . . . . . . . . . . . . . 373\n9.2.1 Overview of the Support Vector Classifier . . . . . 373\n9.2.2 Details of the Support Vector Classifier . . . . . . . 375\n9.3 Support Vector Machines . . . . . . . . . . . . . . . . . . . 379\n9.3.1 Classification with Non-Linear Decision\nBoundaries . . . . . . . . . . . . . . . . . . . . . . 379\n9.3.2 The Support Vector Machine . . . . . . . . . . . . 380\n9.3.3 An Application to the Heart Disease Data . . . . . 383\n9.4 SVMs with More than Two Classes . . . . . . . . . . . . . 385\n9.4.1 One-Versus-One Classification . . . . . . . . . . . . 385\n9.4.2 One-Versus-All Classification . . . . . . . . . . . . 385\n9.5 Relationship to Logistic Regression . . . . . . . . . . . . . 386\n9.6 Lab: Support Vector Machines . . . . . . . . . . . . . . . . 388\n9.6.1 Support Vector Classifier . . . . . . . . . . . . . . . 389\n9.6.2 Support Vector Machine . . . . . . . . . . . . . . . 392\n9.6.3 ROC Curves . . . . . . . . . . . . . . . . . . . . . . 394\n9.6.4 SVM with Multiple Classes . . . . . . . . . . . . . 396\n9.6.5 Application to Gene Expression Data . . . . . . . . 396\n9.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 398\n10 Deep Learning 403\n10.1 Single Layer Neural Networks . . . . . . . . . . . . . . . . 404\n10.2 Multilayer Neural Networks . . . . . . . . . . . . . . . . . . 407\n10.3 Convolutional Neural Networks . . . . . . . . . . . . . . . . 411\n10.3.1 Convolution Layers . . . .", "doc_id": "73f06905-736f-400e-9ee7-3b2fd11b4a67", "embedding": null, "doc_hash": "890581928b8f3a88b8866a16f4895e99a906b9912126ba7b1cdb608457a3ce1a", "extra_info": null, "node_info": {"start": 13810, "end": 16371, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "bd6f9dea-4c77-4eab-b10a-48786c0ae72e", "3": "0e2e156c-cf58-408b-ba54-48e464653d7e"}}, "__type__": "1"}, "0e2e156c-cf58-408b-ba54-48e464653d7e": {"__data__": {"text": ". . . . 411\n10.3.1 Convolution Layers . . . . . . . . . . . . . . . . . . 412\n10.3.2 Pooling Layers . . . . . . . . . . . . . . . . . . . . 415\n10.3.3 Architecture of a Convolutional Neural Network . . 415\n10.3.4 Data Augmentation . . . . . . . . . . . . . . . . . . 417\n10.3.5 Results Using a Pretrained Classifier . . . . . . . . 417\n10.4 Document Classification . . . . . . . . . . . . . . . . . . . . 419\n10.5 Recurrent Neural Networks . . . . . . . . . . . . . . . . . . 421\n10.5.1 Sequential Models for Document Classification . . 424\n10.5.2 Time Series Forecasting . . . . . . . . . . . . . . . 427\n10.5.3 Summary of RNNs . . . . . . . . . . . . . . . . . . 431\n10.6 When to Use Deep Learning . . . . . . . . . . . . . . . . . 432\n10.7 Fitting a Neural Network . . . . . . . . . . . . . . . . . . . 434\n10.7.1 Backpropagation . . . . . . . . . . . . . . . . . . . 435\n10.7.2 Regularization and Stochastic Gradient Descent . . 436\n10.7.3 Dropout Learning . . . . . . . . . . . . . . . . . . . 438\n10.7.4 Network Tuning . . . . . . . . . . . . . . . . . . . . 438\n10.8 Interpolation and Double Descent . . . . . . . . . . . . . . 439\n10.9 Lab: Deep Learning . . . . . . . . . . . . . . . . . . . . . . 443\n10.9.1 A Single Layer Network on the Hitters Data . . . . 443\n10.9.2 A Multilayer Network on the MNIST Digit Data . 445\n10.9.3 Convolutional Neural Networks . . . . . . . . . . . 448\n10.9.4 Using Pretrained CNN Models . . . . . . . . . . . 451\n10.9.5 IMDb Document Classification . . . . . . . . . . . 452\n10.9.6 Recurrent Neural Networks . . . . . . . . . . . . . 454\n10.10 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 458\n11 Survival Analysis and Censored Data 461\n11.1 Survival and Censoring Times . . . . . . . . . . . . . . . . 462\n11.2 A Closer Look at Censoring . . . . . . . . . . . . . . . . . . 463\n11.3 The Kaplan-Meier Survival Curve . . . . . . . . . . . . . . 464\n11.4 The Log-Rank Test . . . . . . . . . . . . . . . . . . . . . . 466\n11.5 Regression Models With a Survival Response . . . . . . . . 469\n11.5.1 The Hazard Function . . . . . . . . . . . . . . . . . 469\n11.5.2 Proportional Hazards . . . . . . . . . . . . . . . . . 471\n11.5.3 Example: Brain Cancer Data . . . . . . . . . . . . 475\n11.5.4 Example: Publication Data . . . . . . . . . . . . . 475\n11.6 Shrinkage for the Cox Model . . . . . . . . . . . . . . . . . 478\n11.7 Additional Topics . . . . . . . . . . . . . . . . . . . . . . . 480\n11.7.1 Area Under the Curve for Survival Analysis . . . . 480\n11.7.2 Choice of Time Scale . . . . . .", "doc_id": "0e2e156c-cf58-408b-ba54-48e464653d7e", "embedding": null, "doc_hash": "897be8783a10554ae022f6dd1bc7dc85fae237458914bc531cd1dc5eeb1aec76", "extra_info": null, "node_info": {"start": 16357, "end": 18907, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "73f06905-736f-400e-9ee7-3b2fd11b4a67", "3": "05a5ab7b-df62-46b4-b820-b52b9a506faf"}}, "__type__": "1"}, "05a5ab7b-df62-46b4-b820-b52b9a506faf": {"__data__": {"text": ". . . 480\n11.7.2 Choice of Time Scale . . . . . . . . . . . . . . . . . 481\n11.7.3 Time-Dependent Covariates . . . . . . . . . . . . . 481\n11.7.4 Checking the Proportional Hazards Assumption . . 482\n11.7.5 Survival Trees . . . . . . . . . . . . . . . . . . . . . 482\n11.8 Lab: Survival Analysis . . . . . . . . . . . . . . . . . . . . . 483\n11.8.1 Brain Cancer Data . . . . . . . . . . . . . . . . . . 483\n11.8.2 Publication Data . . . . . . . . . . . . . . . . . . . 486\n11.8.3 Call Center Data . . . . . . . . . . . . . . . . . . . 487\n11.9 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 490\n12 Unsupervised Learning 497\n12.1 The Challenge of Unsupervised Learning . . . . . . . . . . 497\n12.2 Principal Components Analysis . . . . . . . . . . . . . . . . 498\n12.2.1 What Are Principal Components? . . . . . . . . . . 499\n12.2.2 Another Interpretation of Principal Components . 503\n12.2.3 The Proportion of Variance Explained . . . . . . . 505\n12.2.4 More on PCA . . . . . . . . . . . . . . . . . . . . . 507\n12.2.5 Other Uses for Principal Components . . . . . . . . 510\n12.3 Missing Values and Matrix Completion . . . . . . . . . . . 510\n12.4 Clustering Methods . . . . . . . . . . . . . . . . . . . . . . 516\n12.4.1 K-Means Clustering . . . . . . . . . . . . . . . . . 517\n12.4.2 Hierarchical Clustering . . . . . . . . . . . . . . . . 521\n12.4.3 Practical Issues in Clustering . . . . . . . . . . . . 530\n12.5 Lab: Unsupervised Learning . . . . . . . . . . . . . . . . . 532\nxiv CONTENTS\nCONTENTS xv\n12.5.1 Principal Components Analysis . . . . . . . . . . . 532\n12.5.2 Matrix Completion . . . . . . . . . . . . . . . . . . 535\n12.5.3 Clustering . . . . . . . . . . . . . . . . . . . . . . . 538\n12.5.4 NCI60 Data Example . . . . . . . . . . . . . . . . . 542\n12.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 548\n13 Multiple Testing 553\n13.1 A Quick Review of Hypothesis Testing . . . . . . . . . . . 554\n13.1.1 Testing a Hypothesis . . . . . . . . . . . . . . . . . 555\n13.1.2 Type I and Type II Errors . . . . . . . . . . . . . . 559\n13.2 The Challenge of Multiple Testing . . . . . . . . . . . . . . 560\n13.3 The Family-Wise Error Rate . . . . . . . . . . . . . . . . . 561\n13.3.1 What is the Family-Wise Error Rate? . . . . . . . 562\n13.3.2 Approaches to Control the Family-Wise Error Rate 564\n13.3.3 Trade-Off Between the FWER and Power . . . . . 570\n13.4 The False Discovery Rate . . . . . . . . . . . . . . . . . . . 571\n13.4.1 Intuition for the False Discovery Rate . . .", "doc_id": "05a5ab7b-df62-46b4-b820-b52b9a506faf", "embedding": null, "doc_hash": "de2923166c5de30bfc0193e929ab08e65a19abb509dd8b0a12ee0292306113e7", "extra_info": null, "node_info": {"start": 18907, "end": 21433, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "0e2e156c-cf58-408b-ba54-48e464653d7e", "3": "280e6d87-8024-421d-9fcc-03f568fc6f58"}}, "__type__": "1"}, "280e6d87-8024-421d-9fcc-03f568fc6f58": {"__data__": {"text": ". 571\n13.4.1 Intuition for the False Discovery Rate . . . . . . . 571\n13.4.2 The Benjamini-Hochberg Procedure . . . . . . . . 573\n13.5 A Re-Sampling Approach to p-Values and False Discovery\nRates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 575\n13.5.1 A Re-Sampling Approach to the p-Value . . . . . . 576\n13.5.2 A Re-Sampling Approach to the False Discovery Rate578\n13.5.3 When Are Re-Sampling Approaches Useful? . . . . 581\n13.6 Lab: Multiple Testing . . . . . . . . . . . . . . . . . . . . . 582\n13.6.1 Review of Hypothesis Tests . . . . . . . . . . . . . 582\n13.6.2 The Family-Wise Error Rate . . . . . . . . . . . . . 583\n13.6.3 The False Discovery Rate . . . . . . . . . . . . . . 586\n13.6.4 A Re-Sampling Approach . . . . . . . . . . . . . . 588\n13.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 591\nIndex 597\n1\nIntroduction\nAn Overview of Statistical Learning\nStatistical learning refers to a vast set of tools for understanding data. These\ntools can be classified as supervised or unsupervised. Broadly speaking,\nsupervised statistical learning involves building a statistical model for predicting,\nor estimating, an output based on one or more inputs. Problems of\nthis nature occur in fields as diverse as business, medicine, astrophysics, and\npublic policy. With unsupervised statistical learning, there are inputs but\nno supervising output; nevertheless we can learn relationships and structure\nfrom such data. To provide an illustration of some applications of\nstatistical learning, we briefly discuss three real-world data sets that are\nconsidered in this book.\nWage Data\nIn this application (which we refer to as the Wage data set throughout this\nbook), we examine a number of factors that relate to wages for a group of\nmen from the Atlantic region of the United States. In particular, we wish\nto understand the association between an employee\u2019s age and education, as\nwell as the calendar year, on his wage. Consider, for example, the left-hand\npanel of Figure 1.1, which displays wage versus age for each of the individuals\nin the data set. There is evidence that wage increases with age but then\ndecreases again after approximately age 60. The blue line, which provides\nan estimate of the average wage for a given age, makes this trend clearer.\n\u00a9 Springer Science+Business Media, LLC, part of Springer Nature 2021\nG. James et al., An Introduction to Statistical Learning, Springer Texts in Statistics,\nhttps://doi.org/10.1007/978-1-0716-1418-1_1\n1\n2 1. Introduction\n20 40 60 80\n50 100 200 300\nAge\nWage\n2003 2006 2009\n50 100 200 300\nYear\nWage\n1 2 3 4 5\n50 100 200 300\nEducation Level\nWage\nFIGURE 1.1. Wage data, which contains income survey information for men\nfrom the central Atlantic region of the United States. Left: wage as a function of\nage. On average, wage increases with age until about 60 years of age, at which\npoint it begins to decline. Center: wage as a function of year. There is a slow\nbut steady increase of approximately $10,000 in the average wage between 2003\nand 2009. Right: Boxplots displaying wage as a function of education, with 1\nindicating the lowest level (no high school diploma) and 5 the highest level (an\nadvanced graduate degree). On average, wage increases with the level of education.\nGiven an employee\u2019s age, we can use this curve to predict his wage. However,\nit is also clear from Figure 1.1 that there is a significant amount of", "doc_id": "280e6d87-8024-421d-9fcc-03f568fc6f58", "embedding": null, "doc_hash": "9e5fea98bbba5194e411e2051308f431fde2c0b3f60b3b3019654f68de7d381a", "extra_info": null, "node_info": {"start": 21423, "end": 24845, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "05a5ab7b-df62-46b4-b820-b52b9a506faf", "3": "349c5ccd-be65-415c-aac4-f3b81836c034"}}, "__type__": "1"}, "349c5ccd-be65-415c-aac4-f3b81836c034": {"__data__": {"text": "However,\nit is also clear from Figure 1.1 that there is a significant amount of variability\nassociated with this average value, and so age alone is unlikely to\nprovide an accurate prediction of a particular man\u2019s wage.\nWe also have information regarding each employee\u2019s education level and\nthe year in which the wage was earned. The center and right-hand panels of\nFigure 1.1, which display wage as a function of both year and education, indicate\nthat both of these factors are associated with wage. Wages increase\nby approximately $10,000, in a roughly linear (or straight-line) fashion,\nbetween 2003 and 2009, though this rise is very slight relative to the variability\nin the data. Wages are also typically greater for individuals with\nhigher education levels: men with the lowest education level (1) tend to\nhave substantially lower wages than those with the highest education level\n(5). Clearly, the most accurate prediction of a given man\u2019s wage will be\nobtained by combining his age, his education, and the year. In Chapter 3,\nwe discuss linear regression, which can be used to predict wage from this\ndata set. Ideally, we should predict wage in a way that accounts for the\nnon-linear relationship between wage and age. In Chapter 7, we discuss a\nclass of approaches for addressing this problem.\n1. Introduction 3\nDown Up\n\u22124 \u22122 0 2 4 6\nYesterday\nToday\u2019s Direction\nPercentage change in S&P\nDown Up\n\u22124 \u22122 0 2 4 6\nTwo Days Previous\nToday\u2019s Direction\nPercentage change in S&P\nDown Up\n\u22124 \u22122 0 2 4 6\nThree Days Previous\nToday\u2019s Direction\nPercentage change in S&P\nFIGURE 1.2. Left: Boxplots of the previous day\u2019s percentage change in the S&P\nindex for the days for which the market increased or decreased, obtained from the\nSmarket data. Center and Right: Same as left panel, but the percentage changes\nfor 2 and 3 days previous are shown.\nStock Market Data\nThe Wage data involves predicting a continuous or quantitative output value.\nThis is often referred to as a regression problem. However, in certain cases\nwe may instead wish to predict a non-numerical value\u2014that is, a categorical\nor qualitative output. For example, in Chapter 4 we examine a stock market\ndata set that contains the daily movements in the Standard & Poor\u2019s 500\n(S&P) stock index over a 5-year period between 2001 and 2005. We refer\nto this as the Smarket data. The goal is to predict whether the index will\nincrease or decrease on a given day, using the past 5 days\u2019 percentage\nchanges in the index. Here the statistical learning problem does not involve\npredicting a numerical value. Instead it involves predicting whether a given\nday\u2019s stock market performance will fall into the Up bucket or the Down\nbucket. This is known as a classification problem. A model that could\naccurately predict the direction in which the market will move would be\nvery useful!\nThe left-hand panel of Figure 1.2 displays two boxplots of the previous\nday\u2019s percentage changes in the stock index: one for the 648 days for which\nthe market increased on the subsequent day, and one for the 602 days for\nwhich the market decreased. The two plots look almost identical, suggesting\nthat there is no simple strategy for using yesterday\u2019s movement in the\nS&P to predict today\u2019s returns. The remaining panels, which display boxplots\nfor the percentage changes 2 and 3 days previous to today, similarly\nindicate little association between past and present returns. Of course, this\nlack of pattern is to be expected: in the presence of strong correlations between\nsuccessive days\u2019 returns, one could adopt a simple trading strategy\n4 1. Introduction\nDown Up\n0.46 0.48 0.50 0.52\nToday\u2019s Direction\nPredicted Probability\nFIGURE 1.3. We fit a quadratic discriminant analysis model to the subset\nof the Smarket data corresponding to the 2001\u20132004 time period, and", "doc_id": "349c5ccd-be65-415c-aac4-f3b81836c034", "embedding": null, "doc_hash": "0e11427cf9eb404f3740c586be16a3dbea2c518544d97aa0b93695ae3352a87f", "extra_info": null, "node_info": {"start": 24827, "end": 28628, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "280e6d87-8024-421d-9fcc-03f568fc6f58", "3": "a34828f0-90e0-4b3d-8c46-30c6ad528e36"}}, "__type__": "1"}, "a34828f0-90e0-4b3d-8c46-30c6ad528e36": {"__data__": {"text": "subset\nof the Smarket data corresponding to the 2001\u20132004 time period, and predicted\nthe probability of a stock market decrease using the 2005 data. On average, the\npredicted probability of decrease is higher for the days in which the market does\ndecrease. Based on these results, we are able to correctly predict the direction of\nmovement in the market 60% of the time.\nto generate profits from the market. Nevertheless, in Chapter 4, we explore\nthese data using several different statistical learning methods. Interestingly,\nthere are hints of some weak trends in the data that suggest that, at least\nfor this 5-year period, it is possible to correctly predict the direction of\nmovement in the market approximately 60% of the time (Figure 1.3).\nGene Expression Data\nThe previous two applications illustrate data sets with both input and\noutput variables. However, another important class of problems involves\nsituations in which we only observe input variables, with no corresponding\noutput. For example, in a marketing setting, we might have demographic\ninformation for a number of current or potential customers.We may wish to\nunderstand which types of customers are similar to each other by grouping\nindividuals according to their observed characteristics. This is known as a\nclustering problem. Unlike in the previous examples, here we are not trying\nto predict an output variable.\nWe devote Chapter 12 to a discussion of statistical learning methods\nfor problems in which no natural output variable is available. We consider\nthe NCI60 data set, which consists of 6,830 gene expression measurements\nfor each of 64 cancer cell lines. Instead of predicting a particular output\nvariable, we are interested in determining whether there are groups, or\nclusters, among the cell lines based on their gene expression measurements.\nThis is a difficult question to address, in part because there are thousands\nof gene expression measurements per cell line, making it hard to visualize\nthe data.\n1. Introduction 5\n\u221240 \u221220 0 20 40 60\n\u221260 \u221240 \u221220 0 20\n\u221240 \u221220 0 20 40 60\n\u221260 \u221240 \u221220 0 20\nZ1 Z1\nZ2\nZ2\nFIGURE 1.4. Left: Representation of the NCI60 gene expression data set in\na two-dimensional space, Z1 and Z2. Each point corresponds to one of the 64\ncell lines. There appear to be four groups of cell lines, which we have represented\nusing different colors. Right: Same as left panel except that we have represented\neach of the 14 different types of cancer using a different colored symbol. Cell lines\ncorresponding to the same cancer type tend to be nearby in the two-dimensional\nspace.\nThe left-hand panel of Figure 1.4 addresses this problem by representing\neach of the 64 cell lines using just two numbers, Z1 and Z2. These\nare the first two principal components of the data, which summarize the\n6,830 expression measurements for each cell line down to two numbers or\ndimensions. While it is likely that this dimension reduction has resulted in\nsome loss of information, it is now possible to visually examine the data\nfor evidence of clustering. Deciding on the number of clusters is often a\ndifficult problem. But the left-hand panel of Figure 1.4 suggests at least\nfour groups of cell lines, which we have represented using separate colors.\nIn this particular data set, it turns out that the cell lines correspond\nto 14 different types of cancer. (However, this information was not used\nto create the left-hand panel of Figure 1.4.) The right-hand panel of Figure\n1.4 is identical to the left-hand panel, except that the 14 cancer types\nare shown using distinct colored symbols. There is clear evidence that cell\nlines with the same cancer type tend to be located near each other in this\ntwo-dimensional representation. In addition, even though the cancer information\nwas not used to produce the left-hand panel, the clustering obtained\ndoes bear some resemblance to some of the actual cancer types observed\nin the right-hand panel. This provides some independent verification of the\naccuracy of our clustering analysis.\n6 1. Introduction\nA Brief History of Statistical", "doc_id": "a34828f0-90e0-4b3d-8c46-30c6ad528e36", "embedding": null, "doc_hash": "372ab55a63d13c5e6f9771a548bb3473e92ae67ac9bff0f464852a90c1138752", "extra_info": null, "node_info": {"start": 28631, "end": 32700, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "349c5ccd-be65-415c-aac4-f3b81836c034", "3": "9c63ba09-c6c5-43e0-b331-933214fc3cae"}}, "__type__": "1"}, "9c63ba09-c6c5-43e0-b331-933214fc3cae": {"__data__": {"text": "of our clustering analysis.\n6 1. Introduction\nA Brief History of Statistical Learning\nThough the term statistical learning is fairly new, many of the concepts that\nunderlie the field were developed long ago. At the beginning of the nineteenth\ncentury, the method of least squares was developed, implementing\nthe earliest form of what is now known as linear regression. The approach\nwas first successfully applied to problems in astronomy. Linear regression\nis used for predicting quantitative values, such as an individual\u2019s salary. In\norder to predict qualitative values, such as whether a patient survives or\ndies, or whether the stock market increases or decreases, linear discriminant\nanalysis was proposed in 1936. In the 1940s, various authors put\nforth an alternative approach, logistic regression. In the early 1970s, the\nterm generalized linear model was developed to describe an entire class of\nstatistical learning methods that include both linear and logistic regression\nas special cases.\nBy the end of the 1970s, many more techniques for learning from data\nwere available. However, they were almost exclusively linear methods because\nfitting non-linear relationships was computationally difficult at the\ntime. By the 1980s, computing technology had finally improved sufficiently\nthat non-linear methods were no longer computationally prohibitive. In\nthe mid 1980s, classification and regression trees were developed, followed\nshortly by generalized additive models. Neural networks gained popularity\nin the 1980s, and support vector machines arose in the 1990s.\nSince that time, statistical learning has emerged as a new subfield in\nstatistics, focused on supervised and unsupervised modeling and prediction.\nIn recent years, progress in statistical learning has been marked by the\nincreasing availability of powerful and relatively user-friendly software, such\nas the popular and freely available R system. This has the potential to\ncontinue the transformation of the field from a set of techniques used and\ndeveloped by statisticians and computer scientists to an essential toolkit\nfor a much broader community.\nThis Book\nThe Elements of Statistical Learning (ESL) by Hastie, Tibshirani, and\nFriedman was first published in 2001. Since that time, it has become an\nimportant reference on the fundamentals of statistical machine learning.\nIts success derives from its comprehensive and detailed treatment of many\nimportant topics in statistical learning, as well as the fact that (relative to\nmany upper-level statistics textbooks) it is accessible to a wide audience.\nHowever, the greatest factor behind the success of ESL has been its topical\nnature. At the time of its publication, interest in the field of statistical\n1. Introduction 7\nlearning was starting to explode. ESL provided one of the first accessible\nand comprehensive introductions to the topic.\nSince ESL was first published, the field of statistical learning has continued\nto flourish. The field\u2019s expansion has taken two forms. The most\nobvious growth has involved the development of new and improved statistical\nlearning approaches aimed at answering a range of scientific questions\nacross a number of fields. However, the field of statistical learning has\nalso expanded its audience. In the 1990s, increases in computational power\ngenerated a surge of interest in the field from non-statisticians who were\neager to use cutting-edge statistical tools to analyze their data. Unfortunately,\nthe highly technical nature of these approaches meant that the user\ncommunity remained primarily restricted to experts in statistics, computer\nscience, and related fields with the training (and time) to understand and\nimplement them.\nIn recent years, new and improved software packages have significantly\neased the implementation burden for many statistical learning methods.\nAt the same time, there has been growing recognition across a number of\nfields, from business to health care to genetics to the social sciences and\nbeyond, that statistical learning is a powerful tool with important practical\napplications. As a result, the field has moved from one of primarily academic\ninterest to a mainstream discipline, with an enormous potential audience.\nThis trend will surely continue with the increasing availability of enormous\nquantities of data and the software to", "doc_id": "9c63ba09-c6c5-43e0-b331-933214fc3cae", "embedding": null, "doc_hash": "d627b7844457fb9967d4f78d4c2c894603c2286b3fb32c9ef160799d78d24222", "extra_info": null, "node_info": {"start": 32698, "end": 37038, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "a34828f0-90e0-4b3d-8c46-30c6ad528e36", "3": "6ed63bc5-b14b-4535-92a1-f9b2f6ecdc62"}}, "__type__": "1"}, "6ed63bc5-b14b-4535-92a1-f9b2f6ecdc62": {"__data__": {"text": "surely continue with the increasing availability of enormous\nquantities of data and the software to analyze it.\nThe purpose of An Introduction to Statistical Learning (ISL) is to facilitate\nthe transition of statistical learning from an academic to a mainstream\nfield. ISL is not intended to replace ESL, which is a far more comprehensive\ntext both in terms of the number of approaches considered and the\ndepth to which they are explored. We consider ESL to be an important\ncompanion for professionals (with graduate degrees in statistics, machine\nlearning, or related fields) who need to understand the technical details\nbehind statistical learning approaches. However, the community of users of\nstatistical learning techniques has expanded to include individuals with a\nwider range of interests and backgrounds. Therefore, there is a place for a\nless technical and more accessible version of ESL.\nIn teaching these topics over the years, we have discovered that they are\nof interest to master\u2019s and PhD students in fields as disparate as business\nadministration, biology, and computer science, as well as to quantitativelyoriented\nupper-division undergraduates. It is important for this diverse\ngroup to be able to understand the models, intuitions, and strengths and\nweaknesses of the various approaches. But for this audience, many of the\ntechnical details behind statistical learning methods, such as optimization\nalgorithms and theoretical properties, are not of primary interest.\nWe believe that these students do not need a deep understanding of these\naspects in order to become informed users of the various methodologies, and\n8 1. Introduction\nin order to contribute to their chosen fields through the use of statistical\nlearning tools.\nISL is based on the following four premises.\n1. Many statistical learning methods are relevant and useful in a wide\nrange of academic and non-academic disciplines, beyond just the statistical\nsciences.We believe that many contemporary statistical learning\nprocedures should, and will, become as widely available and used\nas is currently the case for classical methods such as linear regression.\nAs a result, rather than attempting to consider every possible\napproach (an impossible task), we have concentrated on presenting\nthe methods that we believe are most widely applicable.\n2. Statistical learning should not be viewed as a series of black boxes. No\nsingle approach will perform well in all possible applications. Without\nunderstanding all of the cogs inside the box, or the interaction\nbetween those cogs, it is impossible to select the best box. Hence, we\nhave attempted to carefully describe the model, intuition, assumptions,\nand trade-offs behind each of the methods that we consider.\n3. While it is important to know what job is performed by each cog, it\nis not necessary to have the skills to construct the machine inside the\nbox! Thus, we have minimized discussion of technical details related\nto fitting procedures and theoretical properties. We assume that the\nreader is comfortable with basic mathematical concepts, but we do\nnot assume a graduate degree in the mathematical sciences. For instance,\nwe have almost completely avoided the use of matrix algebra,\nand it is possible to understand the entire book without a detailed\nknowledge of matrices and vectors.\n4. We presume that the reader is interested in applying statistical learning\nmethods to real-world problems. In order to facilitate this, as well\nas to motivate the techniques discussed, we have devoted a section\nwithin each chapter to R computer labs. In each lab, we walk the\nreader through a realistic application of the methods considered in\nthat chapter. When we have taught this material in our courses,\nwe have allocated roughly one-third of classroom time to working\nthrough the labs, and we have found them to be extremely useful.\nMany of the less computationally-oriented students who were initially\nintimidated by R\u2019s command level interface got the hang of\nthings over the course of the quarter or semester. We have used R\nbecause it is freely available and is powerful enough to implement all\nof the methods discussed in the book. It also has optional packages\nthat can be", "doc_id": "6ed63bc5-b14b-4535-92a1-f9b2f6ecdc62", "embedding": null, "doc_hash": "c456d66c95de246b33ef5e2a68903f8d27048b2a09be2df55cce16b94e7c7e18", "extra_info": null, "node_info": {"start": 37020, "end": 41232, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "9c63ba09-c6c5-43e0-b331-933214fc3cae", "3": "66b0032c-dda4-4450-aeb9-f62f1f9b938f"}}, "__type__": "1"}, "66b0032c-dda4-4450-aeb9-f62f1f9b938f": {"__data__": {"text": "the methods discussed in the book. It also has optional packages\nthat can be downloaded to implement literally thousands of additional\nmethods. Most importantly, R is the language of choice for\nacademic statisticians, and new approaches often become available in\n1. Introduction 9\nR years before they are implemented in commercial packages. However,\nthe labs in ISL are self-contained, and can be skipped if the\nreader wishes to use a different software package or does not wish to\napply the methods discussed to real-world problems.\nWho Should Read This Book?\nThis book is intended for anyone who is interested in using modern statistical\nmethods for modeling and prediction from data. This group includes\nscientists, engineers, data analysts, data scientists, and quants, but also\nless technical individuals with degrees in non-quantitative fields such as\nthe social sciences or business. We expect that the reader will have had at\nleast one elementary course in statistics. Background in linear regression is\nalso useful, though not required, since we review the key concepts behind\nlinear regression in Chapter 3. The mathematical level of this book is modest,\nand a detailed knowledge of matrix operations is not required. This\nbook provides an introduction to the statistical programming language R.\nPrevious exposure to a programming language, such as MATLAB or Python,\nis useful but not required.\nThe first edition of this textbook has been used as to teach master\u2019s and\nPhD students in business, economics, computer science, biology, earth sciences,\npsychology, and many other areas of the physical and social sciences.\nIt has also been used to teach advanced undergraduates who have already\ntaken a course on linear regression. In the context of a more mathematically\nrigorous course in which ESL serves as the primary textbook, ISL\ncould be used as a supplementary text for teaching computational aspects\nof the various approaches.\nNotation and Simple Matrix Algebra\nChoosing notation for a textbook is always a difficult task. For the most\npart we adopt the same notational conventions as ESL.\nWe will use n to represent the number of distinct data points, or observations,\nin our sample. We will let p denote the number of variables that are\navailable for use in making predictions. For example, the Wage data set consists\nof 11 variables for 3,000 people, so we have n = 3,000 observations and\np = 11 variables (such as year, age, race, and more). Note that throughout\nthis book, we indicate variable names using colored font: Variable Name.\nIn some examples, p might be quite large, such as on the order of thousands\nor even millions; this situation arises quite often, for example, in the\nanalysis of modern biological data or web-based advertising data.\n10 1. Introduction\nIn general, we will let xij represent the value of the jth variable for the\nith observation, where i = 1, 2, . . . ,n and j = 1, 2, . . . ,p. Throughout this\nbook, i will be used to index the samples or observations (from 1 to n) and\nj will be used to index the variables (from 1 to p). We let X denote an\nn \u00d7 p matrix whose (i, j)th element is xij . That is,\nX =\n\u239b\n\u239c\u239c\u239c\u239d\nx11 x12 . . . x1p\nx21 x22 . . . x2p\n...\n...\n. . .\n...\nxn1 xn2 . . . xnp\n\u239e\n\u239f\u239f\u239f\u23a0\n.\nFor readers who are unfamiliar with matrices, it is useful to visualize X as\na spreadsheet of numbers with n rows and p columns.\nAt times we will be interested in the rows of X, which we write as\nx1, x2, . . . ,xn. Here xi is a vector of length p, containing the p variable\nmeasurements for the ith observation. That is,\nxi", "doc_id": "66b0032c-dda4-4450-aeb9-f62f1f9b938f", "embedding": null, "doc_hash": "3602ed0797ca3d8489cd88f337719161c5c3f610e270b2a4072f3fa71bcb9bf7", "extra_info": null, "node_info": {"start": 41255, "end": 44820, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "6ed63bc5-b14b-4535-92a1-f9b2f6ecdc62", "3": "f874ffd9-0acf-4695-9401-58d482ee6018"}}, "__type__": "1"}, "f874ffd9-0acf-4695-9401-58d482ee6018": {"__data__": {"text": "containing the p variable\nmeasurements for the ith observation. That is,\nxi =\n\u239b\n\u239c\u239c\u239c\u239d\nxi1\nxi2\n...\nxip\n\u239e\n\u239f\u239f\u239f\u23a0\n. (1.1)\n(Vectors are by default represented as columns.) For example, for the Wage\ndata, xi is a vector of length 11, consisting of year, age, race, and other\nvalues for the ith individual. At other times we will instead be interested\nin the columns of X, which we write as x1, x2, . . . , xp. Each is a vector of\nlength n. That is,\nxj =\n\u239b\n\u239c\u239c\u239c\u239d\nx1j\nx2j\n... xnj\n\u239e\n\u239f\u239f\u239f\u23a0\n.\nFor example, for the Wage data, x1 contains the n = 3,000 values for year.\nUsing this notation, the matrix X can be written as\nX =\n'\nx1 x2 \u00b7 \u00b7 \u00b7 xp\n(\n,\nor\nX =\n\u239b\n\u239c\u239c\u239c\u239d\nxT1\nxT2\n...\nxT\nn\n\u239e\n\u239f\u239f\u239f\u23a0\n.\n1. Introduction 11\nThe T notation denotes the transpose of a matrix or vector. So, for example,\nXT =\n\u239b\n\u239c\u239c\u239c\u239d\nx11 x21 . . . xn1\nx12 x22 . . . xn2\n...\n...\n...\nx1p x2p . . . xnp\n\u239e\n\u239f\u239f\u239f\u23a0\n,\nwhile\nxTi\n=\n'\nxi1 xi2 \u00b7 \u00b7 \u00b7 xip\n(\n.\nWe use yi to denote the ith observation of the variable on which we\nwish to make predictions, such as wage. Hence, we write the set of all n\nobservations in vector form as\ny =\n\u239b\n\u239c\u239c\u239c\u239d\ny1\ny2\n...\nyn\n\u239e\n\u239f\u239f\u239f\u23a0\n.\nThen our observed data consists of {(x1, y1), (x2, y2), . . . , (xn, yn)}, where\neach xi is a vector of length p. (If p = 1, then xi is simply a scalar.)\nIn this text, a vector of length n will always be denoted in lower case\nbold; e.g.\na =\n\u239b\n\u239c\u239c\u239c\u239d\na1\na2\n...\nan\n\u239e\n\u239f\u239f\u239f\u23a0\n.\nHowever, vectors that are not of length n (such as feature vectors of length\np, as in (1.1)) will be denoted in lower case normal font, e.g. a. Scalars will\nalso be denoted in lower case normal font, e.g. a. In the rare cases in which\nthese two uses for lower case normal font lead to ambiguity, we will clarify\nwhich use is intended. Matrices will be denoted using bold capitals, such\nas A. Random variables will be denoted using capital normal font, e.g. A,\nregardless of their dimensions.\nOccasionally we will want to indicate the dimension of a particular object.\nTo indicate that an object is a scalar, we will use the notation a \u2208 R.\nTo indicate that it is a vector of length k, we will use a \u2208 Rk (or a \u2208 Rn if\nit is of length n). We will indicate that an object is an r \u00d7 s matrix using\nA \u2208 Rr\u00d7s.\nWe have avoided using matrix algebra whenever possible. However, in\na few instances it becomes too cumbersome to avoid it entirely. In these\nrare instances it is important to understand the concept of multiplying\ntwo matrices. Suppose that A \u2208 Rr\u00d7d and B \u2208 Rd\u00d7s. Then the product\nof A and B is denoted", "doc_id": "f874ffd9-0acf-4695-9401-58d482ee6018", "embedding": null, "doc_hash": "7cc1d9d9afd442a0b66ae954e8959e472a60d9ee9f996dfecb15cd89050e8242", "extra_info": null, "node_info": {"start": 44819, "end": 47289, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "66b0032c-dda4-4450-aeb9-f62f1f9b938f", "3": "349d3747-7a1d-4840-a597-0a2a21fa6449"}}, "__type__": "1"}, "349d3747-7a1d-4840-a597-0a2a21fa6449": {"__data__": {"text": "and B \u2208 Rd\u00d7s. Then the product\nof A and B is denoted AB. The (i, j)th element of AB is computed by\n12 1. Introduction\nmultiplying each element of the ith row of A by the corresponding element\nof the jth column of B. That is, (AB)ij =\n)d\nk=1 aikbkj. As an example,\nconsider\nA =\n*\n1 2\n3 4\n+\nand B =\n*\n5 6\n7 8\n+\n.\nThen\nAB =\n*\n1 2\n3 4\n+*\n5 6\n7 8\n+\n=\n*\n1 \u00d7 5 + 2 \u00d77 1\u00d7 6 + 2 \u00d7 8\n3 \u00d7 5 + 4 \u00d77 3\u00d7 6 + 4 \u00d7 8\n+\n=\n*\n19 22\n43 50\n+\n.\nNote that this operation produces an r \u00d7 s matrix. It is only possible to\ncompute AB if the number of columns of A is the same as the number of\nrows of B.\nOrganization of This Book\nChapter 2 introduces the basic terminology and concepts behind statistical\nlearning. This chapter also presents the K-nearest neighbor classifier, a\nvery simple method that works surprisingly well on many problems. Chapters\n3 and 4 cover classical linear methods for regression and classification.\nIn particular, Chapter 3 reviews linear regression, the fundamental starting\npoint for all regression methods. In Chapter 4 we discuss two of the\nmost important classical classification methods, logistic regression and linear\ndiscriminant analysis.\nA central problem in all statistical learning situations involves choosing\nthe best method for a given application. Hence, in Chapter 5 we introduce\ncross-validation and the bootstrap, which can be used to estimate the\naccuracy of a number of different methods in order to choose the best one.\nMuch of the recent research in statistical learning has concentrated on\nnon-linear methods. However, linear methods often have advantages over\ntheir non-linear competitors in terms of interpretability and sometimes also\naccuracy. Hence, in Chapter 6 we consider a host of linear methods, both\nclassical and more modern, which offer potential improvements over standard\nlinear regression. These include stepwise selection, ridge regression,\nprincipal components regression, and the lasso.\nThe remaining chapters move into the world of non-linear statistical\nlearning. We first introduce in Chapter 7 a number of non-linear methods\nthat work well for problems with a single input variable. We then\nshow how these methods can be used to fit non-linear additive models for\nwhich there is more than one input. In Chapter 8, we investigate tree-based\nmethods, including bagging, boosting, and random forests. Support vector\nmachines, a set of approaches for performing both linear and non-linear\nclassification, are discussed in Chapter 9. We cover deep learning, an approach\nfor non-linear regression and classification that has received a lot\n1. Introduction 13\nof attention in recent years, in Chapter 10. Chapter 11 explores survival\nanalysis, a regression approach that is specialized to the setting in which\nthe output variable is censored, i.e. not fully observed.\nIn Chapter 12, we consider the unsupervised setting in which we have\ninput variables but no output variable. In particular, we present principal\ncomponents analysis, K-means clustering, and hierarchical clustering.\nFinally, in Chapter 13 we cover the very important topic of multiple hypothesis\ntesting.\nAt the end of each chapter, we present one or more R lab sections in\nwhich we systematically work through applications of the various methods\ndiscussed in that chapter. These labs demonstrate the strengths and\nweaknesses of the various approaches, and also provide a useful reference\nfor the syntax required to implement the various methods. The reader may\nchoose to work through the labs at his or her own pace, or the labs may\nbe the focus of group sessions as part of a classroom environment. Within\neach R lab, we present the results that we obtained when we performed\nthe lab at the time of writing this book. However, new versions of R are\ncontinuously released, and over time, the packages called in the labs will be\nupdated. Therefore,", "doc_id": "349d3747-7a1d-4840-a597-0a2a21fa6449", "embedding": null, "doc_hash": "3f4e01ae3aec762992f3bc85a9d317a236f33eefda2b3b0ced42f92431abeb5e", "extra_info": null, "node_info": {"start": 47315, "end": 51172, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "f874ffd9-0acf-4695-9401-58d482ee6018", "3": "9964a53e-7ff8-4752-9d1c-d74f09e0d40c"}}, "__type__": "1"}, "9964a53e-7ff8-4752-9d1c-d74f09e0d40c": {"__data__": {"text": "released, and over time, the packages called in the labs will be\nupdated. Therefore, in the future, it is possible that the results shown in\nthe lab sections may no longer correspond precisely to the results obtained\nby the reader who performs the labs. As necessary, we will post updates to\nthe labs on the book website.\nWe use the symbol to denote sections or exercises that contain more\nchallenging concepts. These can be easily skipped by readers who do not\nwish to delve as deeply into the material, or who lack the mathematical\nbackground.\nData Sets Used in Labs and Exercises\nIn this textbook, we illustrate statistical learning methods using applications\nfrom marketing, finance, biology, and other areas. The ISLR2 package\navailable on the book website and CRAN contains a number of data sets\nthat are required in order to perform the labs and exercises associated with\nthis book. One other data set is part of the base R distribution. Table 1.1\ncontains a summary of the data sets required to perform the labs and exercises.\nA couple of these data sets are also available as text files on the\nbook website, for use in Chapter 2.\n14 1. Introduction\nName Description\nAuto Gas mileage, horsepower, and other information for cars.\nBikeshare Hourly usage of a bike sharing program in Washington, DC.\nBoston Housing values and other information about Boston census tracts.\nBrainCancer Survival times for patients diagnosed with brain cancer.\nCaravan Information about individuals offered caravan insurance.\nCarseats Information about car seat sales in 400 stores.\nCollege Demographic characteristics, tuition, and more for USA colleges.\nCredit Information about credit card debt for 10,000 customers.\nDefault Customer default records for a credit card company.\nFund Returns of 2,000 hedge fund managers over 50 months.\nHitters Records and salaries for baseball players.\nKhan Gene expression measurements for four cancer types.\nNCI60 Gene expression measurements for 64 cancer cell lines.\nNYSE Returns, volatility, and volume for the New York Stock Exchange.\nOJ Sales information for Citrus Hill and Minute Maid orange juice.\nPortfolio Past values of financial assets, for use in portfolio allocation.\nPublication Time to publication for 244 clinical trials.\nSmarket Daily percentage returns for S&P 500 over a 5-year period.\nUSArrests Crime statistics per 100,000 residents in 50 states of USA.\nWage Income survey data for men in central Atlantic region of USA.\nWeekly 1,089 weekly stock market returns for 21 years.\nTABLE 1.1. A list of data sets needed to perform the labs and exercises in this\ntextbook. All data sets are available in the ISLR2 library, with the exception of\nUSArrests, which is part of the base R distribution.\nBook Website\nThe website for this book is located at\nIt contains a number of resources, including the R package associated with\nthis book, and some additional data sets.\nAcknowledgements\nA few of the plots in this book were taken from ESL: Figures 6.7, 8.3,\nand 12.14. All other plots are new to this book.\nwww.statlearning.com\n2\nStatistical Learning\n2.1 What Is Statistical Learning?\nIn order to motivate our study of statistical learning, we begin with a simple\nexample. Suppose that we are statistical consultants hired by a client to\ninvestigate the association between advertising and sales of a particular\nproduct. The Advertising data set consists of the sales of that product\nin 200 different markets, along with advertising budgets for the product in\neach of those markets for three different media: TV, radio, and newspaper.\nThe data are displayed in Figure 2.1. It is not possible for our client to\ndirectly increase sales of the product. On the other hand, they can control\nthe advertising expenditure in each of the three media. Therefore, if we\ndetermine that there is an association between advertising and sales, then\nwe can instruct our client to adjust advertising budgets, thereby indirectly\nincreasing sales. In other words, our goal is to develop an accurate", "doc_id": "9964a53e-7ff8-4752-9d1c-d74f09e0d40c", "embedding": null, "doc_hash": "ff1fc2859fccabf57cf36768ec56efcc56d7c60f035ef6c443afea48a9ac041e", "extra_info": null, "node_info": {"start": 51142, "end": 55157, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "349d3747-7a1d-4840-a597-0a2a21fa6449", "3": "6dd1ced5-a7fa-4142-b75c-92c5143bd86f"}}, "__type__": "1"}, "6dd1ced5-a7fa-4142-b75c-92c5143bd86f": {"__data__": {"text": "indirectly\nincreasing sales. In other words, our goal is to develop an accurate model\nthat can be used to predict sales on the basis of the three media budgets.\nIn this setting, the advertising budgets are input variables while sales\ninput\nis an output variable. The input variables are typically denoted using the variable\noutput\nvariable\nsymbol X, with a subscript to distinguish them. So X1 might be the TV\nbudget, X2 the radio budget, and X3 the newspaper budget. The inputs\ngo by different names, such as predictors, independent variables, features,\npredictor\nindependent\nvariable\nfeature\nor sometimes just variables. The output variable\u2014in this case, sales\u2014is\nvariable\noften called the response or dependent variable, and is typically denoted\nresponse\ndependent\nvariable\nusing the symbol Y . Throughout this book, we will use all of these terms\ninterchangeably.\n\u00a9 Springer Science+Business Media, LLC, part of Springer Nature 2021\nG. James et al., An Introduction to Statistical Learning, Springer Texts in Statistics,\nhttps://doi.org/10.1007/978-1-0716-1418-1_2\n15\n16 2. Statistical Learning\n0 50 100 200 300\n5 10 15 20 25\nTV\nSales\n0 10 20 30 40 50\n5 10 15 20 25\nRadio\nSales\n0 20 40 60 80 100\n5 10 15 20 25\nNewspaper\nSales\nFIGURE 2.1. The Advertising data set. The plot displays sales, in thousands\nof units, as a function of TV, radio, and newspaper budgets, in thousands of\ndollars, for 200 different markets. In each plot we show the simple least squares\nfit of sales to that variable, as described in Chapter 3. In other words, each blue\nline represents a simple model that can be used to predict sales using TV, radio,\nand newspaper, respectively.\nMore generally, suppose that we observe a quantitative response Y and p\ndifferent predictors, X1,X2, . . . ,Xp. We assume that there is some\nrelationship between Y and X = (X1,X2, . . . ,Xp), which can be written\nin the very general form\nY = f(X) + \u03f5. (2.1)\nHere f is some fixed but unknown function of X1, . . . ,Xp, and \u03f5 is a random\nerror term, which is independent of X and has mean zero. In this formulaerror\nterm\ntion, f represents the systematic information that X provides about Y .\nsystematic\nAs another example, consider the left-hand panel of Figure 2.2, a plot of\nincome versus years of education for 30 individuals in the Income data set.\nThe plot suggests that one might be able to predict income using years of\neducation. However, the function f that connects the input variable to the\noutput variable is in general unknown. In this situation one must estimate\nf based on the observed points. Since Income is a simulated data set, f is\nknown and is shown by the blue curve in the right-hand panel of Figure 2.2.\nThe vertical lines represent the error terms \u03f5. We note that some of the\n30 observations lie above the blue curve and some lie below it; overall, the\nerrors have approximately mean zero.\nIn general, the function f may involve more than one input variable.\nIn Figure 2.3 we plot income as a function of years of education and\nseniority. Here f is a two-dimensional surface that must be estimated\nbased on the observed data.\n2.1 What Is Statistical Learning? 17\n10 12 14 16 18 20 22\n20 30 40 50 60 70 80\nYears of Education\nIncome\n10 12 14 16 18 20 22\n20 30 40 50 60 70 80\nYears of Education\nIncome\nFIGURE 2.2. The Income data set. Left: The red dots are the observed values\nof income (in tens of thousands of dollars) and years of education for 30 individuals.\nRight: The blue curve represents the true underlying relationship between\nincome and years of education, which is generally unknown (but is known in\nthis case because the data were simulated). The black lines represent the error\nassociated with each observation. Note that some errors are", "doc_id": "6dd1ced5-a7fa-4142-b75c-92c5143bd86f", "embedding": null, "doc_hash": "aab2150b218d7248a9d2ceab3e9074682902845b990f0f986561a64528a13709", "extra_info": null, "node_info": {"start": 55162, "end": 58896, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "9964a53e-7ff8-4752-9d1c-d74f09e0d40c", "3": "27b92255-346f-4de7-aa0a-a9fd7f7c633b"}}, "__type__": "1"}, "27b92255-346f-4de7-aa0a-a9fd7f7c633b": {"__data__": {"text": "The black lines represent the error\nassociated with each observation. Note that some errors are positive (if an observation\nlies above the blue curve) and some are negative (if an observation lies\nbelow the curve). Overall, these errors have approximately mean zero.\nIn essence, statistical learning refers to a set of approaches for estimating\nf. In this chapter we outline some of the key theoretical concepts that arise\nin estimating f, as well as tools for evaluating the estimates obtained.\n2.1.1 Why Estimate f?\nThere are two main reasons that we may wish to estimate f: prediction\nand inference. We discuss each in turn.\nPrediction\nIn many situations, a set of inputs X are readily available, but the output\nY cannot be easily obtained. In this setting, since the error term averages\nto zero, we can predict Y using\n\u02c6 Y = \u02c6 f(X), (2.2)\nwhere \u02c6 f represents our estimate for f, and \u02c6 Y represents the resulting prediction\nfor Y . In this setting, \u02c6 f is often treated as a black box, in the sense\nthat one is not typically concerned with the exact form of \u02c6 f, provided that\nit yields accurate predictions for Y .\nAs an example, suppose that X1, . . . ,Xp are characteristics of a patient\u2019s\nblood sample that can be easily measured in a lab, and Y is a variable\nencoding the patient\u2019s risk for a severe adverse reaction to a particular\n18 2. Statistical Learning\nYears of Education\nSeniority\nIncome\nFIGURE 2.3. The plot displays income as a function of years of education\nand seniority in the Income data set. The blue surface represents the true underlying\nrelationship between income and years of education and seniority,\nwhich is known since the data are simulated. The red dots indicate the observed\nvalues of these quantities for 30 individuals.\ndrug. It is natural to seek to predict Y using X, since we can then avoid\ngiving the drug in question to patients who are at high risk of an adverse\nreaction\u2014that is, patients for whom the estimate of Y is high.\nThe accuracy of \u02c6 Y as a prediction for Y depends on two quantities,\nwhich we will call the reducible error and the irreducible error. In general,\nreducible\nerror\nirreducible\nerror\n\u02c6 f will not be a perfect estimate for f, and this inaccuracy will introduce\nsome error. This error is reducible because we can potentially improve the\naccuracy of \u02c6 f by using the most appropriate statistical learning technique to\nestimate f. However, even if it were possible to form a perfect estimate for\nf, so that our estimated response took the form \u02c6 Y = f(X), our prediction\nwould still have some error in it! This is because Y is also a function of\n\u03f5, which, by definition, cannot be predicted using X. Therefore, variability\nassociated with \u03f5 also affects the accuracy of our predictions. This is known\nas the irreducible error, because no matter how well we estimate f, we\ncannot reduce the error introduced by \u03f5.\nWhy is the irreducible error larger than zero? The quantity \u03f5 may contain\nunmeasured variables that are useful in predicting Y : since we don\u2019t\nmeasure them, f cannot use them for its prediction. The quantity \u03f5 may\nalso contain unmeasurable variation. For example, the risk of an adverse\nreaction might vary for a given patient on a given day, depending on\nmanufacturing variation in the drug itself or the patient\u2019s general feeling\nof well-being on that day.\n2.1 What Is Statistical Learning? 19\nConsider a given estimate \u02c6 f and a set of predictors X, which yields the\nprediction \u02c6 Y = \u02c6 f(X). Assume for a moment that both \u02c6 f and X are fixed,\nso that the only variability comes from \u03f5. Then, it is easy to show that\nE(Y \u2212 \u02c6 Y )2 = E[f(X) + \u03f5 \u2212 \u02c6 f(X)]2\n=", "doc_id": "27b92255-346f-4de7-aa0a-a9fd7f7c633b", "embedding": null, "doc_hash": "e781e65cb9290b35a64056b1d6c75fa9324b43249be260d962866ed683f7b836", "extra_info": null, "node_info": {"start": 58883, "end": 62517, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "6dd1ced5-a7fa-4142-b75c-92c5143bd86f", "3": "e02854ae-4f52-44e1-87c6-73c27a837178"}}, "__type__": "1"}, "e02854ae-4f52-44e1-87c6-73c27a837178": {"__data__": {"text": "= E[f(X) + \u03f5 \u2212 \u02c6 f(X)]2\n= [f(X) \u2212 \u02c6 f(X)]2\n, -. /\nReducible\n+ Var(\u03f5) , -. /\nIrreducible\n, (2.3)\nwhere E(Y \u2212 \u02c6 Y )2 represents the average, or expected value, of the squared\nexpected\ndifference between the predicted and actual value of Y , and Var(\u03f5) repre- value\nsents the variance associated with the error term \u03f5.\nvariance\nThe focus of this book is on techniques for estimating f with the aim of\nminimizing the reducible error. It is important to keep in mind that the\nirreducible error will always provide an upper bound on the accuracy of\nour prediction for Y . This bound is almost always unknown in practice.\nInference\nWe are often interested in understanding the association between Y and\nX1, . . . ,Xp. In this situation we wish to estimate f, but our goal is not\nnecessarily to make predictions for Y . Now \u02c6 f cannot be treated as a black\nbox, because we need to know its exact form. In this setting, one may be\ninterested in answering the following questions:\n\u2022 Which predictors are associated with the response? It is often the case\nthat only a small fraction of the available predictors are substantially\nassociated with Y . Identifying the few important predictors among a\nlarge set of possible variables can be extremely useful, depending on\nthe application.\n\u2022 What is the relationship between the response and each predictor?\nSome predictors may have a positive relationship with Y , in the sense\nthat larger values of the predictor are associated with larger values of\nY . Other predictors may have the opposite relationship. Depending\non the complexity of f, the relationship between the response and a\ngiven predictor may also depend on the values of the other predictors.\n\u2022 Can the relationship between Y and each predictor be adequately summarized\nusing a linear equation, or is the relationship more complicated?\nHistorically, most methods for estimating f have taken a linear\nform. In some situations, such an assumption is reasonable or even desirable.\nBut often the true relationship is more complicated, in which\ncase a linear model may not provide an accurate representation of\nthe relationship between the input and output variables.\nIn this book, we will see a number of examples that fall into the prediction\nsetting, the inference setting, or a combination of the two.\n20 2. Statistical Learning\nFor instance, consider a company that is interested in conducting a\ndirect-marketing campaign. The goal is to identify individuals who are\nlikely to respond positively to a mailing, based on observations of demographic\nvariables measured on each individual. In this case, the demographic\nvariables serve as predictors, and response to the marketing campaign\n(either positive or negative) serves as the outcome. The company is\nnot interested in obtaining a deep understanding of the relationships between\neach individual predictor and the response; instead, the company\nsimply wants to accurately predict the response using the predictors. This\nis an example of modeling for prediction.\nIn contrast, consider the Advertising data illustrated in Figure 2.1. One\nmay be interested in answering questions such as:\n\u2013 Which media are associated with sales?\n\u2013 Which media generate the biggest boost in sales? or\n\u2013 How large of an increase in sales is associated with a given increase\nin TV advertising?\nThis situation falls into the inference paradigm. Another example involves\nmodeling the brand of a product that a customer might purchase based on\nvariables such as price, store location, discount levels, competition price,\nand so forth. In this situation one might really be most interested in the\nassociation between each variable and the probability of purchase. For instance,\nto what extent is the product\u2019s price associated with sales? This is\nan example of modeling for inference.\nFinally, some modeling could be conducted both for prediction and inference.\nFor example, in a real estate setting, one may seek to relate values\nof homes to inputs such as crime rate,", "doc_id": "e02854ae-4f52-44e1-87c6-73c27a837178", "embedding": null, "doc_hash": "47a9560da6a65546165e34fda2bc3e541add1c1e2902e4f58b0504b0522cc617", "extra_info": null, "node_info": {"start": 62581, "end": 66575, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "27b92255-346f-4de7-aa0a-a9fd7f7c633b", "3": "9d0829cc-d899-4ccb-8000-ac4a50ad7342"}}, "__type__": "1"}, "9d0829cc-d899-4ccb-8000-ac4a50ad7342": {"__data__": {"text": "one may seek to relate values\nof homes to inputs such as crime rate, zoning, distance from a river, air\nquality, schools, income level of community, size of houses, and so forth. In\nthis case one might be interested in the association between each individual\ninput variable and housing price\u2014for instance, how much extra will a\nhouse be worth if it has a view of the river? This is an inference problem.\nAlternatively, one may simply be interested in predicting the value of a\nhome given its characteristics: is this house under- or over-valued? This is\na prediction problem.\nDepending on whether our ultimate goal is prediction, inference, or a\ncombination of the two, different methods for estimating f may be appropriate.\nFor example, linear models allow for relatively simple and interlinear\nmodel\npretable inference, but may not yield as accurate predictions as some other\napproaches. In contrast, some of the highly non-linear approaches that we\ndiscuss in the later chapters of this book can potentially provide quite accurate\npredictions for Y , but this comes at the expense of a less interpretable\nmodel for which inference is more challenging.\n2.1 What Is Statistical Learning? 21\n2.1.2 How Do We Estimate f?\nThroughout this book, we explore many linear and non-linear approaches\nfor estimating f. However, these methods generally share certain characteristics.\nWe provide an overview of these shared characteristics in this\nsection. We will always assume that we have observed a set of n different\ndata points. For example in Figure 2.2 we observed n = 30 data points.\nThese observations are called the training data because we will use these\ntraining\nobservations to train, or teach, our method how to estimate f. Let xij data\nrepresent the value of the jth predictor, or input, for observation i, where\ni = 1, 2, . . . ,n and j = 1, 2, . . . ,p. Correspondingly, let yi represent the\nresponse variable for the ith observation. Then our training data consist of\n{(x1, y1), (x2, y2), . . . , (xn, yn)} where xi = (xi1, xi2, . . . ,xip)T .\nOur goal is to apply a statistical learning method to the training data\nin order to estimate the unknown function f. In other words, we want to\nfind a function \u02c6 f such that Y \u2248 \u02c6 f(X) for any observation (X, Y ). Broadly\nspeaking, most statistical learning methods for this task can be characterized\nas either parametric or non-parametric. We now briefly discuss these\nparametric\nnonparametric\ntwo types of approaches.\nParametric Methods\nParametric methods involve a two-step model-based approach.\n1. First, we make an assumption about the functional form, or shape,\nof f. For example, one very simple assumption is that f is linear in\nX:\nf(X) = \u03b20 + \u03b21X1 + \u03b22X2 + \u00b7 \u00b7 \u00b7 + \u03b2pXp. (2.4)\nThis is a linear model, which will be discussed extensively in Chapter\n3. Once we have assumed that f is linear, the problem of estimating\nf is greatly simplified. Instead of having to estimate an entirely\narbitrary p-dimensional function f(X), one only needs to estimate\nthe p + 1 coefficients \u03b20,\u03b21, . . . ,\u03b2p.\n2. After a model has been selected, we need a procedure that uses the\ntraining data to fit or train the model. In the case of the linear model\nfit\ntrain (2.4), we need to estimate the parameters \u03b20,\u03b21, . . . ,\u03b2p. That is, we\nwant to find values of these parameters such that\nY \u2248 \u03b20 + \u03b21X1 + \u03b22X2 + \u00b7 \u00b7 \u00b7 + \u03b2pXp.\nThe most common approach to fitting the model (2.4) is referred to\nas (ordinary) least squares, which we discuss in Chapter 3. However,\nleast squares\nleast squares is one of many possible ways to fit the linear model. In\nChapter 6, we discuss other approaches for estimating the", "doc_id": "9d0829cc-d899-4ccb-8000-ac4a50ad7342", "embedding": null, "doc_hash": "fbaffad9b286a985cdfe79cd859e43fac184b04a990a7c4287aaa84543ee611f", "extra_info": null, "node_info": {"start": 66539, "end": 70179, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "e02854ae-4f52-44e1-87c6-73c27a837178", "3": "2e694b4f-c6e0-4619-869e-7aca237cec54"}}, "__type__": "1"}, "2e694b4f-c6e0-4619-869e-7aca237cec54": {"__data__": {"text": "fit the linear model. In\nChapter 6, we discuss other approaches for estimating the parameters\nin (2.4).\n22 2. Statistical Learning\nYears of Education\nSeniority\nIncome\nFIGURE 2.4. A linear model fit by least squares to the Income data from Figure\n2.3. The observations are shown in red, and the yellow plane indicates the\nleast squares fit to the data.\nThe model-based approach just described is referred to as parametric;\nit reduces the problem of estimating f down to one of estimating a set of\nparameters. Assuming a parametric form for f simplifies the problem of\nestimating f because it is generally much easier to estimate a set of parameters,\nsuch as \u03b20,\u03b21, . . . ,\u03b2p in the linear model (2.4), than it is to fit\nan entirely arbitrary function f. The potential disadvantage of a parametric\napproach is that the model we choose will usually not match the true\nunknown form of f. If the chosen model is too far from the true f, then\nour estimate will be poor. We can try to address this problem by choosing\nflexible models that can fit many different possible functional forms\nflexible\nfor f. But in general, fitting a more flexible model requires estimating a\ngreater number of parameters. These more complex models can lead to a\nphenomenon known as overfitting the data, which essentially means they\noverfitting\nfollow the errors, or noise, too closely. These issues are discussed throughnoise\nout this book.\nFigure 2.4 shows an example of the parametric approach applied to the\nIncome data from Figure 2.3. We have fit a linear model of the form\nincome \u2248 \u03b20 + \u03b21 \u00d7 education + \u03b22 \u00d7 seniority.\nSince we have assumed a linear relationship between the response and the\ntwo predictors, the entire fitting problem reduces to estimating \u03b20, \u03b21, and\n\u03b22, which we do using least squares linear regression. Comparing Figure 2.3\nto Figure 2.4, we can see that the linear fit given in Figure 2.4 is not quite\nright: the true f has some curvature that is not captured in the linear fit.\nHowever, the linear fit still appears to do a reasonable job of capturing the\n2.1 What Is Statistical Learning? 23\nYears of Education\nSeniority\nIncome\nFIGURE 2.5. A smooth thin-plate spline fit to the Income data from Figure 2.3\nis shown in yellow; the observations are displayed in red. Splines are discussed in\nChapter 7.\npositive relationship between years of education and income, as well as the\nslightly less positive relationship between seniority and income. It may be\nthat with such a small number of observations, this is the best we can do.\nNon-Parametric Methods\nNon-parametric methods do not make explicit assumptions about the functional\nform of f. Instead they seek an estimate of f that gets as close to the\ndata points as possible without being too rough or wiggly. Such approaches\ncan have a major advantage over parametric approaches: by avoiding the\nassumption of a particular functional form for f, they have the potential\nto accurately fit a wider range of possible shapes for f. Any parametric\napproach brings with it the possibility that the functional form used to\nestimate f is very different from the true f, in which case the resulting\nmodel will not fit the data well. In contrast, non-parametric approaches\ncompletely avoid this danger, since essentially no assumption about the\nform of f is made. But non-parametric approaches do suffer from a major\ndisadvantage: since they do not reduce the problem of estimating f to a\nsmall number of parameters, a very large number of observations (far more\nthan is typically needed for a parametric approach) is required in order to\nobtain an accurate estimate for f.\nAn example of a non-parametric approach to fitting the Income data is\nshown in Figure 2.5. A thin-plate spline is used to estimate f. This apthin-\nplate\nproach does not impose any pre-specified model on f. It instead attempts spline\nto produce an estimate for f that is as", "doc_id": "2e694b4f-c6e0-4619-869e-7aca237cec54", "embedding": null, "doc_hash": "35b582212611ccda69cc74c50358dff4ea022a2bc98a811f3f4bca5c1c6fbb9d", "extra_info": null, "node_info": {"start": 70166, "end": 74057, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "9d0829cc-d899-4ccb-8000-ac4a50ad7342", "3": "72acecb6-1edc-427a-9ba0-610d001f4b23"}}, "__type__": "1"}, "72acecb6-1edc-427a-9ba0-610d001f4b23": {"__data__": {"text": "It instead attempts spline\nto produce an estimate for f that is as close as possible to the observed\ndata, subject to the fit\u2014that is, the yellow surface in Figure 2.5\u2014being\n24 2. Statistical Learning\nYears of Education\nSeniority\nIncome\nFIGURE 2.6. A rough thin-plate spline fit to the Income data from Figure 2.3.\nThis fit makes zero errors on the training data.\nsmooth. In this case, the non-parametric fit has produced a remarkably accurate\nestimate of the true f shown in Figure 2.3. In order to fit a thin-plate\nspline, the data analyst must select a level of smoothness. Figure 2.6 shows\nthe same thin-plate spline fit using a lower level of smoothness, allowing\nfor a rougher fit. The resulting estimate fits the observed data perfectly!\nHowever, the spline fit shown in Figure 2.6 is far more variable than the\ntrue function f, from Figure 2.3. This is an example of overfitting the\ndata, which we discussed previously. It is an undesirable situation because\nthe fit obtained will not yield accurate estimates of the response on new\nobservations that were not part of the original training data set. We discuss\nmethods for choosing the correct amount of smoothness in Chapter 5.\nSplines are discussed in Chapter 7.\nAs we have seen, there are advantages and disadvantages to parametric\nand non-parametric methods for statistical learning. We explore both types\nof methods throughout this book.\n2.1.3 The Trade-Off Between Prediction Accuracy and Model\nInterpretability\nOf the many methods that we examine in this book, some are less flexible,\nor more restrictive, in the sense that they can produce just a relatively\nsmall range of shapes to estimate f. For example, linear regression is a\nrelatively inflexible approach, because it can only generate linear functions\nsuch as the lines shown in Figure 2.1 or the plane shown in Figure 2.4.\nOther methods, such as the thin plate splines shown in Figures 2.5 and 2.6,\n2.1 What Is Statistical Learning? 25\nFlexibility\nInterpretability\nLow High\nLow High\nSubset Selection\nLasso\nLeast Squares\nGeneralized Additive Models\nTrees\nBagging, Boosting\nSupport Vector Machines\nDeep Learning\nFIGURE 2.7. A representation of the tradeoff between flexibility and interpretability,\nusing different statistical learning methods. In general, as the flexibility\nof a method increases, its interpretability decreases.\nare considerably more flexible because they can generate a much wider\nrange of possible shapes to estimate f.\nOne might reasonably ask the following question: why would we ever\nchoose to use a more restrictive method instead of a very flexible approach?\nThere are several reasons that we might prefer a more restrictive model.\nIf we are mainly interested in inference, then restrictive models are much\nmore interpretable. For instance, when inference is the goal, the linear\nmodel may be a good choice since it will be quite easy to understand\nthe relationship between Y and X1,X2, . . . ,Xp. In contrast, very flexible\napproaches, such as the splines discussed in Chapter 7 and displayed in\nFigures 2.5 and 2.6, and the boosting methods discussed in Chapter 8, can\nlead to such complicated estimates of f that it is difficult to understand\nhow any individual predictor is associated with the response.\nFigure 2.7 provides an illustration of the trade-off between flexibility and\ninterpretability for some of the methods that we cover in this book. Least\nsquares linear regression, discussed in Chapter 3, is relatively inflexible but\nis quite interpretable. The lasso, discussed in Chapter 6, relies upon the\nlasso\nlinear model (2.4) but uses an alternative fitting procedure for estimating\nthe coefficients \u03b20,\u03b21, . . . ,\u03b2p. The new procedure is more restrictive in estimating\nthe coefficients, and sets a number of them to exactly zero. Hence\nin this sense the lasso is a less flexible approach than", "doc_id": "72acecb6-1edc-427a-9ba0-610d001f4b23", "embedding": null, "doc_hash": "a1cd9b29ed64ddf790157a2a810bbe4ef99fe444824075bbb668cf3d1d987cc9", "extra_info": null, "node_info": {"start": 74073, "end": 77928, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "2e694b4f-c6e0-4619-869e-7aca237cec54", "3": "caee6ebc-b481-4dde-89ef-7e7f158d3fae"}}, "__type__": "1"}, "caee6ebc-b481-4dde-89ef-7e7f158d3fae": {"__data__": {"text": "zero. Hence\nin this sense the lasso is a less flexible approach than linear regression.\nIt is also more interpretable than linear regression, because in the final\nmodel the response variable will only be related to a small subset of the\npredictors\u2014namely, those with nonzero coefficient estimates. Generalized\nadditive models (GAMs), discussed in Chapter 7, instead extend the lingeneralized\nadditive\nmodel\near model (2.4) to allow for certain non-linear relationships. Consequently,\n26 2. Statistical Learning\nGAMs are more flexible than linear regression. They are also somewhat\nless interpretable than linear regression, because the relationship between\neach predictor and the response is now modeled using a curve. Finally,\nfully non-linear methods such as bagging, boosting, support vector machines\nbagging\nboosting\nwith non-linear kernels, and neural networks (deep learning), discussed in\nsupport\nvector\nmachine\nChapters 8, 9, and 10, are highly flexible approaches that are harder to\ninterpret.\nWe have established that when inference is the goal, there are clear advantages\nto using simple and relatively inflexible statistical learning methods.\nIn some settings, however, we are only interested in prediction, and\nthe interpretability of the predictive model is simply not of interest. For\ninstance, if we seek to develop an algorithm to predict the price of a\nstock, our sole requirement for the algorithm is that it predict accurately\u2014\ninterpretability is not a concern. In this setting, we might expect that it\nwill be best to use the most flexible model available. Surprisingly, this is\nnot always the case! We will often obtain more accurate predictions using\na less flexible method. This phenomenon, which may seem counterintuitive\nat first glance, has to do with the potential for overfitting in highly flexible\nmethods. We saw an example of overfitting in Figure 2.6. We will discuss\nthis very important concept further in Section 2.2 and throughout this\nbook.\n2.1.4 Supervised Versus Unsupervised Learning\nMost statistical learning problems fall into one of two categories: supervised\nsupervised\nor unsupervised. The examples that we have discussed so far in this chapunsupervised\nter all fall into the supervised learning domain. For each observation of the\npredictor measurement(s) xi, i = 1, . . . ,n there is an associated response\nmeasurement yi. We wish to fit a model that relates the response to the\npredictors, with the aim of accurately predicting the response for future\nobservations (prediction) or better understanding the relationship between\nthe response and the predictors (inference). Many classical statistical learning\nmethods such as linear regression and logistic regression (Chapter 4), as\nlogistic\nwell as more modern approaches such as GAM, boosting, and support vec- regression\ntor machines, operate in the supervised learning domain. The vast majority\nof this book is devoted to this setting.\nBy contrast, unsupervised learning describes the somewhat more challenging\nsituation in which for every observation i = 1, . . . ,n, we observe\na vector of measurements xi but no associated response yi. It is not possible\nto fit a linear regression model, since there is no response variable\nto predict. In this setting, we are in some sense working blind; the situation\nis referred to as unsupervised because we lack a response variable\nthat can supervise our analysis. What sort of statistical analysis is\npossible?We can seek to understand the relationships between the variables\nor between the observations. One statistical learning tool that we may use\n2.1 What Is Statistical Learning? 27\n0 2 4 6 8 10 12\n2 4 6 8 10 12\n0 2 4 6\n2 4 6 8\nX1 X1\nX2\nX2\nFIGURE 2.8. A clustering data set involving three groups. Each group is shown\nusing a different colored symbol. Left: The three groups are well-separated. In\nthis setting, a clustering approach should successfully identify the three groups.\nRight: There is some overlap among the", "doc_id": "caee6ebc-b481-4dde-89ef-7e7f158d3fae", "embedding": null, "doc_hash": "ba492e4f3e7533258e15ae1e19987b9aaa71f284857fc8021417cbad03092b55", "extra_info": null, "node_info": {"start": 77927, "end": 81897, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "72acecb6-1edc-427a-9ba0-610d001f4b23", "3": "232dc53c-2bd6-4f60-92dd-44d316e90306"}}, "__type__": "1"}, "232dc53c-2bd6-4f60-92dd-44d316e90306": {"__data__": {"text": "approach should successfully identify the three groups.\nRight: There is some overlap among the groups. Now the clustering task is more\nchallenging.\nin this setting is cluster analysis, or clustering. The goal of cluster analysis\ncluster\nis to ascertain, on the basis of x1, . . . , xn, whether the observations fall into analysis\nrelatively distinct groups. For example, in a market segmentation study we\nmight observe multiple characteristics (variables) for potential customers,\nsuch as zip code, family income, and shopping habits. We might believe\nthat the customers fall into different groups, such as big spenders versus\nlow spenders. If the information about each customer\u2019s spending patterns\nwere available, then a supervised analysis would be possible. However, this\ninformation is not available\u2014that is, we do not know whether each potential\ncustomer is a big spender or not. In this setting, we can try to cluster\nthe customers on the basis of the variables measured, in order to identify\ndistinct groups of potential customers. Identifying such groups can be of\ninterest because it might be that the groups differ with respect to some\nproperty of interest, such as spending habits.\nFigure 2.8 provides a simple illustration of the clustering problem. We\nhave plotted 150 observations with measurements on two variables, X1\nand X2. Each observation corresponds to one of three distinct groups. For\nillustrative purposes, we have plotted the members of each group using different\ncolors and symbols. However, in practice the group memberships are\nunknown, and the goal is to determine the group to which each observation\nbelongs. In the left-hand panel of Figure 2.8, this is a relatively easy\ntask because the groups are well-separated. By contrast, the right-hand\npanel illustrates a more challenging setting in which there is some overlap\n28 2. Statistical Learning\nbetween the groups. A clustering method could not be expected to assign\nall of the overlapping points to their correct group (blue, green, or orange).\nIn the examples shown in Figure 2.8, there are only two variables, and\nso one can simply visually inspect the scatterplots of the observations in\norder to identify clusters. However, in practice, we often encounter data\nsets that contain many more than two variables. In this case, we cannot\neasily plot the observations. For instance, if there are p variables in our\ndata set, then p(p \u2212 1)/2 distinct scatterplots can be made, and visual\ninspection is simply not a viable way to identify clusters. For this reason,\nautomated clustering methods are important. We discuss clustering and\nother unsupervised learning approaches in Chapter 12.\nMany problems fall naturally into the supervised or unsupervised learning\nparadigms. However, sometimes the question of whether an analysis\nshould be considered supervised or unsupervised is less clear-cut. For instance,\nsuppose that we have a set of n observations. For m of the observations,\nwhere m < n, we have both predictor measurements and a response\nmeasurement. For the remaining n \u2212 m observations, we have predictor\nmeasurements but no response measurement. Such a scenario can arise if\nthe predictors can be measured relatively cheaply but the corresponding\nresponses are much more expensive to collect. We refer to this setting as\na semi-supervised learning problem. In this setting, we wish to use a stasemisupervised\nlearning\ntistical learning method that can incorporate the m observations for which\nresponse measurements are available as well as the n \u2212m observations for\nwhich they are not. Although this is an interesting topic, it is beyond the\nscope of this book.\n2.1.5 Regression Versus Classification Problems\nVariables can be characterized as either quantitative or qualitative (also\nquantitative\nqualitative\nknown as categorical). Quantitative variables take on numerical values.\ncategorical\nExamples include a person\u2019s age, height, or income, the value of a house,\nand the price of", "doc_id": "232dc53c-2bd6-4f60-92dd-44d316e90306", "embedding": null, "doc_hash": "3b45cafebab5660a1b8e35b7d0199a660323d2a72995c9bdfed0b81a28ce5d22", "extra_info": null, "node_info": {"start": 81873, "end": 85851, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "caee6ebc-b481-4dde-89ef-7e7f158d3fae", "3": "622463d1-cc6d-4f08-9c2e-1d2f6eec2ea0"}}, "__type__": "1"}, "622463d1-cc6d-4f08-9c2e-1d2f6eec2ea0": {"__data__": {"text": "age, height, or income, the value of a house,\nand the price of a stock. In contrast, qualitative variables take on values\nin one of K different classes, or categories. Examples of qualitative variclass\nables include a person\u2019s marital status (married or not), the brand of product\npurchased (brand A, B, or C), whether a person defaults on a debt\n(yes or no), or a cancer diagnosis (Acute Myelogenous Leukemia, Acute\nLymphoblastic Leukemia, or No Leukemia). We tend to refer to problems\nwith a quantitative response as regression problems, while those involvregression\ning a qualitative response are often referred to as classification problems.\nclassification\nHowever, the distinction is not always that crisp. Least squares linear regression\n(Chapter 3) is used with a quantitative response, whereas logistic\nregression (Chapter 4) is typically used with a qualitative (two-class, or\nbinary) response. Thus, despite its name, logistic regression is a classificabinary\ntion method. But since it estimates class probabilities, it can be thought of\nas a regression method as well. Some statistical methods, such as K-nearest\n2.2 Assessing Model Accuracy 29\nneighbors (Chapters 2 and 4) and boosting (Chapter 8), can be used in the\ncase of either quantitative or qualitative responses.\nWe tend to select statistical learning methods on the basis of whether\nthe response is quantitative or qualitative; i.e. we might use linear regression\nwhen quantitative and logistic regression when qualitative. However,\nwhether the predictors are qualitative or quantitative is generally considered\nless important. Most of the statistical learning methods discussed in\nthis book can be applied regardless of the predictor variable type, provided\nthat any qualitative predictors are properly coded before the analysis is\nperformed. This is discussed in Chapter 3.\n2.2 Assessing Model Accuracy\nOne of the key aims of this book is to introduce the reader to a wide range\nof statistical learning methods that extend far beyond the standard linear\nregression approach. Why is it necessary to introduce so many different\nstatistical learning approaches, rather than just a single best method? There\nis no free lunch in statistics: no one method dominates all others over all\npossible data sets. On a particular data set, one specific method may work\nbest, but some other method may work better on a similar but different\ndata set. Hence it is an important task to decide for any given set of data\nwhich method produces the best results. Selecting the best approach can\nbe one of the most challenging parts of performing statistical learning in\npractice.\nIn this section, we discuss some of the most important concepts that\narise in selecting a statistical learning procedure for a specific data set. As\nthe book progresses, we will explain how the concepts presented here can\nbe applied in practice.\n2.2.1 Measuring the Quality of Fit\nIn order to evaluate the performance of a statistical learning method on\na given data set, we need some way to measure how well its predictions\nactually match the observed data. That is, we need to quantify the extent\nto which the predicted response value for a given observation is close to\nthe true response value for that observation. In the regression setting, the\nmost commonly-used measure is the mean squared error (MSE), given by mean\nsquared\nerror\nMSE =\n1\nn\n0n\ni=1\n(yi \u2212 \u02c6 f(xi))2, (2.5)\nwhere \u02c6 f(xi) is the prediction that \u02c6 f gives for the ith observation. The MSE\nwill be small if the predicted responses are very close to the true responses,\n30 2. Statistical Learning\nand will be large if for some of the observations, the predicted and true\nresponses differ substantially.\nThe MSE in (2.5) is computed using the training data that was used to\nfit the model, and so should more accurately be referred to as the training\nMSE. But in general, we do not really care how well the method works\ntraining\non the training data. Rather, we", "doc_id": "622463d1-cc6d-4f08-9c2e-1d2f6eec2ea0", "embedding": null, "doc_hash": "1b696f3bb25404eb58595f88589a0a672d2c2f30e85c4b5e930633b8fb3394b4", "extra_info": null, "node_info": {"start": 85883, "end": 89842, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "232dc53c-2bd6-4f60-92dd-44d316e90306", "3": "6331a59d-9d97-4288-be16-f28988c47506"}}, "__type__": "1"}, "6331a59d-9d97-4288-be16-f28988c47506": {"__data__": {"text": "do not really care how well the method works\ntraining\non the training data. Rather, we are interested in the accuracy of the pre- MSE\ndictions that we obtain when we apply our method to previously unseen\ntest data. Why is this what we care about? Suppose that we are interested\ntest data\nin developing an algorithm to predict a stock\u2019s price based on previous\nstock returns. We can train the method using stock returns from the past\n6 months. But we don\u2019t really care how well our method predicts last week\u2019s\nstock price. We instead care about how well it will predict tomorrow\u2019s price\nor next month\u2019s price. On a similar note, suppose that we have clinical\nmeasurements (e.g. weight, blood pressure, height, age, family history of\ndisease) for a number of patients, as well as information about whether each\npatient has diabetes. We can use these patients to train a statistical learning\nmethod to predict risk of diabetes based on clinical measurements. In\npractice, we want this method to accurately predict diabetes risk for future\npatients based on their clinical measurements. We are not very interested\nin whether or not the method accurately predicts diabetes risk for patients\nused to train the model, since we already know which of those patients\nhave diabetes.\nTo state it more mathematically, suppose that we fit our statistical learning\nmethod on our training observations {(x1, y1), (x2, y2), . . . , (xn, yn)},\nand we obtain the estimate \u02c6 f.We can then compute \u02c6 f(x1), \u02c6 f(x2), . . . , \u02c6 f(xn).\nIf these are approximately equal to y1, y2, . . . , yn, then the training MSE\ngiven by (2.5) is small. However, we are really not interested in whether\n\u02c6 f(xi) \u2248 yi; instead, we want to know whether \u02c6 f(x0) is approximately equal\nto y0, where (x0, y0) is a previously unseen test observation not used to train\nthe statistical learning method. We want to choose the method that gives\nthe lowest test MSE, as opposed to the lowest training MSE. In other words,\ntest MSE\nif we had a large number of test observations, we could compute\nAve(y0 \u2212 \u02c6 f(x0))2, (2.6)\nthe average squared prediction error for these test observations (x0, y0).\nWe\u2019d like to select the model for which this quantity is as small as possible.\nHow can we go about trying to select a method that minimizes the test\nMSE? In some settings, we may have a test data set available\u2014that is,\nwe may have access to a set of observations that were not used to train\nthe statistical learning method. We can then simply evaluate (2.6) on the\ntest observations, and select the learning method for which the test MSE is\nsmallest. But what if no test observations are available? In that case, one\nmight imagine simply selecting a statistical learning method that minimizes\nthe training MSE (2.5). This seems like it might be a sensible approach,\n2.2 Assessing Model Accuracy 31\n0 20 40 60 80 100\n2 4 6 8 10 12\nX\nY\n2 5 10 20\n0.0 0.5 1.0 1.5 2.0 2.5\nFlexibility\nMean Squared Error\nFIGURE 2.9. Left: Data simulated from f, shown in black. Three estimates of\nf are shown: the linear regression line (orange curve), and two smoothing spline\nfits (blue and green curves). Right: Training MSE (grey curve), test MSE (red\ncurve), and minimum possible test MSE over all methods (dashed line). Squares\nrepresent the training and test MSEs for the three fits shown in the left-hand\npanel.\nsince the training MSE and the test MSE appear to be closely related.\nUnfortunately, there is a fundamental problem with this strategy: there\nis no guarantee that the method with the lowest training MSE will also\nhave the lowest test", "doc_id": "6331a59d-9d97-4288-be16-f28988c47506", "embedding": null, "doc_hash": "0d93be48d54d47be8cd2cd6580044f0de94b3819a35499d1ca946216e5b71474", "extra_info": null, "node_info": {"start": 89821, "end": 93397, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "622463d1-cc6d-4f08-9c2e-1d2f6eec2ea0", "3": "e53be7b2-5055-4061-8c85-210d78e48729"}}, "__type__": "1"}, "e53be7b2-5055-4061-8c85-210d78e48729": {"__data__": {"text": "that the method with the lowest training MSE will also\nhave the lowest test MSE. Roughly speaking, the problem is that many\nstatistical methods specifically estimate coefficients so as to minimize the\ntraining set MSE. For these methods, the training set MSE can be quite\nsmall, but the test MSE is often much larger.\nFigure 2.9 illustrates this phenomenon on a simple example. In the lefthand\npanel of Figure 2.9, we have generated observations from (2.1) with\nthe true f given by the black curve. The orange, blue and green curves illustrate\nthree possible estimates for f obtained using methods with increasing\nlevels of flexibility. The orange line is the linear regression fit, which is relatively\ninflexible. The blue and green curves were produced using smoothing\nsplines, discussed in Chapter 7, with different levels of smoothness. It is\nsmoothing\nclear that as the level of flexibility increases, the curves fit the observed spline\ndata more closely. The green curve is the most flexible and matches the\ndata very well; however, we observe that it fits the true f (shown in black)\npoorly because it is too wiggly. By adjusting the level of flexibility of the\nsmoothing spline fit, we can produce many different fits to this data.\nWe now move on to the right-hand panel of Figure 2.9. The grey curve\ndisplays the average training MSE as a function of flexibility, or more formally\nthe degrees of freedom, for a number of smoothing splines. The dedegrees\nof\ngrees of freedom is a quantity that summarizes the flexibility of a curve; it freedom\n32 2. Statistical Learning\nis discussed more fully in Chapter 7. The orange, blue and green squares\nindicate the MSEs associated with the corresponding curves in the lefthand\npanel. A more restricted and hence smoother curve has fewer degrees\nof freedom than a wiggly curve\u2014note that in Figure 2.9, linear regression\nis at the most restrictive end, with two degrees of freedom. The training\nMSE declines monotonically as flexibility increases. In this example the\ntrue f is non-linear, and so the orange linear fit is not flexible enough to\nestimate f well. The green curve has the lowest training MSE of all three\nmethods, since it corresponds to the most flexible of the three curves fit in\nthe left-hand panel.\nIn this example, we know the true function f, and so we can also compute\nthe test MSE over a very large test set, as a function of flexibility. (Of\ncourse, in general f is unknown, so this will not be possible.) The test MSE\nis displayed using the red curve in the right-hand panel of Figure 2.9. As\nwith the training MSE, the test MSE initially declines as the level of flexibility\nincreases. However, at some point the test MSE levels off and then\nstarts to increase again. Consequently, the orange and green curves both\nhave high test MSE. The blue curve minimizes the test MSE, which should\nnot be surprising given that visually it appears to estimate f the best in the\nleft-hand panel of Figure 2.9. The horizontal dashed line indicates Var(\u03f5),\nthe irreducible error in (2.3), which corresponds to the lowest achievable\ntest MSE among all possible methods. Hence, the smoothing spline represented\nby the blue curve is close to optimal.\nIn the right-hand panel of Figure 2.9, as the flexibility of the statistical\nlearning method increases, we observe a monotone decrease in the training\nMSE and a U-shape in the test MSE. This is a fundamental property of\nstatistical learning that holds regardless of the particular data set at hand\nand regardless of the statistical method being used. As model flexibility\nincreases, training MSE will decrease, but the test MSE may not. When\na given method yields a small training MSE but a large test MSE, we are\nsaid to be overfitting the data. This happens because our statistical learning\nprocedure", "doc_id": "e53be7b2-5055-4061-8c85-210d78e48729", "embedding": null, "doc_hash": "15bc19a460422e63289c0fc4cd5abdab29b7ae35dfea0976380df5b80fc1822e", "extra_info": null, "node_info": {"start": 93408, "end": 97217, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "6331a59d-9d97-4288-be16-f28988c47506", "3": "e99575af-57cb-4406-8f22-93dac41bfd37"}}, "__type__": "1"}, "e99575af-57cb-4406-8f22-93dac41bfd37": {"__data__": {"text": "to be overfitting the data. This happens because our statistical learning\nprocedure is working too hard to find patterns in the training data, and\nmay be picking up some patterns that are just caused by random chance\nrather than by true properties of the unknown function f. When we overfit\nthe training data, the test MSE will be very large because the supposed\npatterns that the method found in the training data simply don\u2019t exist\nin the test data. Note that regardless of whether or not overfitting has\noccurred, we almost always expect the training MSE to be smaller than\nthe test MSE because most statistical learning methods either directly or\nindirectly seek to minimize the training MSE. Overfitting refers specifically\nto the case in which a less flexible model would have yielded a smaller\ntest MSE.\nFigure 2.10 provides another example in which the true f is approximately\nlinear. Again we observe that the training MSE decreases monotonically\nas the model flexibility increases, and that there is a U-shape in\n2.2 Assessing Model Accuracy 33\n0 20 40 60 80 100\n2 4 6 8 10 12\nX\nY\n2 5 10 20\n0.0 0.5 1.0 1.5 2.0 2.5\nFlexibility\nMean Squared Error\nFIGURE 2.10. Details are as in Figure 2.9, using a different true f that is\nmuch closer to linear. In this setting, linear regression provides a very good fit to\nthe data.\nthe test MSE. However, because the truth is close to linear, the test MSE\nonly decreases slightly before increasing again, so that the orange least\nsquares fit is substantially better than the highly flexible green curve. Finally,\nFigure 2.11 displays an example in which f is highly non-linear. The\ntraining and test MSE curves still exhibit the same general patterns, but\nnow there is a rapid decrease in both curves before the test MSE starts to\nincrease slowly.\nIn practice, one can usually compute the training MSE with relative\nease, but estimating test MSE is considerably more difficult because usually\nno test data are available. As the previous three examples illustrate, the\nflexibility level corresponding to the model with the minimal test MSE can\nvary considerably among data sets. Throughout this book, we discuss a\nvariety of approaches that can be used in practice to estimate this minimum\npoint. One important method is cross-validation (Chapter 5), which is a crossmethod\nfor estimating test MSE using the training data. validation\n2.2.2 The Bias-Variance Trade-Off\nThe U-shape observed in the test MSE curves (Figures 2.9\u20132.11) turns out\nto be the result of two competing properties of statistical learning methods.\nThough the mathematical proof is beyond the scope of this book, it is\npossible to show that the expected test MSE, for a given value x0, can\nalways be decomposed into the sum of three fundamental quantities: the\nvariance of \u02c6 f(x0), the squared bias of \u02c6 f(x0) and the variance of the error\nvariance\nbias\n34 2. Statistical Learning\n0 20 40 60 80 100\n\u221210 0 10 20\nX\nY\n2 5 10 20\n0 5 10 15 20\nFlexibility\nMean Squared Error\nFIGURE 2.11. Details are as in Figure 2.9, using a different f that is far from\nlinear. In this setting, linear regression provides a very poor fit to the data.\nterms \u03f5. That is,\nE\n1\ny0 \u2212 \u02c6 f(x0)\n22\n= Var( \u02c6 f(x0)) + [Bias( \u02c6 f(x0))]2 + Var(\u03f5). (2.7)\nHere the notation E\n1\ny0 \u2212 \u02c6 f(x0)\n22\ndefines the expected test MSE at x0,\nexpected\nand refers to the average test MSE that we would obtain if we repeatedly test MSE\nestimated f using a large number of training sets, and tested each at x0. The\noverall expected test MSE can be computed by averaging E\n1\ny0 \u2212 \u02c6", "doc_id": "e99575af-57cb-4406-8f22-93dac41bfd37", "embedding": null, "doc_hash": "5628f27b6883aba9f9e8d6251bb47e47c00b5d2bc592ec4c150f2b6088d9aa71", "extra_info": null, "node_info": {"start": 97208, "end": 100752, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "e53be7b2-5055-4061-8c85-210d78e48729", "3": "b712d817-9524-4a3b-b00e-b751757d35f7"}}, "__type__": "1"}, "b712d817-9524-4a3b-b00e-b751757d35f7": {"__data__": {"text": "expected test MSE can be computed by averaging E\n1\ny0 \u2212 \u02c6 f(x0)\n22\nover all possible values of x0 in the test set.\nEquation 2.7 tells us that in order to minimize the expected test error,\nwe need to select a statistical learning method that simultaneously achieves\nlow variance and low bias. Note that variance is inherently a nonnegative\nquantity, and squared bias is also nonnegative. Hence, we see that the\nexpected test MSE can never lie below Var(\u03f5), the irreducible error from\n(2.3).\nWhat do we mean by the variance and bias of a statistical learning\nmethod? Variance refers to the amount by which \u02c6 f would change if we\nestimated it using a different training data set. Since the training data\nare used to fit the statistical learning method, different training data sets\nwill result in a different \u02c6 f. But ideally the estimate for f should not vary\ntoo much between training sets. However, if a method has high variance\nthen small changes in the training data can result in large changes in \u02c6 f. In\ngeneral, more flexible statistical methods have higher variance. Consider the\ngreen and orange curves in Figure 2.9. The flexible green curve is following\nthe observations very closely. It has high variance because changing any\n2.2 Assessing Model Accuracy 35\none of these data points may cause the estimate \u02c6 f to change considerably.\nIn contrast, the orange least squares line is relatively inflexible and has low\nvariance, because moving any single observation will likely cause only a\nsmall shift in the position of the line.\nOn the other hand, bias refers to the error that is introduced by approximating\na real-life problem, which may be extremely complicated, by a much\nsimpler model. For example, linear regression assumes that there is a linear\nrelationship between Y and X1,X2, . . . ,Xp. It is unlikely that any real-life\nproblem truly has such a simple linear relationship, and so performing linear\nregression will undoubtedly result in some bias in the estimate of f. In\nFigure 2.11, the true f is substantially non-linear, so no matter how many\ntraining observations we are given, it will not be possible to produce an\naccurate estimate using linear regression. In other words, linear regression\nresults in high bias in this example. However, in Figure 2.10 the true f is\nvery close to linear, and so given enough data, it should be possible for\nlinear regression to produce an accurate estimate. Generally, more flexible\nmethods result in less bias.\nAs a general rule, as we use more flexible methods, the variance will\nincrease and the bias will decrease. The relative rate of change of these\ntwo quantities determines whether the test MSE increases or decreases. As\nwe increase the flexibility of a class of methods, the bias tends to initially\ndecrease faster than the variance increases. Consequently, the expected\ntest MSE declines. However, at some point increasing flexibility has little\nimpact on the bias but starts to significantly increase the variance. When\nthis happens the test MSE increases. Note that we observed this pattern\nof decreasing test MSE followed by increasing test MSE in the right-hand\npanels of Figures 2.9\u20132.11.\nThe three plots in Figure 2.12 illustrate Equation 2.7 for the examples in\nFigures 2.9\u20132.11. In each case the blue solid curve represents the squared\nbias, for different levels of flexibility, while the orange curve corresponds to\nthe variance. The horizontal dashed line represents Var(\u03f5), the irreducible\nerror. Finally, the red curve, corresponding to the test set MSE, is the sum\nof these three quantities. In all three cases, the variance increases and the\nbias decreases as the method\u2019s flexibility increases. However, the flexibility\nlevel corresponding to the optimal test MSE differs considerably among the\nthree data sets, because the squared bias and variance change at different\nrates in each of", "doc_id": "b712d817-9524-4a3b-b00e-b751757d35f7", "embedding": null, "doc_hash": "5cc9f9cd0c5afe0cd308b54c1d85e857af395518107d05ae75dd363a40b5ade4", "extra_info": null, "node_info": {"start": 100779, "end": 104652, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "e99575af-57cb-4406-8f22-93dac41bfd37", "3": "f19ab415-43f2-47a9-ac55-3705725e715e"}}, "__type__": "1"}, "f19ab415-43f2-47a9-ac55-3705725e715e": {"__data__": {"text": "data sets, because the squared bias and variance change at different\nrates in each of the data sets. In the left-hand panel of Figure 2.12, the\nbias initially decreases rapidly, resulting in an initial sharp decrease in the\nexpected test MSE. On the other hand, in the center panel of Figure 2.12\nthe true f is close to linear, so there is only a small decrease in bias as flexibility\nincreases, and the test MSE only declines slightly before increasing\nrapidly as the variance increases. Finally, in the right-hand panel of Figure\n2.12, as flexibility increases, there is a dramatic decline in bias because\nthe true f is very non-linear. There is also very little increase in variance\n36 2. Statistical Learning\n2 5 10 20\n0.0 0.5 1.0 1.5 2.0 2.5\nFlexibility\n2 5 10 20\n0.0 0.5 1.0 1.5 2.0 2.5\nFlexibility\n2 5 10 20\n0 5 10 15 20\nFlexibility\nMSE\nBias\nVar\nFIGURE 2.12. Squared bias (blue curve), variance (orange curve), Var(\u03f5)\n(dashed line), and test MSE (red curve) for the three data sets in Figures 2.9\u20132.11.\nThe vertical dotted line indicates the flexibility level corresponding to the smallest\ntest MSE.\nas flexibility increases. Consequently, the test MSE declines substantially\nbefore experiencing a small increase as model flexibility increases.\nThe relationship between bias, variance, and test set MSE given in Equation\n2.7 and displayed in Figure 2.12 is referred to as the bias-variance\ntrade-off. Good test set performance of a statistical learning method rebias-\nvariance\nquires low variance as well as low squared bias. This is referred to as a trade-off\ntrade-off because it is easy to obtain a method with extremely low bias but\nhigh variance (for instance, by drawing a curve that passes through every\nsingle training observation) or a method with very low variance but high\nbias (by fitting a horizontal line to the data). The challenge lies in finding\na method for which both the variance and the squared bias are low. This\ntrade-off is one of the most important recurring themes in this book.\nIn a real-life situation in which f is unobserved, it is generally not possible\nto explicitly compute the test MSE, bias, or variance for a statistical\nlearning method. Nevertheless, one should always keep the bias-variance\ntrade-off in mind. In this book we explore methods that are extremely\nflexible and hence can essentially eliminate bias. However, this does not\nguarantee that they will outperform a much simpler method such as linear\nregression. To take an extreme example, suppose that the true f is linear.\nIn this situation linear regression will have no bias, making it very hard\nfor a more flexible method to compete. In contrast, if the true f is highly\nnon-linear and we have an ample number of training observations, then\nwe may do better using a highly flexible approach, as in Figure 2.11. In\nChapter 5 we discuss cross-validation, which is a way to estimate the test\nMSE using the training data.\n2.2 Assessing Model Accuracy 37\n2.2.3 The Classification Setting\nThus far, our discussion of model accuracy has been focused on the regression\nsetting. But many of the concepts that we have encountered, such\nas the bias-variance trade-off, transfer over to the classification setting\nwith only some modifications due to the fact that yi is no longer quantitative.\nSuppose that we seek to estimate f on the basis of training observations\n{(x1, y1), . . . , (xn, yn)}, where now y1, . . . , yn are qualitative. The\nmost common approach for quantifying the accuracy of our estimate \u02c6 f is\nthe training error rate, the proportion of mistakes that are made if we apply\nerror rate\nour estimate", "doc_id": "f19ab415-43f2-47a9-ac55-3705725e715e", "embedding": null, "doc_hash": "ece7cc1d0da5ecedab3f91d6a4e36ae5c0c7617fe168bdb7af27bef460781613", "extra_info": null, "node_info": {"start": 104628, "end": 108241, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "b712d817-9524-4a3b-b00e-b751757d35f7", "3": "ae6c0af1-6f7d-4cfb-91a0-8b798f64f72f"}}, "__type__": "1"}, "ae6c0af1-6f7d-4cfb-91a0-8b798f64f72f": {"__data__": {"text": "the proportion of mistakes that are made if we apply\nerror rate\nour estimate \u02c6 f to the training observations:\n1\nn\n0n\ni=1\nI(yi \u0338= \u02c6yi). (2.8)\nHere \u02c6yi is the predicted class label for the ith observation using \u02c6 f. And\nI(yi \u0338= \u02c6yi) is an indicator variable that equals 1 if yi \u0338= \u02c6yi and zero if yi = \u02c6yi.\nindicator\nIf I(yi \u0338= y\u02c6i) = 0 then the ith observation was classified correctly by our variable\nclassification method; otherwise it was misclassified. Hence Equation 2.8\ncomputes the fraction of incorrect classifications.\nEquation 2.8 is referred to as the training error rate because it is comtraining\nputed based on the data that was used to train our classifier. As in the error\nregression setting, we are most interested in the error rates that result from\napplying our classifier to test observations that were not used in training.\nThe test error rate associated with a set of test observations of the form\ntest error\n(x0, y0) is given by\nAve (I(y0 \u0338= \u02c6y0)) , (2.9)\nwhere \u02c6y0 is the predicted class label that results from applying the classifier\nto the test observation with predictor x0. A good classifier is one for which\nthe test error (2.9) is smallest.\nThe Bayes Classifier\nIt is possible to show (though the proof is outside of the scope of this\nbook) that the test error rate given in (2.9) is minimized, on average, by a\nvery simple classifier that assigns each observation to the most likely class,\ngiven its predictor values. In other words, we should simply assign a test\nobservation with predictor vector x0 to the class j for which\nPr(Y = j|X = x0) (2.10)\nis largest. Note that (2.10) is a conditional probability: it is the probability\nconditional\nthat Y = j, given the observed predictor vector x0. This very simple clas- probability\nsifier is called the Bayes classifier. In a two-class problem where there are\nBayes\nonly two possible response values, say class 1 or class 2, the Bayes classifier classifier\n38 2. Statistical Learning\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no o\no\no\no\no\no\no\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\noo o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\nX1\nX2\nFIGURE 2.13. A simulated data set consisting of 100 observations in each of\ntwo groups, indicated in blue and in orange. The purple dashed line represents\nthe", "doc_id": "ae6c0af1-6f7d-4cfb-91a0-8b798f64f72f", "embedding": null, "doc_hash": "a091ed626267390c6bf089e699f1f69824960ebdee9cd3d0ec5ba0409213dc0d", "extra_info": null, "node_info": {"start": 108249, "end": 110772, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "f19ab415-43f2-47a9-ac55-3705725e715e", "3": "ddcbb2df-e69e-472b-ac44-e45e716b423b"}}, "__type__": "1"}, "ddcbb2df-e69e-472b-ac44-e45e716b423b": {"__data__": {"text": "groups, indicated in blue and in orange. The purple dashed line represents\nthe Bayes decision boundary. The orange background grid indicates the region\nin which a test observation will be assigned to the orange class, and the blue\nbackground grid indicates the region in which a test observation will be assigned\nto the blue class.\ncorresponds to predicting class one if Pr(Y = 1|X = x0) > 0.5, and class\ntwo otherwise.\nFigure 2.13 provides an example using a simulated data set in a twodimensional\nspace consisting of predictors X1 and X2. The orange and\nblue circles correspond to training observations that belong to two different\nclasses. For each value of X1 and X2, there is a different probability of the\nresponse being orange or blue. Since this is simulated data, we know how\nthe data were generated and we can calculate the conditional probabilities\nfor each value of X1 and X2. The orange shaded region reflects the set of\npoints for which Pr(Y = orange|X) is greater than 50 %, while the blue\nshaded region indicates the set of points for which the probability is below\n50 %. The purple dashed line represents the points where the probability\nis exactly 50 %. This is called the Bayes decision boundary. The Bayes\nBayes\ndecision\nboundary\nclassifier\u2019s prediction is determined by the Bayes decision boundary; an\nobservation that falls on the orange side of the boundary will be assigned\nto the orange class, and similarly an observation on the blue side of the\nboundary will be assigned to the blue class.\nThe Bayes classifier produces the lowest possible test error rate, called\nthe Bayes error rate. Since the Bayes classifier will always choose the class\nBayes error\nfor which (2.10) is largest, the error rate will be 1\u2212maxj Pr(Y = j|X = x0) rate\n2.2 Assessing Model Accuracy 39\nat X = x0. In general, the overall Bayes error rate is given by\n1 \u2212 E\n*\nmax\nj\nPr(Y = j|X)\n+\n, (2.11)\nwhere the expectation averages the probability over all possible values of\nX. For our simulated data, the Bayes error rate is 0.133. It is greater than\nzero, because the classes overlap in the true population so maxj Pr(Y =\nj|X = x0) < 1 for some values of x0. The Bayes error rate is analogous to\nthe irreducible error, discussed earlier.\nK-Nearest Neighbors\nIn theory we would always like to predict qualitative responses using the\nBayes classifier. But for real data, we do not know the conditional distribution\nof Y given X, and so computing the Bayes classifier is impossible.\nTherefore, the Bayes classifier serves as an unattainable gold standard\nagainst which to compare other methods. Many approaches attempt to\nestimate the conditional distribution of Y given X, and then classify a\ngiven observation to the class with highest estimated probability. One such\nmethod is the K-nearest neighbors (KNN) classifier. Given a positive in-\nK-nearest\nteger K and a test observation x0, the KNN classifier first identifies the neighbors\nK points in the training data that are closest to x0, represented by N0.\nIt then estimates the conditional probability for class j as the fraction of\npoints in N0 whose response values equal j:\nPr(Y = j|X = x0) =\n1\nK\n0\ni\u2208N0\nI(yi = j). (2.12)\nFinally, KNN classifies the test observation x0 to the class with the largest\nprobability from (2.12).\nFigure 2.14 provides an illustrative example of the KNN approach. In\nthe left-hand panel, we have plotted a small training data set consisting of\nsix blue and six orange observations. Our goal is to make a prediction for\nthe point labeled by the black cross. Suppose that we choose K = 3. Then\nKNN will first identify the", "doc_id": "ddcbb2df-e69e-472b-ac44-e45e716b423b", "embedding": null, "doc_hash": "cd34045c130ba83394f07101f034d2c81b1c6742f9eae08af9ad3a40d1bb9364", "extra_info": null, "node_info": {"start": 110771, "end": 114369, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "ae6c0af1-6f7d-4cfb-91a0-8b798f64f72f", "3": "9626834a-7ec0-4ff7-b408-cc2b9df00afe"}}, "__type__": "1"}, "9626834a-7ec0-4ff7-b408-cc2b9df00afe": {"__data__": {"text": "Suppose that we choose K = 3. Then\nKNN will first identify the three observations that are closest to the cross.\nThis neighborhood is shown as a circle. It consists of two blue points and\none orange point, resulting in estimated probabilities of 2/3 for the blue\nclass and 1/3 for the orange class. Hence KNN will predict that the black\ncross belongs to the blue class. In the right-hand panel of Figure 2.14 we\nhave applied the KNN approach with K = 3 at all of the possible values for\nX1 and X2, and have drawn in the corresponding KNN decision boundary.\nDespite the fact that it is a very simple approach, KNN can often produce\nclassifiers that are surprisingly close to the optimal Bayes classifier.\nFigure 2.15 displays the KNN decision boundary, using K = 10, when applied\nto the larger simulated data set from Figure 2.13. Notice that even\n40 2. Statistical Learning\no\no\no\no\no\no o\no\no\no\no\no o\no\no\no\no\no o\no\no\no\no\no\nFIGURE 2.14. The KNN approach, using K = 3, is illustrated in a simple\nsituation with six blue observations and six orange observations. Left: a test observation\nat which a predicted class label is desired is shown as a black cross. The\nthree closest points to the test observation are identified, and it is predicted that\nthe test observation belongs to the most commonly-occurring class, in this case\nblue. Right: The KNN decision boundary for this example is shown in black. The\nblue grid indicates the region in which a test observation will be assigned to the\nblue class, and the orange grid indicates the region in which it will be assigned to\nthe orange class.\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no o\no\no\no\no\no\no\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\noo o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\nX1\nX2\nKNN: K=10\nFIGURE 2.15. The black curve indicates the KNN decision boundary on the\ndata from Figure 2.13, using K = 10. The Bayes decision boundary is shown as\na purple dashed line. The KNN and Bayes decision boundaries are very similar.\n2.2 Assessing Model Accuracy", "doc_id": "9626834a-7ec0-4ff7-b408-cc2b9df00afe", "embedding": null, "doc_hash": "55d782ab4e8e647bd07e0ce892e0bac2cdf2e96ff8f4417229f8424a3bdb4622", "extra_info": null, "node_info": {"start": 114386, "end": 116642, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "ddcbb2df-e69e-472b-ac44-e45e716b423b", "3": "a96ae932-9cad-4c1c-b0a6-dde0d450a046"}}, "__type__": "1"}, "a96ae932-9cad-4c1c-b0a6-dde0d450a046": {"__data__": {"text": "and Bayes decision boundaries are very similar.\n2.2 Assessing Model Accuracy 41\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no o\no\no\no\no\no\no\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no o\no\no\no\no\no\no\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\nKNN: K=1 KNN: K=100\nFIGURE 2.16. A comparison of the KNN decision boundaries (solid black\ncurves) obtained using K = 1 and K = 100 on the data from Figure 2.13. With\nK = 1, the decision boundary is overly flexible, while with K = 100 it is not\nsufficiently flexible. The Bayes decision boundary is shown as a purple dashed\nline.\nthough the true distribution is not known by the KNN classifier, the KNN\ndecision boundary is very close to that of the Bayes classifier. The test error\nrate using KNN is 0.1363, which is close to the Bayes error rate of 0.1304.\nThe choice of K has a drastic effect on the KNN classifier obtained.\nFigure 2.16 displays two KNN fits to the simulated data from Figure 2.13,\nusing K = 1 and K = 100. When K", "doc_id": "a96ae932-9cad-4c1c-b0a6-dde0d450a046", "embedding": null, "doc_hash": "735817bc81894bdc5fb6bdd73a72dded7d3b22d56f3f27c5ce2e85567a00fcba", "extra_info": null, "node_info": {"start": 116627, "end": 118231, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "9626834a-7ec0-4ff7-b408-cc2b9df00afe", "3": "922b5fa2-966a-4464-8b48-35980117e8de"}}, "__type__": "1"}, "922b5fa2-966a-4464-8b48-35980117e8de": {"__data__": {"text": "data from Figure 2.13,\nusing K = 1 and K = 100. When K = 1, the decision boundary is overly\nflexible and finds patterns in the data that don\u2019t correspond to the Bayes\ndecision boundary. This corresponds to a classifier that has low bias but\nvery high variance. As K grows, the method becomes less flexible and\nproduces a decision boundary that is close to linear. This corresponds to\na low-variance but high-bias classifier. On this simulated data set, neither\nK = 1 nor K = 100 give good predictions: they have test error rates of\n0.1695 and 0.1925, respectively.\nJust as in the regression setting, there is not a strong relationship between\nthe training error rate and the test error rate. With K = 1, the\nKNN training error rate is 0, but the test error rate may be quite high. In\ngeneral, as we use more flexible classification methods, the training error\nrate will decline but the test error rate may not. In Figure 2.17, we have\nplotted the KNN test and training errors as a function of 1/K. As 1/K increases,\nthe method becomes more flexible. As in the regression setting, the\ntraining error rate consistently declines as the flexibility increases. However,\nthe test error exhibits a characteristic U-shape, declining at first (with a\nminimum at approximately K = 10) before increasing again when the\nmethod becomes excessively flexible and overfits.\n42 2. Statistical Learning\n0.01 0.02 0.05 0.10 0.20 0.50 1.00\n0.00 0.05 0.10 0.15 0.20\n1/K\nError Rate\nTraining Errors\nTest Errors\nFIGURE 2.17. The KNN training error rate (blue, 200 observations) and test\nerror rate (orange, 5,000 observations) on the data from Figure 2.13, as the level\nof flexibility (assessed using 1/K on the log scale) increases, or equivalently as\nthe number of neighbors K decreases. The black dashed line indicates the Bayes\nerror rate. The jumpiness of the curves is due to the small size of the training\ndata set.\nIn both the regression and classification settings, choosing the correct\nlevel of flexibility is critical to the success of any statistical learning method.\nThe bias-variance tradeoff, and the resulting U-shape in the test error, can\nmake this a difficult task. In Chapter 5, we return to this topic and discuss\nvarious methods for estimating test error rates and thereby choosing the\noptimal level of flexibility for a given statistical learning method.\n2.3 Lab: Introduction to R\nIn this lab, we will introduce some simple R commands. The best way to\nlearn a new language is to try out the commands. R can be downloaded\nfrom\nhttp://cran.r-project.org/\nWe recommend that you run R within an integrated development environment\n(IDE) such as RStudio, which can be freely downloaded from\nhttp://rstudio.com\n2.3 Lab: Introduction to R 43\nThe RStudio website also provides a cloud-based version of R, which does\nnot require installing any software.\n2.3.1 Basic Commands\nR uses functions to perform operations. To run a function called funcname,\nfunction\nwe type funcname(input1, input2), where the inputs (or arguments) input1\nargument\nand input2 tell R how to run the function. A function can have any number\nof inputs. For example, to create a vector of numbers, we use the function\nc() (for concatenate). Any numbers inside the parentheses are joined toc()\ngether. The following command instructs R to join together the numbers\n1, 3, 2, and 5, and to save them as a vector named x. When we type x, it\nvector\ngives us back the vector.\n> x <- c(1, 3, 2, 5)\n> x\n[1] 1 3 2 5\nNote that the > is not part of the command; rather, it is printed by R to\nindicate that it is ready for another command to be entered. We can also\nsave things using = rather", "doc_id": "922b5fa2-966a-4464-8b48-35980117e8de", "embedding": null, "doc_hash": "8015dd36e9238b92ab2da1800b3aeb3499e079722e8fbe8662243daf672074ee", "extra_info": null, "node_info": {"start": 118257, "end": 121899, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "a96ae932-9cad-4c1c-b0a6-dde0d450a046", "3": "2c8cfafe-c1c4-417b-8eb3-68ae79f08e37"}}, "__type__": "1"}, "2c8cfafe-c1c4-417b-8eb3-68ae79f08e37": {"__data__": {"text": "it is ready for another command to be entered. We can also\nsave things using = rather than <-:\n> x = c(1, 6, 2)\n> x\n[1] 1 6 2\n> y = c(1, 4, 3)\nHitting the up arrow multiple times will display the previous commands,\nwhich can then be edited. This is useful since one often wishes to repeat\na similar command. In addition, typing ?funcname will always cause R to\nopen a new help file window with additional information about the function\nfuncname().\nWe can tell R to add two sets of numbers together. It will then add the\nfirst number from x to the first number from y, and so on. However, x and\ny should be the same length. We can check their length using the length()\nlength()\nfunction.\n> length(x)\n[1] 3\n> length(y)\n[1] 3\n> x + y\n[1] 2 10 5\nThe ls() function allows us to look at a list of all of the objects, such\nls()\nas data and functions, that we have saved so far. The rm() function can be\nrm()\nused to delete any that we don\u2019t want.\n> ls()\n[1] \"x\" \"y\"\n> rm(x, y)\n44 2. Statistical Learning\n> ls()\ncharacter (0)\nIt\u2019s also possible to remove all objects at once:\n> rm(list = ls())\nThe matrix() function can be used to create a matrix of numbers. Before\nmatrix()\nwe use the matrix() function, we can learn more about it:\n> ?matrix\nThe help file reveals that the matrix() function takes a number of inputs,\nbut for now we focus on the first three: the data (the entries in the matrix),\nthe number of rows, and the number of columns. First, we create a simple\nmatrix.\n> x <- matrix(data = c(1, 2, 3, 4), nrow = 2, ncol = 2)\n> x\n[,1] [,2]\n[1,] 1 3\n[2,] 2 4\nNote that we could just as well omit typing data=, nrow=, and ncol= in the\nmatrix() command above: that is, we could just type\n> x <- matrix(c(1, 2, 3, 4), 2, 2)\nand this would have the same effect. However, it can sometimes be useful to\nspecify the names of the arguments passed in, since otherwise R will assume\nthat the function arguments are passed into the function in the same order\nthat is given in the function\u2019s help file. As this example illustrates, by\ndefault R creates matrices by successively filling in columns. Alternatively,\nthe byrow = TRUE option can be used to populate the matrix in order of the\nrows.\n> matrix(c(1, 2, 3, 4), 2, 2, byrow = TRUE)\n[,1] [,2]\n[1,] 1 2\n[2,] 3 4\nNotice that in the above command we did not assign the matrix to a value\nsuch as x. In this case the matrix is printed to the screen but is not saved\nfor future calculations. The sqrt() function returns the square root of each\nsqrt()\nelement of a vector or matrix. The command x^2 raises each element of x\nto the power 2; any powers are possible, including fractional or negative\npowers.\n> sqrt(x)\n[,1] [,2]\n[1,] 1.00 1.73\n[2,] 1.41 2.00\n> x^2\n[,1] [,2]\n[1,] 1 9\n[2,] 4 16\n2.3 Lab: Introduction to R 45\nThe rnorm() function generates a vector of random normal variables,\nrnorm()\nwith first argument n the sample size. Each time we call this function, we\nwill get a different answer. Here we create two correlated sets of numbers,\nx and y, and use the cor() function to compute the correlation between\ncor()\nthem.\n> x <- rnorm (50)\n> y <- x + rnorm (50, mean = 50, sd =", "doc_id": "2c8cfafe-c1c4-417b-8eb3-68ae79f08e37", "embedding": null, "doc_hash": "a28e7cb35c64bcd3a55913f1b61bdf0db685da4027d767a2204f3e7e0fa5e65e", "extra_info": null, "node_info": {"start": 121872, "end": 124993, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "922b5fa2-966a-4464-8b48-35980117e8de", "3": "8a3ed58e-2270-4c57-960d-03a06fd9b79d"}}, "__type__": "1"}, "8a3ed58e-2270-4c57-960d-03a06fd9b79d": {"__data__": {"text": "y <- x + rnorm (50, mean = 50, sd = .1)\n> cor(x, y)\n[1] 0.995\nBy default, rnorm() creates standard normal random variables with a mean\nof 0 and a standard deviation of 1. However, the mean and standard deviation\ncan be altered using the mean and sd arguments, as illustrated above.\nSometimes we want our code to reproduce the exact same set of random\nnumbers; we can use the set.seed() function to do this. The set.seed()\nset.seed()\nfunction takes an (arbitrary) integer argument.\n> set.seed (1303)\n> rnorm (50)\n[1] -1.1440 1.3421 2.1854 0.5364 0.0632 0.5022 -0.0004\n. . .\nWe use set.seed() throughout the labs whenever we perform calculations\ninvolving random quantities. In general this should allow the user to reproduce\nour results. However, as new versions of R become available, small\ndiscrepancies may arise between this book and the output from R.\nThe mean() and var() functions can be used to compute the mean and\nmean()\nvar()\nvariance of a vector of numbers. Applying sqrt() to the output of var()\nwill give the standard deviation. Or we can simply use the sd() function.\nsd()\n> set.seed (3)\n> y <- rnorm (100)\n> mean(y)\n[1] 0.0110\n> var(y)\n[1] 0.7329\n> sqrt(var(y))\n[1] 0.8561\n> sd(y)\n[1] 0.8561\n2.3.2 Graphics\nThe plot() function is the primary way to plot data in R. For instance,\nplot()\nplot(x, y) produces a scatterplot of the numbers in x versus the numbers\nin y. There are many additional options that can be passed in to the plot()\nfunction. For example, passing in the argument xlab will result in a label\non the x-axis. To find out more information about the plot() function,\ntype ?plot.\n46 2. Statistical Learning\n> x <- rnorm (100)\n> y <- rnorm (100)\n> plot(x, y)\n> plot(x, y, xlab = \"this is the x-axis\",\nylab = \"this is the y-axis\",\nmain = \"Plot of X vs Y\")\nWe will often want to save the output of an R plot. The command that we\nuse to do this will depend on the file type that we would like to create. For\ninstance, to create a pdf, we use the pdf() function, and to create a jpeg,\npdf()\nwe use the jpeg() function.\njpeg()\n> pdf(\"Figure.pdf\")\n> plot(x, y, col = \"green\")\n> dev.off()\nnull device\n1\nThe function dev.off() indicates to R that we are done creating the plot.\ndev.off()\nAlternatively, we can simply copy the plot window and paste it into an\nappropriate file type, such as a Word document.\nThe function seq() can be used to create a sequence of numbers. For\nseq()\ninstance, seq(a, b) makes a vector of integers between a and b. There are\nmany other options: for instance, seq(0, 1, length = 10) makes a sequence\nof 10 numbers that are equally spaced between 0 and 1. Typing 3:11 is a\nshorthand for seq(3, 11) for integer arguments.\n> x <- seq(1, 10)\n> x\n[1] 1 2 3 4 5 6 7 8 9 10\n> x <- 1:10\n> x\n[1] 1 2 3 4 5 6 7 8 9 10\n> x <- seq(-pi, pi, length = 50)\nWe will now create some more sophisticated plots. The contour() funccontour()\ntion produces a contour plot in order to represent three-dimensional data;\ncontour plot\nit is like a topographical map. It takes three arguments:\n1. A vector of the x values (the first dimension),\n2. A vector of the y values (the second dimension),", "doc_id": "8a3ed58e-2270-4c57-960d-03a06fd9b79d", "embedding": null, "doc_hash": "800b1c916d6aed081ec233ef5e9435d5ab66ccb228855cc498a31a25d4aee0d4", "extra_info": null, "node_info": {"start": 125039, "end": 128154, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "2c8cfafe-c1c4-417b-8eb3-68ae79f08e37", "3": "fa1c0804-2a72-4f94-875f-2485552dbece"}}, "__type__": "1"}, "fa1c0804-2a72-4f94-875f-2485552dbece": {"__data__": {"text": "values (the first dimension),\n2. A vector of the y values (the second dimension), and\n3. A matrix whose elements correspond to the z value (the third dimension)\nfor each pair of (x, y) coordinates.\nAs with the plot() function, there are many other inputs that can be used\nto fine-tune the output of the contour() function. To learn more about\nthese, take a look at the help file by typing ?contour.\n> y <- x\n> f <- outer(x, y, function(x, y) cos(y) / (1 + x^2))\n> contour(x, y, f)\n> contour(x, y, f, nlevels = 45, add = T)\n2.3 Lab: Introduction to R 47\n> fa <- (f - t(f)) / 2\n> contour(x, y, fa , nlevels = 15)\nThe image() function works the same way as contour(), except that it\nimage()\nproduces a color-coded plot whose colors depend on the z value. This is\nknown as a heatmap, and is sometimes used to plot temperature in weather\nheatmap\nforecasts. Alternatively, persp() can be used to produce a three-dimensional\npersp()\nplot. The arguments theta and phi control the angles at which the plot is\nviewed.\n> image(x, y, fa)\n> persp(x, y, fa)\n> persp(x, y, fa , theta = 30)\n> persp(x, y, fa , theta = 30, phi = 20)\n> persp(x, y, fa , theta = 30, phi = 70)\n> persp(x, y, fa , theta = 30, phi = 40)\n2.3.3 Indexing Data\nWe often wish to examine part of a set of data. Suppose that our data is\nstored in the matrix A.\n> A <- matrix (1:16 , 4, 4)\n> A\n[,1] [,2] [,3] [,4]\n[1,] 1 5 9 13\n[2,] 2 6 10 14\n[3,] 3 7 11 15\n[4,] 4 8 12 16\nThen, typing\n> A[2, 3]\n[1] 10\nwill select the element corresponding to the second row and the third column.\nThe first number after the open-bracket symbol [ always refers to\nthe row, and the second number always refers to the column. We can also\nselect multiple rows and columns at a time, by providing vectors as the\nindices.\n> A[c(1, 3), c(2, 4)]\n[,1] [,2]\n[1,] 5 13\n[2,] 7 15\n> A[1:3, 2:4]\n[,1] [,2] [,3]\n[1,] 5 9 13\n[2,] 6 10 14\n[3,] 7 11 15\n> A[1:2, ]\n[,1] [,2] [,3] [,4]\n[1,] 1 5 9 13\n[2,] 2 6 10 14\n48 2. Statistical Learning\n> A[, 1:2]\n[,1] [,2]\n[1,] 1 5\n[2,] 2 6\n[3,] 3 7\n[4,] 4 8\nThe last two examples include either no index for the columns or no index\nfor the rows. These indicate that R should include all columns or all rows,\nrespectively. R treats a single row or column of a matrix as a vector.\n> A[1, ]\n[1] 1 5 9 13\nThe use of a negative sign - in the index tells R to keep all rows or columns\nexcept those indicated in the index.\n> A[-c(1, 3), ]\n[,1] [,2] [,3] [,4]\n[1,] 2 6 10 14\n[2,] 4 8 12 16\n> A[-c(1, 3), -c(1, 3, 4)]\n[1] 6 8\nThe dim() function outputs the number of rows followed by the number of\ndim()\ncolumns of a given matrix.\n> dim(A)\n[1] 4 4\n2.3.4", "doc_id": "fa1c0804-2a72-4f94-875f-2485552dbece", "embedding": null, "doc_hash": "4c23c640109b4ce610146be066728a8198ec1f65cf0a46ec76d1c9839983089b", "extra_info": null, "node_info": {"start": 128111, "end": 130713, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "8a3ed58e-2270-4c57-960d-03a06fd9b79d", "3": "e625acf1-80ad-4342-b6a9-cde1f645fec6"}}, "__type__": "1"}, "e625acf1-80ad-4342-b6a9-cde1f645fec6": {"__data__": {"text": "dim(A)\n[1] 4 4\n2.3.4 Loading Data\nFor most analyses, the first step involves importing a data set into R. The\nread.table() function is one of the primary ways to do this. The help file\nread.table()\ncontains details about how to use this function. We can use the function\nwrite.table() to export data.\nwrite.table()\nBefore attempting to load a data set, we must make sure that R knows\nto search for the data in the proper directory. For example, on a Windows\nsystem one could select the directory using the Change dir. . . option under\nthe File menu. However, the details of how to do this depend on the operating\nsystem (e.g. Windows, Mac, Unix) that is being used, and so we do\nnot give further details here.\nWe begin by loading in the Auto data set. This data is part of the ISLR2\nlibrary, discussed in Chapter 3. To illustrate the read.table() function, we\nload it now from a text file, Auto.data, which you can find on the textbook\nwebsite. The following command will load the Auto.data file into R and\nstore it as an object called Auto, in a format referred to as a data frame.\ndata frame\nOnce the data has been loaded, the View() function can be used to view\n2.3 Lab: Introduction to R 49\nit in a spreadsheet-like window.1 The head() function can also be used to\nview the first few rows of the data.\n> Auto <- read.table(\"Auto.data\")\n> View(Auto)\n> head(Auto)\nV1 V2 V3 V4 V5\n1 mpg cylinders displacement horsepower weight\n2 18.0 8 307.0 130.0 3504.\n3 15.0 8 350.0 165.0 3693.\n4 18.0 8 318.0 150.0 3436.\n5 16.0 8 304.0 150.0 3433.\n6 17.0 8 302.0 140.0 3449.\nV6 V7 V8 V9\n1 acceleration year origin name\n2 12.0 70 1 chevrolet chevelle malibu\n3 11.5 70 1 buick skylark 320\n4 11.0 70 1 plymouth satellite\n5 12.0 70 1 amc rebel sst\n6 10.5 70 1 ford torino\nNote that Auto.data is simply a text file, which you could alternatively\nopen on your computer using a standard text editor. It is often a good idea\nto view a data set using a text editor or other software such as Excel before\nloading it into R.\nThis particular data set has not been loaded correctly, because R has\nassumed that the variable names are part of the data and so has included\nthem in the first row. The data set also includes a number of missing\nobservations, indicated by a question mark ?. Missing values are a common\noccurrence in real data sets. Using the option header = T (or header = TRUE)\nin the read.table() function tells R that the first line of the file contains\nthe variable names, and using the option na.strings tells R that any time\nit sees a particular character or set of characters (such as a question mark),\nit should be treated as a missing element of the data matrix.\n> Auto <- read.table(\"Auto.data\", header = T, na.strings = \"?\",\nstringsAsFactors = T)\n> View(Auto)\nThe stringsAsFactors = T argument tells R that any variable containing\ncharacter strings should be interpreted as a qualitative variable, and that\neach distinct character string represents a distinct level for that qualitative\nvariable. An easy way to load data from Excel into R is to save it as a csv\n(comma-separated values) file, and then use the read.csv() function.\n> Auto <- read.csv(\"Auto.csv\", na.strings = \"?\",\nstringsAsFactors = T)\n> View(Auto)\n1This function can sometimes be a bit finicky. If you have trouble using it, then try\nthe head() function instead.\n50 2. Statistical Learning\n> dim(Auto)\n[1] 397 9\n> Auto[1:4, ]\nThe dim() function tells us that the data has 397 observations, or rows, and\ndim()\nnine variables, or", "doc_id": "e625acf1-80ad-4342-b6a9-cde1f645fec6", "embedding": null, "doc_hash": "7e6fa245f065731afc0be1c08f8559e1e13f81b87e30b2bc1f46fa5c73c7dc92", "extra_info": null, "node_info": {"start": 130765, "end": 134258, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "fa1c0804-2a72-4f94-875f-2485552dbece", "3": "b58e0d57-6645-494f-a6f1-cc7684bca9cc"}}, "__type__": "1"}, "b58e0d57-6645-494f-a6f1-cc7684bca9cc": {"__data__": {"text": "data has 397 observations, or rows, and\ndim()\nnine variables, or columns. There are various ways to deal with the missing\ndata. In this case, only five of the rows contain missing observations, and\nso we choose to use the na.omit() function to simply remove these rows.\nna.omit()\n> Auto <- na.omit(Auto)\n> dim(Auto)\n[1] 392 9\nOnce the data are loaded correctly, we can use names() to check the\nnames()\nvariable names.\n> names(Auto)\n[1] \"mpg\" \"cylinders\" \"displacement\" \"horsepower\"\n[5] \"weight\" \"acceleration\" \"year\" \"origin\"\n[9] \"name\"\n2.3.5 Additional Graphical and Numerical Summaries\nWe can use the plot() function to produce scatterplots of the quantitative\nscatterplot\nvariables. However, simply typing the variable names will produce an error\nmessage, because R does not know to look in the Auto data set for those\nvariables.\n> plot(cylinders , mpg)\nError in plot(cylinders , mpg) : object \u2018cylinders \u2019 not found\nTo refer to a variable, we must type the data set and the variable name\njoined with a $ symbol. Alternatively, we can use the attach() function in\nattach()\norder to tell R to make the variables in this data frame available by name.\n> plot(Auto$cylinders , Auto$mpg)\n> attach(Auto)\n> plot(cylinders , mpg)\nThe cylinders variable is stored as a numeric vector, so R has treated it\nas quantitative. However, since there are only a small number of possible\nvalues for cylinders, one may prefer to treat it as a qualitative variable.\nThe as.factor() function converts quantitative variables into qualitative\nas.factor()\nvariables.\n> cylinders <- as.factor(cylinders)\nIf the variable plotted on the x-axis is qualitative, then boxplots will\nboxplot\nautomatically be produced by the plot() function. As usual, a number\nof options can be specified in order to customize the plots.\n> plot(cylinders , mpg)\n> plot(cylinders , mpg , col = \"red\")\n> plot(cylinders , mpg , col = \"red\", varwidth = T)\n2.3 Lab: Introduction to R 51\n> plot(cylinders , mpg , col = \"red\", varwidth = T,\nhorizontal = T)\n> plot(cylinders , mpg , col = \"red\", varwidth = T,\nxlab = \"cylinders\", ylab = \"MPG\")\nThe hist() function can be used to plot a histogram. Note that col = 2\nhist()\nhistogram has the same effect as col = \"red\".\n> hist(mpg)\n> hist(mpg , col = 2)\n> hist(mpg , col = 2, breaks = 15)\nThe pairs() function creates a scatterplot matrix, i.e. a scatterplot for every\npair of variables. We can also produce scatterplots for just a subset of the\nvariables.\n> pairs(Auto)\n> pairs(\n\u223c mpg + displacement + horsepower + weight + acceleration ,\ndata = Auto\n)\nIn conjunction with the plot() function, identify() provides a useful\nidentify()\ninteractive method for identifying the value of a particular variable for\npoints on a plot. We pass in three arguments to identify(): the x-axis\nvariable, the y-axis variable, and the variable whose values we would like\nto see printed for each point. Then clicking one or more points in the plot\nand hitting Escape will cause R to print the values of the variable of interest.\nThe numbers printed under the identify() function correspond to the rows\nfor the selected points.\n> plot(horsepower , mpg)\n> identify(horsepower , mpg , name)\nThe summary() function produces a numerical summary of each variable in\nsummary()\na particular data set.\n> summary(Auto)\nmpg cylinders displacement\nMin. : 9.00 Min. :3.000 Min. : 68.0\n1st Qu.:17.00 1st Qu", "doc_id": "b58e0d57-6645-494f-a6f1-cc7684bca9cc", "embedding": null, "doc_hash": "f1b9b50ba513c05d458fd44ba10cff81867bc198eb8edb15dd0ee555510a1e65", "extra_info": null, "node_info": {"start": 134221, "end": 137591, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "e625acf1-80ad-4342-b6a9-cde1f645fec6", "3": "d28a7d48-2c1d-40fa-8990-f7da8a58c3da"}}, "__type__": "1"}, "d28a7d48-2c1d-40fa-8990-f7da8a58c3da": {"__data__": {"text": "Min. : 68.0\n1st Qu.:17.00 1st Qu .:4.000 1st Qu .:105.0\nMedian :22.75 Median :4.000 Median :151.0\nMean :23.45 Mean :5.472 Mean :194.4\n3rd Qu.:29.00 3rd Qu .:8.000 3rd Qu .:275.8\nMax. :46.60 Max. :8.000 Max. :455.0\nhorsepower weight acceleration\nMin. : 46.0 Min. :1613 Min. : 8.00\n1st Qu.: 75.0 1st Qu.:2225 1st Qu .:13.78\nMedian : 93.5 Median :2804 Median :15.50\nMean :104.5 Mean :2978 Mean :15.54\n3rd Qu.:126.0 3rd Qu.:3615 3rd Qu.:17.02\nMax. :230.0 Max. :5140 Max. :24.80\nyear origin name\n52 2. Statistical Learning\nMin. :70.00 Min. :1.000 amc matador : 5\n1st Qu.:73.00 1st Qu .:1.000 ford pinto : 5\nMedian :76.00 Median :1.000 toyota corolla : 5\nMean :75.98 Mean :1.577 amc gremlin : 4\n3rd Qu.:79.00 3rd Qu .:2.000 amc hornet : 4\nMax. :82.00 Max. :3.000 chevrolet chevette: 4\n(Other) :365\nFor qualitative variables such as name, R will list the number of observations\nthat fall in each category. We can also produce a summary of just a single\nvariable.\n> summary(mpg)\nMin. 1st Qu. Median Mean 3rd Qu. Max.\n9.00 17.00 22.75 23.45 29.00 46.60\nOnce we have finished using R, we type q() in order to shut it down, or\nq()\nquit. When exiting R, we have the option to save the current workspace so\nworkspace\nthat all objects (such as data sets) that we have created in this R session\nwill be available next time. Before exiting R, we may want to save a record\nof all of the commands that we typed in the most recent session; this can\nbe accomplished using the savehistory() function. Next time we enter R,\nsavehistory()\nwe can load that history using the loadhistory() function, if we wish.\nloadhistory()\n2.4 Exercises\nConceptual\n1. For each of parts (a) through (d), indicate whether we would generally\nexpect the performance of a flexible statistical learning method to be\nbetter or worse than an inflexible method. Justify your answer.\n(a) The sample size n is extremely large, and the number of predictors\np is small.\n(b) The number of predictors p is extremely large, and the number\nof observations n is small.\n(c) The relationship between the predictors and response is highly\nnon-linear.\n(d) The variance of the error terms, i.e. \u03c32 = Var(\u03f5), is extremely\nhigh.\n2. Explain whether each scenario is a classification or regression problem,\nand indicate whether we are most interested in inference or prediction.\nFinally, provide n and p.\n(a) We collect a set of data on the top 500 firms in the US. For each\nfirm we record profit, number of employees, industry and the\nCEO salary. We are interested in understanding which factors\naffect CEO salary.\n2.4 Exercises 53\n(b) We are considering launching a new product and wish to know\nwhether it will be a success or a failure. We collect data on 20\nsimilar products that were previously launched. For each product\nwe have recorded whether it was a success or failure, price\ncharged for the product, marketing budget, competition price,\nand ten other variables.\n(c) We are interested in predicting the % change in the USD/Euro\nexchange rate in relation to the weekly changes in the world\nstock markets. Hence we collect weekly data for all of 2012. For\neach week we record the % change in the USD/Euro, the %\nchange in the US market, the % change in", "doc_id": "d28a7d48-2c1d-40fa-8990-f7da8a58c3da", "embedding": null, "doc_hash": "311ef080b88c540c127b48f7ccc61f89556140e258cfa864c096864c23335d13", "extra_info": null, "node_info": {"start": 137621, "end": 140816, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "b58e0d57-6645-494f-a6f1-cc7684bca9cc", "3": "5e2072c3-6e6a-4afa-819c-364c7665357d"}}, "__type__": "1"}, "5e2072c3-6e6a-4afa-819c-364c7665357d": {"__data__": {"text": "change in the USD/Euro, the %\nchange in the US market, the % change in the British market,\nand the % change in the German market.\n3. We now revisit the bias-variance decomposition.\n(a) Provide a sketch of typical (squared) bias, variance, training error,\ntest error, and Bayes (or irreducible) error curves, on a single\nplot, as we go from less flexible statistical learning methods\ntowards more flexible approaches. The x-axis should represent\nthe amount of flexibility in the method, and the y-axis should\nrepresent the values for each curve. There should be five curves.\nMake sure to label each one.\n(b) Explain why each of the five curves has the shape displayed in\npart (a).\n4. You will now think of some real-life applications for statistical learning.\n(a) Describe three real-life applications in which classification might\nbe useful. Describe the response, as well as the predictors. Is the\ngoal of each application inference or prediction? Explain your\nanswer.\n(b) Describe three real-life applications in which regression might\nbe useful. Describe the response, as well as the predictors. Is the\ngoal of each application inference or prediction? Explain your\nanswer.\n(c) Describe three real-life applications in which cluster analysis\nmight be useful.\n5. What are the advantages and disadvantages of a very flexible (versus\na less flexible) approach for regression or classification? Under what\ncircumstances might a more flexible approach be preferred to a less\nflexible approach? When might a less flexible approach be preferred?\n54 2. Statistical Learning\n6. Describe the differences between a parametric and a non-parametric\nstatistical learning approach. What are the advantages of a parametric\napproach to regression or classification (as opposed to a nonparametric\napproach)? What are its disadvantages?\n7. The table below provides a training data set containing six observations,\nthree predictors, and one qualitative response variable.\nObs. X1 X2 X3 Y\n1 0 3 0 Red\n2 2 0 0 Red\n3 0 1 3 Red\n4 0 1 2 Green\n5 \u22121 0 1 Green\n6 1 1 1 Red\nSuppose we wish to use this data set to make a prediction for Y when\nX1 = X2 = X3 = 0 using K-nearest neighbors.\n(a) Compute the Euclidean distance between each observation and\nthe test point, X1 = X2 = X3 = 0.\n(b) What is our prediction with K = 1? Why?\n(c) What is our prediction with K = 3? Why?\n(d) If the Bayes decision boundary in this problem is highly nonlinear,\nthen would we expect the best value for K to be large or\nsmall? Why?\nApplied\n8. This exercise relates to the College data set, which can be found in\nthe file College.csv on the book website. It contains a number of\nvariables for 777 different universities and colleges in the US. The\nvariables are\n\u2022 Private : Public/private indicator\n\u2022 Apps : Number of applications received\n\u2022 Accept : Number of applicants accepted\n\u2022 Enroll : Number of new students enrolled\n\u2022 Top10perc : New students from top 10% of high school class\n\u2022 Top25perc : New students from top 25% of high school class\n\u2022 F.Undergrad : Number of full-time undergraduates\n\u2022 P.Undergrad : Number of part-time undergraduates\n2.4 Exercises 55\n\u2022 Outstate : Out-of-state tuition\n\u2022 Room.Board : Room and board costs\n\u2022 Books : Estimated book costs\n\u2022 Personal : Estimated personal spending\n\u2022 PhD : Percent of faculty with Ph.D.\u2019s\n\u2022 Terminal : Percent of faculty with terminal degree\n\u2022 S.F.Ratio : Student/faculty ratio\n\u2022 perc.alumni : Percent of alumni who donate\n\u2022 Expend : Instructional expenditure per student\n\u2022 Grad.Rate : Graduation rate\nBefore reading the data into R, it", "doc_id": "5e2072c3-6e6a-4afa-819c-364c7665357d", "embedding": null, "doc_hash": "e9410ef18c20ea4041a102ffbc785ac715f51256be8a59772f0b6d2870424f57", "extra_info": null, "node_info": {"start": 140787, "end": 144336, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "d28a7d48-2c1d-40fa-8990-f7da8a58c3da", "3": "50bb25ee-21b5-4213-ba28-abd90a245f53"}}, "__type__": "1"}, "50bb25ee-21b5-4213-ba28-abd90a245f53": {"__data__": {"text": "per student\n\u2022 Grad.Rate : Graduation rate\nBefore reading the data into R, it can be viewed in Excel or a text\neditor.\n(a) Use the read.csv() function to read the data into R. Call the\nloaded data college. Make sure that you have the directory set\nto the correct location for the data.\n(b) Look at the data using the View() function. You should notice\nthat the first column is just the name of each university.We don\u2019t\nreally want R to treat this as data. However, it may be handy to\nhave these names for later. Try the following commands:\n> rownames(college) <- college[, 1]\n> View(college)\nYou should see that there is now a row.names column with the\nname of each university recorded. This means that R has given\neach row a name corresponding to the appropriate university. R\nwill not try to perform calculations on the row names. However,\nwe still need to eliminate the first column in the data where the\nnames are stored. Try\n> college <- college[, -1]\n> View(college)\nNow you should see that the first data column is Private. Note\nthat another column labeled row.names now appears before the\nPrivate column. However, this is not a data column but rather\nthe name that R is giving to each row.\n(c) i. Use the summary() function to produce a numerical summary\nof the variables in the data set.\nii. Use the pairs() function to produce a scatterplot matrix of\nthe first ten columns or variables of the data. Recall that\nyou can reference the first ten columns of a matrix A using\nA[,1:10].\n56 2. Statistical Learning\niii. Use the plot() function to produce side-by-side boxplots of\nOutstate versus Private.\niv. Create a new qualitative variable, called Elite, by binning\nthe Top10perc variable. We are going to divide universities\ninto two groups based on whether or not the proportion\nof students coming from the top 10% of their high school\nclasses exceeds 50 %.\n> Elite <- rep(\"No\", nrow(college))\n> Elite[college$Top10perc > 50] <- \"Yes\"\n> Elite <- as.factor(Elite)\n> college <- data.frame(college , Elite)\nUse the summary() function to see how many elite universities\nthere are. Now use the plot() function to produce\nside-by-side boxplots of Outstate versus Elite.\nv. Use the hist() function to produce some histograms with\ndiffering numbers of bins for a few of the quantitative variables.\nYou may find the command par(mfrow = c(2, 2))\nuseful: it will divide the print window into four regions so\nthat four plots can be made simultaneously. Modifying the\narguments to this function will divide the screen in other\nways.\nvi. Continue exploring the data, and provide a brief summary\nof what you discover.\n9. This exercise involves the Auto data set studied in the lab. Make sure\nthat the missing values have been removed from the data.\n(a) Which of the predictors are quantitative, and which are qualitative?\n(b) What is the range of each quantitative predictor? You can answer\nthis using the range() function.\nrange()\n(c) What is the mean and standard deviation of each quantitative\npredictor?\n(d) Now remove the 10th through 85th observations. What is the\nrange, mean, and standard deviation of each predictor in the\nsubset of the data that remains?\n(e) Using the full data set, investigate the predictors graphically,\nusing scatterplots or other tools of your choice. Create some plots\nhighlighting the relationships among the predictors. Comment\non your findings.\n(f) Suppose that we wish to predict gas mileage (mpg) on the basis\nof the other variables. Do your plots suggest that any of the\nother variables might be useful in predicting mpg? Justify your\nanswer.\n2.4 Exercises 57\n10. This exercise involves the Boston housing data", "doc_id": "50bb25ee-21b5-4213-ba28-abd90a245f53", "embedding": null, "doc_hash": "d39f26d4fdc124a17d0ce260067fcad17182030829d8afded76127bef54a5769", "extra_info": null, "node_info": {"start": 144329, "end": 147970, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "5e2072c3-6e6a-4afa-819c-364c7665357d", "3": "523b30e3-cb4e-494b-8558-3a7b07c869d5"}}, "__type__": "1"}, "523b30e3-cb4e-494b-8558-3a7b07c869d5": {"__data__": {"text": "Exercises 57\n10. This exercise involves the Boston housing data set.\n(a) To begin, load in the Boston data set. The Boston data set is\npart of the ISLR2 library.\n> library(ISLR2)\nNow the data set is contained in the object Boston.\n> Boston\nRead about the data set:\n> ?Boston\nHow many rows are in this data set? How many columns? What\ndo the rows and columns represent?\n(b) Make some pairwise scatterplots of the predictors (columns) in\nthis data set. Describe your findings.\n(c) Are any of the predictors associated with per capita crime rate?\nIf so, explain the relationship.\n(d) Do any of the census tracts of Boston appear to have particularly\nhigh crime rates? Tax rates? Pupil-teacher ratios? Comment on\nthe range of each predictor.\n(e) How many of the census tracts in this data set bound the Charles\nriver?\n(f) What is the median pupil-teacher ratio among the towns in this\ndata set?\n(g) Which census tract of Boston has lowest median value of owneroccupied\nhomes? What are the values of the other predictors\nfor that census tract, and how do those values compare to the\noverall ranges for those predictors? Comment on your findings.\n(h) In this data set, how many of the census tracts average more\nthan seven rooms per dwelling? More than eight rooms per\ndwelling? Comment on the census tracts that average more than\neight rooms per dwelling.\n3\nLinear Regression\nThis chapter is about linear regression, a very simple approach for supervised\nlearning. In particular, linear regression is a useful tool for predicting\na quantitative response. It has been around for a long time and is the topic\nof innumerable textbooks. Though it may seem somewhat dull compared to\nsome of the more modern statistical learning approaches described in later\nchapters of this book, linear regression is still a useful and widely used statistical\nlearning method. Moreover, it serves as a good jumping-off point for\nnewer approaches: as we will see in later chapters, many fancy statistical\nlearning approaches can be seen as generalizations or extensions of linear\nregression. Consequently, the importance of having a good understanding\nof linear regression before studying more complex learning methods cannot\nbe overstated. In this chapter, we review some of the key ideas underlying\nthe linear regression model, as well as the least squares approach that is\nmost commonly used to fit this model.\nRecall the Advertising data from Chapter 2. Figure 2.1 displays sales\n(in thousands of units) for a particular product as a function of advertising\nbudgets (in thousands of dollars) for TV, radio, and newspaper media.\nSuppose that in our role as statistical consultants we are asked to suggest,\non the basis of this data, a marketing plan for next year that will result in\nhigh product sales. What information would be useful in order to provide\nsuch a recommendation? Here are a few important questions that we might\nseek to address:\n1. Is there a relationship between advertising budget and sales?\nOur first goal should be to determine whether the data provide evi-\n\u00a9 Springer Science+Business Media, LLC, part of Springer Nature 2021\nG. James et al., An Introduction to Statistical Learning, Springer Texts in Statistics,\n59\nhttps://doi.org/10.1007/978-1-0716-1418-1_3\n60 3. Linear Regression\ndence of an association between advertising expenditure and sales. If\nthe evidence is weak, then one might argue that no money should be\nspent on advertising!\n2. How strong is the relationship between advertising budget and sales?\nAssuming that there is a relationship between advertising and sales,\nwe would like to know the strength of this relationship. Does knowledge\nof the advertising budget provide a lot of information about\nproduct sales?\n3. Which media are associated with sales?\nAre all three media\u2014TV, radio, and newspaper\u2014associated with\nsales, or are just", "doc_id": "523b30e3-cb4e-494b-8558-3a7b07c869d5", "embedding": null, "doc_hash": "5cb28119d7cdee7a2402071348156ebc31ce5a7b4e687b6c36b1c5f444dfe99d", "extra_info": null, "node_info": {"start": 147981, "end": 151834, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "50bb25ee-21b5-4213-ba28-abd90a245f53", "3": "1a990ac3-9da6-4789-a63a-ed581e847763"}}, "__type__": "1"}, "1a990ac3-9da6-4789-a63a-ed581e847763": {"__data__": {"text": "media\u2014TV, radio, and newspaper\u2014associated with\nsales, or are just one or two of the media associated? To answer this\nquestion, we must find a way to separate out the individual contribution\nof each medium to sales when we have spent money on all three\nmedia.\n4. How large is the association between each medium and sales?\nFor every dollar spent on advertising in a particular medium, by\nwhat amount will sales increase? How accurately can we predict this\namount of increase?\n5. How accurately can we predict future sales?\nFor any given level of television, radio, or newspaper advertising, what\nis our prediction for sales, and what is the accuracy of this prediction?\n6. Is the relationship linear?\nIf there is approximately a straight-line relationship between advertising\nexpenditure in the various media and sales, then linear regression\nis an appropriate tool. If not, then it may still be possible to transform\nthe predictor or the response so that linear regression can be\nused.\n7. Is there synergy among the advertising media?\nPerhaps spending $50,000 on television advertising and $50,000 on radio\nadvertising is associated with higher sales than allocating $100,000\nto either television or radio individually. In marketing, this is known\nas a synergy effect, while in statistics it is called an interaction effect. synergy\ninteraction\nIt turns out that linear regression can be used to answer each of these\nquestions. We will first discuss all of these questions in a general context,\nand then return to them in this specific context in Section 3.4.\n3.1 Simple Linear Regression\nSimple linear regression lives up to its name: it is a very straightforward\nsimple linear\nregression\n3.1 Simple Linear Regression 61\napproach for predicting a quantitative response Y on the basis of a single\npredictor variable X. It assumes that there is approximately a linear\nrelationship between X and Y . Mathematically, we can write this linear\nrelationship as\nY \u2248 \u03b20 + \u03b21X. (3.1)\nYou might read \u201c\u2248\u201d as \u201cis approximately modeled as\u201d. We will sometimes\ndescribe (3.1) by saying that we are regressing Y on X (or Y onto X).\nFor example, X may represent TV advertising and Y may represent sales.\nThen we can regress sales onto TV by fitting the model\nsales \u2248 \u03b20 + \u03b21 \u00d7 TV.\nIn Equation 3.1, \u03b20 and \u03b21 are two unknown constants that represent\nthe intercept and slope terms in the linear model. Together, \u03b20 and \u03b21 are\nintercept\nslope\nknown as the model coefficients or parameters. Once we have used our\ncoefficient\nparameter\ntraining data to produce estimates \u02c6 \u03b20 and \u02c6 \u03b21 for the model coefficients, we\ncan predict future sales on the basis of a particular value of TV advertising\nby computing\n\u02c6y = \u02c6 \u03b20 + \u02c6 \u03b21x, (3.2)\nwhere \u02c6y indicates a prediction of Y on the basis of X = x. Here we use a\nhat symbol, \u02c6 , to denote the estimated value for an unknown parameter\nor coefficient, or to denote the predicted value of the response.\n3.1.1 Estimating the Coefficients\nIn practice, \u03b20 and \u03b21 are unknown. So before we can use (3.1) to make\npredictions, we must use data to estimate the coefficients. Let\n(x1, y1), (x2, y2), . . . , (xn, yn)\nrepresent n observation pairs, each of which consists of a measurement\nof X and a measurement of Y . In the Advertising example, this data\nset consists of the TV advertising budget and product sales in n = 200\ndifferent markets. (Recall that the data are displayed in Figure 2.1.) Our\ngoal is to obtain coefficient estimates \u02c6 \u03b20 and \u02c6 \u03b21 such that the linear model\n(3.1) fits the available data well\u2014that is, so that yi \u2248 \u02c6 \u03b20 + \u02c6 \u03b21xi for i =\n1, . . . ,n. In other words, we want to find an intercept", "doc_id": "1a990ac3-9da6-4789-a63a-ed581e847763", "embedding": null, "doc_hash": "6f7bb4559369fa275e10a80af90a5ccb6b3deec5cbdc74a1235389d917fc5ed5", "extra_info": null, "node_info": {"start": 151832, "end": 155461, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "523b30e3-cb4e-494b-8558-3a7b07c869d5", "3": "f1ffc41d-678e-42b1-aa62-3f6d32228432"}}, "__type__": "1"}, "f1ffc41d-678e-42b1-aa62-3f6d32228432": {"__data__": {"text": ". . . ,n. In other words, we want to find an intercept \u02c6 \u03b20 and a slope \u02c6 \u03b21 such\nthat the resulting line is as close as possible to the n = 200 data points.\nThere are a number of ways of measuring closeness. However, by far the\nmost common approach involves minimizing the least squares criterion,\nleast squares\nand we take that approach in this chapter. Alternative approaches will be\nconsidered in Chapter 6.\nLet \u02c6yi = \u02c6 \u03b20 + \u02c6 \u03b21xi be the prediction for Y based on the ith value of X.\nThen ei = yi\u2212\u02c6yi represents the ith residual\u2014this is the difference between\nresidual\n62 3. Linear Regression\n0 50 100 150 200 250 300\n5 10 15 20 25\nTV\nSales\nFIGURE 3.1. For the Advertising data, the least squares fit for the regression\nof sales onto TV is shown. The fit is found by minimizing the residual sum of\nsquares. Each grey line segment represents a residual. In this case a linear fit\ncaptures the essence of the relationship, although it overestimates the trend in the\nleft of the plot.\nthe ith observed response value and the ith response value that is predicted\nby our linear model. We define the residual sum of squares (RSS) as\nresidual sum\nof squares RSS = e21\n+ e22\n+ \u00b7 \u00b7 \u00b7 + e2\nn,\nor equivalently as\nRSS = (y1\u2212 \u02c6 \u03b20\u2212 \u02c6 \u03b21x1)2+(y2\u2212 \u02c6 \u03b20\u2212 \u02c6 \u03b21x2)2+\u00b7 \u00b7 \u00b7+(yn\u2212 \u02c6 \u03b20\u2212 \u02c6 \u03b21xn)2. (3.3)\nThe least squares approach chooses \u02c6 \u03b20 and \u02c6 \u03b21 to minimize the RSS. Using\nsome calculus, one can show that the minimizers are\n\u02c6 \u03b21 =\n)n\ni=1)(xi \u2212 x\u00af)(yi \u2212 y\u00af) n\ni=1(xi \u2212 \u00afx)2 ,\n\u02c6 \u03b20 = \u00afy \u2212 \u02c6 \u03b21\u00afx,\n(3.4)\nwhere \u00afy \u2261 1n\n)n\ni=1 yi and \u00afx \u2261 1n\n)n\ni=1 xi are the sample means. In other\nwords, (3.4) defines the least squares coefficient estimates for simple linear\nregression.\nFigure 3.1 displays the simple linear regression fit to the Advertising\ndata, where \u02c6 \u03b20 = 7.03 and \u02c6 \u03b21 = 0.0475. In other words, according to\nthis approximation, an additional $1,000 spent on TV advertising is associated\nwith selling approximately 47.5 additional units of the product. In\n3.1 Simple Linear Regression 63\n\u03b20\n\u03b21\n2.11\n2.15\n2.2\n2.3\n2.5\n2.5\n3\n3\n5 6 7 8 9\n0.03 0.04 0.05 0.06\n\u25cf\nRSS\n\u03b21 \u03b20\nFIGURE 3.2. Contour and three-dimensional plots of the RSS on the\nAdvertising data, using sales as the response and TV as the predictor. The\nred dots correspond to the least squares estimates \u02c6\u03b20 and \u02c6\u03b21, given by (3.4).\nFigure 3.2, we have computed RSS for a number of values of \u03b20 and \u03b21,\nusing the advertising data with sales as the response and TV as the predictor.\nIn each plot, the red dot represents the pair of least squares estimates\n( \u02c6 \u03b20, \u02c6 \u03b21) given by (3.4). These values clearly minimize the RSS.\n3.1.2 Assessing the Accuracy of the Coefficient Estimates\nRecall from (2.1) that we assume that the true relationship between X and\nY takes the form Y = f(X) + \u03f5 for some unknown function f, where \u03f5\nis a mean-zero random error term. If f is to be approximated by a linear\nfunction, then we can write this relationship as\nY = \u03b20 + \u03b21X + \u03f5.", "doc_id": "f1ffc41d-678e-42b1-aa62-3f6d32228432", "embedding": null, "doc_hash": "9144d43a170e3498c7b394a04a369bd769edf7342fbcde6806bc2522d6a228e5", "extra_info": null, "node_info": {"start": 155478, "end": 158388, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "1a990ac3-9da6-4789-a63a-ed581e847763", "3": "ccda122c-aa3d-4d08-9b8f-246967a2c446"}}, "__type__": "1"}, "ccda122c-aa3d-4d08-9b8f-246967a2c446": {"__data__": {"text": "we can write this relationship as\nY = \u03b20 + \u03b21X + \u03f5. (3.5)\nHere \u03b20 is the intercept term\u2014that is, the expected value of Y when X = 0,\nand \u03b21 is the slope\u2014the average increase in Y associated with a one-unit\nincrease in X. The error term is a catch-all for what we miss with this\nsimple model: the true relationship is probably not linear, there may be\nother variables that cause variation in Y , and there may be measurement\nerror. We typically assume that the error term is independent of X.\nThe model given by (3.5) defines the population regression line, which\npopulation\nregression\nline\nis the best linear approximation to the true relationship between X and\nY .1 The least squares regression coefficient estimates (3.4) characterize the\nleast squares line (3.2). The left-hand panel of Figure 3.3 displays these\nleast squares\nline\n1The assumption of linearity is often a useful working model. However, despite what\nmany textbooks might tell us, we seldom believe that the true relationship is linear.\n64 3. Linear Regression\n\u22122 \u22121 0 1 2\n\u221210 \u22125 0 5 10\nX\nY\n\u22122 \u22121 0 1 2\n\u221210 \u22125 0 5 10\nX\nY\nFIGURE 3.3. A simulated data set. Left: The red line represents the true relationship,\nf(X) = 2+3X, which is known as the population regression line. The\nblue line is the least squares line; it is the least squares estimate for f(X) based\non the observed data, shown in black. Right: The population regression line is\nagain shown in red, and the least squares line in dark blue. In light blue, ten least\nsquares lines are shown, each computed on the basis of a separate random set of\nobservations. Each least squares line is different, but on average, the least squares\nlines are quite close to the population regression line.\ntwo lines in a simple simulated example. We created 100 random Xs, and\ngenerated 100 corresponding Y s from the model\nY = 2+3X + \u03f5, (3.6)\nwhere \u03f5 was generated from a normal distribution with mean zero. The\nred line in the left-hand panel of Figure 3.3 displays the true relationship,\nf(X) = 2+3X, while the blue line is the least squares estimate based\non the observed data. The true relationship is generally not known for\nreal data, but the least squares line can always be computed using the\ncoefficient estimates given in (3.4). In other words, in real applications,\nwe have access to a set of observations from which we can compute the\nleast squares line; however, the population regression line is unobserved.\nIn the right-hand panel of Figure 3.3 we have generated ten different data\nsets from the model given by (3.6) and plotted the corresponding ten least\nsquares lines. Notice that different data sets generated from the same true\nmodel result in slightly different least squares lines, but the unobserved\npopulation regression line does not change.\nAt first glance, the difference between the population regression line and\nthe least squares line may seem subtle and confusing. We only have one\ndata set, and so what does it mean that two different lines describe the\nrelationship between the predictor and the response? Fundamentally, the\nconcept of these two lines is a natural extension of the standard statistical\n3.1 Simple Linear Regression 65\napproach of using information from a sample to estimate characteristics of a\nlarge population. For example, suppose that we are interested in knowing\nthe population mean \u03bc of some random variable Y . Unfortunately, \u03bc is\nunknown, but we do have access to n observations from Y , y1, . . . , yn,\nwhich we can use to estimate \u03bc. A reasonable estimate is \u02c6\u03bc = \u00afy, where\n\u00afy = 1n\n)n\ni=1 yi is the sample mean. The sample mean and the population\nmean are different, but in general the sample mean will provide a good\nestimate of the population mean. In the same way,", "doc_id": "ccda122c-aa3d-4d08-9b8f-246967a2c446", "embedding": null, "doc_hash": "8e04e279945ca4a9b14bb51afcb360bfa741a801b998f42524738d514e24edbc", "extra_info": null, "node_info": {"start": 158391, "end": 162129, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "f1ffc41d-678e-42b1-aa62-3f6d32228432", "3": "73d4a547-88d3-4f62-bab2-798e8ad5e6ab"}}, "__type__": "1"}, "73d4a547-88d3-4f62-bab2-798e8ad5e6ab": {"__data__": {"text": "sample mean will provide a good\nestimate of the population mean. In the same way, the unknown coefficients\n\u03b20 and \u03b21 in linear regression define the population regression line. We seek\nto estimate these unknown coefficients using \u02c6 \u03b20 and \u02c6 \u03b21 given in (3.4). These\ncoefficient estimates define the least squares line.\nThe analogy between linear regression and estimation of the mean of a\nrandom variable is an apt one based on the concept of bias. If we use the\nbias\nsample mean \u02c6\u03bc to estimate \u03bc, this estimate is unbiased, in the sense that\nunbiased\non average, we expect \u02c6\u03bc to equal \u03bc. What exactly does this mean? It means\nthat on the basis of one particular set of observations y1, . . . , yn, \u02c6\u03bc might\noverestimate \u03bc, and on the basis of another set of observations, \u02c6\u03bc might\nunderestimate \u03bc. But if we could average a huge number of estimates of\n\u03bc obtained from a huge number of sets of observations, then this average\nwould exactly equal \u03bc. Hence, an unbiased estimator does not systematically\nover- or under-estimate the true parameter. The property of unbiasedness\nholds for the least squares coefficient estimates given by (3.4) as well: if\nwe estimate \u03b20 and \u03b21 on the basis of a particular data set, then our\nestimates won\u2019t be exactly equal to \u03b20 and \u03b21. But if we could average\nthe estimates obtained over a huge number of data sets, then the average\nof these estimates would be spot on! In fact, we can see from the righthand\npanel of Figure 3.3 that the average of many least squares lines, each\nestimated from a separate data set, is pretty close to the true population\nregression line.\nWe continue the analogy with the estimation of the population mean\n\u03bc of a random variable Y . A natural question is as follows: how accurate\nis the sample mean \u02c6\u03bc as an estimate of \u03bc? We have established that the\naverage of \u02c6\u03bc\u2019s over many data sets will be very close to \u03bc, but that a\nsingle estimate \u02c6\u03bc may be a substantial underestimate or overestimate of \u03bc.\nHow far off will that single estimate of \u02c6\u03bc be? In general, we answer this\nquestion by computing the standard error of \u02c6\u03bc, written as SE(\u02c6\u03bc). We have\nstandard\nthe well-known formula error\nVar(\u02c6\u03bc) = SE(\u02c6\u03bc)2 =\n\u03c32\nn\n, (3.7)\nwhere \u03c3 is the standard deviation of each of the realizations yi of Y .2\nRoughly speaking, the standard error tells us the average amount that this\nestimate \u02c6\u03bc differs from the actual value of \u03bc. Equation 3.7 also tells us how\n2This formula holds provided that the n observations are uncorrelated.\n66 3. Linear Regression\nthis deviation shrinks with n\u2014the more observations we have, the smaller\nthe standard error of \u02c6\u03bc. In a similar vein, we can wonder how close \u02c6 \u03b20\nand \u02c6 \u03b21 are to the true values \u03b20 and \u03b21. To compute the standard errors\nassociated with \u02c6 \u03b20 and \u02c6 \u03b21, we use the following formulas:\nSE( \u02c6 \u03b20)\n2\n= \u03c32\n3\n1\nn\n+\n\u00afx2\n)n\ni=1(xi \u2212 \u00afx)2\n4\n, SE( \u02c6 \u03b21)\n2\n=\n\u03c32\n)n\ni=1(xi \u2212 \u00afx)2 , (3.8)\nwhere \u03c32 = Var(\u03f5). For these formulas to be strictly valid, we need to\nassume that the errors \u03f5i for each observation have common variance \u03c32 and\nare uncorrelated. This is clearly not true in Figure 3.1, but the formula still\nturns out to be a good approximation. Notice in the formula that SE( \u02c6 \u03b21) is\nsmaller when the xi are more spread out; intuitively we have more leverage\nto estimate a slope when this is the case. We also see that SE( \u02c6 \u03b20) would be\nthe same as", "doc_id": "73d4a547-88d3-4f62-bab2-798e8ad5e6ab", "embedding": null, "doc_hash": "bbcbe159b507fdda37736dd8bec17b0f36e824af45af7e9ae777f9e2e8a4cb49", "extra_info": null, "node_info": {"start": 162102, "end": 165455, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "ccda122c-aa3d-4d08-9b8f-246967a2c446", "3": "d4cb8c25-0f06-4de5-adf1-5864939a8d3b"}}, "__type__": "1"}, "d4cb8c25-0f06-4de5-adf1-5864939a8d3b": {"__data__": {"text": "the case. We also see that SE( \u02c6 \u03b20) would be\nthe same as SE(\u02c6\u03bc) if \u00afx were zero (in which case \u02c6 \u03b20 would be equal to \u00afy). In\ngeneral, \u03c32 is not known, but can be estimated from the data. This estimate\nof \u03c3 is known as the residual standard error, and is given by the formula\nresidual\nstandard\nerror\nRSE =\n5\nRSS/(n \u2212 2). Strictly speaking, when \u03c32 is estimated from the\ndata we should write 6SE( \u02c6 \u03b21) to indicate that an estimate has been made,\nbut for simplicity of notation we will drop this extra \u201chat\u201d.\nStandard errors can be used to compute confidence intervals. A 95%\nconfidence\nconfidence interval is defined as a range of values such that with 95% interval\nprobability, the range will contain the true unknown value of the parameter.\nThe range is defined in terms of lower and upper limits computed\nfrom the sample of data. A 95% confidence interval has the following property:\nif we take repeated samples and construct the confidence interval for\neach sample, 95% of the intervals will contain the true unknown value of\nthe parameter. For linear regression, the 95% confidence interval for \u03b21\napproximately takes the form\n\u02c6 \u03b21 \u00b1 2 \u00b7 SE( \u02c6 \u03b21). (3.9)\nThat is, there is approximately a 95% chance that the interval\n7\n\u02c6 \u03b21 \u2212 2 \u00b7 SE( \u02c6 \u03b21), \u02c6 \u03b21 + 2 \u00b7 SE( \u02c6 \u03b21)\n8\n(3.10)\nwill contain the true value of \u03b21.3 Similarly, a confidence interval for \u03b20\napproximately takes the form\n\u02c6 \u03b20 \u00b1 2 \u00b7 SE( \u02c6 \u03b20). (3.11)\n3Approximately for several reasons. Equation 3.10 relies on the assumption that the\nerrors are Gaussian. Also, the factor of 2 in front of the SE( \u02c6\u03b21) term will vary slightly\ndepending on the number of observations n in the linear regression. To be precise, rather\nthan the number 2, (3.10) should contain the 97.5% quantile of a t-distribution with\nn\u22122 degrees of freedom. Details of how to compute the 95% confidence interval precisely\nin R will be provided later in this chapter.\n3.1 Simple Linear Regression 67\nIn the case of the advertising data, the 95% confidence interval for \u03b20\nis [6.130, 7.935] and the 95% confidence interval for \u03b21 is [0.042, 0.053].\nTherefore, we can conclude that in the absence of any advertising, sales will,\non average, fall somewhere between 6,130 and 7,935 units. Furthermore,\nfor each $1,000 increase in television advertising, there will be an average\nincrease in sales of between 42 and 53 units.\nStandard errors can also be used to perform hypothesis tests on the\nhypothesis\ncoefficients. The most common hypothesis test involves testing the null test\nhypothesis of\nnull\nhypothesis H0 : There is no relationship between X and Y (3.12)\nversus the alternative hypothesis\nalternative\nhypothesis Ha : There is some relationship between X and Y . (3.13)\nMathematically, this corresponds to testing\nH0 : \u03b21 = 0\nversus\nHa : \u03b21 \u0338= 0,\nsince if \u03b21 = 0 then the model (3.5) reduces to Y = \u03b20 + \u03f5, and X is\nnot associated with Y . To test the null hypothesis, we need to determine\nwhether \u02c6 \u03b21, our estimate for \u03b21, is sufficiently far from zero that we can\nbe confident that \u03b21 is non-zero. How far is far enough? This of course\ndepends on the accuracy of \u02c6 \u03b21\u2014that is, it depends on SE( \u02c6 \u03b21). If SE( \u02c6 \u03b21) is\nsmall, then even relatively small values of \u02c6 \u03b21 may provide strong evidence\nthat \u03b21 \u0338= 0, and hence that there is a relationship between X and Y . In\ncontrast, if SE( \u02c6 \u03b21) is large, then \u02c6", "doc_id": "d4cb8c25-0f06-4de5-adf1-5864939a8d3b", "embedding": null, "doc_hash": "cbdbfedd8ffb3d19dce080ab511930a2bd071ad29f9aebae1b2f4eda7361338e", "extra_info": null, "node_info": {"start": 165479, "end": 168822, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "73d4a547-88d3-4f62-bab2-798e8ad5e6ab", "3": "c845bf66-3df8-44bb-ac85-aad40ec857e7"}}, "__type__": "1"}, "c845bf66-3df8-44bb-ac85-aad40ec857e7": {"__data__": {"text": ". In\ncontrast, if SE( \u02c6 \u03b21) is large, then \u02c6 \u03b21 must be large in absolute value in order\nfor us to reject the null hypothesis. In practice, we compute a t-statistic,\nt-statistic\ngiven by\nt =\n\u02c6 \u03b21 \u2212 0\nSE( \u02c6 \u03b21)\n, (3.14)\nwhich measures the number of standard deviations that \u02c6 \u03b21 is away from 0. If\nthere really is no relationship between X and Y , then we expect that (3.14)\nwill have a t-distribution with n\u22122 degrees of freedom. The t-distribution\nhas a bell shape and for values of n greater than approximately 30 it is\nquite similar to the standard normal distribution. Consequently, it is a\nsimple matter to compute the probability of observing any number equal\nto |t| or larger in absolute value, assuming \u03b21 = 0. We call this probability\nthe p-value. Roughly speaking, we interpret the p-value as follows: a small\np-value\np-value indicates that it is unlikely to observe such a substantial association\nbetween the predictor and the response due to chance, in the absence of\nany real association between the predictor and the response. Hence, if we\n68 3. Linear Regression\nCoefficient Std. error t-statistic p-value\nIntercept 7.0325 0.4578 15.36 < 0.0001\nTV 0.0475 0.0027 17.67 < 0.0001\nTABLE 3.1. For the Advertising data, coefficients of the least squares model\nfor the regression of number of units sold on TV advertising budget. An increase\nof $1,000 in the TV advertising budget is associated with an increase in sales by\naround 50 units. (Recall that the sales variable is in thousands of units, and the\nTV variable is in thousands of dollars.)\nsee a small p-value, then we can infer that there is an association between\nthe predictor and the response. We reject the null hypothesis\u2014that is, we\ndeclare a relationship to exist between X and Y \u2014if the p-value is small\nenough. Typical p-value cutoffs for rejecting the null hypothesis are 5% or\n1%, although this topic will be explored in much greater detail in Chapter\n13. When n = 30, these correspond to t-statistics (3.14) of around 2\nand 2.75, respectively.\nTable 3.1 provides details of the least squares model for the regression of\nnumber of units sold on TV advertising budget for the Advertising data.\nNotice that the coefficients for \u02c6 \u03b20 and \u02c6 \u03b21 are very large relative to their\nstandard errors, so the t-statistics are also large; the probabilities of seeing\nsuch values if H0 is true are virtually zero. Hence we can conclude that\n\u03b20 \u0338= 0 and \u03b21 \u0338= 0.4\n3.1.3 Assessing the Accuracy of the Model\nOnce we have rejected the null hypothesis (3.12) in favor of the alternative\nhypothesis (3.13), it is natural to want to quantify the extent to which the\nmodel fits the data. The quality of a linear regression fit is typically assessed\nusing two related quantities: the residual standard error (RSE) and the R2\nR2\nstatistic.\nTable 3.2 displays the RSE, the R2 statistic, and the F-statistic (to be\ndescribed in Section 3.2.2) for the linear regression of number of units sold\non TV advertising budget.\nResidual Standard Error\nRecall from the model (3.5) that associated with each observation is an\nerror term \u03f5. Due to the presence of these error terms, even if we knew the\ntrue regression line (i.e. even if \u03b20 and \u03b21 were known), we would not be\n4In Table 3.1, a small p-value for the intercept indicates that we can reject the null\nhypothesis that \u03b20 = 0, and a small p-value for TV indicates that we can reject the null\nhypothesis that \u03b21 = 0. Rejecting the latter null hypothesis allows us to conclude that\nthere is a", "doc_id": "c845bf66-3df8-44bb-ac85-aad40ec857e7", "embedding": null, "doc_hash": "8113e6bba959e3dcd848edc6c37b9587a91248a3eb665cc80ee06a9fbe2c37d8", "extra_info": null, "node_info": {"start": 168833, "end": 172324, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "d4cb8c25-0f06-4de5-adf1-5864939a8d3b", "3": "35f5435e-26e4-408b-9e1f-9874883976cd"}}, "__type__": "1"}, "35f5435e-26e4-408b-9e1f-9874883976cd": {"__data__": {"text": "Rejecting the latter null hypothesis allows us to conclude that\nthere is a relationship between TV and sales. Rejecting the former allows us to conclude\nthat in the absence of TV expenditure, sales are non-zero.\n3.1 Simple Linear Regression 69\nQuantity Value\nResidual standard error 3.26\nR2 0.612\nF-statistic 312.1\nTABLE 3.2. For the Advertising data, more information about the least squares\nmodel for the regression of number of units sold on TV advertising budget.\nable to perfectly predict Y from X. The RSE is an estimate of the standard\ndeviation of \u03f5. Roughly speaking, it is the average amount that the response\nwill deviate from the true regression line. It is computed using the formula\nRSE =\n9\n1\nn \u2212 2\nRSS =\n:;;<\n1\nn \u2212 2\n0n\ni=1\n(yi \u2212 \u02c6yi)2. (3.15)\nNote that RSS was defined in Section 3.1.1, and is given by the formula\nRSS =\n0n\ni=1\n(yi \u2212 \u02c6yi)2. (3.16)\nIn the case of the advertising data, we see from the linear regression\noutput in Table 3.2 that the RSE is 3.26. In other words, actual sales in\neach market deviate from the true regression line by approximately 3,260\nunits, on average. Another way to think about this is that even if the\nmodel were correct and the true values of the unknown coefficients \u03b20\nand \u03b21 were known exactly, any prediction of sales on the basis of TV\nadvertising would still be off by about 3,260 units on average. Of course,\nwhether or not 3,260 units is an acceptable prediction error depends on the\nproblem context. In the advertising data set, the mean value of sales over\nall markets is approximately 14,000 units, and so the percentage error is\n3,260/14,000 = 23 %.\nThe RSE is considered a measure of the lack of fit of the model (3.5) to\nthe data. If the predictions obtained using the model are very close to the\ntrue outcome values\u2014that is, if \u02c6yi \u2248 yi for i = 1, . . . ,n\u2014then (3.15) will\nbe small, and we can conclude that the model fits the data very well. On\nthe other hand, if \u02c6yi is very far from yi for one or more observations, then\nthe RSE may be quite large, indicating that the model doesn\u2019t fit the data\nwell.\nR2 Statistic\nThe RSE provides an absolute measure of lack of fit of the model (3.5)\nto the data. But since it is measured in the units of Y , it is not always\nclear what constitutes a good RSE. The R2 statistic provides an alternative\nmeasure of fit. It takes the form of a proportion\u2014the proportion of variance\n70 3. Linear Regression\nexplained\u2014and so it always takes on a value between 0 and 1, and is\nindependent of the scale of Y .\nTo calculate R2, we use the formula\nR2 =\nTSS \u2212 RSS\nTSS\n= 1\u2212\nRSS\nTSS\n(3.17)\nwhere TSS =\n)\n(yi \u2212 \u00afy)2 is the total sum of squares, and RSS is defined\ntotal sum of\nin (3.16). TSS measures the total variance in the response Y , and can be squares\nthought of as the amount of variability inherent in the response before the\nregression is performed. In contrast, RSS measures the amount of variability\nthat is left unexplained after performing the regression. Hence, TSS \u2212RSS\nmeasures the amount of variability in the response that is explained (or\nremoved) by performing the regression, and R2 measures the proportion of\nvariability in Y that can be explained using X. An R2 statistic that is close\nto 1 indicates that a large proportion of the variability in the response is\nexplained by the regression. A number near 0 indicates that the regression\ndoes not explain much of the variability in the response; this might occur\nbecause the linear model is wrong, or the error variance \u03c32 is", "doc_id": "35f5435e-26e4-408b-9e1f-9874883976cd", "embedding": null, "doc_hash": "0ec81b7b2900cac07a2092a4312cac802674cef4fb3b53268efdc986061d1601", "extra_info": null, "node_info": {"start": 172297, "end": 175789, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "c845bf66-3df8-44bb-ac85-aad40ec857e7", "3": "189c959f-21a0-411a-8822-c690149e39f5"}}, "__type__": "1"}, "189c959f-21a0-411a-8822-c690149e39f5": {"__data__": {"text": "this might occur\nbecause the linear model is wrong, or the error variance \u03c32 is high, or both.\nIn Table 3.2, the R2 was 0.61, and so just under two-thirds of the variability\nin sales is explained by a linear regression on TV.\nThe R2 statistic (3.17) has an interpretational advantage over the RSE\n(3.15), since unlike the RSE, it always lies between 0 and 1. However, it can\nstill be challenging to determine what is a good R2 value, and in general,\nthis will depend on the application. For instance, in certain problems in\nphysics, we may know that the data truly comes from a linear model with\na small residual error. In this case, we would expect to see an R2 value that\nis extremely close to 1, and a substantially smaller R2 value might indicate a\nserious problem with the experiment in which the data were generated. On\nthe other hand, in typical applications in biology, psychology, marketing,\nand other domains, the linear model (3.5) is at best an extremely rough\napproximation to the data, and residual errors due to other unmeasured\nfactors are often very large. In this setting, we would expect only a very\nsmall proportion of the variance in the response to be explained by the\npredictor, and an R2 value well below 0.1 might be more realistic!\nThe R2 statistic is a measure of the linear relationship between X and\nY . Recall that correlation, defined as\ncorrelation\nCor(X, Y ) =\n)n\ni=1(xi \u2212 x)(yi \u2212 y) 5)n\ni=1(xi \u2212 x)2\n5)n\ni=1(yi \u2212 y)2\n, (3.18)\nis also a measure of the linear relationship between X and Y .5 This suggests\nthat we might be able to use r = Cor(X, Y ) instead of R2 in order to\n5We note that in fact, the right-hand side of (3.18) is the sample correlation; thus,\nit would be more correct to write Co!r(X, Y ); however, we omit the \u201chat\u201d for ease of\nnotation.\n3.2 Multiple Linear Regression 71\nassess the fit of the linear model. In fact, it can be shown that in the simple\nlinear regression setting, R2 = r2. In other words, the squared correlation\nand the R2 statistic are identical. However, in the next section we will\ndiscuss the multiple linear regression problem, in which we use several predictors\nsimultaneously to predict the response. The concept of correlation\nbetween the predictors and the response does not extend automatically to\nthis setting, since correlation quantifies the association between a single\npair of variables rather than between a larger number of variables. We will\nsee that R2 fills this role.\n3.2 Multiple Linear Regression\nSimple linear regression is a useful approach for predicting a response on the\nbasis of a single predictor variable. However, in practice we often have more\nthan one predictor. For example, in the Advertising data, we have examined\nthe relationship between sales and TV advertising. We also have data for\nthe amount of money spent advertising on the radio and in newspapers,\nand we may want to know whether either of these two media is associated\nwith sales. How can we extend our analysis of the advertising data in order\nto accommodate these two additional predictors?\nOne option is to run three separate simple linear regressions, each of\nwhich uses a different advertising medium as a predictor. For instance,\nwe can fit a simple linear regression to predict sales on the basis of the\namount spent on radio advertisements. Results are shown in Table 3.3 (top\ntable). We find that a $1,000 increase in spending on radio advertising is\nassociated with an increase in sales of around 203 units. Table 3.3 (bottom\ntable) contains the least squares coefficients for a simple linear regression of\nsales onto newspaper advertising budget. A $1,000 increase in newspaper\nadvertising budget is associated with an increase in sales of approximately\n55 units.\nHowever,", "doc_id": "189c959f-21a0-411a-8822-c690149e39f5", "embedding": null, "doc_hash": "b4a6151d33ef63522be7c08e4ffb3d1cf253303934c0ef530fb2f443beb4ea15", "extra_info": null, "node_info": {"start": 175787, "end": 179536, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "35f5435e-26e4-408b-9e1f-9874883976cd", "3": "533a93e7-2c1c-4376-a941-c32c38681f22"}}, "__type__": "1"}, "533a93e7-2c1c-4376-a941-c32c38681f22": {"__data__": {"text": "budget is associated with an increase in sales of approximately\n55 units.\nHowever, the approach of fitting a separate simple linear regression model\nfor each predictor is not entirely satisfactory. First of all, it is unclear how to\nmake a single prediction of sales given the three advertising media budgets,\nsince each of the budgets is associated with a separate regression equation.\nSecond, each of the three regression equations ignores the other two media\nin forming estimates for the regression coefficients. We will see shortly that\nif the media budgets are correlated with each other in the 200 markets\nin our data set, then this can lead to very misleading estimates of the\nassociation between each media budget and sales.\nInstead of fitting a separate simple linear regression model for each predictor,\na better approach is to extend the simple linear regression model\n(3.5) so that it can directly accommodate multiple predictors. We can do\nthis by giving each predictor a separate slope coefficient in a single model.\nIn general, suppose that we have p distinct predictors. Then the multiple\n72 3. Linear Regression\nSimple regression of sales on radio\nCoefficient Std. error t-statistic p-value\nIntercept 9.312 0.563 16.54 < 0.0001\nradio 0.203 0.020 9.92 < 0.0001\nSimple regression of sales on newspaper\nCoefficient Std. error t-statistic p-value\nIntercept 12.351 0.621 19.88 < 0.0001\nnewspaper 0.055 0.017 3.30 0.00115\nTABLE 3.3. More simple linear regression models for the Advertising data. Coefficients\nof the simple linear regression model for number of units sold on Top:\nradio advertising budget and Bottom: newspaper advertising budget. A $1,000 increase\nin spending on radio advertising is associated with an average increase in\nsales by around 203 units, while the same increase in spending on newspaper advertising\nis associated with an average increase in sales by around 55 units. (Note\nthat the sales variable is in thousands of units, and the radio and newspaper\nvariables are in thousands of dollars.)\nlinear regression model takes the form\nY = \u03b20 + \u03b21X1 + \u03b22X2 + \u00b7 \u00b7 \u00b7 + \u03b2pXp + \u03f5, (3.19)\nwhere Xj represents the jth predictor and \u03b2j quantifies the association\nbetween that variable and the response. We interpret \u03b2j as the average\neffect on Y of a one unit increase in Xj , holding all other predictors fixed.\nIn the advertising example, (3.19) becomes\nsales = \u03b20 + \u03b21 \u00d7 TV + \u03b22 \u00d7 radio + \u03b23 \u00d7 newspaper + \u03f5. (3.20)\n3.2.1 Estimating the Regression Coefficients\nAs was the case in the simple linear regression setting, the regression coefficients\n\u03b20,\u03b21, . . . ,\u03b2p in (3.19) are unknown, and must be estimated. Given\nestimates \u02c6 \u03b20, \u02c6 \u03b21, . . . , \u02c6 \u03b2p, we can make predictions using the formula\n\u02c6y = \u02c6 \u03b20 + \u02c6 \u03b21x1 + \u02c6 \u03b22x2 + \u00b7 \u00b7 \u00b7 + \u02c6 \u03b2pxp. (3.21)\nThe parameters are estimated using the same least squares approach that\nwe saw in the context of simple linear regression. We choose \u03b20,\u03b21, . . . ,\u03b2p\nto minimize the sum of squared residuals\nRSS =\n0n\ni=1\n(yi \u2212 \u02c6yi)2\n=\n0n\ni=1\n(yi \u2212 \u02c6 \u03b20 \u2212 \u02c6 \u03b21xi1 \u2212 \u02c6 \u03b22xi2 \u2212\u00b7 \u00b7 \u00b7\u2212 \u02c6 \u03b2pxip)2. (3.22)\n3.2 Multiple Linear Regression 73\nX1\nX2\nY\nFIGURE 3.4. In a three-dimensional setting, with two predictors and one response,\nthe least squares regression line becomes a plane. The plane is chosen\nto minimize the sum of the squared vertical distances between each observation\n(shown in", "doc_id": "533a93e7-2c1c-4376-a941-c32c38681f22", "embedding": null, "doc_hash": "6f26a2ba45e9fb62dd9f1aa17337199f5c75dc408776520e4e7589edb7c3ae72", "extra_info": null, "node_info": {"start": 179531, "end": 182872, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "189c959f-21a0-411a-8822-c690149e39f5", "3": "6595748e-04ff-41dc-bcdf-4b9e36cf5699"}}, "__type__": "1"}, "6595748e-04ff-41dc-bcdf-4b9e36cf5699": {"__data__": {"text": "the sum of the squared vertical distances between each observation\n(shown in red) and the plane.\nThe values \u02c6 \u03b20, \u02c6 \u03b21, . . . , \u02c6 \u03b2p that minimize (3.22) are the multiple least squares\nregression coefficient estimates. Unlike the simple linear regression estimates\ngiven in (3.4), the multiple regression coefficient estimates have\nsomewhat complicated forms that are most easily represented using matrix\nalgebra. For this reason, we do not provide them here. Any statistical\nsoftware package can be used to compute these coefficient estimates, and\nlater in this chapter we will show how this can be done in R. Figure 3.4\nillustrates an example of the least squares fit to a toy data set with p = 2\npredictors.\nTable 3.4 displays the multiple regression coefficient estimates when TV,\nradio, and newspaper advertising budgets are used to predict product sales\nusing the Advertising data.We interpret these results as follows: for a given\namount of TV and newspaper advertising, spending an additional $1,000 on\nradio advertising is associated with approximately 189 units of additional\nsales. Comparing these coefficient estimates to those displayed in Tables 3.1\nand 3.3, we notice that the multiple regression coefficient estimates for\nTV and radio are pretty similar to the simple linear regression coefficient\nestimates. However, while the newspaper regression coefficient estimate in\nTable 3.3 was significantly non-zero, the coefficient estimate for newspaper\n74 3. Linear Regression\nin the multiple regression model is close to zero, and the corresponding pvalue\nis no longer significant, with a value around 0.86. This illustrates that\nthe simple and multiple regression coefficients can be quite different. This\ndifference stems from the fact that in the simple regression case, the slope\nterm represents the average increase in product sales associated with a\n$1,000 increase in newspaper advertising, ignoring other predictors such as\nTV and radio. By contrast, in the multiple regression setting, the coefficient\nfor newspaper represents the average increase in product sales associated\nwith increasing newspaper spending by $1,000 while holding TV and radio\nfixed.\nCoefficient Std. error t-statistic p-value\nIntercept 2.939 0.3119 9.42 < 0.0001\nTV 0.046 0.0014 32.81 < 0.0001\nradio 0.189 0.0086 21.89 < 0.0001\nnewspaper \u22120.001 0.0059 \u22120.18 0.8599\nTABLE 3.4. For the Advertising data, least squares coefficient estimates of the\nmultiple linear regression of number of units sold on TV, radio, and newspaper\nadvertising budgets.\nDoes it make sense for the multiple regression to suggest no relationship\nbetween sales and newspaper while the simple linear regression implies the\nopposite? In fact it does. Consider the correlation matrix for the three\npredictor variables and response variable, displayed in Table 3.5. Notice\nthat the correlation between radio and newspaper is 0.35. This indicates\nthat markets with high newspaper advertising tend to also have high radio\nadvertising. Now suppose that the multiple regression is correct and\nnewspaper advertising is not associated with sales, but radio advertising\nis associated with sales. Then in markets where we spend more on radio\nour sales will tend to be higher, and as our correlation matrix shows, we\nalso tend to spend more on newspaper advertising in those same markets.\nHence, in a simple linear regression which only examines sales versus\nnewspaper, we will observe that higher values of newspaper tend to be associated\nwith higher values of sales, even though newspaper advertising is\nnot directly associated with sales. So newspaper advertising is a surrogate\nfor radio advertising; newspaper gets \u201ccredit\u201d for the association between\nradio on sales.\nThis slightly counterintuitive result is very common in many real life\nsituations. Consider an absurd example to illustrate the point. Running\na regression of shark attacks versus ice cream sales for data collected at\na given beach community over a", "doc_id": "6595748e-04ff-41dc-bcdf-4b9e36cf5699", "embedding": null, "doc_hash": "3a3c30c03a93bceeac78cf6a3301a284b428f4a9178a2700c48978c2e434eedd", "extra_info": null, "node_info": {"start": 182879, "end": 186854, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "533a93e7-2c1c-4376-a941-c32c38681f22", "3": "bf0f477f-4a62-4d5f-95c6-fdc9edb0cc78"}}, "__type__": "1"}, "bf0f477f-4a62-4d5f-95c6-fdc9edb0cc78": {"__data__": {"text": "attacks versus ice cream sales for data collected at\na given beach community over a period of time would show a positive\nrelationship, similar to that seen between sales and newspaper. Of course\nno one has (yet) suggested that ice creams should be banned at beaches\nto reduce shark attacks. In reality, higher temperatures cause more people\n3.2 Multiple Linear Regression 75\nTV radio newspaper sales\nTV 1.0000 0.0548 0.0567 0.7822\nradio 1.0000 0.3541 0.5762\nnewspaper 1.0000 0.2283\nsales 1.0000\nTABLE 3.5. Correlation matrix for TV, radio, newspaper, and sales for the\nAdvertising data.\nto visit the beach, which in turn results in more ice cream sales and more\nshark attacks. A multiple regression of shark attacks onto ice cream sales\nand temperature reveals that, as intuition implies, ice cream sales is no\nlonger a significant predictor after adjusting for temperature.\n3.2.2 Some Important Questions\nWhen we perform multiple linear regression, we usually are interested in\nanswering a few important questions.\n1. Is at least one of the predictors X1,X2, . . . ,Xp useful in predicting\nthe response?\n2. Do all the predictors help to explain Y , or is only a subset of the\npredictors useful?\n3. How well does the model fit the data?\n4. Given a set of predictor values, what response value should we predict,\nand how accurate is our prediction?\nWe now address each of these questions in turn.\nOne: Is There a Relationship Between the Response and Predictors?\nRecall that in the simple linear regression setting, in order to determine\nwhether there is a relationship between the response and the predictor we\ncan simply check whether \u03b21 = 0. In the multiple regression setting with p\npredictors, we need to ask whether all of the regression coefficients are zero,\ni.e. whether \u03b21 = \u03b22 = \u00b7 \u00b7 \u00b7 = \u03b2p = 0. As in the simple linear regression\nsetting, we use a hypothesis test to answer this question. We test the null\nhypothesis,\nH0 : \u03b21 = \u03b22 = \u00b7 \u00b7 \u00b7 = \u03b2p = 0\nversus the alternative\nHa : at least one \u03b2j is non-zero.\nThis hypothesis test is performed by computing the F-statistic,\nF-statistic\n76 3. Linear Regression\nQuantity Value\nResidual standard error 1.69\nR2 0.897\nF-statistic 570\nTABLE 3.6. More information about the least squares model for the regression\nof number of units sold on TV, newspaper, and radio advertising budgets in the\nAdvertising data. Other information about this model was displayed in Table 3.4.\nF =\n(TSS \u2212 RSS)/p\nRSS/(n \u2212 p \u2212 1)\n, (3.23)\nwhere, as with simple linear regression, TSS =\n)\n) (yi \u2212 y\u00af)2 and RSS =\n(yi\u2212\u02c6yi)2. If the linear model assumptions are correct, one can show that\nE{RSS/(n \u2212 p \u2212 1)} = \u03c32\nand that, provided H0 is true,\nE{(TSS \u2212 RSS)/p} = \u03c32.\nHence, when there is no relationship between the response and predictors,\none would expect the F-statistic to take on a value close to 1. On the other\nhand, if Ha is true, then E{(TSS \u2212 RSS)/p} > \u03c32, so we expect F to be\ngreater than 1.\nThe F-statistic for the multiple linear regression model obtained by regressing\nsales onto radio, TV, and newspaper is shown in Table 3.6. In this\nexample the F-statistic is 570. Since this is far larger than 1, it provides\ncompelling evidence against the null hypothesis H0. In other words, the\nlarge F-statistic suggests that at least one of the advertising media must\nbe related to sales. However, what if the F-statistic had been closer to\n1? How large does the", "doc_id": "bf0f477f-4a62-4d5f-95c6-fdc9edb0cc78", "embedding": null, "doc_hash": "ea316daf717cf51c8d31ac504e26cffc597fc264098fc5ae696e971ecb434fa9", "extra_info": null, "node_info": {"start": 186851, "end": 190241, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "6595748e-04ff-41dc-bcdf-4b9e36cf5699", "3": "0a49f0b6-51f4-4555-99d2-24137357f1b6"}}, "__type__": "1"}, "0a49f0b6-51f4-4555-99d2-24137357f1b6": {"__data__": {"text": "what if the F-statistic had been closer to\n1? How large does the F-statistic need to be before we can reject H0 and\nconclude that there is a relationship? It turns out that the answer depends\non the values of n and p. When n is large, an F-statistic that is just a\nlittle larger than 1 might still provide evidence against H0. In contrast,\na larger F-statistic is needed to reject H0 if n is small. When H0 is true\nand the errors \u03f5i have a normal distribution, the F-statistic follows an\nF-distribution.6 For any given value of n and p, any statistical software\npackage can be used to compute the p-value associated with the F-statistic\nusing this distribution. Based on this p-value, we can determine whether\nor not to reject H0. For the advertising data, the p-value associated with\nthe F-statistic in Table 3.6 is essentially zero, so we have extremely strong\nevidence that at least one of the media is associated with increased sales.\n6Even if the errors are not normally-distributed, the F-statistic approximately follows\nan F-distribution provided that the sample size n is large.\n3.2 Multiple Linear Regression 77\nIn (3.23) we are testing H0 that all the coefficients are zero. Sometimes\nwe want to test that a particular subset of q of the coefficients are zero.\nThis corresponds to a null hypothesis\nH0 : \u03b2p\u2212q+1 = \u03b2p\u2212q+2 = \u00b7 \u00b7 \u00b7 = \u03b2p = 0,\nwhere for convenience we have put the variables chosen for omission at the\nend of the list. In this case we fit a second model that uses all the variables\nexcept those last q. Suppose that the residual sum of squares for that model\nis RSS0. Then the appropriate F-statistic is\nF =\n(RSS0 \u2212 RSS)/q\nRSS/(n \u2212 p \u2212 1)\n. (3.24)\nNotice that in Table 3.4, for each individual predictor a t-statistic and\na p-value were reported. These provide information about whether each\nindividual predictor is related to the response, after adjusting for the other\npredictors. It turns out that each of these is exactly equivalent7 to the Ftest\nthat omits that single variable from the model, leaving all the others\nin\u2014i.e. q=1 in (3.24). So it reports the partial effect of adding that variable\nto the model. For instance, as we discussed earlier, these p-values indicate\nthat TV and radio are related to sales, but that there is no evidence that\nnewspaper is associated with sales, when TV and radio are held fixed.\nGiven these individual p-values for each variable, why do we need to look\nat the overall F-statistic? After all, it seems likely that if any one of the\np-values for the individual variables is very small, then at least one of the\npredictors is related to the response. However, this logic is flawed, especially\nwhen the number of predictors p is large.\nFor instance, consider an example in which p = 100 and H0 : \u03b21 = \u03b22 =\n\u00b7 \u00b7 \u00b7 = \u03b2p = 0 is true, so no variable is truly associated with the response. In\nthis situation, about 5% of the p-values associated with each variable (of\nthe type shown in Table 3.4) will be below 0.05 by chance. In other words,\nwe expect to see approximately five small p-values even in the absence of\nany true association between the predictors and the response.8 In fact, it\nis likely that we will observe at least one p-value below 0.05 by chance!\nHence, if we use the individual t-statistics and associated p-values in order\nto decide whether or not there is any association between the variables and\nthe response, there is a very high chance that we will incorrectly conclude\nthat there is a relationship. However, the F-statistic does not suffer from\nthis problem because it adjusts for the number of predictors. Hence, if H0\nis true, there is only a 5% chance that the F-statistic will result in a pvalue\nbelow", "doc_id": "0a49f0b6-51f4-4555-99d2-24137357f1b6", "embedding": null, "doc_hash": "b2952e93e422a58fc3983e770c0abc50376f209caee7e2e64f10b2f8fec2436b", "extra_info": null, "node_info": {"start": 190259, "end": 193947, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "bf0f477f-4a62-4d5f-95c6-fdc9edb0cc78", "3": "34465ecd-8913-434c-8be0-e4c1b65b2a75"}}, "__type__": "1"}, "34465ecd-8913-434c-8be0-e4c1b65b2a75": {"__data__": {"text": "is only a 5% chance that the F-statistic will result in a pvalue\nbelow 0.05, regardless of the number of predictors or the number of\nobservations.\n7The square of each t-statistic is the corresponding F-statistic.\n8This is related to the important concept of multiple testing, which is the focus of\nChapter 13.\n78 3. Linear Regression\nThe approach of using an F-statistic to test for any association between\nthe predictors and the response works when p is relatively small, and certainly\nsmall compared to n. However, sometimes we have a very large number\nof variables. If p > n then there are more coefficients \u03b2j to estimate\nthan observations from which to estimate them. In this case we cannot\neven fit the multiple linear regression model using least squares, so the Fstatistic\ncannot be used, and neither can most of the other concepts that\nwe have seen so far in this chapter. When p is large, some of the approaches\ndiscussed in the next section, such as forward selection, can be used. This\nhigh-dimensional setting is discussed in greater detail in Chapter 6.\nhighdimensional\nTwo: Deciding on Important Variables\nAs discussed in the previous section, the first step in a multiple regression\nanalysis is to compute the F-statistic and to examine the associated pvalue.\nIf we conclude on the basis of that p-value that at least one of the\npredictors is related to the response, then it is natural to wonder which are\nthe guilty ones! We could look at the individual p-values as in Table 3.4,\nbut as discussed (and as further explored in Chapter 13), if p is large we\nare likely to make some false discoveries.\nIt is possible that all of the predictors are associated with the response,\nbut it is more often the case that the response is only associated with\na subset of the predictors. The task of determining which predictors are\nassociated with the response, in order to fit a single model involving only\nthose predictors, is referred to as variable selection. The variable selection\nvariable\nproblem is studied extensively in Chapter 6, and so here we will provide selection\nonly a brief outline of some classical approaches.\nIdeally, we would like to perform variable selection by trying out a lot of\ndifferent models, each containing a different subset of the predictors. For\ninstance, if p = 2, then we can consider four models: (1) a model containing\nno variables, (2) a model containing X1 only, (3) a model containing\nX2 only, and (4) a model containing both X1 and X2. We can then select\nthe best model out of all of the models that we have considered. How\ndo we determine which model is best? Various statistics can be used to\njudge the quality of a model. These include Mallow\u2019s Cp, Akaike informa-\nMallow\u2019s Cp tion criterion (AIC), Bayesian information criterion (BIC), and adjusted\nAkaike\ninformation\ncriterion\nBayesian\ninformation\ncriterion\nR2. These are discussed in more detail in Chapter 6. We can also deteradjusted\nR2\nmine which model is best by plotting various model outputs, such as the\nresiduals, in order to search for patterns.\nUnfortunately, there are a total of 2p models that contain subsets of p\nvariables. This means that even for moderate p, trying out every possible\nsubset of the predictors is infeasible. For instance, we saw that if p = 2, then\nthere are 22 = 4 models to consider. But if p = 30, then we must consider\n230 = 1,073,741,824 models! This is not practical. Therefore, unless p is very\nsmall, we cannot consider all 2p models, and instead we need an automated\n3.2 Multiple Linear Regression 79\nand efficient approach to choose a smaller set of models to consider. There\nare three classical approaches for this task:\n\u2022 Forward selection. We begin with the null model\u2014a model that conforward\nselection\nnull model\ntains an intercept but no predictors. We then fit p simple linear regressions\nand add to the null model the variable that", "doc_id": "34465ecd-8913-434c-8be0-e4c1b65b2a75", "embedding": null, "doc_hash": "fb4a994a671db24141742fcae85a16e2767c264023859b80fbdeda0790966ae2", "extra_info": null, "node_info": {"start": 193943, "end": 197829, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "0a49f0b6-51f4-4555-99d2-24137357f1b6", "3": "a239da65-05bb-49b9-beec-d51e3e3c7395"}}, "__type__": "1"}, "a239da65-05bb-49b9-beec-d51e3e3c7395": {"__data__": {"text": "We then fit p simple linear regressions\nand add to the null model the variable that results in the\nlowest RSS. We then add to that model the variable that results\nin the lowest RSS for the new two-variable model. This approach is\ncontinued until some stopping rule is satisfied.\n\u2022 Backward selection. We start with all variables in the model, and\nbackward\nremove the variable with the largest p-value\u2014that is, the variable selection\nthat is the least statistically significant. The new (p \u2212 1)-variable\nmodel is fit, and the variable with the largest p-value is removed. This\nprocedure continues until a stopping rule is reached. For instance, we\nmay stop when all remaining variables have a p-value below some\nthreshold.\n\u2022 Mixed selection. This is a combination of forward and backward semixed\nlection. We start with no variables in the model, and as with forward selection\nselection, we add the variable that provides the best fit. We continue\nto add variables one-by-one. Of course, as we noted with the\nAdvertising example, the p-values for variables can become larger as\nnew predictors are added to the model. Hence, if at any point the\np-value for one of the variables in the model rises above a certain\nthreshold, then we remove that variable from the model. We continue\nto perform these forward and backward steps until all variables\nin the model have a sufficiently low p-value, and all variables outside\nthe model would have a large p-value if added to the model.\nBackward selection cannot be used if p > n, while forward selection can\nalways be used. Forward selection is a greedy approach, and might include\nvariables early that later become redundant. Mixed selection can remedy\nthis.\nThree: Model Fit\nTwo of the most common numerical measures of model fit are the RSE and\nR2, the fraction of variance explained. These quantities are computed and\ninterpreted in the same fashion as for simple linear regression.\nRecall that in simple regression, R2 is the square of the correlation of the\nresponse and the variable. In multiple linear regression, it turns out that it\nequals Cor(Y, \u02c6 Y )2, the square of the correlation between the response and\nthe fitted linear model; in fact one property of the fitted linear model is\nthat it maximizes this correlation among all possible linear models.\nAn R2 value close to 1 indicates that the model explains a large portion\nof the variance in the response variable. As an example, we saw in Table 3.6\n80 3. Linear Regression\nthat for the Advertising data, the model that uses all three advertising media\nto predict sales has an R2 of 0.8972. On the other hand, the model\nthat uses only TV and radio to predict sales has an R2 value of 0.89719.\nIn other words, there is a small increase in R2 if we include newspaper\nadvertising in the model that already contains TV and radio advertising,\neven though we saw earlier that the p-value for newspaper advertising in\nTable 3.4 is not significant. It turns out that R2 will always increase when\nmore variables are added to the model, even if those variables are only\nweakly associated with the response. This is due to the fact that adding\nanother variable always results in a decrease in the residual sum of squares\non the training data (though not necessarily the testing data). Thus, the\nR2 statistic, which is also computed on the training data, must increase.\nThe fact that adding newspaper advertising to the model containing only\nTV and radio advertising leads to just a tiny increase in R2 provides additional\nevidence that newspaper can be dropped from the model. Essentially,\nnewspaper provides no real improvement in the model fit to the training\nsamples, and its inclusion will likely lead to poor results on independent\ntest samples due to overfitting.\nBy contrast, the model containing only TV as a predictor had an R2 of\n0.61 (Table 3.2). Adding radio to the model leads to a substantial improvement\nin R2. This implies that a model that uses TV and radio expenditures\nto predict sales is substantially better than one that uses only TV", "doc_id": "a239da65-05bb-49b9-beec-d51e3e3c7395", "embedding": null, "doc_hash": "c9214f0ca862d046a05a80d34b79c37c2464342f6fa453dd342ef35f7e201c10", "extra_info": null, "node_info": {"start": 197819, "end": 201866, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "34465ecd-8913-434c-8be0-e4c1b65b2a75", "3": "2c47d2df-6c85-4802-a38c-9c572c76fa83"}}, "__type__": "1"}, "2c47d2df-6c85-4802-a38c-9c572c76fa83": {"__data__": {"text": "expenditures\nto predict sales is substantially better than one that uses only TV advertising.\nWe could further quantify this improvement by looking at the p-value\nfor the radio coefficient in a model that contains only TV and radio as\npredictors.\nThe model that contains only TV and radio as predictors has an RSE\nof 1.681, and the model that also contains newspaper as a predictor has\nan RSE of 1.686 (Table 3.6). In contrast, the model that contains only TV\nhas an RSE of 3.26 (Table 3.2). This corroborates our previous conclusion\nthat a model that uses TV and radio expenditures to predict sales is much\nmore accurate (on the training data) than one that only uses TV spending.\nFurthermore, given that TV and radio expenditures are used as predictors,\nthere is no point in also using newspaper spending as a predictor in the\nmodel. The observant reader may wonder how RSE can increase when\nnewspaper is added to the model given that RSS must decrease. In general\nRSE is defined as\nRSE =\n9\n1\nn \u2212 p \u2212 1\nRSS, (3.25)\nwhich simplifies to (3.15) for a simple linear regression. Thus, models with\nmore variables can have higher RSE if the decrease in RSS is small relative\nto the increase in p.\nIn addition to looking at the RSE and R2 statistics just discussed, it\ncan be useful to plot the data. Graphical summaries can reveal problems\nwith a model that are not visible from numerical statistics. For example,\n3.2 Multiple Linear Regression 81\nSales\nRadio\nTV\nFIGURE 3.5. For the Advertising data, a linear regression fit to sales using\nTV and radio as predictors. From the pattern of the residuals, we can see that\nthere is a pronounced non-linear relationship in the data. The positive residuals\n(those visible above the surface), tend to lie along the 45-degree line, where TV\nand Radio budgets are split evenly. The negative residuals (most not visible), tend\nto lie away from this line, where budgets are more lopsided.\nFigure 3.5 displays a three-dimensional plot of TV and radio versus sales.\nWe see that some observations lie above and some observations lie below\nthe least squares regression plane. In particular, the linear model seems to\noverestimate sales for instances in which most of the advertising money\nwas spent exclusively on either TV or radio. It underestimates sales for\ninstances where the budget was split between the two media. This pronounced\nnon-linear pattern suggests a synergy or interaction effect between\ninteraction\nthe advertising media, whereby combining the media together results in a\nbigger boost to sales than using any single medium. In Section 3.3.2, we\nwill discuss extending the linear model to accommodate such synergistic\neffects through the use of interaction terms.\nFour: Predictions\nOnce we have fit the multiple regression model, it is straightforward to\napply (3.21) in order to predict the response Y on the basis of a set of\nvalues for the predictors X1,X2, . . . ,Xp. However, there are three sorts of\nuncertainty associated with this prediction.\n1. The coefficient estimates \u02c6 \u03b20, \u02c6 \u03b21, . . . , \u02c6 \u03b2p are estimates for \u03b20,\u03b21, . . . ,\u03b2p.\nThat is, the least squares plane\n\u02c6 Y = \u02c6 \u03b20 + \u02c6 \u03b21X1 + \u00b7 \u00b7 \u00b7 + \u02c6 \u03b2pXp\n82 3. Linear Regression\nis only an estimate for the true population regression plane\nf(X) = \u03b20 + \u03b21X1 + \u00b7 \u00b7 \u00b7 + \u03b2pXp.\nThe inaccuracy in the coefficient estimates is related to the reducible\nerror from Chapter 2. We can compute a confidence interval in order\nto determine how close \u02c6 Y will be to f(X).\n2. Of course, in practice assuming a linear model for f(X) is almost\nalways an approximation of reality,", "doc_id": "2c47d2df-6c85-4802-a38c-9c572c76fa83", "embedding": null, "doc_hash": "06523aadadc979705d6e33d3bc449340bd87eab90682edd7b75cdbce3971b020", "extra_info": null, "node_info": {"start": 201867, "end": 205432, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "a239da65-05bb-49b9-beec-d51e3e3c7395", "3": "68e1127f-f84b-42e9-9258-a851fa1516ef"}}, "__type__": "1"}, "68e1127f-f84b-42e9-9258-a851fa1516ef": {"__data__": {"text": "assuming a linear model for f(X) is almost\nalways an approximation of reality, so there is an additional source of\npotentially reducible error which we call model bias. So when we use a\nlinear model, we are in fact estimating the best linear approximation\nto the true surface. However, here we will ignore this discrepancy,\nand operate as if the linear model were correct.\n3. Even if we knew f(X)\u2014that is, even if we knew the true values\nfor \u03b20,\u03b21, . . . ,\u03b2p\u2014the response value cannot be predicted perfectly\nbecause of the random error \u03f5 in the model (3.20). In Chapter 2, we\nreferred to this as the irreducible error. How much will Y vary from\n\u02c6 Y ? We use prediction intervals to answer this question. Prediction\nintervals are always wider than confidence intervals, because they\nincorporate both the error in the estimate for f(X) (the reducible\nerror) and the uncertainty as to how much an individual point will\ndiffer from the population regression plane (the irreducible error).\nWe use a confidence interval to quantify the uncertainty surrounding\nconfidence\nthe average sales over a large number of cities. For example, given that interval\n$100,000 is spent on TV advertising and $20,000 is spent on radio advertising\nin each city, the 95% confidence interval is [10,985, 11,528]. We interpret\nthis to mean that 95% of intervals of this form will contain the true value of\nf(X).9 On the other hand, a prediction interval can be used to quantify the\nprediction\nuncertainty surrounding sales for a particular city. Given that $100,000 is interval\nspent on TV advertising and $20,000 is spent on radio advertising in that city\nthe 95% prediction interval is [7,930, 14,580]. We interpret this to mean\nthat 95% of intervals of this form will contain the true value of Y for this\ncity. Note that both intervals are centered at 11,256, but that the prediction\ninterval is substantially wider than the confidence interval, reflecting the\nincreased uncertainty about sales for a given city in comparison to the\naverage sales over many locations.\n9In other words, if we collect a large number of data sets like the Advertising data\nset, and we construct a confidence interval for the average sales on the basis of each\ndata set (given $100,000 in TV and $20,000 in radio advertising), then 95% of these\nconfidence intervals will contain the true value of average sales.\n3.3 Other Considerations in the Regression Model 83\n3.3 Other Considerations in the Regression Model\n3.3.1 Qualitative Predictors\nIn our discussion so far, we have assumed that all variables in our linear\nregression model are quantitative. But in practice, this is not necessarily\nthe case; often some predictors are qualitative.\nFor example, the Credit data set displayed in Figure 3.6 records variables\nfor a number of credit card holders. The response is balance (average credit\ncard debt for each individual) and there are several quantitative predictors:\nage, cards (number of credit cards), education (years of education), income\n(in thousands of dollars), limit (credit limit), and rating (credit rating).\nEach panel of Figure 3.6 is a scatterplot for a pair of variables whose identities\nare given by the corresponding row and column labels. For example,\nthe scatterplot directly to the right of the word \u201cBalance\u201d depicts balance\nversus age, while the plot directly to the right of \u201cAge\u201d corresponds to\nage versus cards. In addition to these quantitative variables, we also have\nfour qualitative variables: own (house ownership), student (student status),\nstatus (marital status), and region (East, West or South).\nPredictors with Only Two Levels\nSuppose that we wish to investigate differences in credit card balance between\nthose who own a house and those who don\u2019t, ignoring the other variables\nfor the moment. If a qualitative predictor (also known as a factor)\nfactor\nonly has two levels, or possible values, then", "doc_id": "68e1127f-f84b-42e9-9258-a851fa1516ef", "embedding": null, "doc_hash": "b7d2a88e06ca6aead355b181e690bb5110c7b72fd629a0adec92f4f2da8e4270", "extra_info": null, "node_info": {"start": 205435, "end": 209330, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "2c47d2df-6c85-4802-a38c-9c572c76fa83", "3": "ca8c6ee5-bf3a-490e-a3e7-34126f2fc8ab"}}, "__type__": "1"}, "ca8c6ee5-bf3a-490e-a3e7-34126f2fc8ab": {"__data__": {"text": "known as a factor)\nfactor\nonly has two levels, or possible values, then incorporating it into a regreslevel\nsion model is very simple. We simply create an indicator or dummy variable\ndummy\nthat takes on two possible numerical values. variable 10 For example, based on the\nown variable, we can create a new variable that takes the form\nxi =\n=\n1 if ith person owns a house\n0 if ith person does not own a house,\n(3.26)\nand use this variable as a predictor in the regression equation. This results\nin the model\nyi = \u03b20 +\u03b21xi +\u03f5i =\n=\n\u03b20 + \u03b21 + \u03f5i if ith person owns a house\n\u03b20 + \u03f5i if ith person does not.\n(3.27)\nNow \u03b20 can be interpreted as the average credit card balance among those\nwho do not own, \u03b20 + \u03b21 as the average credit card balance among those\nwho do own their house, and \u03b21 as the average difference in credit card\nbalance between owners and non-owners.\n10In the machine learning community, the creation of dummy variables to handle\nqualitative predictors is known as \u201cone-hot encoding\u201d.\n84 3. Linear Regression\nBalance\n20 40 60 80 100 5 10 15 20 2000 8000 14000\n0 500 1500\n20 40 60 80 100\nAge\nCards\n2 4 6 8\n5 10 15 20\nEducation\nIncome\n50 100 150\n2000 8000 14000\nLimit\n0 500 1500 2 4 6 8 50 100 150 200 600 1000\n200 600 1000\nRating\nFIGURE 3.6. The Credit data set contains information about balance, age,\ncards, education, income, limit, and rating for a number of potential customers.\nTable 3.7 displays the coefficient estimates and other information associated\nwith the model (3.27). The average credit card debt for non-owners\nis estimated to be $509.80, whereas owners are estimated to carry $19.73\nin additional debt for a total of $509.80 + $19.73 = $529.53. However, we\nnotice that the p-value for the dummy variable is very high. This indicates\nthat there is no statistical evidence of a difference in average credit card\nbalance based on house ownership.\nThe decision to code owners as 1 and non-owners as 0 in (3.27) is arbitrary,\nand has no effect on the regression fit, but does alter the interpretation\nof the coefficients. If we had coded non-owners as 1 and owners\nas 0, then the estimates for \u03b20 and \u03b21 would have been 529.53 and\n\u221219.73, respectively, leading once again to a prediction of credit card debt\nof $529.53 \u2212 $19.73 = $509.80 for non-owners and a prediction of $529.53\n3.3 Other Considerations in the Regression Model 85\nCoefficient Std. error t-statistic p-value\nIntercept 509.80 33.13 15.389 < 0.0001\nown[Yes] 19.73 46.05 0.429 0.6690\nTABLE 3.7. Least squares coefficient estimates associated with the regression of\nbalance onto own in the Credit data set. The linear model is given in (3.27).\nThat is, ownership is encoded as a dummy variable, as in (3.26).\nfor owners. Alternatively, instead of a 0/1 coding scheme, we could create\na dummy variable\nxi =\n=\n1 if ith person owns a house\n\u22121 if ith person does not own a house\nand use this variable in the regression equation. This results in the model\nyi = \u03b20+\u03b21xi+\u03f5i =\n=\n\u03b20 + \u03b21 + \u03f5i if ith person owns a house\n\u03b20 \u2212 \u03b21 + \u03f5i if ith person does not own a house.\nNow \u03b20 can be interpreted as the overall average credit card balance (ignoring\nthe house ownership effect), and \u03b21 is the amount by which house\nowners and non-owners have credit card balances that are above and below\nthe average, respectively. In this example, the estimate for \u03b20 is $519.665,\nhalfway between the non-owner and owner averages of $509.80 and $529.53.\nThe estimate for \u03b21 is", "doc_id": "ca8c6ee5-bf3a-490e-a3e7-34126f2fc8ab", "embedding": null, "doc_hash": "ba7a2bfd4f5b2249294a0da097b14d09ea183a9919db3e54212df90e1dd63935", "extra_info": null, "node_info": {"start": 209337, "end": 212775, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "68e1127f-f84b-42e9-9258-a851fa1516ef", "3": "69a57614-0ca3-44b1-9f67-2409f49eb6a7"}}, "__type__": "1"}, "69a57614-0ca3-44b1-9f67-2409f49eb6a7": {"__data__": {"text": "of $509.80 and $529.53.\nThe estimate for \u03b21 is $9.865, which is half of $19.73, the average difference\nbetween owners and non-owners. It is important to note that the final predictions\nfor the credit balances of owners and non-owners will be identical\nregardless of the coding scheme used. The only difference is in the way that\nthe coefficients are interpreted.\nQualitative Predictors with More than Two Levels\nWhen a qualitative predictor has more than two levels, a single dummy\nvariable cannot represent all possible values. In this situation, we can create\nadditional dummy variables. For example, for the region variable we create\ntwo dummy variables. The first could be\nxi1 =\n=\n1 if ith person is from the South\n0 if ith person is not from the South,\n(3.28)\nand the second could be\nxi2 =\n=\n1 if ith person is from the West\n0 if ith person is not from the West.\n(3.29)\n86 3. Linear Regression\nCoefficient Std. error t-statistic p-value\nIntercept 531.00 46.32 11.464 < 0.0001\nregion[South] \u221218.69 65.02 \u22120.287 0.7740\nregion[West] \u221212.50 56.68 \u22120.221 0.8260\nTABLE 3.8. Least squares coefficient estimates associated with the regression of\nbalance onto region in the Credit data set. The linear model is given in (3.30).\nThat is, region is encoded via two dummy variables (3.28) and (3.29).\nThen both of these variables can be used in the regression equation, in\norder to obtain the model\nyi = \u03b20+\u03b21xi1+\u03b22xi2+\u03f5i =\n\u23a7\u23aa\u23a8\n\u23aa\u23a9\n\u03b20+\u03b21+\u03f5i if ith person is from the South\n\u03b20+\u03b22+\u03f5i if ith person is from the West\n\u03b20+\u03f5i if ith person is from the East.\n(3.30)\nNow \u03b20 can be interpreted as the average credit card balance for individuals\nfrom the East, \u03b21 can be interpreted as the difference in the average balance\nbetween people from the South versus the East, and \u03b22 can be interpreted\nas the difference in the average balance between those from the West versus\nthe East. There will always be one fewer dummy variable than the number\nof levels. The level with no dummy variable\u2014East in this example\u2014is\nknown as the baseline.\nbaseline\nFrom Table 3.8, we see that the estimated balance for the baseline, East,\nis $531.00. It is estimated that those in the South will have $18.69 less\ndebt than those in the East, and that those in the West will have $12.50\nless debt than those in the East. However, the p-values associated with the\ncoefficient estimates for the two dummy variables are very large, suggesting\nno statistical evidence of a real difference in average credit card balance\nbetween South and East or between West and East.11 Once again, the\nlevel selected as the baseline category is arbitrary, and the final predictions\nfor each group will be the same regardless of this choice. However, the\ncoefficients and their p-values do depend on the choice of dummy variable\ncoding. Rather than rely on the individual coefficients, we can use an F-test\nto test H0 : \u03b21 = \u03b22 = 0; this does not depend on the coding. This F-test\nhas a p-value of 0.96, indicating that we cannot reject the null hypothesis\nthat there is no relationship between balance and region.\nUsing this dummy variable approach presents no difficulties when incorporating\nboth quantitative and qualitative predictors. For example, to\nregress balance on both a quantitative variable such as income and a qualitative\nvariable such as student, we must simply create a dummy variable\nfor student and then fit a multiple regression model using income and the\ndummy variable as predictors for credit card balance.\n11There could still in theory be a difference between South and West, although the\ndata here does not suggest any difference.\n3.3 Other Considerations in the", "doc_id": "69a57614-0ca3-44b1-9f67-2409f49eb6a7", "embedding": null, "doc_hash": "2e4f97d3f051d0ad181237b22a41e90dd2e8d58a2ef3d9fd0820f43e7b29b0d0", "extra_info": null, "node_info": {"start": 212798, "end": 216425, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "ca8c6ee5-bf3a-490e-a3e7-34126f2fc8ab", "3": "c5a5c615-fac9-491a-9ece-b5e969194d82"}}, "__type__": "1"}, "c5a5c615-fac9-491a-9ece-b5e969194d82": {"__data__": {"text": "the\ndata here does not suggest any difference.\n3.3 Other Considerations in the Regression Model 87\nThere are many different ways of coding qualitative variables besides\nthe dummy variable approach taken here. All of these approaches lead to\nequivalent model fits, but the coefficients are different and have different\ninterpretations, and are designed to measure particular contrasts. This topic\ncontrast\nis beyond the scope of the book.\n3.3.2 Extensions of the Linear Model\nThe standard linear regression model (3.19) provides interpretable results\nand works quite well on many real-world problems. However, it makes several\nhighly restrictive assumptions that are often violated in practice. Two\nof the most important assumptions state that the relationship between the\npredictors and response are additive and linear. The additivity assumption\nadditive\nlinear means that the association between a predictor Xj and the response Y does\nnot depend on the values of the other predictors. The linearity assumption\nstates that the change in the response Y associated with a one-unit change\nin Xj is constant, regardless of the value of Xj . In later chapters of this\nbook, we examine a number of sophisticated methods that relax these two\nassumptions. Here, we briefly examine some common classical approaches\nfor extending the linear model.\nRemoving the Additive Assumption\nIn our previous analysis of the Advertising data, we concluded that both TV\nand radio seem to be associated with sales. The linear models that formed\nthe basis for this conclusion assumed that the effect on sales of increasing\none advertising medium is independent of the amount spent on the other\nmedia. For example, the linear model (3.20) states that the average increase\nin sales associated with a one-unit increase in TV is always \u03b21, regardless\nof the amount spent on radio.\nHowever, this simple model may be incorrect. Suppose that spending\nmoney on radio advertising actually increases the effectiveness of TV advertising,\nso that the slope term for TV should increase as radio increases.\nIn this situation, given a fixed budget of $100,000, spending half on radio\nand half on TV may increase sales more than allocating the entire amount\nto either TV or to radio. In marketing, this is known as a synergy effect,\nand in statistics it is referred to as an interaction effect. Figure 3.5 suggests\nthat such an effect may be present in the advertising data. Notice\nthat when levels of either TV or radio are low, then the true sales are lower\nthan predicted by the linear model. But when advertising is split between\nthe two media, then the model tends to underestimate sales.\nConsider the standard linear regression model with two variables,\nY = \u03b20 + \u03b21X1 + \u03b22X2 + \u03f5.\n88 3. Linear Regression\nAccording to this model, a one-unit increase in X1 is associated with an\naverage increase in Y of \u03b21 units. Notice that the presence of X2 does\nnot alter this statement\u2014that is, regardless of the value of X2, a oneunit\nincrease in X1 is associated with a \u03b21-unit increase in Y . One way of\nextending this model is to include a third predictor, called an interaction\nterm, which is constructed by computing the product of X1 and X2. This\nresults in the model\nY = \u03b20 + \u03b21X1 + \u03b22X2 + \u03b23X1X2 + \u03f5. (3.31)\nHow does inclusion of this interaction term relax the additive assumption?\nNotice that (3.31) can be rewritten as\nY = \u03b20 + (\u03b21 + \u03b23X2)X1 + \u03b22X2 + \u03f5 (3.32)\n= \u03b20 + \u02dc \u03b21X1 + \u03b22X2 + \u03f5\nwhere \u02dc \u03b21 = \u03b21 + \u03b23X2. Since \u02dc \u03b21 is now a function of X2, the association\nbetween X1 and Y is no longer constant: a change in the value of X2 will\nchange the association between X1 and Y . A similar argument shows that\na change in the value of X1 changes the association between X2 and Y .\nFor example, suppose that we are interested in studying the", "doc_id": "c5a5c615-fac9-491a-9ece-b5e969194d82", "embedding": null, "doc_hash": "29d6f9400bc4930805e918531254ef7ef992de7ac47321cf256c6b31c4196b24", "extra_info": null, "node_info": {"start": 216397, "end": 220198, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "69a57614-0ca3-44b1-9f67-2409f49eb6a7", "3": "08208372-cd7c-4db2-a519-6dc03512194d"}}, "__type__": "1"}, "08208372-cd7c-4db2-a519-6dc03512194d": {"__data__": {"text": "between X2 and Y .\nFor example, suppose that we are interested in studying the productivity\nof a factory. We wish to predict the number of units produced on the\nbasis of the number of production lines and the total number of workers.\nIt seems likely that the effect of increasing the number of production lines\nwill depend on the number of workers, since if no workers are available\nto operate the lines, then increasing the number of lines will not increase\nproduction. This suggests that it would be appropriate to include an interaction\nterm between lines and workers in a linear model to predict units.\nSuppose that when we fit the model, we obtain\nunits \u2248 1.2 + 3.4 \u00d7 lines + 0.22 \u00d7 workers + 1.4 \u00d7 (lines \u00d7 workers)\n= 1.2 + (3.4 + 1.4 \u00d7 workers) \u00d7 lines + 0.22 \u00d7 workers.\nIn other words, adding an additional line will increase the number of units\nproduced by 3.4 + 1.4 \u00d7 workers. Hence the more workers we have, the\nstronger will be the effect of lines.\nWe now return to the Advertising example. A linear model that uses\nradio, TV, and an interaction between the two to predict sales takes the\nform\nsales = \u03b20 + \u03b21 \u00d7 TV + \u03b22 \u00d7 radio + \u03b23 \u00d7 (radio \u00d7 TV) + \u03f5\n= \u03b20 + (\u03b21 + \u03b23 \u00d7 radio) \u00d7 TV + \u03b22 \u00d7 radio + \u03f5. (3.33)\nWe can interpret \u03b23 as the increase in the effectiveness of TV advertising\nassociated with a one-unit increase in radio advertising (or vice-versa). The\ncoefficients that result from fitting the model (3.33) are given in Table 3.9.\n3.3 Other Considerations in the Regression Model 89\nCoefficient Std. error t-statistic p-value\nIntercept 6.7502 0.248 27.23 < 0.0001\nTV 0.0191 0.002 12.70 < 0.0001\nradio 0.0289 0.009 3.24 0.0014\nTV\u00d7radio 0.0011 0.000 20.73 < 0.0001\nTABLE 3.9. For the Advertising data, least squares coefficient estimates associated\nwith the regression of sales onto TV and radio, with an interaction term,\nas in (3.33).\nThe results in Table 3.9 strongly suggest that the model that includes the\ninteraction term is superior to the model that contains only main effects.\nmain effect\nThe p-value for the interaction term, TV\u00d7radio, is extremely low, indicating\nthat there is strong evidence for Ha : \u03b23 \u0338= 0. In other words, it is clear that\nthe true relationship is not additive. The R2 for the model (3.33) is 96.8 %,\ncompared to only 89.7% for the model that predicts sales using TV and\nradio without an interaction term. This means that (96.8 \u2212 89.7)/(100 \u2212 89.7) = 69% of the variability in sales that remains after fitting the additive\nmodel has been explained by the interaction term. The coefficient\nestimates in Table 3.9 suggest that an increase in TV advertising of $1,000 is\nassociated with increased sales of ( \u02c6 \u03b21+ \u02c6 \u03b23\u00d7radio)\u00d71,000 = 19+1.1\u00d7radio\nunits. And an increase in radio advertising of $1,000 will be associated with\nan increase in sales of ( \u02c6 \u03b22 + \u02c6 \u03b23 \u00d7 TV) \u00d7 1,000 = 29 + 1.1 \u00d7 TV units.\nIn this example, the p-values associated with TV, radio, and the interaction\nterm all are statistically significant (Table 3.9), and so it is obvious\nthat all three variables should be included in the model. However, it is\nsometimes the case that an interaction term has a very small p-value, but\nthe associated main effects (in this case, TV and radio) do not. The hierarchical\nprinciple states that if we include an interaction in a model, we\nhierarchical\nshould also include the main effects, even if the p-values associated with principle\ntheir coefficients are not significant. In other words, if the interaction between\nX1 and X2 seems important, then we should include both X1 and\nX2 in the", "doc_id": "08208372-cd7c-4db2-a519-6dc03512194d", "embedding": null, "doc_hash": "6adf58fd0dfbe6f0a4c0e9470bc2ac2fdd3682d133d05765d17170dd09b6ec2c", "extra_info": null, "node_info": {"start": 220202, "end": 223748, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "c5a5c615-fac9-491a-9ece-b5e969194d82", "3": "281e3127-67ab-41ab-b5f7-9c48c65162c1"}}, "__type__": "1"}, "281e3127-67ab-41ab-b5f7-9c48c65162c1": {"__data__": {"text": "and X2 seems important, then we should include both X1 and\nX2 in the model even if their coefficient estimates have large p-values. The\nrationale for this principle is that if X1 \u00d7 X2 is related to the response,\nthen whether or not the coefficients of X1 or X2 are exactly zero is of little\ninterest. Also X1 \u00d7 X2 is typically correlated with X1 and X2, and so\nleaving them out tends to alter the meaning of the interaction.\nIn the previous example, we considered an interaction between TV and\nradio, both of which are quantitative variables. However, the concept of\ninteractions applies just as well to qualitative variables, or to a combination\nof quantitative and qualitative variables. In fact, an interaction between\na qualitative variable and a quantitative variable has a particularly nice\ninterpretation. Consider the Credit data set from Section 3.3.1, and suppose\nthat we wish to predict balance using the income (quantitative) and student\n(qualitative) variables. In the absence of an interaction term, the model\n90 3. Linear Regression\n0 50 100 150\n200 600 1000 1400\nIncome\nBalance\n0 50 100 150\n200 600 1000 1400\nIncome\nBalance\nstudent\nnon\u2212student\nFIGURE 3.7. For the Credit data, the least squares lines are shown for prediction\nof balance from income for students and non-students. Left: The model\n(3.34) was fit. There is no interaction between income and student. Right: The\nmodel (3.35) was fit. There is an interaction term between income and student.\ntakes the form\nbalancei \u2248 \u03b20 + \u03b21 \u00d7 incomei +\n=\n\u03b22 if ith person is a student\n0 if ith person is not a student\n= \u03b21 \u00d7 incomei +\n=\n\u03b20 + \u03b22 if ith person is a student\n\u03b20 if ith person is not a student.\n(3.34)\nNotice that this amounts to fitting two parallel lines to the data, one for\nstudents and one for non-students. The lines for students and non-students\nhave different intercepts, \u03b20 + \u03b22 versus \u03b20, but the same slope, \u03b21. This\nis illustrated in the left-hand panel of Figure 3.7. The fact that the lines\nare parallel means that the average effect on balance of a one-unit increase\nin income does not depend on whether or not the individual is a student.\nThis represents a potentially serious limitation of the model, since in fact a\nchange in income may have a very different effect on the credit card balance\nof a student versus a non-student.\nThis limitation can be addressed by adding an interaction variable, created\nby multiplying income with the dummy variable for student. Our\nmodel now becomes\nbalancei \u2248 \u03b20 + \u03b21 \u00d7 incomei +\n=\n\u03b22 + \u03b23 \u00d7 incomei if student\n0 if not student\n=\n=\n(\u03b20 + \u03b22) + (\u03b21 + \u03b23) \u00d7 incomei if student\n\u03b20 + \u03b21 \u00d7 incomei if not student.\n(3.35)\n3.3 Other Considerations in the Regression Model 91\n50 100 150 200\n10 20 30 40 50\nHorsepower\nMiles per gallon\nLinear\nDegree 2\nDegree 5\nFIGURE 3.8. The Auto data set. For a number of cars, mpg and horsepower are\nshown. The linear regression fit is shown in orange. The linear regression fit for a\nmodel that includes horsepower2 is shown as a blue curve. The linear regression\nfit for a model that includes all polynomials of horsepower up to fifth-degree is\nshown in green.\nOnce again, we have two different regression lines for the students and\nthe non-students. But now those regression lines have different intercepts,\n\u03b20+\u03b22 versus \u03b20, as well as different slopes, \u03b21+\u03b23 versus \u03b21. This allows for\nthe possibility that changes in income may affect the credit card balances\nof students and non-students differently. The right-hand panel of Figure 3.7\nshows the estimated relationships between income and balance for students\nand non-students in the model (3.35). We note that the slope for students\nis lower than", "doc_id": "281e3127-67ab-41ab-b5f7-9c48c65162c1", "embedding": null, "doc_hash": "91b56a0125f409cb995ce6317a26a961a91d4d907c783f096f82058056eb9a41", "extra_info": null, "node_info": {"start": 223758, "end": 227417, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "08208372-cd7c-4db2-a519-6dc03512194d", "3": "7ddca281-74e0-4c7c-a2de-9c4449b3438d"}}, "__type__": "1"}, "7ddca281-74e0-4c7c-a2de-9c4449b3438d": {"__data__": {"text": "the model (3.35). We note that the slope for students\nis lower than the slope for non-students. This suggests that increases in\nincome are associated with smaller increases in credit card balance among\nstudents as compared to non-students.\nNon-linear Relationships\nAs discussed previously, the linear regression model (3.19) assumes a linear\nrelationship between the response and predictors. But in some cases, the\ntrue relationship between the response and the predictors may be nonlinear.\nHere we present a very simple way to directly extend the linear model\nto accommodate non-linear relationships, using polynomial regression. In\npolynomial\nlater chapters, we will present more complex approaches for performing regression\nnon-linear fits in more general settings.\n92 3. Linear Regression\nCoefficient Std. error t-statistic p-value\nIntercept 56.9001 1.8004 31.6 < 0.0001\nhorsepower \u22120.4662 0.0311 \u221215.0 < 0.0001\nhorsepower2 0.0012 0.0001 10.1 < 0.0001\nTABLE 3.10. For the Auto data set, least squares coefficient estimates associated\nwith the regression of mpg onto horsepower and horsepower2.\nConsider Figure 3.8, in which the mpg (gas mileage in miles per gallon)\nversus horsepower is shown for a number of cars in the Auto data set. The\norange line represents the linear regression fit. There is a pronounced relationship\nbetween mpg and horsepower, but it seems clear that this relationship\nis in fact non-linear: the data suggest a curved relationship. A simple\napproach for incorporating non-linear associations in a linear model is to\ninclude transformed versions of the predictors. For example, the points in\nFigure 3.8 seem to have a quadratic shape, suggesting that a model of the\nquadratic\nform\nmpg = \u03b20 + \u03b21 \u00d7 horsepower + \u03b22 \u00d7 horsepower2 + \u03f5 (3.36)\nmay provide a better fit. Equation 3.36 involves predicting mpg using a\nnon-linear function of horsepower. But it is still a linear model! That is,\n(3.36) is simply a multiple linear regression model with X1 = horsepower\nand X2 = horsepower2. So we can use standard linear regression software to\nestimate \u03b20,\u03b21, and \u03b22 in order to produce a non-linear fit. The blue curve\nin Figure 3.8 shows the resulting quadratic fit to the data. The quadratic\nfit appears to be substantially better than the fit obtained when just the\nlinear term is included. The R2 of the quadratic fit is 0.688, compared to\n0.606 for the linear fit, and the p-value in Table 3.10 for the quadratic term\nis highly significant.\nIf including horsepower2 led to such a big improvement in the model, why\nnot include horsepower3, horsepower4, or even horsepower5? The green curve\nin Figure 3.8 displays the fit that results from including all polynomials up\nto fifth degree in the model (3.36). The resulting fit seems unnecessarily\nwiggly\u2014that is, it is unclear that including the additional terms really has\nled to a better fit to the data.\nThe approach that we have just described for extending the linear model\nto accommodate non-linear relationships is known as polynomial regression,\nsince we have included polynomial functions of the predictors in the\nregression model. We further explore this approach and other non-linear\nextensions of the linear model in Chapter 7.\n3.3.3 Potential Problems\nWhen we fit a linear regression model to a particular data set, many problems\nmay occur. Most common among these are the following:\n1. Non-linearity of the response-predictor relationships.\n3.3 Other Considerations in the Regression Model 93\n2. Correlation of error terms.\n3. Non-constant variance of error terms.\n4. Outliers.\n5. High-leverage points.\n6. Collinearity.\nIn practice, identifying and overcoming these problems is as much an\nart as", "doc_id": "7ddca281-74e0-4c7c-a2de-9c4449b3438d", "embedding": null, "doc_hash": "2f4b8dc17161ce48ebb0a70bb213947d347e4274edd25b8b6de1546a0990807e", "extra_info": null, "node_info": {"start": 227418, "end": 231097, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "281e3127-67ab-41ab-b5f7-9c48c65162c1", "3": "5618bcb4-80d2-4104-ad2b-9e75e4f046b1"}}, "__type__": "1"}, "5618bcb4-80d2-4104-ad2b-9e75e4f046b1": {"__data__": {"text": "practice, identifying and overcoming these problems is as much an\nart as a science. Many pages in countless books have been written on this\ntopic. Since the linear regression model is not our primary focus here, we\nwill provide only a brief summary of some key points.\n1. Non-linearity of the Data\n5 10 15 20 25 30\n\u221215 \u221210 \u22125 0 5 10 15 20\nFitted values\nResiduals\nResidual Plot for Linear Fit\n323\n330\n334\n15 20 25 30 35\n\u221215 \u221210 \u22125 0 5 10 15\nFitted values\nResiduals\nResidual Plot for Quadratic Fit\n334\n323\n155\nFIGURE 3.9. Plots of residuals versus predicted (or fitted) values for the Auto\ndata set. In each plot, the red line is a smooth fit to the residuals, intended to make\nit easier to identify a trend. Left: A linear regression of mpg on horsepower. A\nstrong pattern in the residuals indicates non-linearity in the data. Right: A linear\nregression of mpg on horsepower and horsepower2. There is little pattern in the\nresiduals.\nThe linear regression model assumes that there is a straight-line relationship\nbetween the predictors and the response. If the true relationship\nis far from linear, then virtually all of the conclusions that we draw from\nthe fit are suspect. In addition, the prediction accuracy of the model can\nbe significantly reduced.\nResidual plots are a useful graphical tool for identifying non-linearity.\nresidual plot\nGiven a simple linear regression model, we can plot the residuals, ei =\nyi \u2212 \u02c6yi, versus the predictor xi. In the case of a multiple regression model,\n94 3. Linear Regression\nsince there are multiple predictors, we instead plot the residuals versus\nthe predicted (or fitted) values \u02c6yi. Ideally, the residual plot will show no\nfitted\ndiscernible pattern. The presence of a pattern may indicate a problem with\nsome aspect of the linear model.\nThe left panel of Figure 3.9 displays a residual plot from the linear regression\nof mpg onto horsepower on the Auto data set that was illustrated in\nFigure 3.8. The red line is a smooth fit to the residuals, which is displayed in\norder to make it easier to identify any trends. The residuals exhibit a clear\nU-shape, which provides a strong indication of non-linearity in the data.\nIn contrast, the right-hand panel of Figure 3.9 displays the residual plot\nthat results from the model (3.36), which contains a quadratic term. There\nappears to be little pattern in the residuals, suggesting that the quadratic\nterm improves the fit to the data.\nIf the residual plot indicates that there are non-linear associations in the\ndata, then a simple approach is to use non-linear transformations of the\npredictors, such as logX, \u221aX, and X2, in the regression model. In the\nlater chapters of this book, we will discuss other more advanced non-linear\napproaches for addressing this issue.\n2. Correlation of Error Terms\nAn important assumption of the linear regression model is that the error\nterms, \u03f51, \u03f52, . . . , \u03f5n, are uncorrelated. What does this mean? For instance,\nif the errors are uncorrelated, then the fact that \u03f5i is positive provides\nlittle or no information about the sign of \u03f5i+1. The standard errors that\nare computed for the estimated regression coefficients or the fitted values\nare based on the assumption of uncorrelated error terms. If in fact there is\ncorrelation among the error terms, then the estimated standard errors will\ntend to underestimate the true standard errors. As a result, confidence and\nprediction intervals will be narrower than they should be. For example,\na 95% confidence interval may in reality have a much lower probability\nthan 0.95 of containing the true value of the parameter. In addition, pvalues\nassociated with the model will be lower than they should be; this\ncould", "doc_id": "5618bcb4-80d2-4104-ad2b-9e75e4f046b1", "embedding": null, "doc_hash": "59c2186ea941c0d67667165d4b0769adc0d686333431984783702175fa779d3f", "extra_info": null, "node_info": {"start": 231092, "end": 234783, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "7ddca281-74e0-4c7c-a2de-9c4449b3438d", "3": "51ba3307-62f5-4b77-806b-8e4c6e180f53"}}, "__type__": "1"}, "51ba3307-62f5-4b77-806b-8e4c6e180f53": {"__data__": {"text": "pvalues\nassociated with the model will be lower than they should be; this\ncould cause us to erroneously conclude that a parameter is statistically\nsignificant. In short, if the error terms are correlated, we may have an\nunwarranted sense of confidence in our model.\nAs an extreme example, suppose we accidentally doubled our data, leading\nto observations and error terms identical in pairs. If we ignored this, our\nstandard error calculations would be as if we had a sample of size 2n, when\nin fact we have only n samples. Our estimated parameters would be the\nsame for the 2n samples as for the n samples, but the confidence intervals\nwould be narrower by a factor of \u221a2!\nWhy might correlations among the error terms occur? Such correlations\nfrequently occur in the context of time series data, which consists of obtime\nseries\nservations for which measurements are obtained at discrete points in time.\n3.3 Other Considerations in the Regression Model 95\n0 20 40 60 80 100\n\u22123 \u22121 0 1 2 3\n\u03c1=0.0\nResidual\n0 20 40 60 80 100\n\u22124 \u22122 0 1 2\n\u03c1=0.5\nResidual\n0 20 40 60 80 100\n\u22121.5 \u22120.5 0.5 1.5\n\u03c1=0.9\nResidual\nObservation\nFIGURE 3.10. Plots of residuals from simulated time series data sets generated\nwith differing levels of correlation \u03c1 between error terms for adjacent time points.\nIn many cases, observations that are obtained at adjacent time points will\nhave positively correlated errors. In order to determine if this is the case for\na given data set, we can plot the residuals from our model as a function of\ntime. If the errors are uncorrelated, then there should be no discernible pattern.\nOn the other hand, if the error terms are positively correlated, then\nwe may see tracking in the residuals\u2014that is, adjacent residuals may have\ntracking\nsimilar values. Figure 3.10 provides an illustration. In the top panel, we see\nthe residuals from a linear regression fit to data generated with uncorrelated\nerrors. There is no evidence of a time-related trend in the residuals.\nIn contrast, the residuals in the bottom panel are from a data set in which\nadjacent errors had a correlation of 0.9. Now there is a clear pattern in the\nresiduals\u2014adjacent residuals tend to take on similar values. Finally, the\ncenter panel illustrates a more moderate case in which the residuals had a\ncorrelation of 0.5. There is still evidence of tracking, but the pattern is less\nclear.\nMany methods have been developed to properly take account of correlations\nin the error terms in time series data. Correlation among the error\n96 3. Linear Regression\n10 15 20 25 30\n\u221210 \u22125 0 5 10 15\nFitted values\nResiduals\nResponse Y\n998\n975\n845\n2.4 2.6 2.8 3.0 3.2 3.4\n\u22120.8 \u22120.6 \u22120.4 \u22120.2 0.0 0.2 0.4\nFitted values\nResiduals\nResponse log(Y)\n437\n671\n605\nFIGURE 3.11. Residual plots. In each plot, the red line is a smooth fit to the\nresiduals, intended to make it easier to identify a trend. The blue lines track the\nouter quantiles of the residuals, and emphasize patterns. Left: The funnel shape\nindicates heteroscedasticity. Right: The response has been log transformed, and\nthere is now no evidence of heteroscedasticity.\nterms can also occur outside of time series data. For instance, consider a\nstudy in which individuals\u2019 heights are predicted from their weights. The\nassumption of uncorrelated errors could be violated if some of the individuals\nin the study are members of the same family, eat the same diet,\nor have been exposed to the same environmental factors. In general, the\nassumption of uncorrelated errors is extremely important for linear regression\nas well as for other statistical methods, and good experimental", "doc_id": "51ba3307-62f5-4b77-806b-8e4c6e180f53", "embedding": null, "doc_hash": "ddacbc042b081257e01a1ce4b345efe7306ffc4ea5ec6a20a03728468d0880e7", "extra_info": null, "node_info": {"start": 234778, "end": 238371, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "5618bcb4-80d2-4104-ad2b-9e75e4f046b1", "3": "b7a83828-1427-47ce-a20a-b560dca3e044"}}, "__type__": "1"}, "b7a83828-1427-47ce-a20a-b560dca3e044": {"__data__": {"text": "important for linear regression\nas well as for other statistical methods, and good experimental design\nis crucial in order to mitigate the risk of such correlations.\n3. Non-constant Variance of Error Terms\nAnother important assumption of the linear regression model is that the\nerror terms have a constant variance, Var(\u03f5i) = \u03c32. The standard errors,\nconfidence intervals, and hypothesis tests associated with the linear model\nrely upon this assumption.\nUnfortunately, it is often the case that the variances of the error terms are\nnon-constant. For instance, the variances of the error terms may increase\nwith the value of the response. One can identify non-constant variances in\nthe errors, or heteroscedasticity, from the presence of a funnel shape in\nheterothe\nresidual plot. An example is shown in the left-hand panel of Figure 3.11, scedasticity\nin which the magnitude of the residuals tends to increase with the fitted\nvalues. When faced with this problem, one possible solution is to transform\nthe response Y using a concave function such as log Y or \u221aY . Such\na transformation results in a greater amount of shrinkage of the larger responses,\nleading to a reduction in heteroscedasticity. The right-hand panel\n3.3 Other Considerations in the Regression Model 97\n\u22122 \u22121 0 1 2\n\u22124 \u22122 0 2 4 6\n20\n\u22122 0 2 4 6\n\u22121 0 1 2 3 4\nFitted Values\nResiduals\n20\n\u22122 0 2 4 6\n0 2 4 6\nFitted Values\nStudentized Residuals\n20\nX\nY\nFIGURE 3.12. Left: The least squares regression line is shown in red, and the\nregression line after removing the outlier is shown in blue. Center: The residual\nplot clearly identifies the outlier. Right: The outlier has a studentized residual of\n6; typically we expect values between \u22123 and 3.\nof Figure 3.11 displays the residual plot after transforming the response\nusing log Y . The residuals now appear to have constant variance, though\nthere is some evidence of a slight non-linear relationship in the data.\nSometimes we have a good idea of the variance of each response. For\nexample, the ith response could be an average of ni raw observations. If\neach of these raw observations is uncorrelated with variance \u03c32, then their\naverage has variance \u03c32\ni = \u03c32/ni. In this case a simple remedy is to fit our\nmodel by weighted least squares, with weights proportional to the inverse\nweighted\nvariances\u2014i.e. wi = ni in this case. Most linear regression software allows least squares\nfor observation weights.\n4. Outliers\nAn outlier is a point for which yi is far from the value predicted by the\noutlier\nmodel. Outliers can arise for a variety of reasons, such as incorrect recording\nof an observation during data collection.\nThe red point (observation 20) in the left-hand panel of Figure 3.12\nillustrates a typical outlier. The red solid line is the least squares regression\nfit, while the blue dashed line is the least squares fit after removal of the\noutlier. In this case, removing the outlier has little effect on the least squares\nline: it leads to almost no change in the slope, and a miniscule reduction\nin the intercept. It is typical for an outlier that does not have an unusual\npredictor value to have little effect on the least squares fit. However, even\nif an outlier does not have much effect on the least squares fit, it can cause\nother problems. For instance, in this example, the RSE is 1.09 when the\noutlier is included in the regression, but it is only 0.77 when the outlier\nis removed. Since the RSE is used to compute all confidence intervals and\np-values, such a dramatic increase caused by a single data point can have\nimplications for the interpretation of the fit. Similarly, inclusion of the\noutlier causes the R2 to decline from", "doc_id": "b7a83828-1427-47ce-a20a-b560dca3e044", "embedding": null, "doc_hash": "a455b08140aa30e03389d3c66b113de950274f8abfc4460f9bb5015ee747e65a", "extra_info": null, "node_info": {"start": 238357, "end": 242022, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "51ba3307-62f5-4b77-806b-8e4c6e180f53", "3": "7872acfe-007f-4273-b1a1-3fe33f08d1f6"}}, "__type__": "1"}, "7872acfe-007f-4273-b1a1-3fe33f08d1f6": {"__data__": {"text": "fit. Similarly, inclusion of the\noutlier causes the R2 to decline from 0.892 to 0.805.\n98 3. Linear Regression\n\u22122 \u22121 0 1 2 3 4\n0 5 10\n20\n41\n\u22122 \u22121 0 1 2\n\u22122 \u22121 0 1 2\n0.00 0.05 0.10 0.15 0.20 0.25\n\u22121 0 1 2 3 4 5\nLeverage\nStudentized Residuals\n20\n41\nX\nY\nX1\nX2\nFIGURE 3.13. Left: Observation 41 is a high leverage point, while 20 is not.\nThe red line is the fit to all the data, and the blue line is the fit with observation\n41 removed. Center: The red observation is not unusual in terms of its X1 value\nor its X2 value, but still falls outside the bulk of the data, and hence has high\nleverage. Right: Observation 41 has a high leverage and a high residual.\nResidual plots can be used to identify outliers. In this example, the outlier\nis clearly visible in the residual plot illustrated in the center panel of\nFigure 3.12. But in practice, it can be difficult to decide how large a residual\nneeds to be before we consider the point to be an outlier. To address\nthis problem, instead of plotting the residuals, we can plot the studentized\nresiduals, computed by dividing each residual ei by its estimated standard\nstudentized\nerror. Observations whose studentized residuals are greater than 3 in abso- residual\nlute value are possible outliers. In the right-hand panel of Figure 3.12, the\noutlier\u2019s studentized residual exceeds 6, while all other observations have\nstudentized residuals between \u22122 and 2.\nIf we believe that an outlier has occurred due to an error in data collection\nor recording, then one solution is to simply remove the observation.\nHowever, care should be taken, since an outlier may instead indicate a\ndeficiency with the model, such as a missing predictor.\n5. High Leverage Points\nWe just saw that outliers are observations for which the response yi is\nunusual given the predictor xi. In contrast, observations with high leverage\nhigh\nhave an unusual value for xi. For example, observation 41 in the left-hand leverage\npanel of Figure 3.13 has high leverage, in that the predictor value for this\nobservation is large relative to the other observations. (Note that the data\ndisplayed in Figure 3.13 are the same as the data displayed in Figure 3.12,\nbut with the addition of a single high leverage observation.) The red solid\nline is the least squares fit to the data, while the blue dashed line is the\nfit produced when observation 41 is removed. Comparing the left-hand\npanels of Figures 3.12 and 3.13, we observe that removing the high leverage\nobservation has a much more substantial impact on the least squares line\nthan removing the outlier. In fact, high leverage observations tend to have\na sizable impact on the estimated regression line. It is cause for concern if\n3.3 Other Considerations in the Regression Model 99\nthe least squares line is heavily affected by just a couple of observations,\nbecause any problems with these points may invalidate the entire fit. For\nthis reason, it is important to identify high leverage observations.\nIn a simple linear regression, high leverage observations are fairly easy to\nidentify, since we can simply look for observations for which the predictor\nvalue is outside of the normal range of the observations. But in a multiple\nlinear regression with many predictors, it is possible to have an observation\nthat is well within the range of each individual predictor\u2019s values, but that\nis unusual in terms of the full set of predictors. An example is shown in\nthe center panel of Figure 3.13, for a data set with two predictors, X1 and\nX2. Most of the observations\u2019 predictor values", "doc_id": "7872acfe-007f-4273-b1a1-3fe33f08d1f6", "embedding": null, "doc_hash": "ffcf5f07c200852284566db2ce9c2bfcc94b878f1dfe6dd1d34832536840d59a", "extra_info": null, "node_info": {"start": 242046, "end": 245592, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "b7a83828-1427-47ce-a20a-b560dca3e044", "3": "ff27599b-23cf-4963-b2d7-3553d3595860"}}, "__type__": "1"}, "ff27599b-23cf-4963-b2d7-3553d3595860": {"__data__": {"text": "X1 and\nX2. Most of the observations\u2019 predictor values fall within the blue dashed\nellipse, but the red observation is well outside of this range. But neither its\nvalue for X1 nor its value for X2 is unusual. So if we examine just X1 or\njust X2, we will fail to notice this high leverage point. This problem is more\npronounced in multiple regression settings with more than two predictors,\nbecause then there is no simple way to plot all dimensions of the data\nsimultaneously.\nIn order to quantify an observation\u2019s leverage, we compute the leverage\nstatistic. A large value of this statistic indicates an observation with high\nleverage\nleverage. For a simple linear regression, statistic\nhi =\n1\nn\n+\n(xi \u2212 \u00afx)2\n)n\ni\u2032=1(xi\u2032 \u2212 \u00afx)2 . (3.37)\nIt is clear from this equation that hi increases with the distance of xi from \u00afx.\nThere is a simple extension of hi to the case of multiple predictors, though\nwe do not provide the formula here. The leverage statistic hi is always\nbetween 1/n and 1, and the average leverage for all the observations is\nalways equal to (p+1)/n. So if a given observation has a leverage statistic\nthat greatly exceeds (p+1)/n, then we may suspect that the corresponding\npoint has high leverage.\nThe right-hand panel of Figure 3.13 provides a plot of the studentized\nresiduals versus hi for the data in the left-hand panel of Figure 3.13. Observation\n41 stands out as having a very high leverage statistic as well as a\nhigh studentized residual. In other words, it is an outlier as well as a high\nleverage observation. This is a particularly dangerous combination! This\nplot also reveals the reason that observation 20 had relatively little effect\non the least squares fit in Figure 3.12: it has low leverage.\n6. Collinearity\nCollinearity refers to the situation in which two or more predictor variables\ncollinearity\nare closely related to one another. The concept of collinearity is illustrated\nin Figure 3.14 using the Credit data set. In the left-hand panel of Figure\n3.14, the two predictors limit and age appear to have no obvious relationship.\nIn contrast, in the right-hand panel of Figure 3.14, the predictors\n100 3. Linear Regression\n2000 4000 6000 8000 12000\n30 40 50 60 70 80\nLimit\nAge\n2000 4000 6000 8000 12000\n200 400 600 800\nLimit\nRating\nFIGURE 3.14. Scatterplots of the observations from the Credit data set. Left:\nA plot of age versus limit. These two variables are not collinear. Right: A plot\nof rating versus limit. There is high collinearity.\n21.25\n21.5\n21.8\n0.16 0.17 0.18 0.19\n\u22125 \u22124 \u22123 \u22122 \u22121 0\n21.5\n21.8\n\u22120.1 0.0 0.1 0.2\n0 1 2 3 4 5\n\u03b2Limit \u03b2Limit\n\u03b2Age\n\u03b2Rating\nFIGURE 3.15. Contour plots for the RSS values as a function of the parameters\n\u03b2 for various regressions involving the Credit data set. In each plot, the black\ndots represent the coefficient values corresponding to the minimum RSS. Left:\nA contour plot of RSS for the regression of balance onto age and limit. The\nminimum value is well defined. Right: A contour plot of RSS for the regression\nof balance onto rating and limit. Because of the collinearity, there are many\npairs (\u03b2Limit,\u03b2Rating) with a similar value for RSS.\nlimit and rating are very highly correlated with each other, and we say\nthat they are collinear. The presence of collinearity can pose problems in\nthe regression context, since it can be difficult to separate out the individual\neffects of collinear variables on the response. In other words, since\nlimit and rating tend to increase or decrease together, it", "doc_id": "ff27599b-23cf-4963-b2d7-3553d3595860", "embedding": null, "doc_hash": "b67367fc69cead0abc647b7ca91ae759ccb6677a8aae3b276a22e97067c936c9", "extra_info": null, "node_info": {"start": 245607, "end": 249086, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "7872acfe-007f-4273-b1a1-3fe33f08d1f6", "3": "e05ae904-cc42-49f9-bdd5-6e28cc8751da"}}, "__type__": "1"}, "e05ae904-cc42-49f9-bdd5-6e28cc8751da": {"__data__": {"text": "other words, since\nlimit and rating tend to increase or decrease together, it can be difficult to\ndetermine how each one separately is associated with the response, balance.\n3.3 Other Considerations in the Regression Model 101\nFigure 3.15 illustrates some of the difficulties that can result from collinearity.\nThe left-hand panel of Figure 3.15 is a contour plot of the RSS (3.22)\nassociated with different possible coefficient estimates for the regression\nof balance on limit and age. Each ellipse represents a set of coefficients\nthat correspond to the same RSS, with ellipses nearest to the center taking\non the lowest values of RSS. The black dots and associated dashed\nlines represent the coefficient estimates that result in the smallest possible\nRSS\u2014in other words, these are the least squares estimates. The axes for\nlimit and age have been scaled so that the plot includes possible coefficient\nestimates that are up to four standard errors on either side of the\nleast squares estimates. Thus the plot includes all plausible values for the\ncoefficients. For example, we see that the true limit coefficient is almost\ncertainly somewhere between 0.15 and 0.20.\nIn contrast, the right-hand panel of Figure 3.15 displays contour plots\nof the RSS associated with possible coefficient estimates for the regression\nof balance onto limit and rating, which we know to be highly collinear.\nNow the contours run along a narrow valley; there is a broad range of\nvalues for the coefficient estimates that result in equal values for RSS.\nHence a small change in the data could cause the pair of coefficient values\nthat yield the smallest RSS\u2014that is, the least squares estimates\u2014to move\nanywhere along this valley. This results in a great deal of uncertainty in the\ncoefficient estimates. Notice that the scale for the limit coefficient now runs\nfrom roughly \u22120.2 to 0.2; this is an eight-fold increase over the plausible\nrange of the limit coefficient in the regression with age. Interestingly, even\nthough the limit and rating coefficients now have much more individual\nuncertainty, they will almost certainly lie somewhere in this contour valley.\nFor example, we would not expect the true value of the limit and rating\ncoefficients to be \u22120.1 and 1 respectively, even though such a value is\nplausible for each coefficient individually.\nSince collinearity reduces the accuracy of the estimates of the regression\ncoefficients, it causes the standard error for \u02c6 \u03b2j to grow. Recall that the\nt-statistic for each predictor is calculated by dividing \u02c6 \u03b2j by its standard\nerror. Consequently, collinearity results in a decline in the t-statistic. As a\nresult, in the presence of collinearity, we may fail to reject H0 : \u03b2j = 0. This\nmeans that the power of the hypothesis test\u2014the probability of correctly power\ndetecting a non-zero coefficient\u2014is reduced by collinearity.\nTable 3.11 compares the coefficient estimates obtained from two separate\nmultiple regression models. The first is a regression of balance on age and\nlimit, and the second is a regression of balance on rating and limit. In the\nfirst regression, both age and limit are highly significant with very small pvalues.\nIn the second, the collinearity between limit and rating has caused\nthe standard error for the limit coefficient estimate to increase by a factor\nof 12 and the p-value to increase to 0.701. In other words, the importance\nof the limit variable has been masked due to the presence of collinearity.\n102 3. Linear Regression\nCoefficient Std. error t-statistic p-value\nIntercept \u2212173.411 43.828 \u22123.957 < 0.0001\nModel 1 age \u22122.292 0.672 \u22123.407 0.0007\nlimit 0.173 0.005 34.496 < 0.0001\nIntercept \u2212377.537 45.254 \u22128.343 < 0.0001\nModel 2 rating 2.202 0.952 2.312 0.0213\nlimit 0.025 0.064 0.384 0.7012\nTABLE", "doc_id": "e05ae904-cc42-49f9-bdd5-6e28cc8751da", "embedding": null, "doc_hash": "bccc37b5f13e8f70ae50796383b090ac92ade12f453d9fc230ca814440530e03", "extra_info": null, "node_info": {"start": 249067, "end": 252840, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "ff27599b-23cf-4963-b2d7-3553d3595860", "3": "fb8666aa-68b2-4740-990a-c24c3b784ce5"}}, "__type__": "1"}, "fb8666aa-68b2-4740-990a-c24c3b784ce5": {"__data__": {"text": "0.025 0.064 0.384 0.7012\nTABLE 3.11. The results for two multiple regression models involving the\nCredit data set are shown. Model 1 is a regression of balance on age and limit,\nand Model 2 a regression of balance on rating and limit. The standard error\nof \u02c6\u03b2limit increases 12-fold in the second regression, due to collinearity.\nTo avoid such a situation, it is desirable to identify and address potential\ncollinearity problems while fitting the model.\nA simple way to detect collinearity is to look at the correlation matrix\nof the predictors. An element of this matrix that is large in absolute value\nindicates a pair of highly correlated variables, and therefore a collinearity\nproblem in the data. Unfortunately, not all collinearity problems can be\ndetected by inspection of the correlation matrix: it is possible for collinearity\nto exist between three or more variables even if no pair of variables\nhas a particularly high correlation. We call this situation multicollinearity.\nmulti-\nInstead of inspecting the correlation matrix, a better way to assess multi- collinearity\ncollinearity is to compute the variance inflation factor (VIF). The VIF is\nvariance\ninflation\nfactor\nthe ratio of the variance of \u02c6 \u03b2j when fitting the full model divided by the\nvariance of \u02c6 \u03b2j if fit on its own. The smallest possible value for VIF is 1,\nwhich indicates the complete absence of collinearity. Typically in practice\nthere is a small amount of collinearity among the predictors. As a rule of\nthumb, a VIF value that exceeds 5 or 10 indicates a problematic amount of\ncollinearity. The VIF for each variable can be computed using the formula\nVIF( \u02c6 \u03b2j) =\n1\n1 \u2212 R2Xj |X\u2212j\n,\nwhere R2X\nj |X\u2212j\nis the R2 from a regression of Xj onto all of the other\npredictors. If R2X\nj |X\u2212j\nis close to one, then collinearity is present, and so\nthe VIF will be large.\nIn the Credit data, a regression of balance on age, rating, and limit\nindicates that the predictors have VIF values of 1.01, 160.67, and 160.59.\nAs we suspected, there is considerable collinearity in the data!\nWhen faced with the problem of collinearity, there are two simple solutions.\nThe first is to drop one of the problematic variables from the regression.\nThis can usually be done without much compromise to the regression\nfit, since the presence of collinearity implies that the information that this\nvariable provides about the response is redundant in the presence of the\nother variables. For instance, if we regress balance onto age and limit,\n3.4 The Marketing Plan 103\nwithout the rating predictor, then the resulting VIF values are close to\nthe minimum possible value of 1, and the R2 drops from 0.754 to 0.75.\nSo dropping rating from the set of predictors has effectively solved the\ncollinearity problem without compromising the fit. The second solution is\nto combine the collinear variables together into a single predictor. For instance,\nwe might take the average of standardized versions of limit and\nrating in order to create a new variable that measures credit worthiness.\n3.4 The Marketing Plan\nWe now briefly return to the seven questions about the Advertising data\nthat we set out to answer at the beginning of this chapter.\n1. Is there a relationship between sales and advertising budget?\nThis question can be answered by fitting a multiple regression model\nof sales onto TV, radio, and newspaper, as in (3.20), and testing the\nhypothesis H0 : \u03b2TV = \u03b2radio = \u03b2newspaper = 0. In Section 3.2.2,\nwe showed that the F-statistic can be used to determine whether\nor not we should reject this null hypothesis. In this case the p-value\ncorresponding to the F-statistic in Table 3.6 is very low, indicating\nclear evidence of a relationship between", "doc_id": "fb8666aa-68b2-4740-990a-c24c3b784ce5", "embedding": null, "doc_hash": "38aac8971720cdf74fe55e4fc315973646db7b5fb36ab1bfc6bcc890712404d4", "extra_info": null, "node_info": {"start": 252880, "end": 256585, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "e05ae904-cc42-49f9-bdd5-6e28cc8751da", "3": "6e40463b-368d-4853-8fcb-6df7e5914ceb"}}, "__type__": "1"}, "6e40463b-368d-4853-8fcb-6df7e5914ceb": {"__data__": {"text": "in Table 3.6 is very low, indicating\nclear evidence of a relationship between advertising and sales.\n2. How strong is the relationship?\nWe discussed two measures of model accuracy in Section 3.1.3. First,\nthe RSE estimates the standard deviation of the response from the\npopulation regression line. For the Advertising data, the RSE is 1.69\nunits while the mean value for the response is 14.022, indicating a\npercentage error of roughly 12 %. Second, the R2 statistic records\nthe percentage of variability in the response that is explained by\nthe predictors. The predictors explain almost 90% of the variance in\nsales. The RSE and R2 statistics are displayed in Table 3.6.\n3. Which media are associated with sales?\nTo answer this question, we can examine the p-values associated with\neach predictor\u2019s t-statistic (Section 3.1.2). In the multiple linear regression\ndisplayed in Table 3.4, the p-values for TV and radio are low,\nbut the p-value for newspaper is not. This suggests that only TV and\nradio are related to sales. In Chapter 6 we explore this question in\ngreater detail.\n4. How large is the association between each medium and sales?\nWe saw in Section 3.1.2 that the standard error of \u02c6 \u03b2j can be used to\nconstruct confidence intervals for \u03b2j . For the Advertising data, we\n104 3. Linear Regression\ncan use the results in Table 3.4 to compute the 95% confidence intervals\nfor the coefficients in a multiple regression model using all three\nmedia budgets as predictors. The confidence intervals are as follows:\n(0.043, 0.049) for TV, (0.172, 0.206) for radio, and (\u22120.013, 0.011) for\nnewspaper. The confidence intervals for TV and radio are narrow and\nfar from zero, providing evidence that these media are related to\nsales. But the interval for newspaper includes zero, indicating that\nthe variable is not statistically significant given the values of TV and\nradio.\nWe saw in Section 3.3.3 that collinearity can result in very wide standard\nerrors. Could collinearity be the reason that the confidence interval\nassociated with newspaper is so wide? The VIF scores are 1.005,\n1.145, and 1.145 for TV, radio, and newspaper, suggesting no evidence\nof collinearity.\nIn order to assess the association of each medium individually on\nsales, we can perform three separate simple linear regressions. Results\nare shown in Tables 3.1 and 3.3. There is evidence of an extremely\nstrong association between TV and sales and between radio\nand sales. There is evidence of a mild association between newspaper\nand sales, when the values of TV and radio are ignored.\n5. How accurately can we predict future sales?\nThe response can be predicted using (3.21). The accuracy associated\nwith this estimate depends on whether we wish to predict an\nindividual response, Y = f(X) + \u03f5, or the average response, f(X)\n(Section 3.2.2). If the former, we use a prediction interval, and if the\nlatter, we use a confidence interval. Prediction intervals will always\nbe wider than confidence intervals because they account for the uncertainty\nassociated with \u03f5, the irreducible error.\n6. Is the relationship linear?\nIn Section 3.3.3, we saw that residual plots can be used in order to\nidentify non-linearity. If the relationships are linear, then the residual\nplots should display no pattern. In the case of the Advertising data,\nwe observe a non-linear effect in Figure 3.5, though this effect could\nalso be observed in a residual plot. In Section 3.3.2, we discussed the\ninclusion of transformations of the predictors in the linear regression\nmodel in order to accommodate non-linear relationships.\n7. Is there synergy among the advertising media?\nThe standard linear regression model assumes an additive relationship\nbetween the predictors and the response. An additive", "doc_id": "6e40463b-368d-4853-8fcb-6df7e5914ceb", "embedding": null, "doc_hash": "00b6fd706eee074bf1ed20abef4dc5bc34028a5fc40f1c7c7b8fc7621a6c18c0", "extra_info": null, "node_info": {"start": 256547, "end": 260296, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "fb8666aa-68b2-4740-990a-c24c3b784ce5", "3": "3bdd36fd-ccd3-4755-850c-5fd72f861a2f"}}, "__type__": "1"}, "3bdd36fd-ccd3-4755-850c-5fd72f861a2f": {"__data__": {"text": "assumes an additive relationship\nbetween the predictors and the response. An additive model\nis easy to interpret because the association between each predictor\nand the response is unrelated to the values of the other predictors.\nHowever, the additive assumption may be unrealistic for certain data\n105\nsets. In Section 3.3.2, we showed how to include an interaction term\nin the regression model in order to accommodate non-additive relationships.\nA small p-value associated with the interaction term indicates\nthe presence of such relationships. Figure 3.5 suggested that the\nAdvertising data may not be additive. Including an interaction term\nin the model results in a substantial increase in R2, from around 90%\nto almost 97 %.\n3.5 Comparison of Linear Regression\nwith K-Nearest Neighbors\nAs discussed in Chapter 2, linear regression is an example of a parametric\napproach because it assumes a linear functional form for f(X). Parametric\nmethods have several advantages. They are often easy to fit, because one\nneed estimate only a small number of coefficients. In the case of linear regression,\nthe coefficients have simple interpretations, and tests of statistical\nsignificance can be easily performed. But parametric methods do have a\ndisadvantage: by construction, they make strong assumptions about the\nform of f(X). If the specified functional form is far from the truth, and\nprediction accuracy is our goal, then the parametric method will perform\npoorly. For instance, if we assume a linear relationship between X and Y\nbut the true relationship is far from linear, then the resulting model will\nprovide a poor fit to the data, and any conclusions drawn from it will be\nsuspect.\nIn contrast, non-parametric methods do not explicitly assume a parametric\nform for f(X), and thereby provide an alternative and more flexible\napproach for performing regression. We discuss various non-parametric\nmethods in this book. Here we consider one of the simplest and best-known\nnon-parametric methods, K-nearest neighbors regression (KNN regression).\nK-nearest\nneighbors\nregression\nThe KNN regression method is closely related to the KNN classifier discussed\nin Chapter 2. Given a value for K and a prediction point x0, KNN\nregression first identifies the K training observations that are closest to\nx0, represented by N0. It then estimates f(x0) using the average of all the\ntraining responses in N0. In other words,\n\u02c6 f(x0) =\n1\nK\n0\nxi\u2208N0\nyi.\nFigure 3.16 illustrates two KNN fits on a data set with p = 2 predictors.\nThe fit with K = 1 is shown in the left-hand panel, while the right-hand\npanel corresponds to K = 9.We see that when K = 1, the KNN fit perfectly\ninterpolates the training observations, and consequently takes the form of\na step function. When K = 9, the KNN fit still is a step function, but\naveraging over nine observations results in much smaller regions of constant\n3.5 Comparison of Linear Regression with K-Nearest Neighbors\n106 3. Linear Regression\ny\ny\nx1\nx1\nx2\nx2\ny\ny y\nFIGURE 3.16. Plots of \u02c6 f(X) using KNN regression on a two-dimensional data\nset with 64 observations (orange dots). Left: K = 1 results in a rough step function\nfit. Right: K = 9 produces a much smoother fit.\nprediction, and consequently a smoother fit. In general, the optimal value\nfor K will depend on the bias-variance tradeoff, which we introduced in\nChapter 2. A small value for K provides the most flexible fit, which will\nhave low bias but high variance. This variance is due to the fact that the\nprediction in a given region is entirely dependent on just one observation.\nIn contrast, larger values of K provide a smoother and less variable fit; the\nprediction in a region is an average of several points, and so changing", "doc_id": "3bdd36fd-ccd3-4755-850c-5fd72f861a2f", "embedding": null, "doc_hash": "cd6b53dfc8fbe78906d3f6e379dde3ad192a0abc282fe2f556fb4b294a3be94e", "extra_info": null, "node_info": {"start": 260288, "end": 264010, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "6e40463b-368d-4853-8fcb-6df7e5914ceb", "3": "28919f1f-3595-4e98-b8ab-7dbbaae0fa22"}}, "__type__": "1"}, "28919f1f-3595-4e98-b8ab-7dbbaae0fa22": {"__data__": {"text": "fit; the\nprediction in a region is an average of several points, and so changing one\nobservation has a smaller effect. However, the smoothing may cause bias by\nmasking some of the structure in f(X). In Chapter 5, we introduce several\napproaches for estimating test error rates. These methods can be used to\nidentify the optimal value of K in KNN regression.\nIn what setting will a parametric approach such as least squares linear regression\noutperform a non-parametric approach such as KNN regression?\nThe answer is simple: the parametric approach will outperform the nonparametric\napproach if the parametric form that has been selected is close\nto the true form of f. Figure 3.17 provides an example with data generated\nfrom a one-dimensional linear regression model. The black solid lines represent\nf(X), while the blue curves correspond to the KNN fits using K = 1\nand K = 9. In this case, the K = 1 predictions are far too variable, while\nthe smoother K = 9 fit is much closer to f(X). However, since the true\nrelationship is linear, it is hard for a non-parametric approach to compete\nwith linear regression: a non-parametric approach incurs a cost in variance\nthat is not offset by a reduction in bias. The blue dashed line in the lefthand\npanel of Figure 3.18 represents the linear regression fit to the same\ndata. It is almost perfect. The right-hand panel of Figure 3.18 reveals that\nlinear regression outperforms KNN for this data. The green solid line, plot3.5\nComparison of Linear Regression with K-Nearest Neighbors 107\nted as a function of 1/K, represents the test set mean squared error (MSE)\nfor KNN. The KNN errors are well above the black dashed line, which is\nthe test MSE for linear regression. When the value of K is large, then KNN\nperforms only a little worse than least squares regression in terms of MSE.\nIt performs far worse when K is small.\nIn practice, the true relationship between X and Y is rarely exactly linear.\nFigure 3.19 examines the relative performances of least squares regression\nand KNN under increasing levels of non-linearity in the relationship\nbetween X and Y . In the top row, the true relationship is nearly linear.\nIn this case we see that the test MSE for linear regression is still superior\nto that of KNN for low values of K. However, for K \u2265 4, KNN outperforms\nlinear regression. The second row illustrates a more substantial\ndeviation from linearity. In this situation, KNN substantially outperforms\nlinear regression for all values of K. Note that as the extent of non-linearity\nincreases, there is little change in the test set MSE for the non-parametric\nKNN method, but there is a large increase in the test set MSE of linear\nregression.\nFigures 3.18 and 3.19 display situations in which KNN performs slightly\nworse than linear regression when the relationship is linear, but much better\nthan linear regression for non-linear situations. In a real life situation\nin which the true relationship is unknown, one might suspect that KNN\nshould be favored over linear regression because it will at worst be slightly\ninferior to linear regression if the true relationship is linear, and may give\nsubstantially better results if the true relationship is non-linear. But in reality,\neven when the true relationship is highly non-linear, KNN may still\nprovide inferior results to linear regression. In particular, both Figures 3.18\nand 3.19 illustrate settings with p = 1 predictor. But in higher dimensions,\nKNN often performs worse than linear regression.\nFigure 3.20 considers the same strongly non-linear situation as in the\nsecond row of Figure 3.19, except that we have added additional noise\npredictors that are not associated with the response. When p = 1 or p = 2,\nKNN outperforms linear regression. But for p = 3 the results are mixed,\nand for p \u2265 4 linear regression is superior to KNN. In", "doc_id": "28919f1f-3595-4e98-b8ab-7dbbaae0fa22", "embedding": null, "doc_hash": "9d005428c69f5cf00a5600819dc8bcffec0952983be04e86255c8095ffdd99b6", "extra_info": null, "node_info": {"start": 264019, "end": 267867, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "3bdd36fd-ccd3-4755-850c-5fd72f861a2f", "3": "9ce3c2f0-bdbd-43d3-925b-fad2c9aa7ace"}}, "__type__": "1"}, "9ce3c2f0-bdbd-43d3-925b-fad2c9aa7ace": {"__data__": {"text": "for p \u2265 4 linear regression is superior to KNN. In fact, the increase in\ndimension has only caused a small deterioration in the linear regression test\nset MSE, but it has caused more than a ten-fold increase in the MSE for\nKNN. This decrease in performance as the dimension increases is a common\nproblem for KNN, and results from the fact that in higher dimensions\nthere is effectively a reduction in sample size. In this data set there are\n50 training observations; when p = 1, this provides enough information to\naccurately estimate f(X). However, spreading 50 observations over p = 20\ndimensions results in a phenomenon in which a given observation has no\nnearby neighbors\u2014this is the so-called curse of dimensionality. That is,\ncurse of dithe\nK observations that are nearest to a given test observation x0 may be mensionality\nvery far away from x0 in p-dimensional space when p is large, leading to a\nvery poor prediction of f(x0) and hence a poor KNN fit. As a general rule,\n108 3. Linear Regression\n\u22121.0 \u22120.5 0.0 0.5 1.0\n1 2 3 4\n\u22121.0 \u22120.5 0.0 0.5 1.0\n1 2 3 4\ny\ny\nx x\nFIGURE 3.17. Plots of \u02c6 f(X) using KNN regression on a one-dimensional data\nset with 50 observations. The true relationship is given by the black solid line.\nLeft: The blue curve corresponds to K = 1 and interpolates (i.e. passes directly\nthrough) the training data. Right: The blue curve corresponds to K = 9, and\nrepresents a smoother fit.\n\u22121.0 \u22120.5 0.0 0.5 1.0\n1 2 3 4\n0.2 0.5 1.0\n0.00 0.05 0.10 0.15\nMean Squared Error\ny\nx 1/K\nFIGURE 3.18. The same data set shown in Figure 3.17 is investigated further.\nLeft: The blue dashed line is the least squares fit to the data. Since f(X) is in\nfact linear (displayed as the black line), the least squares regression line provides\na very good estimate of f(X). Right: The dashed horizontal line represents the\nleast squares test set MSE, while the green solid line corresponds to the MSE\nfor KNN as a function of 1/K (on the log scale). Linear regression achieves a\nlower test MSE than does KNN regression, since f(X) is in fact linear. For KNN\nregression, the best results occur with a very large value of K, corresponding to a\nsmall value of 1/K.\n3.5 Comparison of Linear Regression with K-Nearest Neighbors 109\n\u22121.0 \u22120.5 0.0 0.5 1.0\n0.5 1.0 1.5 2.0 2.5 3.0 3.5\n0.2 0.5 1.0\n0.00 0.02 0.04 0.06 0.08\nMean Squared Error\n\u22121.0 \u22120.5 0.0 0.5 1.0\n1.0 1.5 2.0 2.5 3.0 3.5\n0.2 0.5 1.0\n0.00 0.05 0.10 0.15\nMean Squared Error\ny y\nx\nx\n1/K\n1/K\nFIGURE 3.19. Top Left: In a setting with a slightly non-linear relationship\nbetween X and Y (solid black line), the KNN fits with K = 1 (blue) and K = 9\n(red) are displayed. Top Right: For the slightly non-linear data, the test set MSE\nfor least squares regression (horizontal black) and KNN with various values of\n1/K (green) are displayed. Bottom Left and Bottom Right: As in the top panel,\nbut with a strongly non-linear relationship between X and Y .\n110 3. Linear Regression\n0.2 0.5 1.0\n0.0 0.2 0.4 0.6 0.8", "doc_id": "9ce3c2f0-bdbd-43d3-925b-fad2c9aa7ace", "embedding": null, "doc_hash": "833a949a0acee9e31a0c83082d09a0891f4d96819f24f8f1baa1b456c65a8671", "extra_info": null, "node_info": {"start": 267895, "end": 270857, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "28919f1f-3595-4e98-b8ab-7dbbaae0fa22", "3": "93d4ca37-5017-4348-be98-ebe10d582e9f"}}, "__type__": "1"}, "93d4ca37-5017-4348-be98-ebe10d582e9f": {"__data__": {"text": "1.0\n0.0 0.2 0.4 0.6 0.8 1.0\np=1\n0.2 0.5 1.0\n0.0 0.2 0.4 0.6 0.8 1.0\np=2\n0.2 0.5 1.0\n0.0 0.2 0.4 0.6 0.8 1.0\np=3\n0.2 0.5 1.0\n0.0 0.2 0.4 0.6 0.8 1.0\np=4\n0.2 0.5 1.0\n0.0 0.2 0.4 0.6 0.8 1.0\np=10\n0.2 0.5 1.0\n0.0 0.2 0.4 0.6 0.8 1.0\np=20\nMean Squared Error\n1/K\nFIGURE 3.20. Test MSE for linear regression (black dashed lines) and KNN\n(green curves) as the number of variables p increases. The true function is non\u2013\nlinear in the first variable, as in the lower panel in Figure 3.19, and does not\ndepend on the additional variables. The performance of linear regression deteriorates\nslowly in the presence of these additional noise variables, whereas KNN\u2019s\nperformance degrades much more quickly as p increases.\nparametric methods will tend to outperform non-parametric approaches\nwhen there is a small number of observations per predictor.\nEven when the dimension is small, we might prefer linear regression to\nKNN from an interpretability standpoint. If the test MSE of KNN is only\nslightly lower than that of linear regression, we might be willing to forego\na little bit of prediction accuracy for the sake of a simple model that can\nbe described in terms of just a few coefficients, and for which p-values are\navailable.\n3.6 Lab: Linear Regression\n3.6.1 Libraries\nThe library() function is used to load libraries, or groups of functions\nlibrary()\nand data sets that are not included in the base R distribution. Basic functions\nthat perform least squares linear regression and other simple analyses\ncome standard with the base distribution, but more exotic functions require\nadditional libraries. Here we load the MASS package, which is a very large\ncollection of data sets and functions. We also load the ISLR2 package, which\nincludes the data sets associated with this book.\n> library(MASS)\n> library(ISLR2)\nIf you receive an error message when loading any of these libraries, it\nlikely indicates that the corresponding library has not yet been installed\non your system. Some libraries, such as MASS, come with R and do not need to\nbe separately installed on your computer. However, other packages, such as\n3.6 Lab: Linear Regression 111\nISLR2, must be downloaded the first time they are used. This can be done directly\nfrom within R. For example, on a Windows system, select the Install\npackage option under the Packages tab. After you select any mirror site, a\nlist of available packages will appear. Simply select the package you wish\nto install and R will automatically download the package. Alternatively,\nthis can be done at the R command line via install.packages(\"ISLR2\").\nThis installation only needs to be done the first time you use a package.\nHowever, the library() function must be called within each R session.\n3.6.2 Simple Linear Regression\nThe ISLR2 library contains the Boston data set, which records medv (median\nhouse value) for 506 census tracts in Boston. We will seek to predict\nmedv using 12 predictors such as rm (average number of rooms per house),\nage (average age of houses), and lstat (percent of households with low\nsocioeconomic status).\n> head(Boston)\ncrim zn indus chas nox rm age dis rad tax\n1 0.00632 18 2.31 0 0.538 6.575 65.2 4.0900 1 296\n2 0.02731 0 7.07 0 0.469 6.421 78.9 4.9671 2 242\n3 0.02729 0 7.07 0 0.469 7.185 61.1 4.9671 2 242\n4 0.03237 0", "doc_id": "93d4ca37-5017-4348-be98-ebe10d582e9f", "embedding": null, "doc_hash": "8291d2d0ace5700b42f9d7a499593a14dcb33f2f2944b7695ea8a1616ca75415", "extra_info": null, "node_info": {"start": 270879, "end": 274163, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "9ce3c2f0-bdbd-43d3-925b-fad2c9aa7ace", "3": "b6197718-3cf7-48db-9f9d-62eb36c6bc20"}}, "__type__": "1"}, "b6197718-3cf7-48db-9f9d-62eb36c6bc20": {"__data__": {"text": "7.185 61.1 4.9671 2 242\n4 0.03237 0 2.18 0 0.458 6.998 45.8 6.0622 3 222\n5 0.06905 0 2.18 0 0.458 7.147 54.2 6.0622 3 222\n6 0.02985 0 2.18 0 0.458 6.430 58.7 6.0622 3 222\nptratio lstat medv\n1 15.3 4.98 24.0\n2 17.8 9.14 21.6\n3 17.8 4.03 34.7\n4 18.7 2.94 33.4\n5 18.7 5.33 36.2\n6 18.7 5.21 28.7\nTo find out more about the data set, we can type ?Boston.\nWe will start by using the lm() function to fit a simple linear regression\nlm()\nmodel, with medv as the response and lstat as the predictor. The basic\nsyntax is lm(y \u223c x, data), where y is the response, x is the predictor, and\ndata is the data set in which these two variables are kept.\n> lm.fit <- lm(medv \u223c lstat)\nError in eval(expr , envir , enclos) : Object \"medv\" not found\nThe command causes an error because R does not know where to find\nthe variables medv and lstat. The next line tells R that the variables are\nin Boston. If we attach Boston, the first line works fine because R now\nrecognizes the variables.\n> lm.fit <- lm(medv \u223c lstat , data = Boston)\n> attach(Boston)\n> lm.fit <- lm(medv \u223c lstat)\n112 3. Linear Regression\nIf we type lm.fit, some basic information about the model is output.\nFor more detailed information, we use summary(lm.fit). This gives us pvalues\nand standard errors for the coefficients, as well as the R2 statistic\nand F-statistic for the model.\n> lm.fit\nCall:\nlm(formula = medv \u223c lstat)\nCoefficients:\n(Intercept) lstat\n34.55 -0.95\n> summary(lm.fit)\nCall:\nlm(formula = medv \u223c lstat)\nResiduals:\nMin 1Q Median 3Q Max\n-15.17 -3.99 -1.32 2.03 24.50\nCoefficients:\nEstimate Std. Error t value Pr(>|t|)\n(Intercept) 34.5538 0.5626 61.4 <2e-16 ***\nlstat -0.9500 0.0387 -24.5 <2e-16 ***\n---\nSignif. codes: 0 *** 0.001 ** 0.01 * 0.05 . 0.1 1\nResidual standard error: 6.22 on 504 degrees of freedom\nMultiple R-squared: 0.544 , Adjusted R-squared: 0.543\nF-statistic: 602 on 1 and 504 DF, p-value: < 2e-16\nWe can use the names() function in order to find out what other pieces\nnames()\nof information are stored in lm.fit. Although we can extract these quantities\nby name\u2014e.g. lm.fit$coefficients\u2014it is safer to use the extractor\nfunctions like coef() to access them.\ncoef()\n> names(lm.fit)\n[1] \"coefficients\" \"residuals\" \"effects\"\n[4] \"rank\" \"fitted.values\" \"assign\"\n[7] \"qr\" \"df.residual\" \"xlevels\"\n[10] \"call\" \"terms\" \"model\"\n> coef(lm.fit)\n(Intercept) lstat\n34.55 -0.95\nIn order to obtain a confidence interval for the coefficient estimates, we can\nuse the confint() command.\nconfint()\n> confint(lm.fit)\n2.5 % 97.5 %\n(Intercept) 33.45 35.659\n3.6 Lab: Linear Regression 113\nlstat -1.03 -0.874\nThe predict() function can be used to produce confidence intervals", "doc_id": "b6197718-3cf7-48db-9f9d-62eb36c6bc20", "embedding": null, "doc_hash": "fc5bc33a52452a9eb908d115ded49781ccb94188f19e5610a995e47afaff8484", "extra_info": null, "node_info": {"start": 274154, "end": 276786, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "93d4ca37-5017-4348-be98-ebe10d582e9f", "3": "3fb0ddf7-6a63-4976-99d5-81d9621597c1"}}, "__type__": "1"}, "3fb0ddf7-6a63-4976-99d5-81d9621597c1": {"__data__": {"text": "-0.874\nThe predict() function can be used to produce confidence intervals and\npredict()\nprediction intervals for the prediction of medv for a given value of lstat.\n> predict(lm.fit , data.frame(lstat = (c(5, 10, 15))),\ninterval = \"confidence\")\nfit lwr upr\n1 29.80 29.01 30.60\n2 25.05 24.47 25.63\n3 20.30 19.73 20.87\n> predict(lm.fit , data.frame(lstat = (c(5, 10, 15))),\ninterval = \"prediction\")\nfit lwr upr\n1 29.80 17.566 42.04\n2 25.05 12.828 37.28\n3 20.30 8.078 32.53\nFor instance, the 95% confidence interval associated with a lstat value of\n10 is (24.47, 25.63), and the 95% prediction interval is (12.828, 37.28). As\nexpected, the confidence and prediction intervals are centered around the\nsame point (a predicted value of 25.05 for medv when lstat equals 10), but\nthe latter are substantially wider.\nWe will now plot medv and lstat along with the least squares regression\nline using the plot() and abline() functions.\nabline()\n> plot(lstat , medv)\n> abline(lm.fit)\nThere is some evidence for non-linearity in the relationship between lstat\nand medv. We will explore this issue later in this lab.\nThe abline() function can be used to draw any line, not just the least\nsquares regression line. To draw a line with intercept a and slope b, we\ntype abline(a, b). Below we experiment with some additional settings for\nplotting lines and points. The lwd = 3 command causes the width of the\nregression line to be increased by a factor of 3; this works for the plot() and\nlines() functions also. We can also use the pch option to create different\nplotting symbols.\n> abline(lm.fit , lwd = 3)\n> abline(lm.fit , lwd = 3, col = \"red\")\n> plot(lstat , medv , col = \"red\")\n> plot(lstat , medv , pch = 20)\n> plot(lstat , medv , pch = \"+\")\n> plot (1:20 , 1:20, pch = 1:20)\nNext we examine some diagnostic plots, several of which were discussed\nin Section 3.3.3. Four diagnostic plots are automatically produced by applying\nthe plot() function directly to the output from lm(). In general, this\ncommand will produce one plot at a time, and hitting Enter will generate\nthe next plot. However, it is often convenient to view all four plots together.\nWe can achieve this by using the par() and mfrow() functions, which tell R\npar()\nmfrow()\n114 3. Linear Regression\nto split the display screen into separate panels so that multiple plots can\nbe viewed simultaneously. For example, par(mfrow = c(2, 2)) divides the\nplotting region into a 2 \u00d7 2 grid of panels.\n> par(mfrow = c(2, 2))\n> plot(lm.fit)\nAlternatively, we can compute the residuals from a linear regression fit\nusing the residuals() function. The function rstudent() will return the\nresiduals()\nrstudent()\nstudentized residuals, and we can use this function to plot the residuals\nagainst the fitted values.\n> plot(predict(lm.fit), residuals(lm.fit))\n> plot(predict(lm.fit), rstudent(lm.fit))\nOn the basis of the residual plots, there is some evidence of non-linearity.\nLeverage statistics can be computed for any number of predictors using the\nhatvalues() function.\nhatvalues()\n> plot(hatvalues(lm.fit))\n> which.max(hatvalues(lm.fit))\n375\nThe which.max() function identifies the index", "doc_id": "3fb0ddf7-6a63-4976-99d5-81d9621597c1", "embedding": null, "doc_hash": "bc77d9332b85973da1e806b00a73d9222e30482fc5bbc1e0117d0a9b6089d987", "extra_info": null, "node_info": {"start": 276752, "end": 279881, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "b6197718-3cf7-48db-9f9d-62eb36c6bc20", "3": "c09b1d2f-7f14-4521-b3ad-e7471ad0dd36"}}, "__type__": "1"}, "c09b1d2f-7f14-4521-b3ad-e7471ad0dd36": {"__data__": {"text": "which.max() function identifies the index of the largest element of a\nwhich.max()\nvector. In this case, it tells us which observation has the largest leverage\nstatistic.\n3.6.3 Multiple Linear Regression\nIn order to fit a multiple linear regression model using least squares, we\nagain use the lm() function. The syntax lm(y \u223c x1 + x2 + x3) is used to\nfit a model with three predictors, x1, x2, and x3. The summary() function\nnow outputs the regression coefficients for all the predictors.\n> lm.fit <- lm(medv \u223c lstat + age , data = Boston)\n> summary(lm.fit)\nCall:\nlm(formula = medv \u223c lstat + age , data = Boston)\nResiduals:\nMin 1Q Median 3Q Max\n-15.98 -3.98 -1.28 1.97 23.16\nCoefficients:\nEstimate Std. Error t value Pr(>|t|)\n(Intercept) 33.2228 0.7308 45.46 <2e-16 ***\nlstat -1.0321 0.0482 -21.42 <2e-16 ***\nage 0.0345 0.0122 2.83 0.0049 **\n---\nSignif. codes: 0 *** 0.001 ** 0.01 * 0.05 . 0.1 1\nResidual standard error: 6.17 on 503 degrees of freedom\n3.6 Lab: Linear Regression 115\nMultiple R-squared: 0.551 , Adjusted R-squared: 0.549\nF-statistic: 309 on 2 and 503 DF, p-value: < 2e-16\nThe Boston data set contains 12 variables, and so it would be cumbersome\nto have to type all of these in order to perform a regression using all of the\npredictors. Instead, we can use the following short-hand:\n> lm.fit <- lm(medv \u223c ., data = Boston)\n> summary(lm.fit)\nCall:\nlm(formula = medv \u223c ., data = Boston)\nResiduals:\nMin 1Q Median 3Q Max\n-15.130 -2.767 -0.581 1.941 26.253\nCoefficients:\nEstimate Std. Error t value Pr(>|t|)\n(Intercept) 41.61727 4.93604 8.43 3.8e-16 ***\ncrim -0.12139 0.03300 -3.68 0.00026 ***\nzn 0.04696 0.01388 3.38 0.00077 ***\nindus 0.01347 0.06214 0.22 0.82852\nchas 2.83999 0.87001 3.26 0.00117 **\nnox -18.75802 3.85135 -4.87 1.5e-06 ***\nrm 3.65812 0.42025 8.70 < 2e -16 ***\nage 0.00361 0.01333 0.27 0.78659\ndis -1.49075 0.20162 -7.39 6.2e-13 ***\nrad 0.28940 0.06691 4.33 1.8e-05 ***\ntax -0.01268 0.00380 -3.34 0.00091 ***\nptratio -0.93753 0.13221 -7.09 4.6e-12 ***\nlstat -0.55202 0.05066 -10.90 < 2e-16 ***\n---\nSignif. codes: 0 *** 0.001 ** 0.01 * 0.05 . 0.1 1\nResidual standard error: 4.8 on 493 degrees of freedom\nMultiple R-squared: 0.734 , Adjusted R-squared: 0.728\nF-statistic: 114 on 12 and 493 DF, p-value: < 2e-16\nWe can access the individual components of a summary object by name\n(type ?summary.lm to see what is available). Hence summary(lm.fit)$r.sq\ngives us the R2, and summary(lm.fit)$sigma gives us the RSE. The vif()\nvif()\nfunction, part of the car package, can be used to compute variance inflation\nfactors.", "doc_id": "c09b1d2f-7f14-4521-b3ad-e7471ad0dd36", "embedding": null, "doc_hash": "42517fd9d89714b2a123a00418e658a7a04766bbec2a29618ad9cbd6e6f7c711", "extra_info": null, "node_info": {"start": 279909, "end": 282447, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "3fb0ddf7-6a63-4976-99d5-81d9621597c1", "3": "6d9e6084-2972-4740-947d-5b36fe422083"}}, "__type__": "1"}, "6d9e6084-2972-4740-947d-5b36fe422083": {"__data__": {"text": "part of the car package, can be used to compute variance inflation\nfactors. Most VIF\u2019s are low to moderate for this data. The car package is\nnot part of the base R installation so it must be downloaded the first time\nyou use it via the install.packages() function in R.\n> library(car)\n> vif(lm.fit)\ncrim zn indus chas nox rm age dis\n1.77 2.30 3.99 1.07 4.37 1.91 3.09 3.95\nrad tax ptratio lstat\n7.45 9.00 1.80 2.87\n116 3. Linear Regression\nWhat if we would like to perform a regression using all of the variables but\none? For example, in the above regression output, age has a high p-value.\nSo we may wish to run a regression excluding this predictor. The following\nsyntax results in a regression using all predictors except age.\n> lm.fit1 <- lm(medv \u223c . - age, data = Boston)\n> summary(lm.fit1)\n...\nAlternatively, the update() function can be used.\nupdate()\n> lm.fit1 <- update(lm.fit , \u223c . - age)\n3.6.4 Interaction Terms\nIt is easy to include interaction terms in a linear model using the lm()\nfunction. The syntax lstat:black tells R to include an interaction term between\nlstat and black. The syntax lstat * age simultaneously includes\nlstat, age, and the interaction term lstat\u00d7age as predictors; it is a shorthand\nfor lstat + age + lstat:age.\n> summary(lm(medv \u223c lstat * age , data = Boston))\nCall:\nlm(formula = medv \u223c lstat * age , data = Boston)\nResiduals:\nMin 1Q Median 3Q Max\n-15.81 -4.04 -1.33 2.08 27.55\nCoefficients:\nEstimate Std. Error t value Pr(>|t|)\n(Intercept) 36.088536 1.469835 24.55 < 2e-16 ***\nlstat -1.392117 0.167456 -8.31 8.8e-16 ***\nage -0.000721 0.019879 -0.04 0.971\nlstat:age 0.004156 0.001852 2.24 0.025 *\n---\nSignif. codes: 0 *** 0.001 ** 0.01 * 0.05 . 0.1 1\nResidual standard error: 6.15 on 502 degrees of freedom\nMultiple R-squared: 0.556 , Adjusted R-squared: 0.553\nF-statistic: 209 on 3 and 502 DF, p-value: < 2e-16\n3.6.5 Non-linear Transformations of the Predictors\nThe lm() function can also accommodate non-linear transformations of the\npredictors. For instance, given a predictor X, we can create a predictor X2\nusing I(X^2). The function I() is needed since the ^ has a special meaning\nI()\nin a formula object; wrapping as we do allows the standard usage in R,\nwhich is to raise X to the power 2. We now perform a regression of medv\nonto lstat and lstat2.\n3.6 Lab: Linear Regression 117\n> lm.fit2 <- lm(medv \u223c lstat + I(lstat^2))\n> summary(lm.fit2)\nCall:\nlm(formula = medv \u223c lstat + I(lstat ^2))\nResiduals:\nMin 1Q Median 3Q Max\n-15.28 -3.83 -0.53 2.31 25.41\nCoefficients:\nEstimate Std. Error t value Pr(>|t|)\n(Intercept) 42.86201 0.87208 49.1 <2e-16 ***\nlstat -2.33282 0.12380 -18.8 <2e-16 ***\nI(lstat ^2) 0.04355 0.00375 11.6 <2e-16 ***\n---\nSignif. codes: 0 *** 0.001 ** 0.01 * 0.05", "doc_id": "6d9e6084-2972-4740-947d-5b36fe422083", "embedding": null, "doc_hash": "0825472c6b57270f839f86d4574069bc112cd3e8f8c3406ecb0913672066a131", "extra_info": null, "node_info": {"start": 282421, "end": 285143, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "c09b1d2f-7f14-4521-b3ad-e7471ad0dd36", "3": "abfb034e-651b-45f4-8fab-7267be82bcf1"}}, "__type__": "1"}, "abfb034e-651b-45f4-8fab-7267be82bcf1": {"__data__": {"text": "codes: 0 *** 0.001 ** 0.01 * 0.05 . 0.1 1\nResidual standard error: 5.52 on 503 degrees of freedom\nMultiple R-squared: 0.641 , Adjusted R-squared: 0.639\nF-statistic: 449 on 2 and 503 DF, p-value: < 2e-16\nThe near-zero p-value associated with the quadratic term suggests that\nit leads to an improved model. We use the anova() function to further\nanova()\nquantify the extent to which the quadratic fit is superior to the linear fit.\n> lm.fit <- lm(medv \u223c lstat)\n> anova(lm.fit , lm.fit2)\nAnalysis of Variance Table\nModel 1: medv \u223c lstat\nModel 2: medv \u223c lstat + I(lstat ^2)\nRes.Df RSS Df Sum of Sq F Pr(>F)\n1 504 19472\n2 503 15347 1 4125135 <2e-16***\n---\nSignif. codes: 0 *** 0.001 ** 0.01 * 0.05 . 0.1 1\nHere Model 1 represents the linear submodel containing only one predictor,\nlstat, while Model 2 corresponds to the larger quadratic model that has two\npredictors, lstat and lstat2. The anova() function performs a hypothesis\ntest comparing the two models. The null hypothesis is that the two models\nfit the data equally well, and the alternative hypothesis is that the full\nmodel is superior. Here the F-statistic is 135 and the associated p-value is\nvirtually zero. This provides very clear evidence that the model containing\nthe predictors lstat and lstat2 is far superior to the model that only\ncontains the predictor lstat. This is not surprising, since earlier we saw\nevidence for non-linearity in the relationship between medv and lstat. If we\ntype\n> par(mfrow = c(2, 2))\n> plot(lm.fit2)\n118 3. Linear Regression\nthen we see that when the lstat2 term is included in the model, there is\nlittle discernible pattern in the residuals.\nIn order to create a cubic fit, we can include a predictor of the form\nI(X^3). However, this approach can start to get cumbersome for higherorder\npolynomials. A better approach involves using the poly() function\npoly()\nto create the polynomial within lm(). For example, the following command\nproduces a fifth-order polynomial fit:\n> lm.fit5 <- lm(medv \u223c poly(lstat , 5))\n> summary(lm.fit5)\nCall:\nlm(formula = medv \u223c poly(lstat , 5))\nResiduals:\nMin 1Q Median 3Q Max\n-13.543 -3.104 -0.705 2.084 27.115\nCoefficients:\nEstimate Std. Error t value Pr(>|t|)\n(Intercept) 22.533 0.232 97.20 < 2e-16 ***\npoly(lstat , 5)1 -152.460 5.215 -29.24 < 2e-16 ***\npoly(lstat , 5)2 64.227 5.215 12.32 < 2e-16 ***\npoly(lstat , 5)3 -27.051 5.215 -5.19 3.1e-07 ***\npoly(lstat , 5)4 25.452 5.215 4.88 1.4e-06 ***\npoly(lstat , 5)5 -19.252 5.215 -3.69 0.00025 ***\n---\nSignif. codes: 0 *** 0.001 ** 0.01 * 0.05 . 0.1 1\nResidual standard error: 5.21 on 500 degrees of freedom\nMultiple R-squared: 0.682 , Adjusted R-squared: 0.679\nF-statistic: 214 on 5 and 500 DF, p-value: < 2e-16\nThis suggests that including additional polynomial terms, up to fifth order,\nleads to an improvement in the model fit! However, further investigation of\nthe data reveals that no polynomial terms beyond fifth order have", "doc_id": "abfb034e-651b-45f4-8fab-7267be82bcf1", "embedding": null, "doc_hash": "36dae84836347ebb8a91abc260ff064a27603f9f4e867dd0f0423d6baf5ce8e6", "extra_info": null, "node_info": {"start": 285182, "end": 288090, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "6d9e6084-2972-4740-947d-5b36fe422083", "3": "1174e43b-3329-46cb-8d85-7b9dfc209417"}}, "__type__": "1"}, "1174e43b-3329-46cb-8d85-7b9dfc209417": {"__data__": {"text": "investigation of\nthe data reveals that no polynomial terms beyond fifth order have significant\np-values in a regression fit.\nBy default, the poly() function orthogonalizes the predictors: this means\nthat the features output by this function are not simply a sequence of\npowers of the argument. However, a linear model applied to the output\nof the poly() function will have the same fitted values as a linear model\napplied to the raw polynomials (although the coefficient estimates, standard\nerrors, and p-values will differ). In order to obtain the raw polynomials from\nthe poly() function, the argument raw = TRUE must be used.\nOf course, we are in no way restricted to using polynomial transformations\nof the predictors. Here we try a log transformation.\n> summary(lm(medv \u223c log(rm), data = Boston))\n...\n3.6 Lab: Linear Regression 119\n3.6.6 Qualitative Predictors\nWe will now examine the Carseats data, which is part of the ISLR2 library.\nWe will attempt to predict Sales (child car seat sales) in 400 locations\nbased on a number of predictors.\n> head(Carseats)\nSales CompPrice Income Advertising Population Price\n1 9.50 138 73 11 276 120\n2 11.22 111 48 16 260 83\n3 10.06 113 35 10 269 80\n4 7.40 117 100 4 466 97\n5 4.15 141 64 3 340 128\n6 10.81 124 113 13 501 72\nShelveLoc Age Education Urban US\n1 Bad 42 17 Yes Yes\n2 Good 65 10 Yes Yes\n3 Medium 59 12 YesYes\n4 Medium 55 14 YesYes\n5 Bad 38 13 Yes No\n6 Bad 78 16 No Yes\nThe Carseats data includes qualitative predictors such as Shelveloc, an indicator\nof the quality of the shelving location\u2014that is, the space within\na store in which the car seat is displayed\u2014at each location. The predictor\nShelveloc takes on three possible values: Bad, Medium, and Good.\nGiven a qualitative variable such as Shelveloc, R generates dummy variables\nautomatically. Below we fit a multiple regression model that includes some\ninteraction terms.\n> lm.fit <- lm(Sales \u223c . + Income:Advertising + Price:Age,\ndata = Carseats)\n> summary(lm.fit)\nCall:\nlm(formula = Sales \u223c . + Income:Advertising + Price:Age, data =\nCarseats)\nResiduals:\nMin 1Q Median 3Q Max\n-2.921 -0.750 0.018 0.675 3.341\nCoefficients:\nEstimate Std. Error t value Pr(>|t|)\n(Intercept) 6.575565 1.008747 6.52 2.2e-10 ***\nCompPrice 0.092937 0.004118 22.57 < 2e-16 ***\nIncome 0.010894 0.002604 4.18 3.6e-05 ***\nAdvertising 0.070246 0.022609 3.11 0.00203 **\nPopulation 0.000159 0.000368 0.43 0.66533\nPrice -0.100806 0.007440 -13.55 < 2e-16 ***\nShelveLocGood 4.848676 0.152838 31.72 < 2e-16 ***\nShelveLocMedium 1.953262 0.125768 15.53 < 2e-16 ***\nAge -0.057947 0.015951 -3.63 0.00032 ***\n120 3. Linear Regression\nEducation -0.020852 0.019613 -1.06 0.28836\nUrbanYes 0.140160 0.112402 1.25 0.21317\nUSYes -0.157557 0.148923 -1.06 0.29073\nIncome:Advertising 0.000751 0.000278 2.70 0.00729 **\nPrice:Age 0.000107 0.000133 0.80 0.42381\n---\nSignif. codes: 0 *** 0.001 ** 0.01 * 0.05 . 0.1 1\nResidual standard error: 1.01 on 386 degrees of freedom\nMultiple R-squared: 0.876 , Adjusted", "doc_id": "1174e43b-3329-46cb-8d85-7b9dfc209417", "embedding": null, "doc_hash": "8d37a00820aadd2ac508c4e4f28e3c6c67d1e13ef1e13541378ff184c4387da9", "extra_info": null, "node_info": {"start": 288046, "end": 291011, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "abfb034e-651b-45f4-8fab-7267be82bcf1", "3": "5f4d4dd8-3f82-49d4-a9d4-4245e9aef5fa"}}, "__type__": "1"}, "5f4d4dd8-3f82-49d4-a9d4-4245e9aef5fa": {"__data__": {"text": "on 386 degrees of freedom\nMultiple R-squared: 0.876 , Adjusted R-squared: 0.872\nF-statistic: 210 on 13 and 386 DF, p-value: < 2e-16\nThe contrasts() function returns the coding that R uses for the dummy\ncontrasts()\nvariables.\n> attach(Carseats)\n> contrasts(ShelveLoc)\nGood Medium\nBad 0 0\nGood 1 0\nMedium 0 1\nUse ?contrasts to learn about other contrasts, and how to set them.\nR has created a ShelveLocGood dummy variable that takes on a value of\n1 if the shelving location is good, and 0 otherwise. It has also created a\nShelveLocMedium dummy variable that equals 1 if the shelving location is\nmedium, and 0 otherwise. A bad shelving location corresponds to a zero\nfor each of the two dummy variables. The fact that the coefficient for\nShelveLocGood in the regression output is positive indicates that a good\nshelving location is associated with high sales (relative to a bad location).\nAnd ShelveLocMedium has a smaller positive coefficient, indicating that a\nmedium shelving location is associated with higher sales than a bad shelving\nlocation but lower sales than a good shelving location.\n3.6.7 Writing Functions\nAs we have seen, R comes with many useful functions, and still more functions\nare available by way of R libraries. However, we will often be interested\nin performing an operation for which no function is available. In this\nsetting, we may want to write our own function. For instance, below we\nprovide a simple function that reads in the ISLR2 and MASS libraries, called\nLoadLibraries(). Before we have created the function, R returns an error if\nwe try to call it.\n> LoadLibraries\nError: object \u2018LoadLibraries \u2019 not found\n> LoadLibraries()\nError: could not find function \"LoadLibraries\"\nWe now create the function. Note that the + symbols are printed by R and\nshould not be typed in. The { symbol informs R that multiple commands\n3.7 Exercises 121\nare about to be input. Hitting Enter after typing { will cause R to print the\n+ symbol. We can then input as many commands as we wish, hitting Enter\nafter each one. Finally the } symbol informs R that no further commands\nwill be entered.\n> LoadLibraries <- function () {\n+ library(ISLR2)\n+ library(MASS)\n+ print(\"The libraries have been loaded.\")\n+ }\nNow if we type in LoadLibraries, R will tell us what is in the function.\n> LoadLibraries\nfunction () {\nlibrary(ISLR2)\nlibrary(MASS)\nprint (\"The libraries have been loaded .\")\n}\nIf we call the function, the libraries are loaded in and the print statement\nis output.\n> LoadLibraries ()\n[1] \"The libraries have been loaded .\"\n3.7 Exercises\nConceptual\n1. Describe the null hypotheses to which the p-values given in Table 3.4\ncorrespond. Explain what conclusions you can draw based on these\np-values. Your explanation should be phrased in terms of sales, TV,\nradio, and newspaper, rather than in terms of the coefficients of the\nlinear model.\n2. Carefully explain the differences between the KNN classifier and KNN\nregression methods.\n3. Suppose we have a data set with five predictors, X1 = GPA, X2 =\nIQ, X3 = Level (1 for College and 0 for High School), X4 = Interaction\nbetween GPA and IQ, and X5 = Interaction between GPA and\nLevel. The response is starting salary after graduation (in thousands\nof dollars). Suppose we use least squares to fit the model, and get\n\u02c6 \u03b20 = 50, \u02c6 \u03b21 = 20, \u02c6 \u03b22 = 0.07, \u02c6 \u03b23 = 35, \u02c6 \u03b24 = 0.01, \u02c6 \u03b25 = \u221210.\n(a) Which answer is correct, and why?\ni. For a fixed value of IQ and GPA, high school graduates earn\nmore, on average, than", "doc_id": "5f4d4dd8-3f82-49d4-a9d4-4245e9aef5fa", "embedding": null, "doc_hash": "e3904bd7492d23d3a7c95c031becca2cb4238a88599149a079df6bd832da55c7", "extra_info": null, "node_info": {"start": 291029, "end": 294503, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "1174e43b-3329-46cb-8d85-7b9dfc209417", "3": "12336e89-94f4-4180-a1ae-086828f185a4"}}, "__type__": "1"}, "12336e89-94f4-4180-a1ae-086828f185a4": {"__data__": {"text": "value of IQ and GPA, high school graduates earn\nmore, on average, than college graduates.\n122 3. Linear Regression\nii. For a fixed value of IQ and GPA, college graduates earn\nmore, on average, than high school graduates.\niii. For a fixed value of IQ and GPA, high school graduates earn\nmore, on average, than college graduates provided that the\nGPA is high enough.\niv. For a fixed value of IQ and GPA, college graduates earn\nmore, on average, than high school graduates provided that\nthe GPA is high enough.\n(b) Predict the salary of a college graduate with IQ of 110 and a\nGPA of 4.0.\n(c) True or false: Since the coefficient for the GPA/IQ interaction\nterm is very small, there is very little evidence of an interaction\neffect. Justify your answer.\n4. I collect a set of data (n = 100 observations) containing a single\npredictor and a quantitative response. I then fit a linear regression\nmodel to the data, as well as a separate cubic regression, i.e. Y =\n\u03b20 + \u03b21X + \u03b22X2 + \u03b23X3 + \u03f5.\n(a) Suppose that the true relationship between X and Y is linear,\ni.e. Y = \u03b20 + \u03b21X + \u03f5. Consider the training residual sum of\nsquares (RSS) for the linear regression, and also the training\nRSS for the cubic regression. Would we expect one to be lower\nthan the other, would we expect them to be the same, or is there\nnot enough information to tell? Justify your answer.\n(b) Answer (a) using test rather than training RSS.\n(c) Suppose that the true relationship between X and Y is not linear,\nbut we don\u2019t know how far it is from linear. Consider the training\nRSS for the linear regression, and also the training RSS for the\ncubic regression. Would we expect one to be lower than the\nother, would we expect them to be the same, or is there not\nenough information to tell? Justify your answer.\n(d) Answer (c) using test rather than training RSS.\n5. Consider the fitted values that result from performing linear regression\nwithout an intercept. In this setting, the ith fitted value takes\nthe form\n\u02c6yi = xi \u02c6\u03b2,\nwhere\n\u02c6 \u03b2 =\n>\n0n\ni=1\nxiyi\n?\n/\n>\n0n\ni\u2032=1\nx2i\n\u2032\n?\n. (3.38)\n3.7 Exercises 123\nShow that we can write\n\u02c6yi =\n0n\ni\u2032=1\nai\u2032yi\u2032 .\nWhat is ai\u2032?\nNote: We interpret this result by saying that the fitted values from\nlinear regression are linear combinations of the response values.\n6. Using (3.4), argue that in the case of simple linear regression, the\nleast squares line always passes through the point (\u00afx, \u00afy).\n7. It is claimed in the text that in the case of simple linear regression\nof Y onto X, the R2 statistic (3.17) is equal to the square of the\ncorrelation between X and Y (3.18). Prove that this is the case. For\nsimplicity, you may assume that \u00afx = \u00afy = 0.\nApplied\n8. This question involves the use of simple linear regression on the Auto\ndata set.\n(a) Use the lm() function to perform a simple linear regression with\nmpg as the response and horsepower as the predictor. Use the\nsummary() function to print the results. Comment on the output.\nFor example:\ni. Is there a relationship between the predictor and the response?\nii. How strong is the relationship between the predictor and\nthe response?\niii. Is the relationship between the predictor and the response\npositive or negative?\niv. What is the predicted mpg associated with a horsepower of\n98? What are the associated 95% confidence and prediction\nintervals?\n(b) Plot the response and the predictor. Use the abline() function\nto display the least squares regression line.\n(c) Use the plot() function to produce diagnostic", "doc_id": "12336e89-94f4-4180-a1ae-086828f185a4", "embedding": null, "doc_hash": "8408a0699c9c6f0ad366f77c411cb1528c7705994b775bfd1f36b7063b68e652", "extra_info": null, "node_info": {"start": 294499, "end": 297971, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "5f4d4dd8-3f82-49d4-a9d4-4245e9aef5fa", "3": "f39f1ba9-af4f-4f73-b490-69afe35ef99f"}}, "__type__": "1"}, "f39f1ba9-af4f-4f73-b490-69afe35ef99f": {"__data__": {"text": "squares regression line.\n(c) Use the plot() function to produce diagnostic plots of the least\nsquares regression fit. Comment on any problems you see with\nthe fit.\n9. This question involves the use of multiple linear regression on the\nAuto data set.\n124 3. Linear Regression\n(a) Produce a scatterplot matrix which includes all of the variables\nin the data set.\n(b) Compute the matrix of correlations between the variables using\nthe function cor(). You will need to exclude the name variable,\ncor()\nwhich is qualitative.\n(c) Use the lm() function to perform a multiple linear regression\nwith mpg as the response and all other variables except name as\nthe predictors. Use the summary() function to print the results.\nComment on the output. For instance:\ni. Is there a relationship between the predictors and the response?\nii. Which predictors appear to have a statistically significant\nrelationship to the response?\niii. What does the coefficient for the year variable suggest?\n(d) Use the plot() function to produce diagnostic plots of the linear\nregression fit. Comment on any problems you see with the fit.\nDo the residual plots suggest any unusually large outliers? Does\nthe leverage plot identify any observations with unusually high\nleverage?\n(e) Use the * and : symbols to fit linear regression models with\ninteraction effects. Do any interactions appear to be statistically\nsignificant?\n(f) Try a few different transformations of the variables, such as\nlog(X), \u221aX, X2. Comment on your findings.\n10. This question should be answered using the Carseats data set.\n(a) Fit a multiple regression model to predict Sales using Price,\nUrban, and US.\n(b) Provide an interpretation of each coefficient in the model. Be\ncareful\u2014some of the variables in the model are qualitative!\n(c) Write out the model in equation form, being careful to handle\nthe qualitative variables properly.\n(d) For which of the predictors can you reject the null hypothesis\nH0 : \u03b2j = 0?\n(e) On the basis of your response to the previous question, fit a\nsmaller model that only uses the predictors for which there is\nevidence of association with the outcome.\n(f) How well do the models in (a) and (e) fit the data?\n(g) Using the model from (e), obtain 95% confidence intervals for\nthe coefficient(s).\n3.7 Exercises 125\n(h) Is there evidence of outliers or high leverage observations in the\nmodel from (e)?\n11. In this problem we will investigate the t-statistic for the null hypothesis\nH0 : \u03b2 = 0 in simple linear regression without an intercept. To\nbegin, we generate a predictor x and a response y as follows.\n> set.seed (1)\n> x <- rnorm (100)\n> y <- 2 * x + rnorm (100)\n(a) Perform a simple linear regression of y onto x, without an intercept.\nReport the coefficient estimate \u02c6 \u03b2, the standard error of\nthis coefficient estimate, and the t-statistic and p-value associated\nwith the null hypothesis H0 : \u03b2 = 0. Comment on these\nresults. (You can perform regression without an intercept using\nthe command lm(y\u223cx+0).)\n(b) Now perform a simple linear regression of x onto y without an\nintercept, and report the coefficient estimate, its standard error,\nand the corresponding t-statistic and p-values associated with\nthe null hypothesis H0 : \u03b2 = 0. Comment on these results.\n(c) What is the relationship between the results obtained in (a) and\n(b)?\n(d) For the regression of Y onto X without an intercept, the tstatistic\nfor H0 : \u03b2 = 0 takes the form \u02c6\u03b2/SE( \u02c6 \u03b2), where \u02c6 \u03b2 is\ngiven by (3.38), and where\nSE( \u02c6 \u03b2) =\n@)n\ni=1(yi \u2212 xi \u02c6 \u03b2)2\n(n \u2212", "doc_id": "f39f1ba9-af4f-4f73-b490-69afe35ef99f", "embedding": null, "doc_hash": "a07fae2f59a2f4fe550b872019b8caa21556093070dbfe91960c89f783d7c64d", "extra_info": null, "node_info": {"start": 297966, "end": 301474, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "12336e89-94f4-4180-a1ae-086828f185a4", "3": "3b525e1d-3416-4264-9c02-a335d7b49007"}}, "__type__": "1"}, "3b525e1d-3416-4264-9c02-a335d7b49007": {"__data__": {"text": "\u2212 xi \u02c6 \u03b2)2\n(n \u2212 1)\n)n\ni\u2032=1 x2i\n\u2032\n.\n(These formulas are slightly different from those given in Sections\n3.1.1 and 3.1.2, since here we are performing regression\nwithout an intercept.) Show algebraically, and confirm numerically\nin R, that the t-statistic can be written as\n(\u221an \u2212 1)\n)n\n5 i=1 xiyi\n(\n)n\ni=1 x2i\n)(\n)n\ni\u2032=1 y2\ni\u2032 ) \u2212 (\n)n\ni\u2032=1 xi\u2032yi\u2032 )2\n.\n(e) Using the results from (d), argue that the t-statistic for the regression\nof y onto x is the same as the t-statistic for the regression\nof x onto y.\n(f) In R, show that when regression is performed with an intercept,\nthe t-statistic for H0 : \u03b21 = 0 is the same for the regression of y\nonto x as it is for the regression of x onto y.\n126 3. Linear Regression\n12. This problem involves simple linear regression without an intercept.\n(a) Recall that the coefficient estimate \u02c6 \u03b2 for the linear regression of\nY onto X without an intercept is given by (3.38). Under what\ncircumstance is the coefficient estimate for the regression of X\nonto Y the same as the coefficient estimate for the regression of\nY onto X?\n(b) Generate an example in R with n = 100 observations in which\nthe coefficient estimate for the regression of X onto Y is different\nfrom the coefficient estimate for the regression of Y onto X.\n(c) Generate an example in R with n = 100 observations in which\nthe coefficient estimate for the regression of X onto Y is the\nsame as the coefficient estimate for the regression of Y onto X.\n13. In this exercise you will create some simulated data and will fit simple\nlinear regression models to it. Make sure to use set.seed(1) prior to\nstarting part (a) to ensure consistent results.\n(a) Using the rnorm() function, create a vector, x, containing 100\nobservations drawn from a N(0, 1) distribution. This represents\na feature, X.\n(b) Using the rnorm() function, create a vector, eps, containing 100\nobservations drawn from a N(0, 0.25) distribution\u2014a normal\ndistribution with mean zero and variance 0.25.\n(c) Using x and eps, generate a vector y according to the model\nY = \u22121 + 0.5X + \u03f5. (3.39)\nWhat is the length of the vector y? What are the values of \u03b20\nand \u03b21 in this linear model?\n(d) Create a scatterplot displaying the relationship between x and\ny. Comment on what you observe.\n(e) Fit a least squares linear model to predict y using x. Comment\non the model obtained. How do \u02c6 \u03b20 and \u02c6 \u03b21 compare to \u03b20 and\n\u03b21?\n(f) Display the least squares line on the scatterplot obtained in (d).\nDraw the population regression line on the plot, in a different\ncolor. Use the legend() command to create an appropriate legend.\n(g) Now fit a polynomial regression model that predicts y using x\nand x2. Is there evidence that the quadratic term improves the\nmodel fit? Explain your answer.\n3.7 Exercises 127\n(h) Repeat (a)\u2013(f) after modifying the data generation process in\nsuch a way that there is less noise in the data. The model (3.39)\nshould remain the same. You can do this by decreasing the variance\nof the normal distribution used to generate the error term\n\u03f5 in (b). Describe your results.\n(i) Repeat (a)\u2013(f) after modifying the data generation process in\nsuch a way that there is more noise in the data. The model\n(3.39) should remain the same. You can do this by increasing\nthe variance of the normal distribution used to generate the\nerror term \u03f5 in (b). Describe", "doc_id": "3b525e1d-3416-4264-9c02-a335d7b49007", "embedding": null, "doc_hash": "b446288eace6947449f63ae0e873aaa89c2917dd1b34c69e6183713fe59f0381", "extra_info": null, "node_info": {"start": 301529, "end": 304852, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "f39f1ba9-af4f-4f73-b490-69afe35ef99f", "3": "45aedabb-c4b2-4ef7-8b0a-c10f987a43d1"}}, "__type__": "1"}, "45aedabb-c4b2-4ef7-8b0a-c10f987a43d1": {"__data__": {"text": "the normal distribution used to generate the\nerror term \u03f5 in (b). Describe your results.\n(j) What are the confidence intervals for \u03b20 and \u03b21 based on the\noriginal data set, the noisier data set, and the less noisy data\nset? Comment on your results.\n14. This problem focuses on the collinearity problem.\n(a) Perform the following commands in R:\n> set.seed (1)\n> x1 <- runif (100)\n> x2 <- 0.5 * x1 + rnorm (100) / 10\n> y <- 2 + 2 * x1 + 0.3 * x2 + rnorm (100)\nThe last line corresponds to creating a linear model in which y is\na function of x1 and x2. Write out the form of the linear model.\nWhat are the regression coefficients?\n(b) What is the correlation between x1 and x2? Create a scatterplot\ndisplaying the relationship between the variables.\n(c) Using this data, fit a least squares regression to predict y using\nx1 and x2. Describe the results obtained. What are \u02c6 \u03b20, \u02c6 \u03b21, and\n\u02c6 \u03b22? How do these relate to the true \u03b20, \u03b21, and \u03b22? Can you\nreject the null hypothesis H0 : \u03b21 = 0? How about the null\nhypothesis H0 : \u03b22 = 0?\n(d) Now fit a least squares regression to predict y using only x1.\nComment on your results. Can you reject the null hypothesis\nH0 : \u03b21 = 0?\n(e) Now fit a least squares regression to predict y using only x2.\nComment on your results. Can you reject the null hypothesis\nH0 : \u03b21 = 0?\n(f) Do the results obtained in (c)\u2013(e) contradict each other? Explain\nyour answer.\n(g) Now suppose we obtain one additional observation, which was\nunfortunately mismeasured.\n128 3. Linear Regression\n> x1 <- c(x1 , 0.1)\n> x2 <- c(x2 , 0.8)\n> y <- c(y, 6)\nRe-fit the linear models from (c) to (e) using this new data. What\neffect does this new observation have on the each of the models?\nIn each model, is this observation an outlier? A high-leverage\npoint? Both? Explain your answers.\n15. This problem involves the Boston data set, which we saw in the lab\nfor this chapter. We will now try to predict per capita crime rate\nusing the other variables in this data set. In other words, per capita\ncrime rate is the response, and the other variables are the predictors.\n(a) For each predictor, fit a simple linear regression model to predict\nthe response. Describe your results. In which of the models is\nthere a statistically significant association between the predictor\nand the response? Create some plots to back up your assertions.\n(b) Fit a multiple regression model to predict the response using\nall of the predictors. Describe your results. For which predictors\ncan we reject the null hypothesis H0 : \u03b2j = 0?\n(c) How do your results from (a) compare to your results from (b)?\nCreate a plot displaying the univariate regression coefficients\nfrom (a) on the x-axis, and the multiple regression coefficients\nfrom (b) on the y-axis. That is, each predictor is displayed as a\nsingle point in the plot. Its coefficient in a simple linear regression\nmodel is shown on the x-axis, and its coefficient estimate\nin the multiple linear regression model is shown on the y-axis.\n(d) Is there evidence of non-linear association between any of the\npredictors and the response? To answer this question, for each\npredictor X, fit a model of the form\nY = \u03b20 + \u03b21X + \u03b22X2 + \u03b23X3 + \u03f5.\n4\nClassification\nThe linear regression model discussed in Chapter 3 assumes that the response\nvariable Y is quantitative. But in many situations, the response\nvariable", "doc_id": "45aedabb-c4b2-4ef7-8b0a-c10f987a43d1", "embedding": null, "doc_hash": "7e950a1ee51a6b8f88d8137fd6368d599c76fc11ad6044d480901b7a4c5c8194", "extra_info": null, "node_info": {"start": 304801, "end": 308146, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "3b525e1d-3416-4264-9c02-a335d7b49007", "3": "abb5ea2a-4e8c-4dd1-bc2f-4eaccf5ffec5"}}, "__type__": "1"}, "abb5ea2a-4e8c-4dd1-bc2f-4eaccf5ffec5": {"__data__": {"text": "that the response\nvariable Y is quantitative. But in many situations, the response\nvariable is instead qualitative. For example, eye color is qualitative. Ofqualitative\nten qualitative variables are referred to as categorical ; we will use these\nterms interchangeably. In this chapter, we study approaches for predicting\nqualitative responses, a process that is known as classification. Predicting\nclassification\na qualitative response for an observation can be referred to as classifying\nthat observation, since it involves assigning the observation to a category,\nor class. On the other hand, often the methods used for classification first\npredict the probability that the observation belongs to each of the categories\nof a qualitative variable, as the basis for making the classification.\nIn this sense they also behave like regression methods.\nThere are many possible classification techniques, or classifiers, that one\nclassifier\nmight use to predict a qualitative response. We touched on some of these\nin Sections 2.1.5 and 2.2.3. In this chapter we discuss some widely-used\nclassifiers: logistic regression, linear discriminant analysis, quadratic dislogistic\nregression\nlinear\ndiscriminant\nanalysis\ncriminant analysis, naive Bayes, and K-nearest neighbors. The discussion\nquadratic\ndiscriminant\nanalysis\nnaive Bayes\nK-nearest\nneighbors\nof logistic regression is used as a jumping-off point for a discussion of generalized\nlinear models, and in particular, Poisson regression. We discuss\ngeneralized\nlinear\nmodels\nPoisson\nregression\nmore computer-intensive classification methods in later chapters: these include\ngeneralized additive models (Chapter 7); trees, random forests, and\nboosting (Chapter 8); and support vector machines (Chapter 9).\n\u00a9 Springer Science+Business Media, LLC, part of Springer Nature 2021\nG. James et al., An Introduction to Statistical Learning, Springer Texts in Statistics,\nhttps://doi.org/10.1007/978-1-0716-1418-1_4\n129\n130 4. Classification\n4.1 An Overview of Classification\nClassification problems occur often, perhaps even more so than regression\nproblems. Some examples include:\n1. A person arrives at the emergency room with a set of symptoms\nthat could possibly be attributed to one of three medical conditions.\nWhich of the three conditions does the individual have?\n2. An online banking service must be able to determine whether or not\na transaction being performed on the site is fraudulent, on the basis\nof the user\u2019s IP address, past transaction history, and so forth.\n3. On the basis of DNA sequence data for a number of patients with\nand without a given disease, a biologist would like to figure out which\nDNA mutations are deleterious (disease-causing) and which are not.\nJust as in the regression setting, in the classification setting we have a\nset of training observations (x1, y1), . . . , (xn, yn) that we can use to build\na classifier. We want our classifier to perform well not only on the training\ndata, but also on test observations that were not used to train the classifier.\nIn this chapter, we will illustrate the concept of classification using the\nsimulated Default data set. We are interested in predicting whether an\nindividual will default on his or her credit card payment, on the basis of\nannual income and monthly credit card balance. The data set is displayed\nin Figure 4.1. In the left-hand panel of Figure 4.1, we have plotted annual\nincome and monthly credit card balance for a subset of 10, 000 individuals.\nThe individuals who defaulted in a given month are shown in orange, and\nthose who did not in blue. (The overall default rate is about 3 %, so we\nhave plotted only a fraction of the individuals who did not default.) It\nappears that individuals who defaulted tended to have higher credit card\nbalances than those who did not. In the center and right-hand panels of\nFigure 4.1, two pairs of boxplots are shown. The first shows the", "doc_id": "abb5ea2a-4e8c-4dd1-bc2f-4eaccf5ffec5", "embedding": null, "doc_hash": "1874f1550abc2bf87a735b7a67b9932b10f710b9118b4d484a0aa3335dfdaa32", "extra_info": null, "node_info": {"start": 308130, "end": 312041, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "45aedabb-c4b2-4ef7-8b0a-c10f987a43d1", "3": "70573e35-163a-4d4f-8f1c-5d088cb7fa3b"}}, "__type__": "1"}, "70573e35-163a-4d4f-8f1c-5d088cb7fa3b": {"__data__": {"text": "4.1, two pairs of boxplots are shown. The first shows the distribution\nof balance split by the binary default variable; the second is a similar plot\nfor income. In this chapter, we learn how to build a model to predict default\n(Y ) for any given value of balance (X1) and income (X2). Since Y is not\nquantitative, the simple linear regression model of Chapter 3 is not a good\nchoice: we will elaborate on this further in Section 4.2.\nIt is worth noting that Figure 4.1 displays a very pronounced relationship\nbetween the predictor balance and the response default. In most real\napplications, the relationship between the predictor and the response will\nnot be nearly so strong. However, for the sake of illustrating the classification\nprocedures discussed in this chapter, we use an example in which the\nrelationship between the predictor and the response is somewhat exaggerated.\n4.2 Why Not Linear Regression? 131\n0 500 1000 1500 2000 2500\n0 20000 40000 60000\nBalance\nIncome\nNo Yes\n0 500 1000 1500 2000 2500\nDefault\nBalance\nNo Yes\n0 20000 40000 60000\nDefault\nIncome\nFIGURE 4.1. The Default data set. Left: The annual incomes and monthly\ncredit card balances of a number of individuals. The individuals who defaulted on\ntheir credit card payments are shown in orange, and those who did not are shown\nin blue. Center: Boxplots of balance as a function of default status. Right:\nBoxplots of income as a function of default status.\n4.2 Why Not Linear Regression?\nWe have stated that linear regression is not appropriate in the case of a\nqualitative response. Why not?\nSuppose that we are trying to predict the medical condition of a patient\nin the emergency room on the basis of her symptoms. In this simplified\nexample, there are three possible diagnoses: stroke, drug overdose, and\nepileptic seizure. We could consider encoding these values as a quantitative\nresponse variable, Y , as follows:\nY =\n\u23a7\u23aa\u23a8\n\u23aa\u23a9\n1 if stroke;\n2 if drug overdose;\n3 if epileptic seizure.\nUsing this coding, least squares could be used to fit a linear regression model\nto predict Y on the basis of a set of predictors X1, . . . ,Xp. Unfortunately,\nthis coding implies an ordering on the outcomes, putting drug overdose in\nbetween stroke and epileptic seizure, and insisting that the difference\nbetween stroke and drug overdose is the same as the difference between\ndrug overdose and epileptic seizure. In practice there is no particular\nreason that this needs to be the case. For instance, one could choose an\n132 4. Classification\nequally reasonable coding,\nY =\n\u23a7\u23aa\u23a8\n\u23aa\u23a9\n1 if epileptic seizure;\n2 if stroke;\n3 if drug overdose.\nwhich would imply a totally different relationship among the three conditions.\nEach of these codings would produce fundamentally different linear\nmodels that would ultimately lead to different sets of predictions on test\nobservations.\nIf the response variable\u2019s values did take on a natural ordering, such as\nmild, moderate, and severe, and we felt the gap between mild and moderate\nwas similar to the gap between moderate and severe, then a 1, 2, 3 coding\nwould be reasonable. Unfortunately, in general there is no natural way to\nconvert a qualitative response variable with more than two levels into a\nquantitative response that is ready for linear regression.\nFor a binary (two level) qualitative response, the situation is better. For\nbinary\ninstance, perhaps there are only two possibilities for the patient\u2019s medical\ncondition: stroke and drug overdose. We could then potentially use\nthe dummy variable approach from Section 3.3.1 to code the response as\nfollows:\nY =\n=\n0 if stroke;\n1 if drug overdose.\nWe could then fit a linear regression to this binary response, and predict\ndrug overdose if \u02c6Y >0.5 and stroke otherwise. In the binary case it is not\nhard to show that even if we flip", "doc_id": "70573e35-163a-4d4f-8f1c-5d088cb7fa3b", "embedding": null, "doc_hash": "e5953d5dad1e9849eb21aa8622076454802d96fc0e41df757ca694130a8fad19", "extra_info": null, "node_info": {"start": 312075, "end": 315868, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "abb5ea2a-4e8c-4dd1-bc2f-4eaccf5ffec5", "3": "beac6bf0-8894-4bf2-9ad5-e4ae79f4bfe9"}}, "__type__": "1"}, "beac6bf0-8894-4bf2-9ad5-e4ae79f4bfe9": {"__data__": {"text": "otherwise. In the binary case it is not\nhard to show that even if we flip the above coding, linear regression will\nproduce the same final predictions.\nFor a binary response with a 0/1 coding as above, regression by least\nsquares is not completely unreasonable: it can be shown that the X \u02c6 \u03b2 obtained\nusing linear regression is in fact an estimate of Pr(drug overdose|X)\nin this special case. However, if we use linear regression, some of our estimates\nmight be outside the [0, 1] interval (see Figure 4.2), making them\nhard to interpret as probabilities! Nevertheless, the predictions provide an\nordering and can be interpreted as crude probability estimates. Curiously,\nit turns out that the classifications that we get if we use linear regression\nto predict a binary response will be the same as for the linear discriminant\nanalysis (LDA) procedure we discuss in Section 4.4.\nTo summarize, there are at least two reasons not to perform classification\nusing a regression method: (a) a regression method cannot accommodate\na qualitative response with more than two classes; (b) a regression\nmethod will not provide meaningful estimates of Pr(Y |X), even with just\ntwo classes. Thus, it is preferable to use a classification method that is\ntruly suited for qualitative response values. In the next section, we present\nlogistic regression, which is well-suited for the case of a binary qualita4.3\nLogistic Regression 133\n0 500 1000 1500 2000 2500\n0.0 0.2 0.4 0.6 0.8 1.0\nBalance\nProbability of Default\n|\n|| || | | ||| || |||||||| ||| |||||| ||||||||||||| | || ||| |||||||||||||||||| || |||| ||| |||| |||||| ||| |\n|| ||| ||| || |\n|\n|\n|\n|\n| | ||||| | || |\n| || | ||| | | | |\n| | |\n|| | |\n|\n|\n|\n| | | |\n| | | | ||| || || |\n|| || | |\n|\n|\n| |\n|\n|\n|\n|\n|\n| |\n| | |\n|||| || | || || || ||| | | || |\n|\n|\n|\n|\n| | | ||| |\n| || |\n|\n|\n|\n|\n|\n|| | | || | ||||| || | | | | |||||||| |\n||| | ||||||||| || |\n| | ||\n|| |\n|\n|| |\n|\n|\n| |\n|\n| |\n|| || | ||| || || || | || | || || ||| |\n|\n||\n|\n| | || | |\n|| |\n| | ||| |\n|\n|| | || || || |\n|| |\n|\n|\n|\n| | |\n| | | | || | ||| ||||||| || | | |\n|\n|\n|\n|\n| | | |||| |||| | | | || | |\n| |\n| || | || ||| | |||| ||| |||| |||||||| |\n|\n|\n|\n| | |\n|| |||| ||||||||| ||| ||||| |||| || || |||| | || | || ||\n| |\n|\n|| ||| |||| | ||||| |\n|| | | | ||| ||| || ||| ||||| || |\n|\n| | || || || || || |\n|| |||| || ||||||| | |||| |\n|\n|\n|| | |\n|\n| || || || || ||| | || |\n|\n|\n|\n|| || | || |\n|||| | | |\n|\n||| | ||||| |||| ||||| | ||| || |\n|| ||| | || |\n|\n| ||\n| |\n|||\n|| |||| | |||| || || |\n|\n|\n|| | || || ||\n|\n|\n||| || ||||| |||| ||| |||| ||||||||| || |||||| ||| || || |||||| |\n|| ||\n|\n| |\n|\n|\n|| || ||\n| || | ||| || |\n||| ||\n|\n|| |\n|\n|\n|||| ||| | |\n|\n| | |||| || |\n|\n| | |\n| | | || | | | |\n| ||||| |||| ||||||| ||| |\n||| | ||", "doc_id": "beac6bf0-8894-4bf2-9ad5-e4ae79f4bfe9", "embedding": null, "doc_hash": "4a2f467e911ff23f74a59797517093b84b1fecaae184fd6a3d39ae75aaece3e0", "extra_info": null, "node_info": {"start": 315857, "end": 318576, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "70573e35-163a-4d4f-8f1c-5d088cb7fa3b", "3": "997643ee-a5e1-4bd3-9465-be4e95d351fa"}}, "__type__": "1"}, "997643ee-a5e1-4bd3-9465-be4e95d351fa": {"__data__": {"text": "| | | |\n| ||||| |||| ||||||| ||| |\n||| | || |\n||| ||| ||| |\n| ||| |||| |||| |||| | | |\n| | ||| ||| || |\n|\n| || || | |\n| |||||||||||||| ||||| ||| ||| | |\n|\n| | ||| | || | | | | ||| |\n|\n|| |\n|\n|\n||| |||| || || ||| || | |\n|\n|| || |\n|\n|| ||| |\n|| |\n| ||| || |||| |\n|\n||| || |||||| || |||| |||||| |||| ||||||||| ||| |||| ||||| |\n||| |||| || ||| || |||| ||||||||| ||| ||| |\n|\n|\n|||| || ||||| ||| ||| |\n||| | || |\n|||||| | | || || || || || || | |\n||| |\n|||| || |||| ||| ||| |||| ||||||||||| |||||| ||| || || |\n||| |||\n|\n|||| |||| ||||||||||| ||||||| ||| |||||| ||||||| ||||| ||| || ||| ||| |\n|\n|\n|\n|| |\n| |\n| | |\n| | | |\n|| | | |\n| |\n|||| || |||| || ||| ||| ||||| ||||| |\n|\n||| ||| ||| | ||| ||||| ||| |\n||| ||| |\n| ||| | |||||| || |||||||| |\n|\n||| || |||||| || |||| ||||| ||| ||| || ||| ||| | |\n||| |||| || |\n|\n||||| ||| |\n|\n|\n|| ||||| |||| |||||||| |||| | | |\n|\n|\n|\n|| |\n|\n|\n||\n| ||| | |\n|\n||||||| |||||| |||| |||| |||| |\n| | || ||||| || |\n|\n| | | |\n|| ||\n||| |\n||| ||||| ||\n|\n||||||| ||||| |||||||||||| |||||| | |||| || |\n| | | || |||||||||| ||||||| ||| ||||||||||||||| ||||| |||||||||| ||||||||||| |||||| |||\n|| |\n|\n|| |||| | || |\n|||| | ||| ||| | ||| |||| || ||| ||| | |\n|\n|||| | |||| ||| ||||| ||||| ||| ||\n|\n|| |||| |||| || |\n|| ||||||| ||| |\n|| |\n|\n|||||||| |||| ||||| |||||| ||| |||||| |||||||||| ||||||| |\n| |||| |||||||||||| |||| ||| |||||||||||| |\n|| |\n|||| |\n| ||| |||\n|||||| |||| |||||| ||||| |||||| |||| ||\n| |||| |\n| ||\n|||| ||||| | ||| |||||||| |||| |||||| |||| | |\n|\n|||||| ||| ||| |\n|\n| |\n| |||||| || | || ||| |||| |\n| | ||||||||| ||| ||||| | ||\n|| ||| |\n|\n|| ||| ||||| ||||| ||| || |\n| || ||||||||| |||| ||| ||||| ||||| | |||||| |||||||| |||||||||||| |||||| || | | |||||| |||||| ||||| || |\n|| ||| | |\n|||||| ||\n|||| ||||||| ||||||| ||||||| ||||||| |||||||| ||||| || ||| ||||||||||||| |||| | | |\n|\n||| ||\n|||||||| ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| |||||||||||||||||||||||| |||||||||||||||||| || ||||||||||| ||| ||||| |\n|\n|\n||| | || |\n|\n| |\n||||| || || |||| ||||| |||||||||||||| ||||||||||||||| ||||| ||||||||| || | | |||||| ||||| ||||||| |\n|||| ||| |||||| |||| |\n||\n||||||||| |||||| ||||| |\n||| || |\n|\n| |\n|\n||| ||||| ||||||| |||||| |||| || | ||| ||||| |||| |||| |\n|||| || |\n|\n|\n|\n|\n|||||", "doc_id": "997643ee-a5e1-4bd3-9465-be4e95d351fa", "embedding": null, "doc_hash": "1d8d549e7b0f7fc7f5ed668af43d5f36071f8415b9719be3ec3eeb880b5bd2a8", "extra_info": null, "node_info": {"start": 318603, "end": 320831, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "beac6bf0-8894-4bf2-9ad5-e4ae79f4bfe9", "3": "4b6ddc48-0b24-4555-ae21-794c5ef13dfa"}}, "__type__": "1"}, "4b6ddc48-0b24-4555-ae21-794c5ef13dfa": {"__data__": {"text": "| ||| ||||| ||||| |||||||| ||| ||||| ||||| ||||||||||| |||| ||||||||||| ||||| ||\n| |\n|| | || ||||| | || 0 500 1000 1500 2000 2500\n0.0 0.2 0.4 0.6 0.8 1.0\nBalance\nProbability of Default\n|\n|| || | | ||| || |||||||| ||| |||||| ||||||||||||| | || ||| |||||||||||||||||| || |||| ||| |||| |||||| ||| |\n|| ||| ||| || |\n|\n|\n|\n|\n| | ||||| | || |\n| || | ||| | | | |\n| | |\n|| | |\n|\n|\n|\n| | | |\n| | | | ||| || || |\n|| || | |\n|\n|\n| |\n|\n|\n|\n|\n|\n| |\n| | |\n|||| || | || || || ||| | | || |\n|\n|\n|\n|\n| | | ||| |\n| || |\n|\n|\n|\n|\n|\n|| | | || | ||||| || | | | | |||||||| |\n||| | ||||||||| || |\n| | ||\n|| |\n|\n|| |\n|\n|\n| |\n|\n| |\n|| || | ||| || || || | || | || || ||| |\n|\n||\n|\n| | || | |\n|| |\n| | ||| |\n|\n|| | || || || |\n|| |\n|\n|\n|\n| | |\n| | | | || | ||| ||||||| || | | |\n|\n|\n|\n|\n| | | |||| |||| | | | || | |\n| |\n| || | || ||| | |||| ||| |||| |||||||| |\n|\n|\n|\n| | |\n|| |||| ||||||||| ||| ||||| |||| || || |||| | || | || ||\n| |\n|\n|| ||| |||| | ||||| |\n|| | | | ||| ||| || ||| ||||| || |\n|\n| | || || || || || |\n|| |||| || ||||||| | |||| |\n|\n|\n|| | |\n|\n| || || || || ||| | || |\n|\n|\n|\n|| || | || |\n|||| | | |\n|\n||| | ||||| |||| ||||| | ||| || |\n|| ||| | || |\n|\n| ||\n| |\n|||\n|| |||| | |||| || || |\n|\n|\n|| | || || ||\n|\n|\n||| || ||||| |||| ||| |||| ||||||||| || |||||| ||| || || |||||| |\n|| ||\n|\n| |\n|\n|\n|| || ||\n| || | ||| || |\n||| ||\n|\n|| |\n|\n|\n|||| ||| | |\n|\n| | |||| || |\n|\n| | |\n| | | || | | | |\n| ||||| |||| ||||||| ||| |\n||| | || |\n||| ||| ||| |\n| ||| |||| |||| |||| | | |\n| | ||| ||| || |\n|\n| || || | |\n| |||||||||||||| ||||| ||| ||| | |\n|\n| | ||| | || | | | | ||| |\n|\n|| |\n|\n|\n||| |||| || || ||| || | |\n|\n|| || |\n|\n|| ||| |\n|| |\n| ||| || |||| |\n|\n||| || |||||| || |||| |||||| |||| ||||||||| ||| |||| ||||| |\n||| |||| || ||| || |||| ||||||||| ||| ||| |\n|\n|\n|||| || ||||| ||| ||| |\n||| | || |\n|||||| | | || || || || || || | |\n||| |\n|||| || |||| ||| ||| |||| ||||||||||| |||||| ||| || || |\n||| |||\n|\n|||| |||| ||||||||||| ||||||| ||| |||||| ||||||| ||||| ||| || ||| ||| |\n|\n|\n|\n|| |\n| |\n| | |\n| | | |\n|| | | |\n| |\n|||| || |||| ||", "doc_id": "4b6ddc48-0b24-4555-ae21-794c5ef13dfa", "embedding": null, "doc_hash": "e9a37ec7847b7cd153c5ded246278654c57dcbe54c62bc0477d3df306de9d90d", "extra_info": null, "node_info": {"start": 320865, "end": 322867, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "997643ee-a5e1-4bd3-9465-be4e95d351fa", "3": "b40427ce-ffda-49ba-99ef-ff7b699644d9"}}, "__type__": "1"}, "b40427ce-ffda-49ba-99ef-ff7b699644d9": {"__data__": {"text": "||| ||| ||||| ||||| |\n|\n||| ||| ||| | ||| ||||| ||| |\n||| ||| |\n| ||| | |||||| || |||||||| |\n|\n||| || |||||| || |||| ||||| ||| ||| || ||| ||| | |\n||| |||| || |\n|\n||||| ||| |\n|\n|\n|| ||||| |||| |||||||| |||| | | |\n|\n|\n|\n|| |\n|\n|\n||\n| ||| | |\n|\n||||||| |||||| |||| |||| |||| |\n| | || ||||| || |\n|\n| | | |\n|| ||\n||| |\n||| ||||| ||\n|\n||||||| ||||| |||||||||||| |||||| | |||| || |\n| | | || |||||||||| ||||||| ||| ||||||||||||||| ||||| |||||||||| ||||||||||| |||||| |||\n|| |\n|\n|| |||| | || |\n|||| | ||| ||| | ||| |||| || ||| ||| | |\n|\n|||| | |||| ||| ||||| ||||| ||| ||\n|\n|| |||| |||| || |\n|| ||||||| ||| |\n|| |\n|\n|||||||| |||| ||||| |||||| ||| |||||| |||||||||| ||||||| |\n| |||| |||||||||||| |||| ||| |||||||||||| |\n|| |\n|||| |\n| ||| |||\n|||||| |||| |||||| ||||| |||||| |||| ||\n| |||| |\n| ||\n|||| ||||| | ||| |||||||| |||| |||||| |||| | |\n|\n|||||| ||| ||| |\n|\n| |\n| |||||| || | || ||| |||| |\n| | ||||||||| ||| ||||| | ||\n|| ||| |\n|\n|| ||| ||||| ||||| ||| || |\n| || ||||||||| |||| ||| ||||| ||||| | |||||| |||||||| |||||||||||| |||||| || | | |||||| |||||| ||||| || |\n|| ||| | |\n|||||| ||\n|||| ||||||| ||||||| ||||||| ||||||| |||||||| ||||| || ||| ||||||||||||| |||| | | |\n|\n||| ||\n|||||||| ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| |||||||||||||||||||||||| |||||||||||||||||| || ||||||||||| ||| ||||| |\n|\n|\n||| | || |\n|\n| |\n||||| || || |||| ||||| |||||||||||||| ||||||||||||||| ||||| ||||||||| || | | |||||| ||||| ||||||| |\n|||| ||| |||||| |||| |\n||\n||||||||| |||||| ||||| |\n||| || |\n|\n| |\n|\n||| ||||| ||||||| |||||| |||| || | ||| ||||| |||| |||| |\n|||| || |\n|\n|\n|\n|\n||||| | ||| ||||| ||||| |||||||| ||| ||||| ||||| ||||||||||| |||| ||||||||||| ||||| ||\n| |\n|| | || ||||| | || FIGURE 4.2. Classification using the Default data. Left: Estimated probability\nof default using linear regression. Some estimated probabilities are negative!\nThe orange ticks indicate the 0/1 values coded for default(No or Yes). Right:\nPredicted probabilities of default using logistic regression. All probabilities lie\nbetween 0 and 1.\ntive response; in later sections we will cover classification methods that are\nappropriate when the qualitative response has two or more classes.\n4.3 Logistic Regression\nConsider again the Default data set, where the response default falls into\none of two categories, Yes or No. Rather than modeling this response Y\ndirectly, logistic regression models the probability that Y belongs to a particular\ncategory.\nFor the Default data, logistic regression models the probability of default.\nFor example, the probability of default given balance can be written as\nPr(default = Yes|balance).\nThe values of Pr(default = Yes|balance), which we abbreviate p(balance),\nwill range between 0 and 1. Then for any given value of balance, a prediction\ncan be made for default. For example, one might predict default = Yes\nfor any individual for whom p(balance) > 0.5. Alternatively, if a company\nwishes to", "doc_id": "b40427ce-ffda-49ba-99ef-ff7b699644d9", "embedding": null, "doc_hash": "5370819a9cbac20db0062bac8b1be64c1308d7573dcdb0c52bba4423e8bc305f", "extra_info": null, "node_info": {"start": 322868, "end": 325785, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "4b6ddc48-0b24-4555-ae21-794c5ef13dfa", "3": "789bbe72-695f-4ab7-a047-91b1a91020b9"}}, "__type__": "1"}, "789bbe72-695f-4ab7-a047-91b1a91020b9": {"__data__": {"text": "be conservative in predicting individuals who are at risk for default,\nthen they may choose to use a lower threshold, such as p(balance) >\n0.1.\n4.3.1 The Logistic Model\nHow should we model the relationship between p(X) = Pr(Y = 1|X) and\nX? (For convenience we are using the generic 0/1 coding for the response.)\n134 4. Classification\nIn Section 4.2 we considered using a linear regression model to represent\nthese probabilities:\np(X) = \u03b20 + \u03b21X. (4.1)\nIf we use this approach to predict default=Yes using balance, then we\nobtain the model shown in the left-hand panel of Figure 4.2. Here we see\nthe problem with this approach: for balances close to zero we predict a\nnegative probability of default; if we were to predict for very large balances,\nwe would get values bigger than 1. These predictions are not sensible, since\nof course the true probability of default, regardless of credit card balance,\nmust fall between 0 and 1. This problem is not unique to the credit default\ndata. Any time a straight line is fit to a binary response that is coded as\n0 or 1, in principle we can always predict p(X) < 0 for some values of X\nand p(X) > 1 for others (unless the range of X is limited).\nTo avoid this problem, we must model p(X) using a function that gives\noutputs between 0 and 1 for all values of X. Many functions meet this\ndescription. In logistic regression, we use the logistic function,\nlogistic\nfunction\np(X) =\ne\u03b20+\u03b21X\n1 + e\u03b20+\u03b21X . (4.2)\nTo fit the model (4.2), we use a method called maximum likelihood, which\nmaximum\nwe discuss in the next section. The right-hand panel of Figure 4.2 illustrates likelihood\nthe fit of the logistic regression model to the Default data. Notice that for\nlow balances we now predict the probability of default as close to, but never\nbelow, zero. Likewise, for high balances we predict a default probability\nclose to, but never above, one. The logistic function will always produce\nan S-shaped curve of this form, and so regardless of the value of X, we\nwill obtain a sensible prediction. We also see that the logistic model is\nbetter able to capture the range of probabilities than is the linear regression\nmodel in the left-hand plot. The average fitted probability in both cases is\n0.0333 (averaged over the training data), which is the same as the overall\nproportion of defaulters in the data set.\nAfter a bit of manipulation of (4.2), we find that\np(X)\n1 \u2212 p(X)\n= e\u03b20+\u03b21X. (4.3)\nThe quantity p(X)/[1\u2212p(X)] is called the odds, and can take on any value\nodds\nbetween 0 and \u221e. Values of the odds close to 0 and \u221e indicate very low\nand very high probabilities of default, respectively. For example, on average\n1 in 5 people with an odds of 1/4 will default, since p(X) = 0.2 implies an\nodds of 0.2\n1\u22120.2 = 1/4. Likewise, on average nine out of every ten people with\nan odds of 9 will default, since p(X) = 0.9 implies an odds of 0.9\n1\u22120.9 = 9.\nOdds are traditionally used instead of probabilities in horse-racing, since\nthey relate more naturally to the correct betting strategy.\n4.3 Logistic Regression 135\nBy taking the logarithm of both sides of (4.3), we arrive at\nlog\n*\np(X)\n1 \u2212 p(X)\n+\n= \u03b20 + \u03b21X. (4.4)\nThe left-hand side is called the log odds or logit. We see that the logistic\nlog odds\nlogit\nregression model (4.2) has a logit that is linear in X.\nRecall from Chapter 3 that in a linear regression model,", "doc_id": "789bbe72-695f-4ab7-a047-91b1a91020b9", "embedding": null, "doc_hash": "90f775f20c554d284db217e1a3e89f62d71a7f33773d165321cdfb190abfa4f4", "extra_info": null, "node_info": {"start": 325786, "end": 329140, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "b40427ce-ffda-49ba-99ef-ff7b699644d9", "3": "c4fdb178-1cca-4c50-b976-15466b8649be"}}, "__type__": "1"}, "c4fdb178-1cca-4c50-b976-15466b8649be": {"__data__": {"text": "that is linear in X.\nRecall from Chapter 3 that in a linear regression model, \u03b21 gives the\naverage change in Y associated with a one-unit increase in X. By contrast,\nin a logistic regression model, increasing X by one unit changes the log\nodds by \u03b21 (4.4). Equivalently, it multiplies the odds by e\u03b21 (4.3). However,\nbecause the relationship between p(X) and X in (4.2) is not a straight line,\n\u03b21 does not correspond to the change in p(X) associated with a one-unit\nincrease in X. The amount that p(X) changes due to a one-unit change in\nX depends on the current value of X. But regardless of the value of X, if\n\u03b21 is positive then increasing X will be associated with increasing p(X),\nand if \u03b21 is negative then increasing X will be associated with decreasing\np(X). The fact that there is not a straight-line relationship between p(X)\nand X, and the fact that the rate of change in p(X) per unit change in X\ndepends on the current value of X, can also be seen by inspection of the\nright-hand panel of Figure 4.2.\n4.3.2 Estimating the Regression Coefficients\nThe coefficients \u03b20 and \u03b21 in (4.2) are unknown, and must be estimated\nbased on the available training data. In Chapter 3, we used the least squares\napproach to estimate the unknown linear regression coefficients. Although\nwe could use (non-linear) least squares to fit the model (4.4), the more\ngeneral method of maximum likelihood is preferred, since it has better statistical\nproperties. The basic intuition behind using maximum likelihood\nto fit a logistic regression model is as follows: we seek estimates for \u03b20 and\n\u03b21 such that the predicted probability \u02c6p(xi) of default for each individual,\nusing (4.2), corresponds as closely as possible to the individual\u2019s observed\ndefault status. In other words, we try to find \u02c6 \u03b20 and \u02c6 \u03b21 such that plugging\nthese estimates into the model for p(X), given in (4.2), yields a number\nclose to one for all individuals who defaulted, and a number close to zero\nfor all individuals who did not. This intuition can be formalized using a\nmathematical equation called a likelihood function:\nlikelihood\nfunction \u2113(\u03b20,\u03b21) =\nE\ni:yi=1\np(xi)\nE\ni\u2032:yi\u2032=0\n(1 \u2212 p(xi\u2032 )). (4.5)\nThe estimates \u02c6 \u03b20 and \u02c6 \u03b21 are chosen to maximize this likelihood function.\nMaximum likelihood is a very general approach that is used to fit many\nof the non-linear models that we examine throughout this book. In the\nlinear regression setting, the least squares approach is in fact a special case\n136 4. Classification\nCoefficient Std. error z-statistic p-value\nIntercept \u221210.6513 0.3612 \u221229.5 <0.0001\nbalance 0.0055 0.0002 24.9 <0.0001\nTABLE 4.1. For the Default data, estimated coefficients of the logistic regression\nmodel that predicts the probability of default using balance. A one-unit\nincrease in balance is associated with an increase in the log odds of default by\n0.0055 units.\nof maximum likelihood. The mathematical details of maximum likelihood\nare beyond the scope of this book. However, in general, logistic regression\nand other models can be easily fit using statistical software such as R, and\nso we do not need to concern ourselves with the details of the maximum\nlikelihood fitting procedure.\nTable 4.1 shows the coefficient estimates and related information that\nresult from fitting a logistic regression model on the Default data in order\nto predict the probability of default=Yes using balance. We see that \u02c6 \u03b21 =\n0.0055; this indicates that an increase in balance is associated with an\nincrease in the probability of default. To be precise, a one-unit increase in\nbalance is associated with an increase in the log odds of default", "doc_id": "c4fdb178-1cca-4c50-b976-15466b8649be", "embedding": null, "doc_hash": "011fe93cf74f788389f221f91f9c3887653cf1e7c010b673d438884755e051d8", "extra_info": null, "node_info": {"start": 329077, "end": 332698, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "789bbe72-695f-4ab7-a047-91b1a91020b9", "3": "d37a99f3-3d38-46b3-98ff-8734a0d3758d"}}, "__type__": "1"}, "d37a99f3-3d38-46b3-98ff-8734a0d3758d": {"__data__": {"text": "increase in\nbalance is associated with an increase in the log odds of default by 0.0055\nunits.\nMany aspects of the logistic regression output shown in Table 4.1 are\nsimilar to the linear regression output of Chapter 3. For example, we can\nmeasure the accuracy of the coefficient estimates by computing their standard\nerrors. The z-statistic in Table 4.1 plays the same role as the t-statistic\nin the linear regression output, for example in Table 3.1 on page 68. For\ninstance, the z-statistic associated with \u03b21 is equal to \u02c6 \u03b21/SE( \u02c6 \u03b21), and so a\nlarge (absolute) value of the z-statistic indicates evidence against the null\nhypothesis H0 : \u03b21 = 0. This null hypothesis implies that p(X) = e\u03b20\n1+e\u03b20 : in\nother words, that the probability of default does not depend on balance.\nSince the p-value associated with balance in Table 4.1 is tiny, we can reject\nH0. In other words, we conclude that there is indeed an association between\nbalance and probability of default. The estimated intercept in Table 4.1\nis typically not of interest; its main purpose is to adjust the average fitted\nprobabilities to the proportion of ones in the data (in this case, the overall\ndefault rate).\n4.3.3 Making Predictions\nOnce the coefficients have been estimated, we can compute the probability\nof default for any given credit card balance. For example, using the coefficient\nestimates given in Table 4.1, we predict that the default probability\nfor an individual with a balance of $1, 000 is\n\u02c6p(X) =\ne\u02c6\u03b20+\u02c6\u03b21X\n1 + e\u02c6\u03b20+\u02c6\u03b21X\n=\ne\u221210.6513+0.0055\u00d71,000\n1 + e\u221210.6513+0.0055\u00d71,000 = 0.00576,\n4.3 Logistic Regression 137\nCoefficient Std. error z-statistic p-value\nIntercept \u22123.5041 0.0707 \u221249.55 <0.0001\nstudent[Yes] 0.4049 0.1150 3.52 0.0004\nTABLE 4.2. For the Default data, estimated coefficients of the logistic regression\nmodel that predicts the probability of default using student status. Student\nstatus is encoded as a dummy variable, with a value of 1 for a student and a value\nof 0 for a non-student, and represented by the variable student[Yes] in the table.\nwhich is below 1 %. In contrast, the predicted probability of default for an\nindividual with a balance of $2, 000 is much higher, and equals 0.586 or\n58.6 %.\nOne can use qualitative predictors with the logistic regression model using\nthe dummy variable approach from Section 3.3.1. As an example, the\nDefault data set contains the qualitative variable student. To fit a model\nthat uses student status as a predictor variable, we simply create a dummy\nvariable that takes on a value of 1 for students and 0 for non-students. The\nlogistic regression model that results from predicting probability of default\nfrom student status can be seen in Table 4.2. The coefficient associated\nwith the dummy variable is positive, and the associated p-value is statistically\nsignificant. This indicates that students tend to have higher default\nprobabilities than non-students:\n6Pr(default=Yes|student=Yes) =\ne\u22123.5041+0.4049\u00d71\n1 + e\u22123.5041+0.4049\u00d71 = 0.0431,\n6Pr(default=Yes|student=No) =\ne\u22123.5041+0.4049\u00d70\n1 + e\u22123.5041+0.4049\u00d70 = 0.0292.\n4.3.4 Multiple Logistic Regression\nWe now consider the problem of predicting a binary response using multiple\npredictors. By analogy with the extension from simple to multiple linear\nregression in Chapter 3, we can generalize (4.4) as follows:\nlog\n*\np(X)\n1 \u2212 p(X)\n+\n= \u03b20 +", "doc_id": "d37a99f3-3d38-46b3-98ff-8734a0d3758d", "embedding": null, "doc_hash": "eadd52072b2e54654436182e2065f2356fb78a2edc632ffb64ee70aa51c0bbc4", "extra_info": null, "node_info": {"start": 332698, "end": 336042, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "c4fdb178-1cca-4c50-b976-15466b8649be", "3": "91f74a62-d09e-4bde-8919-5cb0c5f2f401"}}, "__type__": "1"}, "91f74a62-d09e-4bde-8919-5cb0c5f2f401": {"__data__": {"text": "\u2212 p(X)\n+\n= \u03b20 + \u03b21X1 + \u00b7 \u00b7 \u00b7 + \u03b2pXp, (4.6)\nwhere X = (X1, . . . ,Xp) are p predictors. Equation 4.6 can be rewritten as\np(X) =\ne\u03b20+\u03b21X1+\u00b7\u00b7\u00b7+\u03b2pXp\n1 + e\u03b20+\u03b21X1+\u00b7\u00b7\u00b7+\u03b2pXp\n. (4.7)\nJust as in Section 4.3.2, we use the maximum likelihood method to estimate\n\u03b20,\u03b21, . . . ,\u03b2p.\nTable 4.3 shows the coefficient estimates for a logistic regression model\nthat uses balance, income (in thousands of dollars), and student status to\npredict probability of default. There is a surprising result here. The p138\n4. Classification\nCoefficient Std. error z-statistic p-value\nIntercept \u221210.8690 0.4923 \u221222.08 <0.0001\nbalance 0.0057 0.0002 24.74 <0.0001\nincome 0.0030 0.0082 0.37 0.7115\nstudent[Yes] \u22120.6468 0.2362 \u22122.74 0.0062\nTABLE 4.3. For the Default data, estimated coefficients of the logistic regression\nmodel that predicts the probability of default using balance, income, and\nstudent status. Student status is encoded as a dummy variable student[Yes],\nwith a value of 1 for a student and a value of 0 for a non-student. In fitting this\nmodel, income was measured in thousands of dollars.\nvalues associated with balance and the dummy variable for student status\nare very small, indicating that each of these variables is associated with\nthe probability of default. However, the coefficient for the dummy variable\nis negative, indicating that students are less likely to default than nonstudents.\nIn contrast, the coefficient for the dummy variable is positive in\nTable 4.2. How is it possible for student status to be associated with an\nincrease in probability of default in Table 4.2 and a decrease in probability\nof default in Table 4.3? The left-hand panel of Figure 4.3 provides a graphical\nillustration of this apparent paradox. The orange and blue solid lines\nshow the average default rates for students and non-students, respectively,\nas a function of credit card balance. The negative coefficient for student in\nthe multiple logistic regression indicates that for a fixed value of balance\nand income, a student is less likely to default than a non-student. Indeed,\nwe observe from the left-hand panel of Figure 4.3 that the student default\nrate is at or below that of the non-student default rate for every value of\nbalance. But the horizontal broken lines near the base of the plot, which\nshow the default rates for students and non-students averaged over all values\nof balance and income, suggest the opposite effect: the overall student\ndefault rate is higher than the non-student default rate. Consequently, there\nis a positive coefficient for student in the single variable logistic regression\noutput shown in Table 4.2.\nThe right-hand panel of Figure 4.3 provides an explanation for this discrepancy.\nThe variables student and balance are correlated. Students tend\nto hold higher levels of debt, which is in turn associated with higher probability\nof default. In other words, students are more likely to have large\ncredit card balances, which, as we know from the left-hand panel of Figure\n4.3, tend to be associated with high default rates. Thus, even though\nan individual student with a given credit card balance will tend to have a\nlower probability of default than a non-student with the same credit card\nbalance, the fact that students on the whole tend to have higher credit card\nbalances means that overall, students tend to default at a higher rate than\nnon-students. This is an important distinction for a credit card company\nthat is trying to determine to whom they should offer credit. A student is\n4.3 Logistic Regression 139\n500 1000 1500 2000\n0.0 0.2 0.4 0.6 0.8\nCredit Card Balance\nDefault Rate\nNo Yes\n0 500 1000 1500 2000", "doc_id": "91f74a62-d09e-4bde-8919-5cb0c5f2f401", "embedding": null, "doc_hash": "06e80ccd8b450a9aaafa78f0af4290be9a791edb042a8cc27a93312561a06090", "extra_info": null, "node_info": {"start": 336096, "end": 339732, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "d37a99f3-3d38-46b3-98ff-8734a0d3758d", "3": "40de10e3-6785-4418-8a1d-66efe1708d49"}}, "__type__": "1"}, "40de10e3-6785-4418-8a1d-66efe1708d49": {"__data__": {"text": "0.8\nCredit Card Balance\nDefault Rate\nNo Yes\n0 500 1000 1500 2000 2500\nStudent Status\nCredit Card Balance\nFIGURE 4.3. Confounding in the Default data. Left: Default rates are shown\nfor students (orange) and non-students (blue). The solid lines display default rate\nas a function of balance, while the horizontal broken lines display the overall\ndefault rates. Right: Boxplots of balance for students (orange) and non-students\n(blue) are shown.\nriskier than a non-student if no information about the student\u2019s credit card\nbalance is available. However, that student is less risky than a non-student\nwith the same credit card balance!\nThis simple example illustrates the dangers and subtleties associated\nwith performing regressions involving only a single predictor when other\npredictors may also be relevant. As in the linear regression setting, the\nresults obtained using one predictor may be quite different from those obtained\nusing multiple predictors, especially when there is correlation among\nthe predictors. In general, the phenomenon seen in Figure 4.3 is known as\nconfounding.\nconfounding\nBy substituting estimates for the regression coefficients from Table 4.3\ninto (4.7), we can make predictions. For example, a student with a credit\ncard balance of $1, 500 and an income of $40, 000 has an estimated probability\nof default of\n\u02c6p(X) =\ne\u221210.869+0.00574\u00d71,500+0.003\u00d740\u22120.6468\u00d71\n1 + e\u221210.869+0.00574\u00d71,500+0.003\u00d740\u22120.6468\u00d71 = 0.058. (4.8)\nA non-student with the same balance and income has an estimated probability\nof default of\n\u02c6p(X) =\ne\u221210.869+0.00574\u00d71,500+0.003\u00d740\u22120.6468\u00d70\n1 + e\u221210.869+0.00574\u00d71,500+0.003\u00d740\u22120.6468\u00d70 = 0.105. (4.9)\n(Here we multiply the income coefficient estimate from Table 4.3 by 40,\nrather than by 40,000, because in that table the model was fit with income\nmeasured in units of $1, 000.)\n140 4. Classification\n4.3.5 Multinomial Logistic Regression\nWe sometimes wish to classify a response variable that has more than two\nclasses. For example, in Section 4.2 we had three categories of medical condition\nin the emergency room: stroke, drug overdose, epileptic seizure.\nHowever, the logistic regression approach that we have seen in this section\nonly allows for K = 2 classes for the response variable.\nIt turns out that it is possible to extend the two-class logistic regression\napproach to the setting of K > 2 classes. This extension is sometimes\nknown as multinomial logistic regression. To do this, we first select a single\nmultinomial\nlogistic\nregression\nclass to serve as the baseline; without loss of generality, we select the Kth\nclass for this role. Then we replace the model (4.7) with the model\nPr(Y = k|X = x) =\ne\u03b2k0+\u03b2k1x1+\u00b7\u00b7\u00b7+\u03b2kpxp\n1 +\n)K\u22121\nl=1 e\u03b2l0+\u03b2l1x1+\u00b7\u00b7\u00b7+\u03b2lpxp\n(4.10)\nfor k = 1, . . . ,K\u22121, and\nPr(Y = K|X = x) =\n1\n1 +\n)K\u22121\nl=1 e\u03b2l0+\u03b2l1x1+\u00b7\u00b7\u00b7+\u03b2lpxp\n. (4.11)\nIt is not hard to show that for k = 1, . . . ,K\u22121,\nlog\n*\nPr(Y = k|X = x)\nPr(Y = K|X = x)\n+\n= \u03b2k0 + \u03b2k1x1 + \u00b7 \u00b7 \u00b7 + \u03b2kpxp. (4.12)\nNotice that (4.12) is quite similar to (4.6). Equation 4.12 indicates that once\nagain, the log odds between any", "doc_id": "40de10e3-6785-4418-8a1d-66efe1708d49", "embedding": null, "doc_hash": "e4208e90fe9612a650dd4e931b0c0ae754d158ca5d5415b8c8c6d75a4d5d4412", "extra_info": null, "node_info": {"start": 339689, "end": 342740, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "91f74a62-d09e-4bde-8919-5cb0c5f2f401", "3": "55b7f496-d32a-48ac-ba72-0ecbe2425a93"}}, "__type__": "1"}, "55b7f496-d32a-48ac-ba72-0ecbe2425a93": {"__data__": {"text": "Equation 4.12 indicates that once\nagain, the log odds between any pair of classes is linear in the features.\nIt turns out that in (4.10)\u2013(4.12), the decision to treat the Kth class as\nthe baseline is unimportant. For example, when classifying emergency room\nvisits into stroke, drug overdose, and epileptic seizure, suppose that we\nfit two multinomial logistic regression models: one treating stroke as the\nbaseline, another treating drug overdose as the baseline. The coefficient\nestimates will differ between the two fitted models due to the differing\nchoice of baseline, but the fitted values (predictions), the log odds between\nany pair of classes, and the other key model outputs will remain the same.\nNonetheless, interpretation of the coefficients in a multinomial logistic\nregression model must be done with care, since it is tied to the choice\nof baseline. For example, if we set epileptic seizure to be the baseline,\nthen we can interpret \u03b2stroke0 as the log odds of stroke versus epileptic\nseizure, given that x1 = . . . = xp = 0. Furthermore, a one-unit increase\nin Xj is associated with a \u03b2strokej increase in the log odds of stroke over\nepileptic seizure. Stated another way, if Xj increases by one unit, then\nPr(Y = stroke|X = x)\nPr(Y = epileptic seizure|X = x)\nincreases by e\u03b2strokej .\n4.4 Generative Models for Classification 141\nWe now briefly present an alternative coding for multinomial logistic\nregression, known as the softmax coding. The softmax coding is equivalent\nsoftmax\nto the coding just described in the sense that the fitted values, log odds\nbetween any pair of classes, and other key model outputs will remain the\nsame, regardless of coding. But the softmax coding is used extensively in\nsome areas of the machine learning literature (and will appear again in\nChapter 10), so it is worth being aware of it. In the softmax coding, rather\nthan selecting a baseline class, we treat all K classes symmetrically, and\nassume that for k = 1, . . . ,K,\nPr(Y = k|X = x) =\ne\u03b2k0+\u03b2k1x1+\u00b7\u00b7\u00b7+\u03b2kpxp\n)K\nl=1 e\u03b2l0+\u03b2l1x1+\u00b7\u00b7\u00b7+\u03b2lpxp\n. (4.13)\nThus, rather than estimating coefficients for K \u2212 1 classes, we actually\nestimate coefficients for all K classes. It is not hard to see that as a result\nof (4.13), the log odds ratio between the kth and k\u2032th classes equals\nlog\n%\nPr(Y = k|X = x)\nPr(Y = k\u2032|X = x)\n&\n= (\u03b2k0 \u2212 \u03b2k\u20320) + (\u03b2k1 \u2212 \u03b2k\u20321)x1 + \u00b7 \u00b7 \u00b7 + (\u03b2kp \u2212 \u03b2k\u2032p)xp.\n(4.14)\n4.4 Generative Models for Classification\nLogistic regression involves directly modeling Pr(Y = k|X = x) using the\nlogistic function, given by (4.7) for the case of two response classes. In\nstatistical jargon, we model the conditional distribution of the response Y ,\ngiven the predictor(s) X. We now consider an alternative and less direct\napproach to estimating these probabilities. In this new approach, we model\nthe distribution of the predictors X separately in each of the response\nclasses (i.e. for each value of Y ). We then use Bayes\u2019 theorem to flip these\naround into estimates for Pr(Y = k|X = x). When the distribution of X\nwithin each class is assumed to be normal, it turns out that the model is\nvery similar in form to logistic regression.\nWhy do we need another method, when we have logistic regression?\nThere are several reasons:\n\u2022 When there is substantial separation between the two classes, the\nparameter estimates for the logistic regression model are surprisingly\nunstable. The methods that we consider in this", "doc_id": "55b7f496-d32a-48ac-ba72-0ecbe2425a93", "embedding": null, "doc_hash": "42342909ea79753050e46c724e3853775dd288fe73ecb77307dea195546115a8", "extra_info": null, "node_info": {"start": 342741, "end": 346155, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "40de10e3-6785-4418-8a1d-66efe1708d49", "3": "135ced2b-7734-4e79-a134-6a5c526654d4"}}, "__type__": "1"}, "135ced2b-7734-4e79-a134-6a5c526654d4": {"__data__": {"text": "the logistic regression model are surprisingly\nunstable. The methods that we consider in this section do not suffer\nfrom this problem.\n\u2022 If the distribution of the predictors X is approximately normal in\neach of the classes and the sample size is small, then the approaches\nin this section may be more accurate than logistic regression.\n\u2022 The methods in this section can be naturally extended to the case\nof more than two response classes. (In the case of more than two\n142 4. Classification\nresponse classes, we can also use multinomial logistic regression from\nSection 4.3.5.)\nSuppose that we wish to classify an observation into one of K classes,\nwhere K \u2265 2. In other words, the qualitative response variable Y can take\non K possible distinct and unordered values. Let \u03c0k represent the overall\nor prior probability that a randomly chosen observation comes from the\nprior\nkth class. Let fk(X) \u2261 Pr(X|Y = k)1 denote the density function of X\ndensity\nfor an observation that comes from the kth class. In other words, fk(x) is function\nrelatively large if there is a high probability that an observation in the kth\nclass has X \u2248 x, and fk(x) is small if it is very unlikely that an observation\nin the kth class has X \u2248 x. Then Bayes\u2019 theorem states that\nBayes\u2019\ntheorem\nPr(Y = k|X = x) =\n\u03c0kfk(x)\n)K\nl=1 \u03c0lfl(x)\n. (4.15)\nIn accordance with our earlier notation, we will use the abbreviation pk(x) =\nPr(Y = k|X = x); this is the posterior probability that an observation\nposterior\nX = x belongs to the kth class. That is, it is the probability that the\nobservation belongs to the kth class, given the predictor value for that\nobservation.\nEquation 4.15 suggests that instead of directly computing the posterior\nprobability pk(x) as in Section 4.3.1, we can simply plug in estimates of \u03c0k\nand fk(x) into (4.15). In general, estimating \u03c0k is easy if we have a random\nsample from the population: we simply compute the fraction of the training\nobservations that belong to the kth class. However, estimating the density\nfunction fk(x) is much more challenging. As we will see, to estimate fk(x),\nwe will typically have to make some simplifying assumptions.\nWe know from Chapter 2 that the Bayes classifier, which classifies an\nobservation x to the class for which pk(x) is largest, has the lowest possible\nerror rate out of all classifiers. (Of course, this is only true if all of the\nterms in (4.15) are correctly specified.) Therefore, if we can find a way to\nestimate fk(x), then we can plug it into (4.15) in order to approximate the\nBayes classifier.\nIn the following sections, we discuss three classifiers that use different\nestimates of fk(x) in (4.15) to approximate the Bayes classifier: linear discriminant\nanalysis, quadratic discriminant analysis, and naive Bayes.\n4.4.1 Linear Discriminant Analysis for p = 1\nFor now, assume that p = 1\u2014that is, we have only one predictor. We would\nlike to obtain an estimate for fk(x) that we can plug into (4.15) in order to\nestimate pk(x). We will then classify an observation to the class for which\n1Technically, this definition is only correct if X is a qualitative random variable. If\nX is quantitative, then fk(x)dx corresponds to the probability of X falling in a small\nregion dx around x.\n4.4 Generative Models for Classification 143\npk(x) is greatest. To estimate fk(x), we will first make some assumptions\nabout its form.\nIn particular, we assume that", "doc_id": "135ced2b-7734-4e79-a134-6a5c526654d4", "embedding": null, "doc_hash": "5fe923f9bbdcb30e1c354c653f3f45272628796d17124125b25ad0084308bd6f", "extra_info": null, "node_info": {"start": 346131, "end": 349531, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "55b7f496-d32a-48ac-ba72-0ecbe2425a93", "3": "5435a1a2-7192-432b-b4ed-e9603f82db25"}}, "__type__": "1"}, "5435a1a2-7192-432b-b4ed-e9603f82db25": {"__data__": {"text": "first make some assumptions\nabout its form.\nIn particular, we assume that fk(x) is normal or Gaussian. In the onenormal\nGaussian dimensional setting, the normal density takes the form\nfk(x) =\n1\n\u221a2\u03c0\u03c3k\nexp\n*\n\u2212\n1\n2\u03c32\nk\n(x \u2212 \u03bck)2\n+\n, (4.16)\nwhere \u03bck and \u03c32\nk are the mean and variance parameters for the kth class.\nFor now, let us further assume that \u03c32\n1 = \u00b7 \u00b7 \u00b7 = \u03c32K\n: that is, there is a shared\nvariance term across all K classes, which for simplicity we can denote by\n\u03c32. Plugging (4.16) into (4.15), we find that\npk(x) =\n\u03c0k\n1 \u221a2\u03c0\u03c3\nexp\n'\n\u2212 1\n2\u03c32 (x \u2212 \u03bck)2\n(\n)K\nl=1 \u03c0l\n1 \u221a2\u03c0\u03c3\nexp\n'\n\u2212 1\n2\u03c32 (x \u2212 \u03bcl)2\n( . (4.17)\n(Note that in (4.17), \u03c0k denotes the prior probability that an observation\nbelongs to the kth class, not to be confused with \u03c0 \u2248 3.14159, the mathematical\nconstant.) The Bayes classifier2 involves assigning an observation\nX = x to the class for which (4.17) is largest. Taking the log of (4.17) and\nrearranging the terms, it is not hard to show3 that this is equivalent to\nassigning the observation to the class for which\n\u03b4k(x) = x \u00b7\n\u03bck\n\u03c32 \u2212\n\u03bc2\nk\n2\u03c32 + log(\u03c0k) (4.18)\nis largest. For instance, if K = 2 and \u03c01 = \u03c02, then the Bayes classifier\nassigns an observation to class 1 if 2x (\u03bc1 \u2212 \u03bc2) > \u03bc21\n\u2212 \u03bc22\n, and to class\n2 otherwise. The Bayes decision boundary is the point for which \u03b41(x) =\n\u03b42(x); one can show that this amounts to\nx =\n\u03bc21\n\u2212 \u03bc22\n2(\u03bc1 \u2212 \u03bc2)\n=\n\u03bc1 + \u03bc2\n2\n. (4.19)\nAn example is shown in the left-hand panel of Figure 4.4. The two normal\ndensity functions that are displayed, f1(x) and f2(x), represent two distinct\nclasses. The mean and variance parameters for the two density functions\nare \u03bc1 = \u22121.25, \u03bc2 = 1.25, and \u03c32\n1 = \u03c32\n2 = 1. The two densities overlap,\nand so given that X = x, there is some uncertainty about the class to which\nthe observation belongs. If we assume that an observation is equally likely\nto come from either class\u2014that is, \u03c01 = \u03c02 = 0.5\u2014then by inspection of\n(4.19), we see that the Bayes classifier assigns the observation to class 1\nif x < 0 and class 2 otherwise. Note that in this case, we can compute\nthe Bayes classifier because we know that X is drawn from a Gaussian\ndistribution within each class, and we know all of the parameters involved.\nIn a real-life situation, we are not able to calculate the Bayes classifier.\n2Recall that the Bayes classifier assigns an observation to the class for which pk(x)\nis largest. This is different from Bayes\u2019 theorem in (4.13), which allows us to manipulate\nconditional distributions.\n3See Exercise 2 at the end of this chapter.\n144 4. Classification\n\u22124 \u22122 0 2 4 \u22123 \u22122 \u22121 0 1 2 3 4\n0 1 2 3 4 5\nFIGURE 4.4. Left: Two one-dimensional normal density functions are shown.\nThe dashed vertical line represents the Bayes decision boundary. Right: 20 observations\nwere drawn from each of the two classes, and are shown as histograms.\nThe Bayes decision boundary is again shown as a dashed vertical line. The solid\nvertical line", "doc_id": "5435a1a2-7192-432b-b4ed-e9603f82db25", "embedding": null, "doc_hash": "559bd102d4402ab501742304dfe1241c9264c95b06c8a9b4ca405f43603d1ee4", "extra_info": null, "node_info": {"start": 349549, "end": 352466, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "135ced2b-7734-4e79-a134-6a5c526654d4", "3": "353e16a3-1f1e-4de7-93b0-295a7501dcae"}}, "__type__": "1"}, "353e16a3-1f1e-4de7-93b0-295a7501dcae": {"__data__": {"text": "boundary is again shown as a dashed vertical line. The solid\nvertical line represents the LDA decision boundary estimated from the training\ndata.\nIn practice, even if we are quite certain of our assumption that X is\ndrawn from a Gaussian distribution within each class, to apply the Bayes\nclassifier we still have to estimate the parameters \u03bc1, . . . ,\u03bcK, \u03c01, . . . ,\u03c0K,\nand \u03c32. The linear discriminant analysis (LDA) method approximates the\nlinear\ndiscriminant\nanalysis\nBayes classifier by plugging estimates for \u03c0k, \u03bck, and \u03c32 into (4.18). In\nparticular, the following estimates are used:\n\u02c6\u03bck =\n1\nnk\n0\ni:yi=k\nxi\n\u02c6\u03c32 =\n1\nn \u2212 K\n0K\nk=1\n0\ni:yi=k\n(xi \u2212 \u02c6\u03bck)2 (4.20)\nwhere n is the total number of training observations, and nk is the number\nof training observations in the kth class. The estimate for \u03bck is simply the\naverage of all the training observations from the kth class, while \u02c6\u03c32 can\nbe seen as a weighted average of the sample variances for each of the K\nclasses. Sometimes we have knowledge of the class membership probabilities\n\u03c01, . . . ,\u03c0K, which can be used directly. In the absence of any additional\ninformation, LDA estimates \u03c0k using the proportion of the training observations\nthat belong to the kth class. In other words,\n\u02c6\u03c0k = nk/n. (4.21)\nThe LDA classifier plugs the estimates given in (4.20) and (4.21) into (4.18),\nand assigns an observation X = x to the class for which\n\u02c6\u03b4k(x) = x \u00b7\n\u02c6\u03bck\n\u02c6\u03c32 \u2212\n\u02c6\u03bc2\nk\n2\u02c6\u03c32 + log(\u02c6\u03c0k) (4.22)\n4.4 Generative Models for Classification 145\nis largest. The word linear in the classifier\u2019s name stems from the fact\nthat the discriminant functions \u02c6\u03b4k(x) in (4.22) are linear functions of x (as\ndiscriminant\nopposed to a more complex function of x). function\nThe right-hand panel of Figure 4.4 displays a histogram of a random\nsample of 20 observations from each class. To implement LDA, we began\nby estimating \u03c0k, \u03bck, and \u03c32 using (4.20) and (4.21).We then computed the\ndecision boundary, shown as a black solid line, that results from assigning\nan observation to the class for which (4.22) is largest. All points to the left\nof this line will be assigned to the green class, while points to the right of\nthis line are assigned to the purple class. In this case, since n1 = n2 = 20,\nwe have \u02c6\u03c01 = \u02c6\u03c02. As a result, the decision boundary corresponds to the\nmidpoint between the sample means for the two classes, (\u02c6\u03bc1 + \u02c6\u03bc2)/2. The\nfigure indicates that the LDA decision boundary is slightly to the left of\nthe optimal Bayes decision boundary, which instead equals (\u03bc1 + \u03bc2)/2 =\n0. How well does the LDA classifier perform on this data? Since this is\nsimulated data, we can generate a large number of test observations in order\nto compute the Bayes error rate and the LDA test error rate. These are\n10.6% and 11.1 %, respectively. In other words, the LDA classifier\u2019s error\nrate is only 0.5% above the smallest possible error rate! This indicates that\nLDA is performing pretty well on this data set.\nTo reiterate, the LDA classifier results from assuming that the observations\nwithin each class come from a normal distribution with a classspecific\nmean and a common variance \u03c32, and plugging estimates for these\nparameters into the Bayes classifier. In Section 4.4.3, we will consider a less\nstringent set of", "doc_id": "353e16a3-1f1e-4de7-93b0-295a7501dcae", "embedding": null, "doc_hash": "fd949b1f56acd9277a2b43adc895a732041cc00d7c3589f417fd32cf25145a38", "extra_info": null, "node_info": {"start": 352468, "end": 355722, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "5435a1a2-7192-432b-b4ed-e9603f82db25", "3": "67851e26-1fe8-4a23-a5ad-a072309149c7"}}, "__type__": "1"}, "67851e26-1fe8-4a23-a5ad-a072309149c7": {"__data__": {"text": "In Section 4.4.3, we will consider a less\nstringent set of assumptions, by allowing the observations in the kth class\nto have a class-specific variance, \u03c32\nk.\n4.4.2 Linear Discriminant Analysis for p >1\nWe now extend the LDA classifier to the case of multiple predictors. To\ndo this, we will assume that X = (X1,X2, . . . ,Xp) is drawn from a multivariate\nGaussian (or multivariate normal) distribution, with a class-specific\nmultivariate\nmean vector and a common covariance matrix.We begin with a brief review Gaussian\nof this distribution.\nThe multivariate Gaussian distribution assumes that each individual predictor\nfollows a one-dimensional normal distribution, as in (4.16), with some\ncorrelation between each pair of predictors. Two examples of multivariate\nGaussian distributions with p = 2 are shown in Figure 4.5. The height of\nthe surface at any particular point represents the probability that both X1\nand X2 fall in a small region around that point. In either panel, if the surface\nis cut along the X1 axis or along the X2 axis, the resulting cross-section\nwill have the shape of a one-dimensional normal distribution. The left-hand\npanel of Figure 4.5 illustrates an example in which Var(X1) = Var(X2) and\nCor(X1,X2) = 0; this surface has a characteristic bell shape. However, the\nbell shape will be distorted if the predictors are correlated or have unequal\nvariances, as is illustrated in the right-hand panel of Figure 4.5. In this\nsituation, the base of the bell will have an elliptical, rather than circular,\n146 4. Classification\nx1\nx1\nx2\nx2\nFIGURE 4.5. Two multivariate Gaussian density functions are shown, with\np = 2. Left: The two predictors are uncorrelated. Right: The two variables have\na correlation of 0.7.\nshape. To indicate that a p-dimensional random variable X has a multivariate\nGaussian distribution, we write X \u223c N(\u03bc,\u03a3). Here E(X) = \u03bc is\nthe mean of X (a vector with p components), and Cov(X) = \u03a3 is the\np \u00d7 p covariance matrix of X. Formally, the multivariate Gaussian density\nis defined as\nf(x) =\n1\n(2\u03c0)p/2|\u03a3|1/2 exp\n*\n\u2212\n1\n2\n(x \u2212 \u03bc)T\u03a3\u22121(x \u2212 \u03bc)\n+\n. (4.23)\nIn the case of p > 1 predictors, the LDA classifier assumes that the\nobservations in the kth class are drawn from a multivariate Gaussian distribution\nN(\u03bck,\u03a3), where \u03bck is a class-specific mean vector, and \u03a3 is a\ncovariance matrix that is common to all K classes. Plugging the density\nfunction for the kth class, fk(X = x), into (4.15) and performing a little\nbit of algebra reveals that the Bayes classifier assigns an observation X = x\nto the class for which\n\u03b4k(x) = xT\u03a3\u22121\u03bck \u2212\n1\n2\n\u03bcTk\u03a3\u22121\u03bck + log \u03c0k (4.24)\nis largest. This is the vector/matrix version of (4.18).\nAn example is shown in the left-hand panel of Figure 4.6. Three equallysized\nGaussian classes are shown with class-specific mean vectors and a\ncommon covariance matrix. The three ellipses represent regions that contain\n95% of the probability for each of the three classes. The dashed lines\nare the Bayes decision boundaries. In other words, they represent the set\nof values x for which \u03b4k(x) = \u03b4\u2113(x); i.e.\nxT\u03a3\u22121\u03bck \u2212\n1\n2\n\u03bcTk\n\u03a3\u22121\u03bck = xT\u03a3\u22121\u03bcl \u2212\n1\n2\n\u03bcTl\n\u03a3\u22121\u03bcl (4.25)\nfor k", "doc_id": "67851e26-1fe8-4a23-a5ad-a072309149c7", "embedding": null, "doc_hash": "37465d52f59c3c2359074451f65a3f8b647e3c4a6911bfcaa195b31278074692", "extra_info": null, "node_info": {"start": 355737, "end": 358863, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "353e16a3-1f1e-4de7-93b0-295a7501dcae", "3": "9eefa56a-d096-4c61-b870-33b40d351081"}}, "__type__": "1"}, "9eefa56a-d096-4c61-b870-33b40d351081": {"__data__": {"text": "(4.25)\nfor k \u0338= l. (The log \u03c0k term from (4.24) has disappeared because each of\nthe three classes has the same number of training observations; i.e. \u03c0k is\n4.4 Generative Models for Classification 147\n\u22124 \u22122 0 2 4\n\u22124 \u22122 0 2 4\n\u22124 \u22122 0 2 4\n\u22124 \u22122 0 2 4\nX1 X1\nX2\nX2\nFIGURE 4.6. An example with three classes. The observations from each class\nare drawn from a multivariate Gaussian distribution with p = 2, with a class-specific\nmean vector and a common covariance matrix. Left: Ellipses that contain\n95% of the probability for each of the three classes are shown. The dashed lines\nare the Bayes decision boundaries. Right: 20 observations were generated from\neach class, and the corresponding LDA decision boundaries are indicated using\nsolid black lines. The Bayes decision boundaries are once again shown as dashed\nlines.\nthe same for each class.) Note that there are three lines representing the\nBayes decision boundaries because there are three pairs of classes among\nthe three classes. That is, one Bayes decision boundary separates class 1\nfrom class 2, one separates class 1 from class 3, and one separates class 2\nfrom class 3. These three Bayes decision boundaries divide the predictor\nspace into three regions. The Bayes classifier will classify an observation\naccording to the region in which it is located.\nOnce again, we need to estimate the unknown parameters \u03bc1, . . . ,\u03bcK,\n\u03c01, . . . ,\u03c0K, and \u03a3; the formulas are similar to those used in the onedimensional\ncase, given in (4.20). To assign a new observation X = x,\nLDA plugs these estimates into (4.24) to obtain quantities \u02c6\u03b4k(x), and classifies\nto the class for which \u02c6\u03b4k(x) is largest. Note that in (4.24) \u03b4k(x) is\na linear function of x; that is, the LDA decision rule depends on x only\nthrough a linear combination of its elements. As previously discussed, this\nis the reason for the word linear in LDA.\nIn the right-hand panel of Figure 4.6, 20 observations drawn from each of\nthe three classes are displayed, and the resulting LDA decision boundaries\nare shown as solid black lines. Overall, the LDA decision boundaries are\npretty close to the Bayes decision boundaries, shown again as dashed lines.\nThe test error rates for the Bayes and LDA classifiers are 0.0746 and 0.0770,\nrespectively. This indicates that LDA is performing well on this data.\nWe can perform LDA on the Default data in order to predict whether\nor not an individual will default on the basis of credit card balance and\n148 4. Classification\nTrue default status\nNo Yes Total\nPredicted No 9644 252 9896\ndefault status Yes 23 81 104\nTotal 9667 333 10000\nTABLE 4.4. A confusion matrix compares the LDA predictions to the true default\nstatuses for the 10,000 training observations in the Default data set. Elements\non the diagonal of the matrix represent individuals whose default statuses\nwere correctly predicted, while off-diagonal elements represent individuals that\nwere misclassified. LDA made incorrect predictions for 23 individuals who did\nnot default and for 252 individuals who did default.\nstudent status.4 The LDA model fit to the 10,000 training samples results\nin a training error rate of 2.75 %. This sounds like a low error rate, but two\ncaveats must be noted.\n\u2022 First of all, training error rates will usually be lower than test error\nrates, which are the real quantity of interest. In other words, we\nmight expect this classifier to perform worse if we use it to predict\nwhether or not a new set of individuals will default. The reason is\nthat we specifically adjust the parameters of our model to do well on\nthe training data. The higher the ratio of parameters p to number\nof samples n, the more we expect this overfitting to play a role.", "doc_id": "9eefa56a-d096-4c61-b870-33b40d351081", "embedding": null, "doc_hash": "68c6c8e74d02e7b7be50784d547915661bda03a66a3c3e69013db762c4d962ba", "extra_info": null, "node_info": {"start": 358902, "end": 362593, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "67851e26-1fe8-4a23-a5ad-a072309149c7", "3": "78a7a7fd-edff-4fc9-bc68-19e1ea95de6b"}}, "__type__": "1"}, "78a7a7fd-edff-4fc9-bc68-19e1ea95de6b": {"__data__": {"text": "number\nof samples n, the more we expect this overfitting to play a role. For\noverfitting\nthese data we don\u2019t expect this to be a problem, since p = 2 and\nn = 10, 000.\n\u2022 Second, since only 3.33% of the individuals in the training sample\ndefaulted, a simple but useless classifier that always predicts that\nan individual will not default, regardless of his or her credit card\nbalance and student status, will result in an error rate of 3.33 %. In\nother words, the trivial null classifier will achieve an error rate that\nnull\nis only a bit higher than the LDA training set error rate.\nIn practice, a binary classifier such as this one can make two types of\nerrors: it can incorrectly assign an individual who defaults to the no default\ncategory, or it can incorrectly assign an individual who does not default to\nthe default category. It is often of interest to determine which of these two\ntypes of errors are being made. A confusion matrix, shown for the Default\nconfusion\ndata in Table 4.4, is a convenient way to display this information. The matrix\ntable reveals that LDA predicted that a total of 104 people would default.\nOf these people, 81 actually defaulted and 23 did not. Hence only 23 out\nof 9,667 of the individuals who did not default were incorrectly labeled.\n4The careful reader will notice that student status is qualitative\u2014thus, the normality\nassumption made by LDA is clearly violated in this example! However, LDA is often\nremarkably robust to model violations, as this example shows. Naive Bayes, discussed in\nSection 4.4.4, provides an alternative to LDA that does not assume normally distributed\npredictors.\n4.4 Generative Models for Classification 149\nThis looks like a pretty low error rate! However, of the 333 individuals who\ndefaulted, 252 (or 75.7 %) were missed by LDA. So while the overall error\nrate is low, the error rate among individuals who defaulted is very high.\nFrom the perspective of a credit card company that is trying to identify\nhigh-risk individuals, an error rate of 252/333 = 75.7% among individuals\nwho default may well be unacceptable.\nClass-specific performance is also important in medicine and biology,\nwhere the terms sensitivity and specificity characterize the performance of\nsensitivity\nspecificity\na classifier or screening test. In this case the sensitivity is the percentage\nof true defaulters that are identified; it equals 24.3 %. The specificity is\nthe percentage of non-defaulters that are correctly identified; it equals (1\u2212 23/9667) = 99.8 %.\nWhy does LDA do such a poor job of classifying the customers who default?\nIn other words, why does it have such low sensitivity? As we have\nseen, LDA is trying to approximate the Bayes classifier, which has the lowest\ntotal error rate out of all classifiers. That is, the Bayes classifier will\nyield the smallest possible total number of misclassified observations, regardless\nof the class from which the errors stem. Some misclassifications will\nresult from incorrectly assigning a customer who does not default to the\ndefault class, and others will result from incorrectly assigning a customer\nwho defaults to the non-default class. In contrast, a credit card company\nmight particularly wish to avoid incorrectly classifying an individual who\nwill default, whereas incorrectly classifying an individual who will not default,\nthough still to be avoided, is less problematic. We will now see that it\nis possible to modify LDA in order to develop a classifier that better meets\nthe credit card company\u2019s needs.\nThe Bayes classifier works by assigning an observation to the class for\nwhich the posterior probability pk(X) is greatest. In the two-class case, this\namounts to assigning an observation to the default class if\nPr(default = Yes|X = x) > 0.5. (4.26)\nThus, the Bayes classifier, and by extension LDA, uses a threshold of 50%\nfor the posterior probability of default in order to assign an observation\nto the", "doc_id": "78a7a7fd-edff-4fc9-bc68-19e1ea95de6b", "embedding": null, "doc_hash": "fa66a5cb164ef53ab5419a0655a1696e9e64ea6299a52bfca5267b8174a8d66e", "extra_info": null, "node_info": {"start": 362545, "end": 366467, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "9eefa56a-d096-4c61-b870-33b40d351081", "3": "f3f87614-a692-431f-b14b-2c0f136c393e"}}, "__type__": "1"}, "f3f87614-a692-431f-b14b-2c0f136c393e": {"__data__": {"text": "posterior probability of default in order to assign an observation\nto the default class. However, if we are concerned about incorrectly predicting\nthe default status for individuals who default, then we can consider\nlowering this threshold. For instance, we might label any customer with a\nposterior probability of default above 20% to the default class. In other\nwords, instead of assigning an observation to the default class if (4.26)\nholds, we could instead assign an observation to this class if\nPr(default = Yes|X = x) > 0.2. (4.27)\nThe error rates that result from taking this approach are shown in Table 4.5.\nNow LDA predicts that 430 individuals will default. Of the 333 individuals\nwho default, LDA correctly predicts all but 138, or 41.4 %. This is a vast\nimprovement over the error rate of 75.7% that resulted from using the\nthreshold of 50 %. However, this improvement comes at a cost: now 235\n150 4. Classification\nTrue default status\nNo Yes Total\nPredicted No 9432 138 9570\ndefault status Yes 235 195 430\nTotal 9667 333 10000\nTABLE 4.5. A confusion matrix compares the LDA predictions to the true default\nstatuses for the 10,000 training observations in the Default data set, using a\nmodified threshold value that predicts default for any individuals whose posterior\ndefault probability exceeds 20 %.\n0.0 0.1 0.2 0.3 0.4 0.5\n0.0 0.2 0.4 0.6\nThreshold\nError Rate\nFIGURE 4.7. For the Default data set, error rates are shown as a function of\nthe threshold value for the posterior probability that is used to perform the assignment.\nThe black solid line displays the overall error rate. The blue dashed line\nrepresents the fraction of defaulting customers that are incorrectly classified, and\nthe orange dotted line indicates the fraction of errors among the non-defaulting\ncustomers.\nindividuals who do not default are incorrectly classified. As a result, the\noverall error rate has increased slightly to 3.73 %. But a credit card company\nmay consider this slight increase in the total error rate to be a small price to\npay for more accurate identification of individuals who do indeed default.\nFigure 4.7 illustrates the trade-off that results from modifying the threshold\nvalue for the posterior probability of default. Various error rates are\nshown as a function of the threshold value. Using a threshold of 0.5, as in\n(4.26), minimizes the overall error rate, shown as a black solid line. This\nis to be expected, since the Bayes classifier uses a threshold of 0.5 and is\nknown to have the lowest overall error rate. But when a threshold of 0.5 is\nused, the error rate among the individuals who default is quite high (blue\ndashed line). As the threshold is reduced, the error rate among individuals\nwho default decreases steadily, but the error rate among the individuals\nwho do not default increases. How can we decide which threshold value is\nbest? Such a decision must be based on domain knowledge, such as detailed\ninformation about the costs associated with default.\nThe ROC curve is a popular graphic for simultaneously displaying the\nROC curve\ntwo types of errors for all possible thresholds. The name \u201cROC\u201d is historic,\nand comes from communications theory. It is an acronym for receiver\n4.4 Generative Models for Classification 151\nROC Curve\nFalse positive rate\nTrue positive rate\n0.0 0.2 0.4 0.6 0.8 1.0\n0.0 0.2 0.4 0.6 0.8 1.0\nFIGURE 4.8. A ROC curve for the LDA classifier on the Default data. It\ntraces out two types of error as we vary the threshold value for the posterior\nprobability of default. The actual thresholds are not shown. The true positive rate\nis the sensitivity: the fraction of defaulters that are correctly identified, using\na given threshold value. The false positive rate is 1-specificity: the fraction", "doc_id": "f3f87614-a692-431f-b14b-2c0f136c393e", "embedding": null, "doc_hash": "dcb0f27b0b82f6b53c8498978a9ed5fe60b8790cbce62f3390e647e5e18e53f4", "extra_info": null, "node_info": {"start": 366465, "end": 370215, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "78a7a7fd-edff-4fc9-bc68-19e1ea95de6b", "3": "b0875d76-5f8c-4c10-bc6b-259626110b5c"}}, "__type__": "1"}, "b0875d76-5f8c-4c10-bc6b-259626110b5c": {"__data__": {"text": "given threshold value. The false positive rate is 1-specificity: the fraction of\nnon-defaulters that we classify incorrectly as defaulters, using that same threshold\nvalue. The ideal ROC curve hugs the top left corner, indicating a high true positive\nrate and a low false positive rate. The dotted line represents the \u201cno information\u201d\nclassifier; this is what we would expect if student status and credit card balance\nare not associated with probability of default.\noperating characteristics. Figure 4.8 displays the ROC curve for the LDA\nclassifier on the training data. The overall performance of a classifier, summarized\nover all possible thresholds, is given by the area under the (ROC)\ncurve (AUC). An ideal ROC curve will hug the top left corner, so the larger\narea under\nthe (ROC)\ncurve\nthe AUC the better the classifier. For this data the AUC is 0.95, which is\nclose to the maximum of one so would be considered very good. We expect\na classifier that performs no better than chance to have an AUC of 0.5\n(when evaluated on an independent test set not used in model training).\nROC curves are useful for comparing different classifiers, since they take\ninto account all possible thresholds. It turns out that the ROC curve for the\nlogistic regression model of Section 4.3.4 fit to these data is virtually indistinguishable\nfrom this one for the LDA model, so we do not display it here.\nAs we have seen above, varying the classifier threshold changes its true\npositive and false positive rate. These are also called the sensitivity and one\nsensitivity\nminus the specificity of our classifier. Since there is an almost bewildering\nspecificity\narray of terms used in this context, we now give a summary. Table 4.6\nshows the possible results when applying a classifier (or diagnostic test)\n152 4. Classification\nTrue class\n\u2212 or Null + or Non-null Total\nPredicted \u2212 or Null True Neg. (TN) False Neg. (FN) N\u2217\nclass + or Non-null False Pos. (FP) True Pos. (TP) P\u2217\nTotal N P\nTABLE 4.6. Possible results when applying a classifier or diagnostic test to a\npopulation.\nName Definition Synonyms\nFalse Pos. rate FP/N Type I error, 1\u2212Specificity\nTrue Pos. rate TP/P 1\u2212Type II error, power, sensitivity, recall\nPos. Pred. value TP/P\u2217 Precision, 1\u2212false discovery proportion\nNeg. Pred. value TN/N\u2217\nTABLE 4.7. Important measures for classification and diagnostic testing,\nderived from quantities in Table 4.6.\nto a population. To make the connection with the epidemiology literature,\nwe think of \u201c+\u201d as the \u201cdisease\u201d that we are trying to detect, and \u201c\u2212\u201d as\nthe \u201cnon-disease\u201d state. To make the connection to the classical hypothesis\ntesting literature, we think of \u201c\u2212\u201d as the null hypothesis and \u201c+\u201d as the\nalternative (non-null) hypothesis. In the context of the Default data, \u201c+\u201d\nindicates an individual who defaults, and \u201c\u2212\u201d indicates one who does not.\nTable 4.7 lists many of the popular performance measures that are used in\nthis context. The denominators for the false positive and true positive rates\nare the actual population counts in each class. In contrast, the denominators\nfor the positive predictive value and the negative predictive value are the\ntotal predicted counts for each class.\n4.4.3 Quadratic Discriminant Analysis\nAs we have discussed, LDA assumes that the observations within each\nclass are drawn from a multivariate Gaussian distribution with a classspecific\nmean vector and a covariance matrix that is common to all K\nclasses. Quadratic discriminant analysis (QDA) provides an alternative\nquadratic\ndiscriminant\nanalysis\napproach. Like LDA, the QDA classifier results from assuming that the\nobservations from each class are drawn from a Gaussian distribution, and\nplugging estimates for the", "doc_id": "b0875d76-5f8c-4c10-bc6b-259626110b5c", "embedding": null, "doc_hash": "f02ddc42db6db556cdf6fc25fb26fd46b69f8ca38a8622e58a25f37c5fa82295", "extra_info": null, "node_info": {"start": 370212, "end": 373920, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "f3f87614-a692-431f-b14b-2c0f136c393e", "3": "8032eb24-a928-4a50-940f-6b069e371d10"}}, "__type__": "1"}, "8032eb24-a928-4a50-940f-6b069e371d10": {"__data__": {"text": "from each class are drawn from a Gaussian distribution, and\nplugging estimates for the parameters into Bayes\u2019 theorem in order to perform\nprediction. However, unlike LDA, QDA assumes that each class has\nits own covariance matrix. That is, it assumes that an observation from the\nkth class is of the form X \u223c N(\u03bck,\u03a3k), where \u03a3k is a covariance matrix\nfor the kth class. Under this assumption, the Bayes classifier assigns an\n4.4 Generative Models for Classification 153\nobservation X = x to the class for which\n\u03b4k(x) = \u2212\n1\n2\n(x \u2212 \u03bck)T\u03a3\u22121\nk (x \u2212 \u03bck) \u2212\n1\n2\nlog |\u03a3k| + log \u03c0k\n= \u2212\n1\n2\nxT\u03a3\u22121\nk x + xT\u03a3\u22121\nk \u03bck \u2212\n1\n2\n\u03bcTk\n\u03a3\u22121\nk \u03bck \u2212\n1\n2\nlog |\u03a3k| + log \u03c0k\n(4.28)\nis largest. So the QDA classifier involves plugging estimates for \u03a3k, \u03bck,\nand \u03c0k into (4.28), and then assigning an observation X = x to the class\nfor which this quantity is largest. Unlike in (4.24), the quantity x appears\nas a quadratic function in (4.28). This is where QDA gets its name.\nWhy does it matter whether or not we assume that the K classes share a\ncommon covariance matrix? In other words, why would one prefer LDA to\nQDA, or vice-versa? The answer lies in the bias-variance trade-off. When\nthere are p predictors, then estimating a covariance matrix requires estimating\np(p+1)/2 parameters. QDA estimates a separate covariance matrix\nfor each class, for a total of Kp(p+1)/2 parameters. With 50 predictors this\nis some multiple of 1,275, which is a lot of parameters. By instead assuming\nthat the K classes share a common covariance matrix, the LDA model\nbecomes linear in x, which means there are Kp linear coefficients to estimate.\nConsequently, LDA is a much less flexible classifier than QDA, and\nso has substantially lower variance. This can potentially lead to improved\nprediction performance. But there is a trade-off: if LDA\u2019s assumption that\nthe K classes share a common covariance matrix is badly off, then LDA\ncan suffer from high bias. Roughly speaking, LDA tends to be a better bet\nthan QDA if there are relatively few training observations and so reducing\nvariance is crucial. In contrast, QDA is recommended if the training set is\nvery large, so that the variance of the classifier is not a major concern, or if\nthe assumption of a common covariance matrix for the K classes is clearly\nuntenable.\nFigure 4.9 illustrates the performances of LDA and QDA in two scenarios.\nIn the left-hand panel, the two Gaussian classes have a common correlation\nof 0.7 between X1 and X2. As a result, the Bayes decision boundary\nis linear and is accurately approximated by the LDA decision boundary.\nThe QDA decision boundary is inferior, because it suffers from higher variance\nwithout a corresponding decrease in bias. In contrast, the right-hand\npanel displays a situation in which the orange class has a correlation of 0.7\nbetween the variables and the blue class has a correlation of \u22120.7. Now\nthe Bayes decision boundary is quadratic, and so QDA more accurately\napproximates this boundary than does LDA.\n4.4.4 Naive Bayes\nIn previous sections, we used Bayes\u2019 theorem (4.15) to develop the LDA\nand QDA classifiers. Here, we use Bayes\u2019 theorem to motivate the popular\nnaive Bayes classifier.\nnaive Bayes\n154 4.", "doc_id": "8032eb24-a928-4a50-940f-6b069e371d10", "embedding": null, "doc_hash": "c3c3781ed04e8eab77324c07ce3b97d4df532af21516b279fbc323ee4e93a3f0", "extra_info": null, "node_info": {"start": 373914, "end": 377095, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "b0875d76-5f8c-4c10-bc6b-259626110b5c", "3": "537f5bd2-52bc-40ca-a657-ba9333b24e68"}}, "__type__": "1"}, "537f5bd2-52bc-40ca-a657-ba9333b24e68": {"__data__": {"text": "the popular\nnaive Bayes classifier.\nnaive Bayes\n154 4. Classification\n\u22124 \u22122 0 2 4\n\u22124 \u22123 \u22122 \u22121 0 1 2\n\u22124 \u22122 0 2 4\n\u22124 \u22123 \u22122 \u22121 0 1 2\nX1 X1\nX2\nX2\nFIGURE 4.9. Left: The Bayes (purple dashed), LDA (black dotted), and QDA\n(green solid) decision boundaries for a two-class problem with \u03a31 = \u03a32. The\nshading indicates the QDA decision rule. Since the Bayes decision boundary is\nlinear, it is more accurately approximated by LDA than by QDA. Right: Details\nare as given in the left-hand panel, except that \u03a31 \u0338= \u03a32. Since the Bayes decision\nboundary is non-linear, it is more accurately approximated by QDA than by LDA.\nRecall that Bayes\u2019 theorem (4.15) provides an expression for the posterior\nprobability pk(x) = Pr(Y = k|X = x) in terms of \u03c01, . . . ,\u03c0K and\nf1(x), . . . , fK(x). To use (4.15) in practice, we need estimates for \u03c01, . . . ,\u03c0K\nand f1(x), . . . , fK(x). As we saw in previous sections, estimating the prior\nprobabilities \u03c01, . . . ,\u03c0K is typically straightforward: for instance, we can\nestimate \u02c6\u03c0k as the proportion of training observations belonging to the kth\nclass, for k = 1, . . . ,K.\nHowever, estimating f1(x), . . . , fK(x) is more subtle. Recall that fk(x)\nis the p-dimensional density function for an observation in the kth class,\nfor k = 1, . . . ,K. In general, estimating a p-dimensional density function is\nchallenging. In LDA, we make a very strong assumption that greatly simplifies\nthe task: we assume that fk is the density function for a multivariate\nnormal random variable with class-specific mean \u03bck, and shared covariance\nmatrix \u03a3. By contrast, in QDA, we assume that fk is the density function\nfor a multivariate normal random variable with class-specific mean \u03bck, and\nclass-specific covariance matrix \u03a3k. By making these very strong assumptions,\nwe are able to replace the very challenging problem of estimating K\np-dimensional density functions with the much simpler problem of estimating\nK p-dimensional mean vectors and one (in the case of LDA) or K (in\nthe case of QDA) (p \u00d7 p)-dimensional covariance matrices.\nThe naive Bayes classifier takes a different tack for estimating f1(x), . . . ,\nfK(x). Instead of assuming that these functions belong to a particular\nfamily of distributions (e.g. multivariate normal), we instead make a single\nassumption:\n4.4 Generative Models for Classification 155\nWithin the kth class, the p predictors are independent.\nStated mathematically, this assumption means that for k = 1, . . . ,K,\nfk(x) = fk1(x1) \u00d7 fk2(x2)\u00d7\u00b7 \u00b7 \u00b7\u00d7fkp(xp), (4.29)\nwhere fkj is the density function of the jth predictor among observations\nin the kth class.\nWhy is this assumption so powerful? Essentially, estimating a p-dimensional\ndensity function is challenging because we must consider not only\nthe marginal distribution of each predictor \u2014 that is, the distribution of\nmarginal\neach predictor on its own \u2014 but also the joint distribution of the predictors distribution\njoint\ndistribution\n\u2014 that is, the association between the different predictors. In the case of\na multivariate normal distribution, the association between the different\npredictors is summarized by the off-diagonal elements of the covariance\nmatrix. However, in general, this association can be very hard to characterize,\nand exceedingly", "doc_id": "537f5bd2-52bc-40ca-a657-ba9333b24e68", "embedding": null, "doc_hash": "3ba1b605df3a3ca937a505d48b114090a260ceb05f7835960962930226be9989", "extra_info": null, "node_info": {"start": 377121, "end": 380373, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "8032eb24-a928-4a50-940f-6b069e371d10", "3": "1cc53043-6816-4f92-94ac-c33e6557d5a1"}}, "__type__": "1"}, "1cc53043-6816-4f92-94ac-c33e6557d5a1": {"__data__": {"text": "in general, this association can be very hard to characterize,\nand exceedingly challenging to estimate. But by assuming that the\np covariates are independent within each class, we completely eliminate the\nneed to worry about the association between the p predictors, because we\nhave simply assumed that there is no association between the predictors!\nDo we really believe the naive Bayes assumption that the p covariates\nare independent within each class? In most settings, we do not. But even\nthough this modeling assumption is made for convenience, it often leads\nto pretty decent results, especially in settings where n is not large enough\nrelative to p for us to effectively estimate the joint distribution of the predictors\nwithin each class. In fact, since estimating a joint distribution requires\nsuch a huge amount of data, naive Bayes is a good choice in a wide range of\nsettings. Essentially, the naive Bayes assumption introduces some bias, but\nreduces variance, leading to a classifier that works quite well in practice as\na result of the bias-variance trade-off.\nOnce we have made the naive Bayes assumption, we can plug (4.29) into\n(4.15) to obtain an expression for the posterior probability,\nPr(Y = k|X = x) =\n\u03c0k \u00d7 fk1(x1) \u00d7 fk2(x2)\u00d7\u00b7 \u00b7 \u00b7\u00d7fkp(xp)\n)K\nl=1 \u03c0l \u00d7 fl1(x1) \u00d7 fl2(x2)\u00d7\u00b7 \u00b7 \u00b7\u00d7flp(xp)\n(4.30)\nfor k = 1, . . . ,K.\nTo estimate the one-dimensional density function fkj using training data\nx1j, . . . ,xnj, we have a few options.\n\u2022 If Xj is quantitative, then we can assume that Xj |Y = k \u223c N(\u03bcjk,\u03c32\njk).\nIn other words, we assume that within each class, the jth predictor is\ndrawn from a (univariate) normal distribution. While this may sound\na bit like QDA, there is one key difference, in that here we are assuming\nthat the predictors are independent; this amounts to QDA with\nan additional assumption that the class-specific covariance matrix is\ndiagonal.\n156 4. Classification\nTrue default status\nNo Yes Total\nPredicted No 9615 241 9856\ndefault status Yes 52 92 144\nTotal 9667 333 10000\nTABLE 4.8. Comparison of the naive Bayes predictions to the true default status\nfor the 10, 000 training observations in the Default data set, when we predict\ndefault for any observation for which P(Y = default|X = x) > 0.5.\n\u2022 If Xj is quantitative, then another option is to use a non-parametric\nestimate for fkj. A very simple way to do this is by making a histogram\nfor the observations of the jth predictor within each class.\nThen we can estimate fkj(xj) as the fraction of the training observations\nin the kth class that belong to the same histogram bin as xj .\nAlternatively, we can use a kernel density estimator, which is essenkernel\ndensity\nestimator\ntially a smoothed version of a histogram.\n\u2022 If Xj is qualitative, then we can simply count the proportion of training\nobservations for the jth predictor corresponding to each class. For\ninstance, suppose that Xj \u2208 {1, 2, 3}, and we have 100 observations\nin the kth class. Suppose that the jth predictor takes on values of 1,\n2, and 3 in 32, 55, and 13 of those observations, respectively. Then\nwe can estimate fkj as\n\u02c6 fkj(xj) =\n\u23a7\u23aa\u23a8\n\u23aa\u23a9\n0.32 if xj = 1\n0.55 if xj = 2\n0.13 if xj = 3.\nWe now consider the naive Bayes classifier in a toy example with p = 3\npredictors and K = 2 classes. The first two predictors are quantitative,\nand the third predictor is qualitative with three", "doc_id": "1cc53043-6816-4f92-94ac-c33e6557d5a1", "embedding": null, "doc_hash": "6709d091dd9ae52def39922d4f5be2f3bd530c62eec4d0ec72803dbc9fefd76d", "extra_info": null, "node_info": {"start": 380355, "end": 383700, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "537f5bd2-52bc-40ca-a657-ba9333b24e68", "3": "c55c34c3-e6ef-4739-9a77-f67c17e518a3"}}, "__type__": "1"}, "c55c34c3-e6ef-4739-9a77-f67c17e518a3": {"__data__": {"text": "two predictors are quantitative,\nand the third predictor is qualitative with three levels. Suppose further\nthat \u02c6\u03c01 = \u02c6\u03c02 = 0.5. The estimated density functions \u02c6 fkj for k = 1, 2\nand j = 1, 2, 3 are displayed in Figure 4.10. Now suppose that we wish\nto classify a new observation, x\u2217 = (0.4, 1.5, 1)T . It turns out that in this\nexample, \u02c6 f11(0.4) = 0.368, \u02c6 f12(1.5) = 0.484, \u02c6 f13(1) = 0.226, and \u02c6 f21(0.4) =\n0.030, \u02c6 f22(1.5) = 0.130, \u02c6 f23(1) = 0.616. Plugging these estimates into (4.30)\nresults in posterior probability estimates of Pr(Y = 1|X = x\u2217) = 0.944 and\nPr(Y = 2|X = x\u2217) = 0.056.\nTable 4.8 provides the confusion matrix resulting from applying the naive\nBayes classifier to the Default data set, where we predict a default if the\nposterior probability of a default \u2014 that is, P(Y = default|X = x) \u2014 exceeds\n0.5. Comparing this to the results for LDA in Table 4.4, our findings\nare mixed. While LDA has a slightly lower overall error rate, naive Bayes\ncorrectly predicts a higher fraction of the true defaulters. In this implementation\nof naive Bayes, we have assumed that each quantitative predictor is\n4.4 Generative Models for Classification 157\nDensity estimates for class k=1\n\u02c6 f11 \u02c6 f12 \u02c6 f13\n\u22124 \u22122 0 2 4\nFrequency\n\u22122 0 2 4 1 2 3\nDensity estimates for class k=2\n\u02c6 f21 \u02c6 f22 \u02c6 f23\n\u22124 \u22122 0 2 4\nFrequency\n\u22122 0 2 4 1 2 3\nFIGURE 4.10. In the toy example in Section 4.4.4, we generate data with p = 3\npredictors and K = 2 classes. The first two predictors are quantitative, and the\nthird predictor is qualitative with three levels. In each class, the estimated density\nfor each of the three predictors is displayed. If the prior probabilities for the two\nclasses are equal, then the observation x\u2217 = (0.4, 1.5, 1)T has a 94.4% posterior\nprobability of belonging to the first class.\nTrue default status\nNo Yes Total\nPredicted No 9320 128 9448\ndefault status Yes 347 205 552\nTotal 9667 333 10000\nTABLE 4.9. Comparison of the naive Bayes predictions to the true default status\nfor the 10, 000 training observations in the Default data set, when we predict\ndefault for any observation for which P(Y = default|X = x) > 0.2.\ndrawn from a Gaussian distribution (and, of course, that within each class,\neach predictor is independent).\nJust as with LDA, we can easily adjust the probability threshold for\npredicting a default. For example, Table 4.9 provides the confusion matrix\nresulting from predicting a default if P(Y = default|X = x) > 0.2. Again,\n158 4. Classification\nthe results are mixed relative to LDA with the same threshold (Table 4.5).\nNaive Bayes has a higher error rate, but correctly predicts almost two-thirds\nof the true defaults.\nIn this example, it should not be too surprising that naive Bayes does\nnot convincingly outperform LDA: this data set has n = 10,000 and p = 4,\nand so the reduction in variance resulting from the naive Bayes assumption\nis not necessarily worthwhile. We expect to see a greater pay-off to using\nnaive Bayes relative to LDA or QDA in instances where p is larger or n is\nsmaller, so that reducing the variance is very important.\n4.5 A Comparison of", "doc_id": "c55c34c3-e6ef-4739-9a77-f67c17e518a3", "embedding": null, "doc_hash": "90f0785d482cb74eaadb46241ec5dbebb8cd28327ee0b9fa889e1a0bfff548fd", "extra_info": null, "node_info": {"start": 383697, "end": 386800, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "1cc53043-6816-4f92-94ac-c33e6557d5a1", "3": "5abacb1e-7d91-4f45-a11f-d53520734126"}}, "__type__": "1"}, "5abacb1e-7d91-4f45-a11f-d53520734126": {"__data__": {"text": "so that reducing the variance is very important.\n4.5 A Comparison of Classification Methods\n4.5.1 An Analytical Comparison\nWe now perform an analytical (or mathematical) comparison of LDA,\nQDA, naive Bayes, and logistic regression. We consider these approaches in\na setting with K classes, so that we assign an observation to the class that\nmaximizes Pr(Y = k|X = x). Equivalently, we can set K as the baseline\nclass and assign an observation to the class that maximizes\nlog\n*\nPr(Y = k|X = x)\nPr(Y = K|X = x)\n+\n(4.31)\nfor k = 1, . . . ,K. Examining the specific form of (4.31) for each method\nprovides a clear understanding of their similarities and differences.\nFirst, for LDA, we can make use of Bayes\u2019 Theorem (4.15) as well as\nthe assumption that the predictors within each class are drawn from a\nmultivariate normal density (4.23) with class-specific mean and shared covariance\nmatrix in order to show that\nlog\n*\nPr(Y = k|X = x)\nPr(Y = K|X = x)\n+\n= log\n*\n\u03c0kfk(x)\n\u03c0KfK(x)\n+\n= log\n>\n\u03c0k exp\n'\n\u221212\n(x \u2212 \u03bck)T\u03a3\u22121(x \u2212 \u03bck)\n(\n\u03c0K exp\n'\n\u221212\n(x \u2212 \u03bcK)T\u03a3\u22121(x \u2212 \u03bcK)\n(\n?\n= log\n*\n\u03c0k\n\u03c0K\n+\n\u2212\n1\n2\n(x \u2212 \u03bck)T\u03a3\u22121(x \u2212 \u03bck)\n+\n1\n2\n(x \u2212 \u03bcK)T\u03a3\u22121(x \u2212 \u03bcK)\n= log\n*\n\u03c0k\n\u03c0K\n+\n\u2212\n1\n2\n(\u03bck + \u03bcK)T\u03a3\u22121(\u03bck \u2212 \u03bcK)\n+ xT\u03a3\u22121(\u03bck \u2212 \u03bcK)\n= ak +\n0p\nj=1\nbkjxj , (4.32)\n4.5 A Comparison of Classification Methods 159\nwhere ak = log\n1\n\u03c0k\n\u03c0K\n2\n\u2212 12\n(\u03bck + \u03bcK)T\u03a3\u22121(\u03bck \u2212 \u03bcK) and bkj is the jth\ncomponent of \u03a3\u22121(\u03bck \u2212\u03bcK). Hence LDA, like logistic regression, assumes\nthat the log odds of the posterior probabilities is linear in x.\nUsing similar calculations, in the QDA setting (4.31) becomes\nlog\n*\nPr(Y = k|X = x)\nPr(Y = K|X = x)\n+\n= ak +\n0p\nj=1\nbkjxj +\n0p\nj=1\n0p\nl=1\nckjlxjxl, (4.33)\nwhere ak, bkj, and ckjl are functions of \u03c0k,\u03c0K, \u03bck, \u03bcK,\u03a3k and \u03a3K. Again,\nas the name suggests, QDA assumes that the log odds of the posterior\nprobabilities is quadratic in x.\nFinally, we examine (4.31) in the naive Bayes setting. Recall that in\nthis setting, fk(x) is modeled as a product of p one-dimensional functions\nfkj(xj) for j = 1, . . . ,p. Hence,\nlog\n*\nPr(Y = k|X = x)\nPr(Y = K|X = x)\n+\n= log\n*\n\u03c0kfk(x)\n\u03c0KfK(x)\n+\n= log\n>\n\u03c0k\nFp\nj=1 fkj(xj)\n\u03c0K\nFp\nj=1 fKj(xj)\n?\n= log\n*\n\u03c0k\n\u03c0K\n+\n+\n0p\nj=1\nlog\n*\nfkj(xj)\nfKj(xj)\n+\n= ak +\n0p\nj=1\ngkj(xj), (4.34)\nwhere", "doc_id": "5abacb1e-7d91-4f45-a11f-d53520734126", "embedding": null, "doc_hash": "32f1f9289d61bf9267aa82371578e0a69f20fd12029ed259bb572114532e2a1b", "extra_info": null, "node_info": {"start": 386815, "end": 388998, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "c55c34c3-e6ef-4739-9a77-f67c17e518a3", "3": "4f8da87b-526b-4e1b-b2fe-d970dcdfb0c6"}}, "__type__": "1"}, "4f8da87b-526b-4e1b-b2fe-d970dcdfb0c6": {"__data__": {"text": "(4.34)\nwhere ak = log\n1\n\u03c0k\n\u03c0K\n2\nand gkj(xj) = log\n1\nfkj(xj )\nfKj(xj )\n2\n. Hence, the right-hand\nside of (4.34) takes the form of a generalized additive model, a topic that is\ndiscussed further in Chapter 7.\nInspection of (4.32), (4.33), and (4.34) yields the following observations\nabout LDA, QDA, and naive Bayes:\n\u2022 LDA is a special case of QDA with ckjl = 0 for all j = 1, . . . ,p,\nl = 1, . . . ,p, and k = 1, . . . ,K. (Of course, this is not surprising, since\nLDA is simply a restricted version of QDA with \u03a31 = \u00b7 \u00b7 \u00b7 = \u03a3K = \u03a3.)\n\u2022 Any classifier with a linear decision boundary is a special case of naive\nBayes with gkj(xj) = bkjxj . In particular, this means that LDA is\na special case of naive Bayes! This is not at all obvious from the\ndescriptions of LDA and naive Bayes earlier in the chapter, since\neach method makes very different assumptions: LDA assumes that\nthe features are normally distributed with a common within-class\ncovariance matrix, and naive Bayes instead assumes independence of\nthe features.\n160 4. Classification\n\u2022 If we model fkj(xj) in the naive Bayes classifier using a one-dimensional\nGaussian distribution N(\u03bckj,\u03c32\nj ), then we end up with gkj(xj) =\nbkjxj where bkj = (\u03bckj \u2212 \u03bcKj)/\u03c32\nj . In this case, naive Bayes is actually\na special case of LDA with \u03a3 restricted to be a diagonal matrix\nwith jth diagonal element equal to \u03c32\nj .\n\u2022 Neither QDA nor naive Bayes is a special case of the other. Naive\nBayes can produce a more flexible fit, since any choice can be made\nfor gkj(xj ). However, it is restricted to a purely additive fit, in the\nsense that in (4.34), a function of xj is added to a function of xl, for\nj \u0338= l; however, these terms are never multiplied. By contrast, QDA\nincludes multiplicative terms of the form ckjlxjxl. Therefore, QDA\nhas the potential to be more accurate in settings where interactions\namong the predictors are important in discriminating between classes.\nNone of these methods uniformly dominates the others: in any setting, the\nchoice of method will depend on the true distribution of the predictors in\neach of the K classes, as well as other considerations, such as the values of\nn and p. The latter ties into the bias-variance trade-off.\nHow does logistic regression tie into this story? Recall from (4.12) that\nmultinomial logistic regression takes the form\nlog\n*\nPr(Y = k|X = x)\nPr(Y = K|X = x)\n+\n= \u03b2k0 +\n0p\nj=1\n\u03b2kjxj .\nThis is identical to the linear form of LDA (4.32): in both cases,\nlog\n1\nPr(Y =k|X=x)\nPr(Y =K|X=x)\n2\nis a linear function of the predictors. In LDA, the coefficients\nin this linear function are functions of estimates for \u03c0k, \u03c0K, \u03bck,\n\u03bcK, and \u03a3 obtained by assuming that X1, . . . ,Xp follow a normal distribution\nwithin each class. By contrast, in logistic regression, the coefficients\nare chosen to maximize the likelihood function (4.5). Thus, we expect LDA\nto outperform logistic regression when the normality assumption (approximately)\nholds, and we expect logistic regression to perform better when it\ndoes not.\nWe close with a brief discussion of K-nearest neighbors (KNN), introduced\nin Chapter 2. Recall that KNN takes a completely", "doc_id": "4f8da87b-526b-4e1b-b2fe-d970dcdfb0c6", "embedding": null, "doc_hash": "c9e306d093cd20c2a071bbfdce9218ffed48b38a6bfa8e93b582611dc064a2ff", "extra_info": null, "node_info": {"start": 389045, "end": 392173, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "5abacb1e-7d91-4f45-a11f-d53520734126", "3": "8c3b7ec7-1664-4ba8-8e8c-0c016009374f"}}, "__type__": "1"}, "8c3b7ec7-1664-4ba8-8e8c-0c016009374f": {"__data__": {"text": "(KNN), introduced\nin Chapter 2. Recall that KNN takes a completely different approach\nfrom the classifiers seen in this chapter. In order to make a prediction for\nan observation X = x, the training observations that are closest to x are\nidentified. Then X is assigned to the class to which the plurality of these\nobservations belong. Hence KNN is a completely non-parametric approach:\nno assumptions are made about the shape of the decision boundary. We\nmake the following observations about KNN:\n\u2022 Because KNN is completely non-parametric, we can expect this approach\nto dominate LDA and logistic regression when the decision\n4.5 A Comparison of Classification Methods 161\nboundary is highly non-linear, provided that n is very large and p is\nsmall.\n\u2022 In order to provide accurate classification, KNN requires a lot of observations\nrelative to the number of predictors\u2014that is, n much larger\nthan p. This has to do with the fact that KNN is non-parametric, and\nthus tends to reduce the bias while incurring a lot of variance.\n\u2022 In settings where the decision boundary is non-linear but n is only\nmodest, or p is not very small, then QDA may be preferred to KNN.\nThis is because QDA can provide a non-linear decision boundary\nwhile taking advantage of a parametric form, which means that it\nrequires a smaller sample size for accurate classification, relative to\nKNN.\n\u2022 Unlike logistic regression, KNN does not tell us which predictors are\nimportant: we don\u2019t get a table of coefficients as in Table 4.3.\n4.5.2 An Empirical Comparison\nWe now compare the empirical (practical) performance of logistic regression,\nLDA, QDA, naive Bayes, and KNN. We generated data from six different\nscenarios, each of which involves a binary (two-class) classification\nproblem. In three of the scenarios, the Bayes decision boundary is linear,\nand in the remaining scenarios it is non-linear. For each scenario, we produced\n100 random training data sets. On each of these training sets, we\nfit each method to the data and computed the resulting test error rate on\na large test set. Results for the linear scenarios are shown in Figure 4.11,\nand the results for the non-linear scenarios are in Figure 4.12. The KNN\nmethod requires selection of K, the number of neighbors (not to be confused\nwith the number of classes in earlier sections of this chapter). We\nperformed KNN with two values of K: K = 1, and a value of K that was\nchosen automatically using an approach called cross-validation, which we\ndiscuss further in Chapter 5. We applied naive Bayes assuming univariate\nGaussian densities for the features within each class (and, of course \u2014 since\nthis is the key characteristic of naive Bayes \u2014 assuming independence of\nthe features).\nIn each of the six scenarios, there were p = 2 quantitative predictors.\nThe scenarios were as follows:\nScenario 1: There were 20 training observations in each of two classes. The\nobservations within each class were uncorrelated random normal variables\nwith a different mean in each class. The left-hand panel of Figure 4.11 shows\nthat LDA performed well in this setting, as one would expect since this is\nthe model assumed by LDA. Logistic regression also performed quite well,\nsince it assumes a linear decision boundary. KNN performed poorly because\n162 4. Classification\nKNN\u22121\nKNN\u2212CV\nLDA\nLogistic\nNBayes\nQDA\nSCENARIO 1\n0.25 0.30 0.35 0.40 0.45\nKNN\u22121\nKNN\u2212CV\nLDA\nLogistic\nNBayes\nQDA\nSCENARIO 2\n0.15 0.20 0.25 0.30\nKNN\u22121\nKNN\u2212CV\nLDA\nLogistic\nNBayes\nQDA\nSCENARIO 3\n0.20 0.25 0.30 0.35 0.40 0.45 0.50\nFIGURE", "doc_id": "8c3b7ec7-1664-4ba8-8e8c-0c016009374f", "embedding": null, "doc_hash": "f18d46bd333d9d71e708154aa6a124bf81b67487b33eb5059375ab5a28763369", "extra_info": null, "node_info": {"start": 392129, "end": 395654, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "4f8da87b-526b-4e1b-b2fe-d970dcdfb0c6", "3": "4a007a7f-6fcd-4dfe-a989-5c771a8a210d"}}, "__type__": "1"}, "4a007a7f-6fcd-4dfe-a989-5c771a8a210d": {"__data__": {"text": "0.30 0.35 0.40 0.45 0.50\nFIGURE 4.11. Boxplots of the test error rates for each of the linear scenarios\ndescribed in the main text.\nit paid a price in terms of variance that was not offset by a reduction in bias.\nQDA also performed worse than LDA, since it fit a more flexible classifier\nthan necessary. The performance of naive Bayes was slightly better than\nQDA, because the naive Bayes assumption of independent predictors is\ncorrect.\nScenario 2: Details are as in Scenario 1, except that within each class, the\ntwo predictors had a correlation of \u22120.5. The center panel of Figure 4.11\nindicates that the performance of most methods is similar to the previous\nscenario. The notable exception is naive Bayes, which performs very\npoorly here, since the naive Bayes assumption of independent predictors is\nviolated.\nScenario 3: As in the previous scenario, there is substantial negative correlation\nbetween the predictors within each class. However, this time we\ngenerated X1 and X2 from the t-distribution, with 50 observations per class.\nt-\nThe t-distribution has a similar shape to the normal distribution, but it distribution\nhas a tendency to yield more extreme points\u2014that is, more points that are\nfar from the mean. In this setting, the decision boundary was still linear,\nand so fit into the logistic regression framework. The set-up violated the\nassumptions of LDA, since the observations were not drawn from a normal\ndistribution. The right-hand panel of Figure 4.11 shows that logistic regression\noutperformed LDA, though both methods were superior to the other\napproaches. In particular, the QDA results deteriorated considerably as a\nconsequence of non-normality. Naive Bayes performed very poorly because\nthe independence assumption is violated.\nScenario 4: The data were generated from a normal distribution, with a\ncorrelation of 0.5 between the predictors in the first class, and correlation of\n\u22120.5 between the predictors in the second class. This setup corresponded to\nthe QDA assumption, and resulted in quadratic decision boundaries. The\nleft-hand panel of Figure 4.12 shows that QDA outperformed all of the\nother approaches. The naive Bayes assumption of independent predictors\nis violated, so naive Bayes performs poorly.\n4.5 A Comparison of Classification Methods 163\nKNN\u22121\nKNN\u2212CV\nLDA\nLogistic\nNBayes\nQDA\nSCENARIO 4\n0.30 0.35 0.40\nKNN\u22121\nKNN\u2212CV\nLDA\nLogistic\nNBayes\nQDA\nSCENARIO 5\n0.18 0.20 0.22 0.24 0.26 0.28 0.30 0.32\nKNN\u22121\nKNN\u2212CV\nLDA\nLogistic\nNBayes\nQDA\nSCENARIO 6\n0.15 0.20 0.25 0.30 0.35 0.40 0.45\nFIGURE 4.12. Boxplots of the test error rates for each of the non-linear scenarios\ndescribed in the main text.\nScenario 5: The data were generated from a normal distribution with uncorrelated\npredictors. Then the responses were sampled from the logistic\nfunction applied to a complicated non-linear function of the predictors. The\ncenter panel of Figure 4.12 shows that both QDA and naive Bayes gave\nslightly better results than the linear methods, while the much more flexible\nKNN-CV method gave the best results. But KNN with K = 1 gave the\nworst results out of all methods. This highlights the fact that even when the\ndata exhibits a complex non-linear relationship, a non-parametric method\nsuch as KNN can still give poor results if the level of smoothness is not\nchosen correctly.\nScenario 6: The observations were generated from a normal distribution\nwith a different diagonal covariance matrix for each class. However, the\nsample size was very small: just n = 6 in each class. Naive Bayes performed\nvery well, because its", "doc_id": "4a007a7f-6fcd-4dfe-a989-5c771a8a210d", "embedding": null, "doc_hash": "ad4cffd5b12fe9af712764d3ca467cc070485589d8debf70db79d1b3da1462ad", "extra_info": null, "node_info": {"start": 395685, "end": 399239, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "8c3b7ec7-1664-4ba8-8e8c-0c016009374f", "3": "0ed6055e-bf8e-4ef2-9a91-41ff2aec3f5f"}}, "__type__": "1"}, "0ed6055e-bf8e-4ef2-9a91-41ff2aec3f5f": {"__data__": {"text": "just n = 6 in each class. Naive Bayes performed\nvery well, because its assumptions are met. LDA and logistic regression\nperformed poorly because the true decision boundary is non-linear, due to\nthe unequal covariance matrices. QDA performed a bit worse than naive\nBayes, because given the very small sample size, the former incurred too\nmuch variance in estimating the correlation between the predictors within\neach class. KNN\u2019s performance also suffered due to the very small sample\nsize.\nThese six examples illustrate that no one method will dominate the others\nin every situation. When the true decision boundaries are linear, then\nthe LDA and logistic regression approaches will tend to perform well. When\nthe boundaries are moderately non-linear, QDA or naive Bayes may give\nbetter results. Finally, for much more complicated decision boundaries, a\nnon-parametric approach such as KNN can be superior. But the level of\nsmoothness for a non-parametric approach must be chosen carefully. In the\nnext chapter we examine a number of approaches for choosing the correct\nlevel of smoothness and, in general, for selecting the best overall method.\nFinally, recall from Chapter 3 that in the regression setting we can accommodate\na non-linear relationship between the predictors and the response\n164 4. Classification\nby performing regression using transformations of the predictors. A similar\napproach could be taken in the classification setting. For instance, we could\ncreate a more flexible version of logistic regression by including X2, X3,\nand even X4 as predictors. This may or may not improve logistic regression\u2019s\nperformance, depending on whether the increase in variance due to\nthe added flexibility is offset by a sufficiently large reduction in bias. We\ncould do the same for LDA. If we added all possible quadratic terms and\ncross-products to LDA, the form of the model would be the same as the\nQDA model, although the parameter estimates would be different. This\ndevice allows us to move somewhere between an LDA and a QDA model.\n4.6 Generalized Linear Models\nIn Chapter 3, we assumed that the response Y is quantitative, and explored\nthe use of least squares linear regression to predict Y . Thus far in\nthis chapter, we have instead assumed that Y is qualitative. However, we\nmay sometimes be faced with situations in which Y is neither qualitative\nnor quantitative, and so neither linear regression from Chapter 3 nor the\nclassification approaches covered in this chapter is applicable.\nAs a concrete example, we consider the Bikeshare data set. The response\nis bikers, the number of hourly users of a bike sharing program in Washington,\nDC. This response value is neither qualitative nor quantitative:\ninstead, it takes on non-negative integer values, or counts. We will consider\ncounts\npredicting bikers using the covariates mnth (month of the year), hr (hour\nof the day, from 0 to 23), workingday (an indicator variable that equals 1 if\nit is neither a weekend nor a holiday), temp (the normalized temperature,\nin Celsius), and weathersit (a qualitative variable that takes on one of four\npossible values: clear; misty or cloudy; light rain or light snow; or heavy\nrain or heavy snow.)\nIn the analyses that follow, we will treat mnth, hr, and weathersit as\nqualitative variables.\n4.6.1 Linear Regression on the Bikeshare Data\nTo begin, we consider predicting bikers using linear regression. The results\nare shown in Table 4.10.\nWe see, for example, that a progression of weather from clear to cloudy\nresults in, on average, 12.89 fewer bikers per hour; however, if the weather\nprogresses further to rain or snow, then this further results in 53.60 fewer\nbikers per hour. Figure 4.13 displays the coefficients associated with mnth\nand the coefficients associated with hr. We see that bike usage is highest in\nthe spring and fall, and lowest during the winter months. Furthermore, bike\nusage is greatest around rush hour (9", "doc_id": "0ed6055e-bf8e-4ef2-9a91-41ff2aec3f5f", "embedding": null, "doc_hash": "7eda7f8e48f1d37f1ad7196a5f69f46597868e3d483ce8dda257eecf63b747f6", "extra_info": null, "node_info": {"start": 399209, "end": 403149, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "4a007a7f-6fcd-4dfe-a989-5c771a8a210d", "3": "96a33f52-6618-4e83-b15d-f5957fc589a4"}}, "__type__": "1"}, "96a33f52-6618-4e83-b15d-f5957fc589a4": {"__data__": {"text": "lowest during the winter months. Furthermore, bike\nusage is greatest around rush hour (9 AM and 6 PM), and lowest overnight.\nThus, at first glance, fitting a linear regression model to the Bikeshare data\nset seems to provide reasonable and intuitive results.\n4.6 Generalized Linear Models 165\nCoefficient Std. error z-statistic p-value\nIntercept 73.60 5.13 14.34 0.00\nworkingday 1.27 1.78 0.71 0.48\ntemp 157.21 10.26 15.32 0.00\nweathersit[cloudy/misty] -12.89 1.96 -6.56 0.00\nweathersit[light rain/snow] -66.49 2.97 -22.43 0.00\nweathersit[heavy rain/snow] -109.75 76.67 -1.43 0.15\nTABLE 4.10. Results for a least squares linear model fit to predict bikers in\nthe Bikeshare data. The predictors mnth and hr are omitted from this table due\nto space constraints, and can be seen in Figure 4.13. For the qualitative variable\nweathersit, the baseline level corresponds to clear skies.\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u221240 \u221220 0 20\nMonth\nCoefficient\nJ F M A M J J A S O N D\n\u25cf\n\u25cf\n\u25cf\n\u25cf \u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf \u25cf\n\u25cf \u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n5 10 15 20\n\u2212100 0 50 100 200\nHour\nCoefficient\nFIGURE 4.13. A least squares linear regression model was fit to predict bikers\nin the Bikeshare data set. Left: The coefficients associated with the month of the\nyear. Bike usage is highest in the spring and fall, and lowest in the winter. Right:\nThe coefficients associated with the hour of the day. Bike usage is highest during\npeak commute times, and lowest overnight.\nBut upon more careful inspection, some issues become apparent. For\nexample, 9.6% of the fitted values in the Bikeshare data set are negative:\nthat is, the linear regression model predicts a negative number of users\nduring 9.6% of the hours in the data set. This calls into question our ability\nto perform meaningful predictions on the data, and it also raises concerns\nabout the accuracy of the coefficient estimates, confidence intervals, and\nother outputs of the regression model.\nFurthermore, it is reasonable to suspect that when the expected value\nof bikers is small, the variance of bikers should be small as well. For\ninstance, at 2 AM during a heavy December snow storm, we expect that\nextremely few people will use a bike, and moreover that there should be\nlittle variance associated with the number of users during those conditions.\nThis is borne out in the data: between 1 AM and 4 AM, in December,\nJanuary, and February, when it is raining, there are 5.05 users, on average,\n166 4. Classification\n5 10 15 20\n0 100 200 300 400 500 600\nHour\nNumber of Bikers\n5 10 15 20\n0 1 2 3 4 5 6\nHour\nLog(Number of Bikers)\nFIGURE 4.14. Left: On the Bikeshare dataset, the number of bikers is displayed\non the y-axis, and the hour of the day is displayed on the x-axis. Jitter\nwas applied for ease of visualization. For the most part, as the mean number of\nbikers increases, so does the variance in the number of bikers. A smoothing spline\nfit is shown in green. Right: The log of the number of bikers is now displayed on\nthe y-axis.\nwith a standard deviation of 3.73. By contrast, between 7 AM and 10 AM,\nin April, May, and June, when skies are clear, there are 243.59 users, on\naverage, with a standard deviation of 131.7. The mean-variance relationship\nis displayed in the left-hand panel of Figure 4.14. This is a major violation\nof the assumptions of a linear model, which state that Y", "doc_id": "96a33f52-6618-4e83-b15d-f5957fc589a4", "embedding": null, "doc_hash": "bded9d33dcb7558b130c4d610fead22a26701d0b6c7ac268565146d673326f23", "extra_info": null, "node_info": {"start": 403132, "end": 406443, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "0ed6055e-bf8e-4ef2-9a91-41ff2aec3f5f", "3": "50ed038a-0870-4d16-bc9f-85882ad5c8dc"}}, "__type__": "1"}, "50ed038a-0870-4d16-bc9f-85882ad5c8dc": {"__data__": {"text": "is a major violation\nof the assumptions of a linear model, which state that Y =\n)p\nj=1 Xj\u03b2j +\u03f5,\nwhere \u03f5 is a mean-zero error term with variance \u03c32 that is constant, and\nnot a function of the covariates. Therefore, the heteroscedasticity of the\ndata calls into question the suitability of a linear regression model.\nFinally, the response bikers is integer-valued. But under a linear model,\nY = \u03b20 +\n)p\nj=1 Xj\u03b2j + \u03f5, where \u03f5 is a continuous-valued error term. This\nmeans that in a linear model, the response Y is necessarily continuousvalued\n(quantitative). Thus, the integer nature of the response bikers suggests\nthat a linear regression model is not entirely satisfactory for this data\nset.\nSome of the problems that arise when fitting a linear regression model\nto the Bikeshare data can be overcome by transforming the response; for\ninstance, we can fit the model\nlog(Y ) =\n0p\nj=1\nXj\u03b2j + \u03f5.\nTransforming the response avoids the possibility of negative predictions,\nand it overcomes much of the heteroscedasticity in the untransformed data,\nas is shown in the right-hand panel of Figure 4.14. However, it is not quite\na satisfactory solution, since predictions and inference are made in terms of\nthe log of the response, rather than the response. This leads to challenges\nin interpretation, e.g. \u201ca one-unit increase in Xj is associated with an\nincrease in the mean of the log of Y by an amount \u03b2j\u201d. Furthermore, a\n4.6 Generalized Linear Models 167\nlog transformation of the response cannot be applied in settings where the\nresponse can take on a value of 0. Thus, while fitting a linear model to\na transformation of the response may be an adequate approach for some\ncount-valued data sets, it often leaves something to be desired. We will see\nin the next section that a Poisson regression model provides a much more\nnatural and elegant approach for this task.\n4.6.2 Poisson Regression on the Bikeshare Data\nTo overcome the inadequacies of linear regression for analyzing the Bikeshare\ndata set, we will make use of an alternative approach, called Poisson\nregression. Before we can talk about Poisson regression, we must first in-\nPoisson\ntroduce the Poisson distribution. regression\nPoisson\ndistribution\nSuppose that a random variable Y takes on nonnegative integer values,\ni.e. Y \u2208 {0, 1, 2, . . .}. If Y follows the Poisson distribution, then\nPr(Y = k) =\ne\u2212\u03bb\u03bbk\nk!\nfor k = 0, 1, 2, . . . . (4.35)\nHere, \u03bb > 0 is the expected value of Y , i.e. E(Y ). It turns out that \u03bb also\nequals the variance of Y , i.e. \u03bb = E(Y ) = Var(Y ). This means that if Y\nfollows the Poisson distribution, then the larger the mean of Y , the larger\nits variance. (In (4.35), the notation k!, pronounced \u201ck factorial\u201d, is defined\nas k! = k \u00d7 (k \u2212 1) \u00d7 (k \u2212 2) \u00d7 . . . \u00d7 3 \u00d7 2 \u00d7 1.)\nThe Poisson distribution is typically used to model counts; this is a\nnatural choice for a number of reasons, including the fact that counts, like\nthe Poisson distribution, take on nonnegative integer values. To see how we\nmight use the Poisson distribution in practice, let Y denote the number of\nusers of the bike sharing program during a particular hour of the day, under\na particular set of weather conditions, and during a particular month of the\nyear.We might model Y as a Poisson distribution with mean E(Y ) = \u03bb = 5.\nThis means that the probability of no users during this particular hour is\nPr(Y = 0) = e\u2212550\n0! = e\u22125 = 0.0067 (where 0! = 1 by convention). The\nprobability that there is exactly one user", "doc_id": "50ed038a-0870-4d16-bc9f-85882ad5c8dc", "embedding": null, "doc_hash": "90cb3bcfd4257fb39397a5beac0ce824c63f9e7fb1dc0b156ac94bc8e07223d5", "extra_info": null, "node_info": {"start": 406456, "end": 409929, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "96a33f52-6618-4e83-b15d-f5957fc589a4", "3": "2b2352f0-6ea1-4f21-aa4e-04dd85602588"}}, "__type__": "1"}, "2b2352f0-6ea1-4f21-aa4e-04dd85602588": {"__data__": {"text": "0! = 1 by convention). The\nprobability that there is exactly one user is Pr(Y = 1) = e\u2212551\n1! = 5e\u22125 =\n0.034, the probability of two users is Pr(Y = 2) = e\u2212552\n2! = 0.084, and so\non.\nOf course, in reality, we expect the mean number of users of the bike\nsharing program, \u03bb = E(Y ), to vary as a function of the hour of the day,\nthe month of the year, the weather conditions, and so forth. So rather\nthan modeling the number of bikers, Y , as a Poisson distribution with a\nfixed mean value like \u03bb = 5, we would like to allow the mean to vary as a\nfunction of the covariates. In particular, we consider the following model\nfor the mean \u03bb = E(Y ), which we now write as \u03bb(X1, . . . ,Xp) to emphasize\nthat it is a function of the covariates X1, . . . ,Xp:\nlog(\u03bb(X1, . . . ,Xp)) = \u03b20 + \u03b21X1 + \u00b7 \u00b7 \u00b7 + \u03b2pXp (4.36)\n168 4. Classification\nCoefficient Std. error z-statistic p-value\nIntercept 4.12 0.01 683.96 0.00\nworkingday 0.01 0.00 7.5 0.00\ntemp 0.79 0.01 68.43 0.00\nweathersit[cloudy/misty] -0.08 0.00 -34.53 0.00\nweathersit[light rain/snow] -0.58 0.00 -141.91 0.00\nweathersit[heavy rain/snow] -0.93 0.17 -5.55 0.00\nTABLE 4.11. Results for a Poisson regression model fit to predict bikers in\nthe Bikeshare data. The predictors mnth and hr are omitted from this table due\nto space constraints, and can be seen in Figure 4.15. For the qualitative variable\nweathersit, the baseline corresponds to clear skies.\nor equivalently\n\u03bb(X1, . . . ,Xp) = e\u03b20+\u03b21X1+\u00b7\u00b7\u00b7+\u03b2pXp . (4.37)\nHere, \u03b20,\u03b21, . . . ,\u03b2p are parameters to be estimated. Together, (4.35) and\n(4.36) define the Poisson regression model. Notice that in (4.36), we take\nthe log of \u03bb(X1, . . . ,Xp) to be linear in X1, . . . ,Xp, rather than having\n\u03bb(X1, . . . ,Xp) itself be linear in X1, . . . ,Xp, in order to ensure that\n\u03bb(X1, . . . ,Xp) takes on nonnegative values for all values of the covariates.\nTo estimate the coefficients \u03b20,\u03b21, . . . ,\u03b2p, we use the same maximum\nlikelihood approach that we adopted for logistic regression in Section 4.3.2.\nSpecifically, given n independent observations from the Poisson regression\nmodel, the likelihood takes the form\n\u2113(\u03b20,\u03b21, . . . ,\u03b2p) =\nEn\ni=1\ne\u2212\u03bb(xi)\u03bb(xi)yi\nyi!\n, (4.38)\nwhere \u03bb(xi) = e\u03b20+\u03b21xi1+\u00b7\u00b7\u00b7+\u03b2pxip , due to (4.37). We estimate the coefficients\nthat maximize the likelihood \u2113(\u03b20,\u03b21, . . . ,\u03b2p), i.e. that make the\nobserved data as likely as possible.\nWe now fit a Poisson regression model to the Bikeshare data set. The\nresults are shown in Table 4.11 and Figure 4.15. Qualitatively, the results\nare similar to those from linear regression in Section 4.6.1. We again see\nthat bike usage is highest in the spring and fall and during rush hour,\nand lowest during the winter and in the early morning hours. Moreover,\nbike usage increases as the temperature increases, and decreases as the\nweather worsens. Interestingly, the coefficient associated with workingday\nis statistically significant under the", "doc_id": "2b2352f0-6ea1-4f21-aa4e-04dd85602588", "embedding": null, "doc_hash": "610bf4eb7341d7148fb42663e8b330c6e500483a280ed89db3548166509e68a6", "extra_info": null, "node_info": {"start": 409936, "end": 412835, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "50ed038a-0870-4d16-bc9f-85882ad5c8dc", "3": "30dd2b9e-59f1-4566-8c0d-f315121f2ff4"}}, "__type__": "1"}, "30dd2b9e-59f1-4566-8c0d-f315121f2ff4": {"__data__": {"text": "worsens. Interestingly, the coefficient associated with workingday\nis statistically significant under the Poisson regression model, but not under\nthe linear regression model.\nSome important distinctions between the Poisson regression model and\nthe linear regression model are as follows:\n\u2022 Interpretation: To interpret the coefficients in the Poisson regression\nmodel, we must pay close attention to (4.37), which states that an\nincrease in Xj by one unit is associated with a change in E(Y) = \u03bb\nby a factor of exp(\u03b2j ). For example, a change in weather from clear\n4.6 Generalized Linear Models 169\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf \u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u22120.6 \u22120.4 \u22120.2 0.0 0.2\nMonth\nCoefficient\nJ F M A M J J A S O N D\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf \u25cf \u25cf \u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n5 10 15 20\n\u22122 \u22121 0 1\nHour\nCoefficient\nFIGURE 4.15. A Poisson regression model was fit to predict bikers in the\nBikeshare data set. Left: The coefficients associated with the month of the year.\nBike usage is highest in the spring and fall, and lowest in the winter. Right: The\ncoefficients associated with the hour of the day. Bike usage is highest during peak\ncommute times, and lowest overnight.\nto cloudy skies is associated with a change in mean bike usage by a\nfactor of exp(\u22120.08) = 0.923, i.e. on average, only 92.3% as many\npeople will use bikes when it is cloudy relative to when it is clear.\nIf the weather worsens further and it begins to rain, then the mean\nbike usage will further change by a factor of exp(\u22120.5) = 0.607, i.e.\non average only 60.7% as many people will use bikes when it is rainy\nrelative to when it is cloudy.\n\u2022 Mean-variance relationship: As mentioned earlier, under the Poisson\nmodel, \u03bb = E(Y ) = Var(Y ). Thus, by modeling bike usage with a\nPoisson regression, we implicitly assume that mean bike usage in a\ngiven hour equals the variance of bike usage during that hour. By\ncontrast, under a linear regression model, the variance of bike usage\nalways takes on a constant value. Recall from Figure 4.14 that in the\nBikeshare data, when biking conditions are favorable, both the mean\nand the variance in bike usage are much higher than when conditions\nare unfavorable. Thus, the Poisson regression model is able to handle\nthe mean-variance relationship seen in the Bikeshare data in a way\nthat the linear regression model is not.5\noverdispersion\n\u2022 nonnegative fitted values: There are no negative predictions using the\nPoisson regression model. This is because the Poisson model itself\nonly allows for nonnegative values; see (4.35). By contrast, when we\n5In fact, the variance in the Bikeshare data appears to be much higher than the\nmean, a situation referred to as overdispersion. This causes the Z-values to be inflated\nin Table 4.11. A more careful analysis should account for this overdispersion to obtain\nmore accurate Z-values, and there are a variety of methods for doing this. But they are\nbeyond the scope of this book.\n170 4. Classification\nfit a linear regression model to the Bikeshare data set, almost 10% of\nthe predictions were negative.\n4.6.3 Generalized Linear Models in Greater Generality\nWe have now discussed three types of regression models: linear, logistic and\nPoisson. These approaches share some common characteristics:\n1. Each approach uses predictors X1, . . . ,Xp to predict a response Y .\nWe assume that, conditional on X1, . . . ,Xp, Y belongs to a certain\nfamily of distributions. For linear regression, we typically assume that\nY follows a Gaussian or normal distribution. For", "doc_id": "30dd2b9e-59f1-4566-8c0d-f315121f2ff4", "embedding": null, "doc_hash": "76f5549f040e4cf11a527ce040efbbfc1e7134f47800e1e00b42090be93300b8", "extra_info": null, "node_info": {"start": 412799, "end": 416275, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "2b2352f0-6ea1-4f21-aa4e-04dd85602588", "3": "b60a689d-eb34-4479-8c6d-c27e5f749093"}}, "__type__": "1"}, "b60a689d-eb34-4479-8c6d-c27e5f749093": {"__data__": {"text": "we typically assume that\nY follows a Gaussian or normal distribution. For logistic regression,\nwe assume that Y follows a Bernoulli distribution. Finally, for Poisson\nregression, we assume that Y follows a Poisson distribution.\n2. Each approach models the mean of Y as a function of the predictors.\nIn linear regression, the mean of Y takes the form\nE(Y |X1, . . . ,Xp) = \u03b20 + \u03b21X1 + \u00b7 \u00b7 \u00b7 + \u03b2pXp, (4.39)\ni.e. it is a linear function of the predictors. For logistic regression, the\nmean instead takes the form\nE(Y |X1, . . . ,Xp) = Pr(Y = 1|X1, . . . ,Xp)\n=\ne\u03b20+\u03b21X1+\u00b7\u00b7\u00b7+\u03b2pXp\n1 + e\u03b20+\u03b21X1+\u00b7\u00b7\u00b7+\u03b2pXp\n, (4.40)\nwhile for Poisson regression it takes the form\nE(Y |X1, . . . ,Xp) = \u03bb(X1, . . . ,Xp) = e\u03b20+\u03b21X1+\u00b7\u00b7\u00b7+\u03b2pXp . (4.41)\nEquations (4.39)\u2013(4.41) can be expressed using a link function, \u03b7, which\nlink function\napplies a transformation to E(Y |X1, . . . ,Xp) so that the transformed mean\nis a linear function of the predictors. That is,\n\u03b7(E(Y |X1, . . . ,Xp)) = \u03b20 + \u03b21X1 + \u00b7 \u00b7 \u00b7 + \u03b2pXp. (4.42)\nThe link functions for linear, logistic and Poisson regression are \u03b7(\u03bc) = \u03bc,\n\u03b7(\u03bc) = log(\u03bc/(1 \u2212 \u03bc)), and \u03b7(\u03bc) = log(\u03bc), respectively.\nThe Gaussian, Bernoulli and Poisson distributions are all members of a\nwider class of distributions, known as the exponential family. Other wellexponential\nknown members of this family are the exponential distribution, the Gamma family\nexponential\ndistribution\ndistribution, and the negative binomial distribution. In general, we can per-\nGamma\ndistribution\nnegative\nbinomial\ndistribution\nform a regression by modeling the response Y as coming from a particular\nmember of the exponential family, and then transforming the mean of the\nresponse so that the transformed mean is a linear function of the predictors\nvia (4.42). Any regression approach that follows this very general recipe is\nknown as a generalized linear model (GLM). Thus, linear regression, logistic\ngeneralized\nlinear model\nregression, and Poisson regression are three examples of GLMs. Other examples\nnot covered here include Gamma regression and negative binomial\nGamma\nregression\nregression.\nnegative\nbinomial\nregression\n4.7 Lab: Classification Methods 171\n4.7 Lab: Classification Methods\n4.7.1 The Stock Market Data\nWe will begin by examining some numerical and graphical summaries of\nthe Smarket data, which is part of the ISLR2 library. This data set consists of\npercentage returns for the S&P 500 stock index over 1, 250 days, from the\nbeginning of 2001 until the end of 2005. For each date, we have recorded\nthe percentage returns for each of the five previous trading days, Lag1\nthrough Lag5. We have also recorded Volume (the number of shares traded\non the previous day, in billions), Today (the percentage return on the date\nin question) and Direction (whether the market was Up or Down on this\ndate). Our goal is to predict Direction (a qualitative response) using the\nother features.\n> library(ISLR2)\n> names(Smarket)\n[1] \"Year\" \"Lag1\" \"Lag2\" \"Lag3\" \"Lag4\"\n[6] \"Lag5\" \"Volume\" \"Today\" \"Direction\"\n> dim(Smarket)\n[1] 1250 9\n> summary(Smarket)\nYear Lag1 Lag2\nMin. :2001 Min. : -4.92200", "doc_id": "b60a689d-eb34-4479-8c6d-c27e5f749093", "embedding": null, "doc_hash": "8c99eec057f9af190ab2d9f0d81cb3c3f639cae58b21c059bd067ff37266a5c1", "extra_info": null, "node_info": {"start": 416308, "end": 419396, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "30dd2b9e-59f1-4566-8c0d-f315121f2ff4", "3": "c7ba0c9d-097a-4ebb-81fd-7a0f08961be4"}}, "__type__": "1"}, "c7ba0c9d-097a-4ebb-81fd-7a0f08961be4": {"__data__": {"text": "Lag1 Lag2\nMin. :2001 Min. : -4.92200 Min. : -4.92200\n1st Qu.:2002 1st Qu.: -0.63950 1st Qu.: -0.63950\nMedian :2003 Median : 0.03900 Median : 0.03900\nMean :2003 Mean : 0.00383 Mean : 0.00392\n3rd Qu.:2004 3rd Qu.: 0.59675 3rd Qu.: 0.59675\nMax. :2005 Max. : 5.73300 Max. : 5.73300\nLag3 Lag4 Lag5\nMin. : -4.92200 Min. : -4.92200 Min. : -4.92200\n1st Qu.: -0.64000 1st Qu.: -0.64000 1st Qu.: -0.64000\nMedian : 0.03850 Median : 0.03850 Median : 0.03850\nMean : 0.00172 Mean : 0.00164 Mean : 0.00561\n3rd Qu.: 0.59675 3rd Qu.: 0.59675 3rd Qu.: 0.59700\nMax. : 5.73300 Max. : 5.73300 Max. : 5.73300\nVolume Today Direction\nMin. :0.356 Min. : -4.92200 Down :602\n1st Qu.:1.257 1st Qu.: -0.63950 Up :648\nMedian :1.423 Median : 0.03850\nMean :1.478 Mean : 0.00314\n3rd Qu.:1.642 3rd Qu.: 0.59675\nMax. :3.152 Max. : 5.73300\n> pairs(Smarket)\nThe cor() function produces a matrix that contains all of the pairwise\ncorrelations among the predictors in a data set. The first command below\ngives an error message because the Direction variable is qualitative.\n> cor(Smarket)\nError in cor(Smarket) : \u2018x\u2019 must be numeric\n> cor(Smarket[, -9])\n172 4. Classification\nYear Lag1 Lag2 Lag3 Lag4 Lag5\nYear 1.0000 0.02970 0.03060 0.03319 0.03569 0.02979\nLag1 0.0297 1.00000 -0.02629 -0.01080 -0.00299 -0.00567\nLag2 0.0306 -0.02629 1.00000 -0.02590 -0.01085 -0.00356\nLag3 0.0332 -0.01080 -0.02590 1.00000 -0.02405 -0.01881\nLag4 0.0357 -0.00299 -0.01085 -0.02405 1.00000 -0.02708\nLag5 0.0298 -0.00567 -0.00356 -0.01881 -0.02708 1.00000\nVolume 0.5390 0.04091 -0.04338 -0.04182 -0.04841 -0.02200\nToday 0.0301 -0.02616 -0.01025 -0.00245 -0.00690 -0.03486\nVolume Today\nYear 0.5390 0.03010\nLag1 0.0409 -0.02616\nLag2 -0.0434 -0.01025\nLag3 -0.0418 -0.00245\nLag4 -0.0484 -0.00690\nLag5 -0.0220 -0.03486\nVolume 1.0000 0.01459\nToday 0.0146 1.00000\nAs one would expect, the correlations between the lag variables and today\u2019s\nreturns are close to zero. In other words, there appears to be little\ncorrelation between today\u2019s returns and previous days\u2019 returns. The only\nsubstantial correlation is between Year and Volume. By plotting the data,\nwhich is ordered chronologically, we see that Volume is increasing over time.\nIn other words, the average number of shares traded daily increased from\n2001 to 2005.\n> attach(Smarket)\n> plot(Volume)\n4.7.2 Logistic Regression\nNext, we will fit a logistic regression model in order to predict Direction\nusing Lag1 through Lag5 and Volume.", "doc_id": "c7ba0c9d-097a-4ebb-81fd-7a0f08961be4", "embedding": null, "doc_hash": "f6fd88b2086ab8ad379b399ee685f2fdc0f4aada032b548645f5dcee45b5f42c", "extra_info": null, "node_info": {"start": 419429, "end": 421857, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "b60a689d-eb34-4479-8c6d-c27e5f749093", "3": "645cd72d-1260-48b2-b59c-6147aa7bcefd"}}, "__type__": "1"}, "645cd72d-1260-48b2-b59c-6147aa7bcefd": {"__data__": {"text": "model in order to predict Direction\nusing Lag1 through Lag5 and Volume. The glm() function can be used to fit\nglm()\nmany types of generalized linear models, including logistic regression. The\ngeneralized\nlinear model syntax of the glm() function is similar to that of lm(), except that we must\npass in the argument family = binomial in order to tell R to run a logistic\nregression rather than some other type of generalized linear model.\n> glm.fits <- glm(\nDirection \u223c Lag1 + Lag2 + Lag3 + Lag4 + Lag5 + Volume ,\ndata = Smarket , family = binomial\n)\n> summary(glm.fits)\nCall:\nglm(formula = Direction \u223c Lag1 + Lag2 + Lag3 + Lag4 + Lag5\n+ Volume, family = binomial, data = Smarket)\nDeviance Residuals:\nMin 1Q Median 3Q Max\n4.7 Lab: Classification Methods 173\n-1.45 -1.20 1.07 1.15 1.33\nCoefficients:\nEstimate Std. Error z value Pr(>|z|)\n(Intercept) -0.12600 0.24074 -0.52 0.60\nLag1 -0.07307 0.05017 -1.46 0.15\nLag2 -0.04230 0.05009 -0.84 0.40\nLag3 0.01109 0.04994 0.22 0.82\nLag4 0.00936 0.04997 0.19 0.85\nLag5 0.01031 0.04951 0.21 0.83\nVolume 0.13544 0.15836 0.86 0.39\n(Dispersion parameter for binomial family taken to be 1)\nNull deviance: 1731.2 on 1249 degrees of freedom\nResidual deviance: 1727.6 on 1243 degrees of freedom\nAIC: 1742\nNumber of Fisher Scoring iterations: 3\nThe smallest p-value here is associated with Lag1. The negative coefficient\nfor this predictor suggests that if the market had a positive return yesterday,\nthen it is less likely to go up today. However, at a value of 0.15, the p-value\nis still relatively large, and so there is no clear evidence of a real association\nbetween Lag1 and Direction.\nWe use the coef() function in order to access just the coefficients for this\nfitted model. We can also use the summary() function to access particular\naspects of the fitted model, such as the p-values for the coefficients.\n> coef(glm.fits)\n(Intercept) Lag1 Lag2 Lag3 Lag4\n-0.12600 -0.07307 -0.04230 0.01109 0.00936\nLag5 Volume\n0.01031 0.13544\n> summary(glm.fits)$coef\nEstimate Std. Error z value Pr(>|z|)\n(Intercept) -0.12600 0.2407 -0.523 0.601\nLag1 -0.07307 0.0502 -1.457 0.145\nLag2 -0.04230 0.0501 -0.845 0.398\nLag3 0.01109 0.0499 0.222 0.824\nLag4 0.00936 0.0500 0.187 0.851\nLag5 0.01031 0.0495 0.208 0.835\nVolume 0.13544 0.1584 0.855 0.392\n> summary(glm.fits)$coef[, 4]\n(Intercept) Lag1 Lag2 Lag3 Lag4\n0.601 0.145 0.398 0.824 0.851\nLag5 Volume\n0.835 0.392\nThe predict() function can be used to predict the probability that the\nmarket will go up, given values of the predictors. The type = \"response\"\noption tells R to output probabilities of the form P(Y = 1|X), as opposed\nto other information such as the logit. If no data set is supplied to the\n174 4. Classification\npredict() function, then the probabilities are computed for the", "doc_id": "645cd72d-1260-48b2-b59c-6147aa7bcefd", "embedding": null, "doc_hash": "179acf80373bff6d4b860e30f2689349b8ffa74188118f4d1d23c63d518acf38", "extra_info": null, "node_info": {"start": 421828, "end": 424587, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "c7ba0c9d-097a-4ebb-81fd-7a0f08961be4", "3": "42ef401a-78b2-4987-b2fd-bc119f22e3f3"}}, "__type__": "1"}, "42ef401a-78b2-4987-b2fd-bc119f22e3f3": {"__data__": {"text": "4. Classification\npredict() function, then the probabilities are computed for the training\ndata that was used to fit the logistic regression model. Here we have printed\nonly the first ten probabilities. We know that these values correspond to\nthe probability of the market going up, rather than down, because the\ncontrasts() function indicates that R has created a dummy variable with\na 1 for Up.\n> glm.probs <- predict(glm.fits , type = \"response\")\n> glm.probs[1:10]\n1 2 3 4 5 6 7 8 9 10\n0.507 0.481 0.481 0.515 0.511 0.507 0.493 0.509 0.518 0.489\n> contrasts(Direction)\nUp\nDown 0\nUp 1\nIn order to make a prediction as to whether the market will go up or\ndown on a particular day, we must convert these predicted probabilities\ninto class labels, Up or Down. The following two commands create a vector\nof class predictions based on whether the predicted probability of a market\nincrease is greater than or less than 0.5.\n> glm.pred <- rep(\"Down\", 1250)\n> glm.pred[glm.probs > .5] = \"Up\"\nThe first command creates a vector of 1,250 Down elements. The second line\ntransforms to Up all of the elements for which the predicted probability of a\nmarket increase exceeds 0.5. Given these predictions, the table() function\ntable()\ncan be used to produce a confusion matrix in order to determine how many\nobservations were correctly or incorrectly classified.\n> table(glm.pred , Direction)\nDirection\nglm.pred Down Up\nDown 145 141\nUp 457 507\n> (507 + 145) / 1250\n[1] 0.5216\n> mean(glm.pred == Direction)\n[1] 0.5216\nThe diagonal elements of the confusion matrix indicate correct predictions,\nwhile the off-diagonals represent incorrect predictions. Hence our model\ncorrectly predicted that the market would go up on 507 days and that\nit would go down on 145 days, for a total of 507 + 145 = 652 correct\npredictions. The mean() function can be used to compute the fraction of\ndays for which the prediction was correct. In this case, logistic regression\ncorrectly predicted the movement of the market 52.2% of the time.\nAt first glance, it appears that the logistic regression model is working\na little better than random guessing. However, this result is misleading\nbecause we trained and tested the model on the same set of 1, 250 observations.\nIn other words, 100% \u2212 52.2% = 47.8%, is the training error\n4.7 Lab: Classification Methods 175\nrate. As we have seen previously, the training error rate is often overly\noptimistic\u2014it tends to underestimate the test error rate. In order to better\nassess the accuracy of the logistic regression model in this setting, we can\nfit the model using part of the data, and then examine how well it predicts\nthe held out data. This will yield a more realistic error rate, in the sense\nthat in practice we will be interested in our model\u2019s performance not on\nthe data that we used to fit the model, but rather on days in the future for\nwhich the market\u2019s movements are unknown.\nTo implement this strategy, we will first create a vector corresponding\nto the observations from 2001 through 2004. We will then use this vector\nto create a held out data set of observations from 2005.\n> train <- (Year < 2005)\n> Smarket.2005 <- Smarket[!train, ]\n> dim(Smarket .2005)\n[1] 252 9\n> Direction.2005 <- Direction[!train]\nThe object train is a vector of 1,250 elements, corresponding to the observations\nin our data set. The elements of the vector that correspond to\nobservations that occurred before 2005 are set to TRUE, whereas those that\ncorrespond to observations in 2005 are set to FALSE. The object train is a\nBoolean vector, since its elements are TRUE and FALSE.", "doc_id": "42ef401a-78b2-4987-b2fd-bc119f22e3f3", "embedding": null, "doc_hash": "76acf4b07922ee7abc76f0c2b7836e12b4fcf67290c5922910e3426663350898", "extra_info": null, "node_info": {"start": 424577, "end": 428161, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "645cd72d-1260-48b2-b59c-6147aa7bcefd", "3": "877a72d0-8837-4d99-a084-82b699287a67"}}, "__type__": "1"}, "877a72d0-8837-4d99-a084-82b699287a67": {"__data__": {"text": "object train is a\nBoolean vector, since its elements are TRUE and FALSE. Boolean vectors can\nboolean\nbe used to obtain a subset of the rows or columns of a matrix. For instance,\nthe command Smarket[train, ] would pick out a submatrix of the stock\nmarket data set, corresponding only to the dates before 2005, since those\nare the ones for which the elements of train are TRUE. The ! symbol can be\nused to reverse all of the elements of a Boolean vector. That is, !train is\na vector similar to train, except that the elements that are TRUE in train\nget swapped to FALSE in !train, and the elements that are FALSE in train\nget swapped to TRUE in !train. Therefore, Smarket[!train, ] yields a submatrix\nof the stock market data containing only the observations for which\ntrain is FALSE\u2014that is, the observations with dates in 2005. The output\nabove indicates that there are 252 such observations.\nWe now fit a logistic regression model using only the subset of the observations\nthat correspond to dates before 2005, using the subset argument.\nWe then obtain predicted probabilities of the stock market going up for\neach of the days in our test set\u2014that is, for the days in 2005.\n> glm.fits <- glm(\nDirection \u223c Lag1 + Lag2 + Lag3 + Lag4 + Lag5 + Volume ,\ndata = Smarket , family = binomial , subset = train\n)\n> glm.probs <- predict(glm.fits , Smarket .2005,\ntype = \"response\")\nNotice that we have trained and tested our model on two completely separate\ndata sets: training was performed using only the dates before 2005,\n176 4. Classification\nand testing was performed using only the dates in 2005. Finally, we compute\nthe predictions for 2005 and compare them to the actual movements\nof the market over that time period.\n> glm.pred <- rep(\"Down\", 252)\n> glm.pred[glm.probs > .5] <- \"Up\"\n> table(glm.pred , Direction .2005)\nDirection .2005\nglm.pred Down Up\nDown 77 97\nUp 34 44\n> mean(glm.pred == Direction .2005)\n[1] 0.48\n> mean(glm.pred != Direction .2005)\n[1] 0.52\nThe != notation means not equal to, and so the last command computes\nthe test set error rate. The results are rather disappointing: the test error\nrate is 52 %, which is worse than random guessing! Of course this result\nis not all that surprising, given that one would not generally expect to be\nable to use previous days\u2019 returns to predict future market performance.\n(After all, if it were possible to do so, then the authors of this book would\nbe out striking it rich rather than writing a statistics textbook.)\nWe recall that the logistic regression model had very underwhelming pvalues\nassociated with all of the predictors, and that the smallest p-value,\nthough not very small, corresponded to Lag1. Perhaps by removing the\nvariables that appear not to be helpful in predicting Direction, we can\nobtain a more effective model. After all, using predictors that have no\nrelationship with the response tends to cause a deterioration in the test\nerror rate (since such predictors cause an increase in variance without a\ncorresponding decrease in bias), and so removing such predictors may in\nturn yield an improvement. Below we have refit the logistic regression using\njust Lag1 and Lag2, which seemed to have the highest predictive power in\nthe original logistic regression model.\n> glm.fits <- glm(Direction \u223c Lag1 + Lag2 , data = Smarket ,\nfamily = binomial , subset = train)\n> glm.probs <- predict(glm.fits , Smarket .2005,\ntype = \"response\")\n> glm.pred <- rep(\"Down\", 252)\n> glm.pred[glm.probs > .5] <- \"Up\"\n>", "doc_id": "877a72d0-8837-4d99-a084-82b699287a67", "embedding": null, "doc_hash": "7f1e259bdb1aaf275724aaa85fd9fdf15b298f92b5ef8f990c6837a4a8008445", "extra_info": null, "node_info": {"start": 428173, "end": 431651, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "42ef401a-78b2-4987-b2fd-bc119f22e3f3", "3": "59fd747a-c9c5-415b-a5b8-6457ac98725c"}}, "__type__": "1"}, "59fd747a-c9c5-415b-a5b8-6457ac98725c": {"__data__": {"text": "> .5] <- \"Up\"\n> table(glm.pred , Direction .2005)\nDirection .2005\nglm.pred Down Up\nDown 35 35\nUp 76 106\n> mean(glm.pred == Direction .2005)\n[1] 0.56\n> 106 / (106 + 76)\n[1] 0.582\n4.7 Lab: Classification Methods 177\nNow the results appear to be a little better: 56% of the daily movements\nhave been correctly predicted. It is worth noting that in this case, a much\nsimpler strategy of predicting that the market will increase every day will\nalso be correct 56% of the time! Hence, in terms of overall error rate, the\nlogistic regression method is no better than the naive approach. However,\nthe confusion matrix shows that on days when logistic regression predicts\nan increase in the market, it has a 58% accuracy rate. This suggests a\npossible trading strategy of buying on days when the model predicts an increasing\nmarket, and avoiding trades on days when a decrease is predicted.\nOf course one would need to investigate more carefully whether this small\nimprovement was real or just due to random chance.\nSuppose that we want to predict the returns associated with particular\nvalues of Lag1 and Lag2. In particular, we want to predict Direction on a\nday when Lag1 and Lag2 equal 1.2 and 1.1, respectively, and on a day when\nthey equal 1.5 and \u22120.8. We do this using the predict() function.\n> predict(glm.fits,\nnewdata =\ndata.frame(Lag1 = c(1.2 , 1.5) , Lag2 = c(1.1 , -0.8)),\ntype = \"response\"\n)\n1 2\n0.4791 0.4961\n4.7.3 Linear Discriminant Analysis\nNow we will perform LDA on the Smarket data. In R, we fit an LDA model\nusing the lda() function, which is part of the MASS library. Notice that the\nlda()\nsyntax for the lda() function is identical to that of lm(), and to that of\nglm() except for the absence of the family option. We fit the model using\nonly the observations before 2005.\n> library(MASS)\n> lda.fit <- lda(Direction \u223c Lag1 + Lag2 , data = Smarket ,\nsubset = train)\n> lda.fit\nCall:\nlda(Direction \u223c Lag1 + Lag2 , data = Smarket , subset = train)\nPrior probabilities of groups:\nDown Up\n0.492 0.508\nGroup means:\nLag1 Lag2\nDown 0.0428 0.0339\nUp -0.0395 -0.0313\n178 4. Classification\nCoefficients of linear discriminants:\nLD1\nLag1 -0.642\nLag2 -0.514\n> plot(lda.fit)\nThe LDA output indicates that \u02c6\u03c01 = 0.492 and \u02c6\u03c02 = 0.508; in other words,\n49.2% of the training observations correspond to days during which the\nmarket went down. It also provides the group means; these are the average\nof each predictor within each class, and are used by LDA as estimates of\n\u03bck. These suggest that there is a tendency for the previous 2 days\u2019 returns\nto be negative on days when the market increases, and a tendency for the\nprevious days\u2019 returns to be positive on days when the market declines. The\ncoefficients of linear discriminants output provides the linear combination\nof Lag1 and Lag2 that are used to form the LDA decision rule. In other\nwords, these are the multipliers of the elements of X = x in (4.24). If\n\u22120.642 \u00d7 Lag1 \u2212 0.514 \u00d7 Lag2 is large, then the LDA classifier will predict\na market increase, and if it is small, then the LDA classifier will predict a\nmarket decline.\nThe plot() function produces plots of the linear discriminants, obtained\nby computing", "doc_id": "59fd747a-c9c5-415b-a5b8-6457ac98725c", "embedding": null, "doc_hash": "4944ee9a81c0eaed7ebb4dc8220a0bd0ed37ec5a14e89d7e88291b94f2b708e7", "extra_info": null, "node_info": {"start": 431701, "end": 434869, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "877a72d0-8837-4d99-a084-82b699287a67", "3": "fb053df3-85cf-48a9-bbec-f049fc152d44"}}, "__type__": "1"}, "fb053df3-85cf-48a9-bbec-f049fc152d44": {"__data__": {"text": "function produces plots of the linear discriminants, obtained\nby computing \u22120.642\u00d7Lag1\u22120.514\u00d7Lag2 for each of the training observations.\nThe Up and Down observations are displayed separately.\nThe predict() function returns a list with three elements. The first element,\nclass, contains LDA\u2019s predictions about the movement of the market.\nThe second element, posterior, is a matrix whose kth column contains the\nposterior probability that the corresponding observation belongs to the kth\nclass, computed from (4.15). Finally, x contains the linear discriminants,\ndescribed earlier.\n> lda.pred <- predict(lda.fit , Smarket .2005)\n> names(lda.pred)\n[1] \"class\" \"posterior\" \"x\"\nAs we observed in Section 4.5, the LDA and logistic regression predictions\nare almost identical.\n> lda.class <- lda.pred$class\n> table(lda.class, Direction .2005)\nDirection .2005\nlda.pred Down Up\nDown 35 35\nUp 76 106\n> mean(lda.class == Direction .2005)\n[1] 0.56\nApplying a 50% threshold to the posterior probabilities allows us to recreate\nthe predictions contained in lda.pred$class.\n> sum(lda.pred$posterior[, 1] >= .5)\n[1] 70\n4.7 Lab: Classification Methods 179\n> sum(lda.pred$posterior[, 1] < .5)\n[1] 182\nNotice that the posterior probability output by the model corresponds to\nthe probability that the market will decrease:\n> lda.pred$posterior[1:20, 1]\n> lda.class[1:20]\nIf we wanted to use a posterior probability threshold other than 50% in\norder to make predictions, then we could easily do so. For instance, suppose\nthat we wish to predict a market decrease only if we are very certain that the\nmarket will indeed decrease on that day\u2014say, if the posterior probability\nis at least 90 %.\n> sum(lda.pred$posterior[, 1] > .9)\n[1] 0\nNo days in 2005 meet that threshold! In fact, the greatest posterior probability\nof decrease in all of 2005 was 52.02 %.\n4.7.4 Quadratic Discriminant Analysis\nWe will now fit a QDA model to the Smarket data. QDA is implemented\nin R using the qda() function, which is also part of the MASS library. The\nqda()\nsyntax is identical to that of lda().\n> qda.fit <- qda(Direction \u223c Lag1 + Lag2 , data = Smarket ,\nsubset = train)\n> qda.fit\nCall:\nqda(Direction \u223c Lag1 + Lag2 , data = Smarket , subset = train)\nPrior probabilities of groups:\nDown Up\n0.492 0.508\nGroup means:\nLag1 Lag2\nDown 0.0428 0.0339\nUp -0.0395 -0.0313\nThe output contains the group means. But it does not contain the coefficients\nof the linear discriminants, because the QDA classifier involves a\nquadratic, rather than a linear, function of the predictors. The predict()\nfunction works in exactly the same fashion as for LDA.\n> qda.class <- predict(qda.fit , Smarket .2005)$class\n> table(qda.class , Direction .2005)\nDirection .2005\nqda.class Down Up\nDown 30 20\n180 4. Classification\nUp 81 121\n> mean(qda.class == Direction .2005)\n[1] 0.599\nInterestingly, the QDA predictions are accurate almost 60% of the time,\neven though the 2005 data was not used to fit the model. This level of accuracy\nis quite impressive for stock market data, which is known to be quite\nhard to model accurately. This suggests that the quadratic form assumed\nby QDA may", "doc_id": "fb053df3-85cf-48a9-bbec-f049fc152d44", "embedding": null, "doc_hash": "10590e21e6c8b091f817c02b9959f6c14feec1ec186dca0889426e3b4bebcd6f", "extra_info": null, "node_info": {"start": 434816, "end": 437937, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "59fd747a-c9c5-415b-a5b8-6457ac98725c", "3": "a2c1328c-a9db-4207-8f2d-561d5011b572"}}, "__type__": "1"}, "a2c1328c-a9db-4207-8f2d-561d5011b572": {"__data__": {"text": "accurately. This suggests that the quadratic form assumed\nby QDA may capture the true relationship more accurately than the linear\nforms assumed by LDA and logistic regression. However, we recommend\nevaluating this method\u2019s performance on a larger test set before betting\nthat this approach will consistently beat the market!\n4.7.5 Naive Bayes\nNext, we fit a naive Bayes model to the Smarket data. Naive Bayes is implemented\nin R using the naiveBayes() function, which is part of the e1071\nnaiveBayes()\nlibrary. The syntax is identical to that of lda() and qda(). By default, this\nimplementation of the naive Bayes classifier models each quantitative feature\nusing a Gaussian distribution. However, a kernel density method can\nalso be used to estimate the distributions.\n> library(e1071)\n> nb.fit <- naiveBayes(Direction \u223c Lag1 + Lag2 , data = Smarket ,\nsubset = train)\n> nb.fit\nNaive Bayes Classifier for Discrete Predictors\nCall:\nnaiveBayes.default(x = X, y = Y, laplace = laplace)\nA-priori probabilities:\nY\nDown Up\n0.492 0.508\nConditional probabilities:\nLag1\nY [,1] [ ,2]\nDown 0.0428 1.23\nUp -0.0395 1.23\nLag2\nY [,1] [ ,2]\nDown 0.0339 1.24\nUp -0.0313 1.22\nThe output contains the estimated mean and standard deviation for each\nvariable in each class. For example, the mean for Lag1 is 0.0428 for\nDirection=Down, and the standard deviation is 1.23. We can easily verify\nthis:\n4.7 Lab: Classification Methods 181\n> mean(Lag1[train][Direction[train] == \"Down\"])\n[1] 0.0428\n> sd(Lag1[train][Direction[train] == \"Down\"])\n[1] 1.23\nThe predict() function is straightforward.\n> nb.class <- predict(nb.fit , Smarket .2005)\n> table(nb.class , Direction .2005)\nDirection .2005\nnb.class Down Up\nDown 28 20\nUp 83 121\n> mean(nb.class == Direction .2005)\n[1] 0.591\nNaive Bayes performs very well on this data, with accurate predictions over\n59% of the time. This is slightly worse than QDA, but much better than\nLDA.\nThe predict() function can also generate estimates of the probability\nthat each observation belongs to a particular class.\n> nb.preds <- predict(nb.fit , Smarket .2005, type = \"raw\")\n> nb.preds[1:5, ]\nDown Up\n[1,] 0.487 0.513\n[2,] 0.476 0.524\n[3,] 0.465 0.535\n[4,] 0.475 0.525\n[5,] 0.490 0.510\n4.7.6 K-Nearest Neighbors\nWe will now perform KNN using the knn() function, which is part of the\nknn()\nclass library. This function works rather differently from the other modelfitting\nfunctions that we have encountered thus far. Rather than a two-step\napproach in which we first fit the model and then we use the model to make\npredictions, knn() forms predictions using a single command. The function\nrequires four inputs.\n1. A matrix containing the predictors associated with the training data,\nlabeled train.X below.\n2. A matrix containing the predictors associated with the data for which\nwe wish to make predictions, labeled test.X below.\n3. A vector containing the class labels for the training observations,\nlabeled train.Direction below.\n4. A value for K, the number of nearest neighbors to be used by the\nclassifier.\n182 4. Classification\nWe use the cbind() function, short for column bind, to bind the Lag1 and\ncbind()\nLag2 variables together into", "doc_id": "a2c1328c-a9db-4207-8f2d-561d5011b572", "embedding": null, "doc_hash": "e0ac7b6178751548614483d5e3472c949aa462a2b560e6dfcc252d7dab4b181b", "extra_info": null, "node_info": {"start": 437945, "end": 441101, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "fb053df3-85cf-48a9-bbec-f049fc152d44", "3": "b1767e86-a268-4b07-9b70-ee033ed855b7"}}, "__type__": "1"}, "b1767e86-a268-4b07-9b70-ee033ed855b7": {"__data__": {"text": "to bind the Lag1 and\ncbind()\nLag2 variables together into two matrices, one for the training set and the\nother for the test set.\n> library(class)\n> train.X <- cbind(Lag1 , Lag2)[train , ]\n> test.X <- cbind(Lag1 , Lag2)[!train , ]\n> train.Direction <- Direction[train]\nNow the knn() function can be used to predict the market\u2019s movement for\nthe dates in 2005. We set a random seed before we apply knn() because\nif several observations are tied as nearest neighbors, then R will randomly\nbreak the tie. Therefore, a seed must be set in order to ensure reproducibility\nof results.\n> set.seed (1)\n> knn.pred <- knn(train.X, test.X, train.Direction , k = 1)\n> table(knn.pred , Direction .2005)\nDirection .2005\nknn.pred Down Up\nDown 43 58\nUp 68 83\n> (83 + 43) / 252\n[1] 0.5\nThe results using K = 1 are not very good, since only 50% of the observations\nare correctly predicted. Of course, it may be that K = 1 results in an\noverly flexible fit to the data. Below, we repeat the analysis using K = 3.\n> knn.pred <- knn(train.X, test.X, train.Direction , k = 3)\n> table(knn.pred , Direction .2005)\nDirection .2005\nknn.pred Down Up\nDown 48 54\nUp 63 87\n> mean(knn.pred == Direction .2005)\n[1] 0.536\nThe results have improved slightly. But increasing K further turns out\nto provide no further improvements. It appears that for this data, QDA\nprovides the best results of the methods that we have examined so far.\nKNN does not perform well on the Smarket data but it does often provide\nimpressive results. As an example we will apply the KNN approach to the\nCaravan data set, which is part of the ISLR2 library. This data set includes 85\npredictors that measure demographic characteristics for 5,822 individuals.\nThe response variable is Purchase, which indicates whether or not a given\nindividual purchases a caravan insurance policy. In this data set, only 6%\nof people purchased caravan insurance.\n> dim(Caravan)\n[1] 5822 86\n4.7 Lab: Classification Methods 183\n> attach(Caravan)\n> summary(Purchase)\nNo Yes\n5474 348\n> 348 / 5822\n[1] 0.0598\nBecause the KNN classifier predicts the class of a given test observation by\nidentifying the observations that are nearest to it, the scale of the variables\nmatters. Variables that are on a large scale will have a much larger effect\non the distance between the observations, and hence on the KNN classifier,\nthan variables that are on a small scale. For instance, imagine a data set\nthat contains two variables, salary and age (measured in dollars and years,\nrespectively). As far as KNN is concerned, a difference of $1,000 in salary\nis enormous compared to a difference of 50 years in age. Consequently,\nsalary will drive the KNN classification results, and age will have almost\nno effect. This is contrary to our intuition that a salary difference of $1,000\nis quite small compared to an age difference of 50 years. Furthermore, the\nimportance of scale to the KNN classifier leads to another issue: if we\nmeasured salary in Japanese yen, or if we measured age in minutes, then\nwe\u2019d get quite different classification results from what we get if these two\nvariables are measured in dollars and years.\nA good way to handle this problem is to standardize the data so that all\nstandardize\nvariables are given a mean of zero and a standard deviation of one. Then\nall variables will be on a comparable scale. The scale() function does just\nscale()\nthis. In standardizing the data, we exclude column 86, because that is", "doc_id": "b1767e86-a268-4b07-9b70-ee033ed855b7", "embedding": null, "doc_hash": "70643912a38bd54657cd00f0b7e0174c61043f99241b75f20f7fee18dbace87f", "extra_info": null, "node_info": {"start": 441111, "end": 444555, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "a2c1328c-a9db-4207-8f2d-561d5011b572", "3": "5f4bffd3-06c2-4ee7-a0b0-54c559512ed9"}}, "__type__": "1"}, "5f4bffd3-06c2-4ee7-a0b0-54c559512ed9": {"__data__": {"text": "In standardizing the data, we exclude column 86, because that is the\nqualitative Purchase variable.\n> standardized.X <- scale(Caravan[, -86])\n> var(Caravan[, 1])\n[1] 165\n> var(Caravan[, 2])\n[1] 0.165\n> var(standardized.X[, 1])\n[1] 1\n> var(standardized.X[, 2])\n[1] 1\nNow every column of standardized.X has a standard deviation of one and\na mean of zero.\nWe now split the observations into a test set, containing the first 1,000\nobservations, and a training set, containing the remaining observations.\nWe fit a KNN model on the training data using K = 1, and evaluate its\nperformance on the test data.\n> test <- 1:1000\n> train.X <- standardized.X[-test, ]\n> test.X <- standardized.X[test, ]\n> train.Y <- Purchase[-test]\n184 4. Classification\n> test.Y <- Purchase[test]\n> set.seed (1)\n> knn.pred <- knn(train.X, test.X, train.Y, k = 1)\n> mean(test.Y != knn.pred)\n[1] 0.118\n> mean(test.Y != \"No\")\n[1] 0.059\nThe vector test is numeric, with values from 1 through 1, 000. Typing\nstandardized.X[test, ] yields the submatrix of the data containing the\nobservations whose indices range from 1 to 1, 000, whereas typing\nstandardized.X[-test, ] yields the submatrix containing the observations\nwhose indices do not range from 1 to 1, 000. The KNN error rate on the\n1,000 test observations is just under 12%. At first glance, this may appear\nto be fairly good. However, since only 6% of customers purchased\ninsurance, we could get the error rate down to 6% by always predicting No\nregardless of the values of the predictors!\nSuppose that there is some non-trivial cost to trying to sell insurance\nto a given individual. For instance, perhaps a salesperson must visit each\npotential customer. If the company tries to sell insurance to a random\nselection of customers, then the success rate will be only 6 %, which may\nbe far too low given the costs involved. Instead, the company would like\nto try to sell insurance only to customers who are likely to buy it. So the\noverall error rate is not of interest. Instead, the fraction of individuals that\nare correctly predicted to buy insurance is of interest.\nIt turns out that KNN with K = 1 does far better than random guessing\namong the customers that are predicted to buy insurance. Among 77 such\ncustomers, 9, or 11.7 %, actually do purchase insurance. This is double the\nrate that one would obtain from random guessing.\n> table(knn.pred , test.Y)\ntest.Y\nknn.pred No Yes\nNo 873 50\nYes 68 9\n> 9 / (68 + 9)\n[1] 0.117\nUsing K = 3, the success rate increases to 19 %, and with K = 5 the rate is\n26.7 %. This is over four times the rate that results from random guessing.\nIt appears that KNN is finding some real patterns in a difficult data set!\n> knn.pred <- knn(train.X, test.X, train.Y, k = 3)\n> table(knn.pred , test.Y)\ntest.Y\nknn.pred No Yes\nNo 920 54\nYes 21 5\n> 5 / 26\n[1] 0.192\n> knn.pred <- knn(train.X, test.X, train.Y, k = 5)\n4.7 Lab: Classification Methods 185\n> table(knn.pred , test.Y)\ntest.Y\nknn.pred No Yes\nNo 930 55\nYes 11 4\n> 4 / 15\n[1] 0.267\nHowever, while this strategy is cost-effective, it is worth noting that only\n15 customers are predicted to purchase insurance using KNN with K =\n5.", "doc_id": "5f4bffd3-06c2-4ee7-a0b0-54c559512ed9", "embedding": null, "doc_hash": "f0832cb3712ca32870833b83e7d8158e4e729d800f4e8f959573b22fa005d484", "extra_info": null, "node_info": {"start": 444552, "end": 447692, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "b1767e86-a268-4b07-9b70-ee033ed855b7", "3": "babd0ef2-9432-4135-8f59-5d8a89e8611d"}}, "__type__": "1"}, "babd0ef2-9432-4135-8f59-5d8a89e8611d": {"__data__": {"text": "customers are predicted to purchase insurance using KNN with K =\n5. In practice, the insurance company may wish to expend resources on\nconvincing more than just 15 potential customers to buy insurance.\nAs a comparison, we can also fit a logistic regression model to the data.\nIf we use 0.5 as the predicted probability cut-off for the classifier, then\nwe have a problem: only seven of the test observations are predicted to\npurchase insurance. Even worse, we are wrong about all of these! However,\nwe are not required to use a cut-off of 0.5. If we instead predict a purchase\nany time the predicted probability of purchase exceeds 0.25, we get much\nbetter results: we predict that 33 people will purchase insurance, and we\nare correct for about 33% of these people. This is over five times better\nthan random guessing!\n> glm.fits <- glm(Purchase \u223c ., data = Caravan ,\nfamily = binomial , subset = -test)\nWarning message:\nglm.fits: fitted probabilities numerically 0 or 1 occurred\n> glm.probs <- predict(glm.fits , Caravan[test , ],\ntype = \"response \")\n> glm.pred <- rep(\"No\", 1000)\n> glm.pred[glm.probs > .5] <- \"Yes\"\n> table(glm.pred , test.Y)\ntest.Y\nglm.pred No Yes\nNo 934 59\nYes 7 0\n> glm.pred <- rep(\"No\", 1000)\n> glm.pred[glm.probs > .25] <- \"Yes\"\n> table(glm.pred , test.Y)\ntest.Y\nglm.pred No Yes\nNo 919 48\nYes 22 11\n> 11 / (22 + 11)\n[1] 0.333\n4.7.7 Poisson Regression\nFinally, we fit a Poisson regression model to the Bikeshare data set, which\nmeasures the number of bike rentals (bikers) per hour in Washington, DC.\nThe data can be found in the ISLR2 library.\n186 4. Classification\n> attach(Bikeshare)\n> dim(Bikeshare)\n[1] 8645 15\n> names(Bikeshare)\n[1] \"season\" \"mnth\" \"day\" \"hr\"\n[5] \"holiday\" \"weekday\" \"workingday\" \"weathersit\"\n[9] \"temp\" \"atemp\" \"hum\" \"windspeed\"\n[13] \"casual\" \"registered\" \"bikers\"\nWe begin by fitting a least squares linear regression model to the data.\n> mod.lm <- lm(\nbikers \u223c mnth + hr + workingday + temp + weathersit ,\ndata = Bikeshare\n)\n> summary(mod.lm)\nCall:\nlm(formula = bikers \u223c mnth + hr + workingday + temp +\nweathersit , data = Bikeshare)\nResiduals:\nMin 1Q Median 3Q Max\n-299.00 -45.70 -6.23 41.08 425.29\nCoefficients:\nEstimate Std. Error t value Pr(>|t|)\n(Intercept) -68.632 5.307 -12.932 < 2e-16 ***\nmnthFeb 6.845 4.287 1.597 0.110398\nmnthMarch 16.551 4.301 3.848 0.000120 ***\nmnthApril 41.425 4.972 8.331 < 2e-16 ***\nmnthMay 72.557 5.641 12.862 < 2e-16 ***\nDue to space constraints, we truncate the output of summary(mod.lm). In\nmod.lm, the first level of hr (0) and mnth (Jan) are treated as the baseline\nvalues, and so no coefficient estimates are provided for them: implicitly,\ntheir coefficient estimates are zero, and all other levels are measured relative\nto these baselines. For example, the Feb coefficient of 6.845 signifies that,\nholding all other variables constant, there are on average about 7 more\nriders in February than in January. Similarly there are about 16.5", "doc_id": "babd0ef2-9432-4135-8f59-5d8a89e8611d", "embedding": null, "doc_hash": "809dbec6d88c30951da04d6888a89395d1cc76fe50bdd254978268259910cb83", "extra_info": null, "node_info": {"start": 447690, "end": 450615, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "5f4bffd3-06c2-4ee7-a0b0-54c559512ed9", "3": "ba308d1d-77f8-4dca-80d4-94675cec276d"}}, "__type__": "1"}, "ba308d1d-77f8-4dca-80d4-94675cec276d": {"__data__": {"text": "average about 7 more\nriders in February than in January. Similarly there are about 16.5 more\nriders in March than in January.\nThe results seen in Section 4.6.1 used a slightly different coding of the\nvariables hr and mnth, as follows:\n> contrasts(Bikeshare$hr) = contr.sum (24)\n> contrasts(Bikeshare$mnth) = contr.sum (12)\n> mod.lm2 <- lm(\nbikers \u223c mnth + hr + workingday + temp + weathersit ,\ndata = Bikeshare\n)\n> summary(mod.lm2)\nCall:\nlm(formula = bikers \u223c mnth + hr + workingday + temp +\nweathersit , data = Bikeshare)\n4.7 Lab: Classification Methods 187\nResiduals:\nMin 1Q Median 3Q Max\n-299.00 -45.70 -6.23 41.08 425.29\nCoefficients:\nEstimate Std. Error t value Pr(>|t|)\n(Intercept) 73.597 5.132 14.340 < 2e-16 ***\nmnth1 -46.087 4.086 -11.281 < 2e-16 ***\nmnth2 -39.242 3.539 -11.088 < 2e-16 ***\nmnth3 -29.536 3.155 -9.361 < 2e-16 ***\nmnth4 -4.662 2.741 -1.701 0.08895 .\nWhat is the difference between the two codings? In mod.lm2, a coefficient\nestimate is reported for all but the last level of hr and mnth. Importantly,\nin mod.lm2, the coefficient estimate for the last level of mnth is not zero:\ninstead, it equals the negative of the sum of the coefficient estimates for\nall of the other levels. Similarly, in mod.lm2, the coefficient estimate for the\nlast level of hr is the negative of the sum of the coefficient estimates for\nall of the other levels. This means that the coefficients of hr and mnth in\nmod.lm2 will always sum to zero, and can be interpreted as the difference\nfrom the mean level. For example, the coefficient for January of \u221246.087\nindicates that, holding all other variables constant, there are typically 46\nfewer riders in January relative to the yearly average.\nIt is important to realize that the choice of coding really does not matter,\nprovided that we interpret the model output correctly in light of the coding\nused. For example, we see that the predictions from the linear model are\nthe same regardless of coding:\n> sum(( predict(mod.lm) - predict(mod.lm2))^2)\n[1] 1.426e-18\nThe sum of squared differences is zero. We can also see this using the\nall.equal() function:\nall.equal()\n> all.equal(predict(mod.lm), predict(mod.lm2))\nTo reproduce the left-hand side of Figure 4.13, we must first obtain\nthe coefficient estimates associated with mnth. The coefficients for January\nthrough November can be obtained directly from the mod.lm2 object. The\ncoefficient for December must be explicitly computed as the negative sum\nof all the other months.\n> coef.months <- c(coef(mod.lm2)[2:12],\n-sum(coef(mod.lm2)[2:12]))\nTo make the plot, we manually label the x-axis with the names of the\nmonths.\n> plot(coef.months , xlab = \"Month\", ylab = \"Coefficient\",\nxaxt = \"n\", col = \"blue\", pch = 19, type = \"o\")\n188 4. Classification\n> axis(side = 1, at = 1:12, labels = c(\"J\", \"F\", \"M\", \"A\",\n\"M\", \"J\", \"J\", \"A\", \"S\", \"O\", \"N\", \"D\"))\nReproducing the right-hand side of Figure 4.13 follows a similar process.\n> coef.hours <- c(coef(mod.lm2)[13:35]", "doc_id": "ba308d1d-77f8-4dca-80d4-94675cec276d", "embedding": null, "doc_hash": "6ebd2a24b6299a047898b8d9f506a801993e8171a2d67ed8bc806fb3c555aadf", "extra_info": null, "node_info": {"start": 450599, "end": 453563, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "babd0ef2-9432-4135-8f59-5d8a89e8611d", "3": "80febbc7-352c-420d-87e3-2e19efe3f38b"}}, "__type__": "1"}, "80febbc7-352c-420d-87e3-2e19efe3f38b": {"__data__": {"text": "<- c(coef(mod.lm2)[13:35] ,\n-sum(coef(mod.lm2)[13:35]))\n> plot(coef.hours , xlab = \"Hour\", ylab = \"Coefficient\",\ncol = \"blue\", pch = 19, type = \"o\")\nNow, we consider instead fitting a Poisson regression model to the Bikeshare\ndata. Very little changes, except that we now use the function glm() with\nthe argument family = poisson to specify that we wish to fit a Poisson\nregression model:\n> mod.pois <- glm(\nbikers \u223c mnth + hr + workingday + temp + weathersit ,\ndata = Bikeshare , family = poisson\n)\n> summary(mod.pois)\nCall:\nglm(formula = bikers \u223c mnth + hr + workingday + temp +\nweathersit , family = poisson , data = Bikeshare)\nDeviance Residuals:\nMin 1Q Median 3Q Max\n-20.7574 -3.3441 -0.6549 2.6999 21.9628\nCoefficients:\nEstimate Std. Error z value Pr(>|z|)\n(Intercept) 4.118245 0.006021 683.964 < 2e-16 ***\nmnth1 -0.670170 0.005907 -113.445 < 2e-16 ***\nmnth2 -0.444124 0.004860 -91.379 < 2e-16 ***\nmnth3 -0.293733 0.004144 -70.886 < 2e-16 ***\nmnth4 0.021523 0.003125 6.888 5.66e-12 ***\nWe can plot the coefficients associated with mnth and hr, in order to reproduce\nFigure 4.15:\n> coef.mnth <- c(coef(mod.pois)[2:12] ,\n-sum(coef(mod.pois)[2:12]))\n> plot(coef.mnth , xlab = \"Month\", ylab = \"Coefficient\",\nxaxt = \"n\", col = \"blue\", pch = 19, type = \"o\")\n> axis(side = 1, at = 1:12, labels = c(\"J\", \"F\", \"M\", \"A\", \"M\",\n\"J\", \"J\", \"A\", \"S\", \"O\", \"N\", \"D\"))\n> coef.hours <- c(coef(mod.pois)[13:35] ,\n-sum(coef(mod.pois)[13:35]))\n> plot(coef.hours , xlab = \"Hour\", ylab = \"Coefficient\",\ncol = \"blue\", pch = 19, type = \"o\")\nWe can once again use the predict() function to obtain the fitted values\n(predictions) from this Poisson regression model. However, we must use the\nargument type = \"response\" to specify that we want R to output exp( \u02c6 \u03b20 +\n\u02c6 \u03b21X1+. . .+ \u02c6 \u03b2pXp) rather than \u02c6 \u03b20+ \u02c6 \u03b21X1+. . .+ \u02c6 \u03b2pXp, which it will output\nby default.\n4.8 Exercises 189\n> plot(predict(mod.lm2), predict(mod.pois , type = \"response\"))\n> abline (0, 1, col = 2, lwd = 3)\nThe predictions from the Poisson regression model are correlated with those\nfrom the linear model; however, the former are non-negative. As a result\nthe Poisson regression predictions tend to be larger than those from the\nlinear model for either very low or very high levels of ridership.\nIn this section, we used the glm() function with the argument family =\npoisson in order to perform Poisson regression. Earlier in this lab we used\nthe glm() function with family = binomial to perform logistic regression.\nOther choices for the family argument can be used to fit other types of\nGLMs. For instance, family = Gamma fits a gamma regression model.\n4.8 Exercises\nConceptual\n1. Using a little bit of algebra, prove that (4.2) is equivalent to (4.3). In\nother words, the", "doc_id": "80febbc7-352c-420d-87e3-2e19efe3f38b", "embedding": null, "doc_hash": "dc42184307e080f8d8c8c4dba6666f304bec55aa58f5627dc7ddefb9d0a34cff", "extra_info": null, "node_info": {"start": 453614, "end": 456337, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "ba308d1d-77f8-4dca-80d4-94675cec276d", "3": "69445a51-5d9d-4d92-9fe3-7ffe76401202"}}, "__type__": "1"}, "69445a51-5d9d-4d92-9fe3-7ffe76401202": {"__data__": {"text": "(4.2) is equivalent to (4.3). In\nother words, the logistic function representation and logit representation\nfor the logistic regression model are equivalent.\n2. It was stated in the text that classifying an observation to the class\nfor which (4.17) is largest is equivalent to classifying an observation\nto the class for which (4.18) is largest. Prove that this is the case. In\nother words, under the assumption that the observations in the kth\nclass are drawn from a N(\u03bck,\u03c32) distribution, the Bayes classifier\nassigns an observation to the class for which the discriminant function\nis maximized.\n3. This problem relates to the QDA model, in which the observations\nwithin each class are drawn from a normal distribution with a classspecific\nmean vector and a class specific covariance matrix. We consider\nthe simple case where p = 1; i.e. there is only one feature.\nSuppose that we have K classes, and that if an observation belongs\nto the kth class then X comes from a one-dimensional normal distribution,\nX \u223c N(\u03bck,\u03c32\nk). Recall that the density function for the\none-dimensional normal distribution is given in (4.16). Prove that in\nthis case, the Bayes classifier is not linear. Argue that it is in fact\nquadratic.\nHint: For this problem, you should follow the arguments laid out in\nSection 4.4.1, but without making the assumption that \u03c32\n1 = . . . = \u03c32K\n.\n4. When the number of features p is large, there tends to be a deterioration\nin the performance of KNN and other local approaches that\n190 4. Classification\nperform prediction using only observations that are near the test observation\nfor which a prediction must be made. This phenomenon is\nknown as the curse of dimensionality, and it ties into the fact that\ncurse of dinon-\nparametric approaches often perform poorly when p is large. We mensionality\nwill now investigate this curse.\n(a) Suppose that we have a set of observations, each with measurements\non p = 1 feature, X. We assume that X is uniformly\n(evenly) distributed on [0, 1]. Associated with each observation\nis a response value. Suppose that we wish to predict a test observation\u2019s\nresponse using only observations that are within 10% of\nthe range of X closest to that test observation. For instance, in\norder to predict the response for a test observation with X = 0.6,\nwe will use observations in the range [0.55, 0.65]. On average,\nwhat fraction of the available observations will we use to make\nthe prediction?\n(b) Now suppose that we have a set of observations, each with\nmeasurements on p = 2 features, X1 and X2. We assume that\n(X1,X2) are uniformly distributed on [0, 1] \u00d7 [0, 1]. We wish to\npredict a test observation\u2019s response using only observations that\nare within 10% of the range of X1 and within 10% of the range\nof X2 closest to that test observation. For instance, in order to\npredict the response for a test observation with X1 = 0.6 and\nX2 = 0.35, we will use observations in the range [0.55, 0.65] for\nX1 and in the range [0.3, 0.4] for X2. On average, what fraction\nof the available observations will we use to make the prediction?\n(c) Now suppose that we have a set of observations on p = 100 features.\nAgain the observations are uniformly distributed on each\nfeature, and again each feature ranges in value from 0 to 1. We\nwish to predict a test observation\u2019s response using observations\nwithin the 10% of each feature\u2019s range that is closest to that test\nobservation. What fraction of the available observations will we\nuse to make the prediction?\n(d) Using your answers", "doc_id": "69445a51-5d9d-4d92-9fe3-7ffe76401202", "embedding": null, "doc_hash": "1b1afe7624b78f5922f63f7b2aae4cf28ff7b8363663c6ff2e56f8d7516f723c", "extra_info": null, "node_info": {"start": 456320, "end": 459840, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "80febbc7-352c-420d-87e3-2e19efe3f38b", "3": "a252aec2-a725-4e95-bbad-b953fcf3f470"}}, "__type__": "1"}, "a252aec2-a725-4e95-bbad-b953fcf3f470": {"__data__": {"text": "will we\nuse to make the prediction?\n(d) Using your answers to parts (a)\u2013(c), argue that a drawback of\nKNN when p is large is that there are very few training observations\n\u201cnear\u201d any given test observation.\n(e) Now suppose that we wish to make a prediction for a test observation\nby creating a p-dimensional hypercube centered around\nthe test observation that contains, on average, 10% of the training\nobservations. For p = 1, 2, and 100, what is the length of\neach side of the hypercube? Comment on your answer.\n4.8 Exercises 191\nNote: A hypercube is a generalization of a cube to an arbitrary\nnumber of dimensions. When p = 1, a hypercube is simply a line\nsegment, when p = 2 it is a square, and when p = 100 it is a\n100-dimensional cube.\n5. We now examine the differences between LDA and QDA.\n(a) If the Bayes decision boundary is linear, do we expect LDA or\nQDA to perform better on the training set? On the test set?\n(b) If the Bayes decision boundary is non-linear, do we expect LDA\nor QDA to perform better on the training set? On the test set?\n(c) In general, as the sample size n increases, do we expect the test\nprediction accuracy of QDA relative to LDA to improve, decline,\nor be unchanged? Why?\n(d) True or False: Even if the Bayes decision boundary for a given\nproblem is linear, we will probably achieve a superior test error\nrate using QDA rather than LDA because QDA is flexible\nenough to model a linear decision boundary. Justify your answer.\n6. Suppose we collect data for a group of students in a statistics class\nwith variables X1 =hours studied, X2 =undergrad GPA, and Y =\nreceive an A. We fit a logistic regression and produce estimated\ncoefficient, \u02c6 \u03b20 = \u22126, \u02c6 \u03b21 = 0.05, \u02c6 \u03b22 = 1.\n(a) Estimate the probability that a student who studies for 40 h and\nhas an undergrad GPA of 3.5 gets an A in the class.\n(b) How many hours would the student in part (a) need to study to\nhave a 50% chance of getting an A in the class?\n7. Suppose that we wish to predict whether a given stock will issue a\ndividend this year (\u201cYes\u201d or \u201cNo\u201d) based on X, last year\u2019s percent\nprofit.We examine a large number of companies and discover that the\nmean value of X for companies that issued a dividend was \u00afX = 10,\nwhile the mean for those that didn\u2019t was \u00afX = 0. In addition, the\nvariance of X for these two sets of companies was \u02c6\u03c32 = 36. Finally,\n80% of companies issued dividends. Assuming that X follows a normal\ndistribution, predict the probability that a company will issue\na dividend this year given that its percentage profit was X = 4 last\nyear.\nHint: Recall that the density function for a normal random variable\nis f(x) = 1 \u221a2\u03c0\u03c32 e\u2212(x\u2212\u03bc)2/2\u03c32\n. You will need to use Bayes\u2019 theorem.\n8. Suppose that we take a data set, divide it into equally-sized training\nand test sets, and then try out two different classification procedures.\n192 4. Classification\nFirst we use logistic regression and get an error rate of 20% on the\ntraining data and 30% on the test data. Next we use 1-nearest neighbors\n(i.e. K = 1) and get an average error rate (averaged over both\ntest and training data sets) of 18 %. Based on these results, which\nmethod should we prefer to use for classification of new observations?\nWhy?\n9. This problem has to do with odds.\n(a) On average, what fraction of people with an odds of 0.37 of\ndefaulting on their credit card payment will in fact default?\n(b) Suppose that an individual has", "doc_id": "a252aec2-a725-4e95-bbad-b953fcf3f470", "embedding": null, "doc_hash": "f06cf023ad10607bdc9c1b28f7b7e282cf0c9232d3c82e9eaaa8dbf34a9d1352", "extra_info": null, "node_info": {"start": 459833, "end": 463239, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "69445a51-5d9d-4d92-9fe3-7ffe76401202", "3": "0995cfe8-9e82-417c-ba4f-2b505793b352"}}, "__type__": "1"}, "0995cfe8-9e82-417c-ba4f-2b505793b352": {"__data__": {"text": "on their credit card payment will in fact default?\n(b) Suppose that an individual has a 16% chance of defaulting on\nher credit card payment. What are the odds that she will default?\n10. Equation 4.32 derived an expression for log\n1\nPr(Y =k|X=x)\nPr(Y =K|X=x)\n2\nin the\nsetting where p > 1, so that the mean for the kth class, \u03bck, is a pdimensional\nvector, and the shared covariance \u03a3 is a p \u00d7 p matrix.\nHowever, in the setting with p = 1, (4.32) takes a simpler form, since\nthe means \u03bc1, . . . ,\u03bcK and the variance \u03c32 are scalars. In this simpler\nsetting, repeat the calculation in (4.32), and provide expressions for\nak and bkj in terms of \u03c0k, \u03c0K, \u03bck, \u03bcK, and \u03c32.\n11. Work out the detailed forms of ak, bkj, and bkjl in (4.33). Your answer\nshould involve \u03c0k, \u03c0K, \u03bck, \u03bcK, \u03a3k, and \u03a3K.\n12. Suppose that you wish to classify an observation X \u2208 R into apples\nand oranges. You fit a logistic regression model and find that\n6Pr(Y = orange|X = x) =\nexp( \u02c6 \u03b20 + \u02c6 \u03b21x)\n1 + exp( \u02c6 \u03b20 + \u02c6 \u03b21x)\n.\nYour friend fits a logistic regression model to the same data using the\nsoftmax formulation in (4.13), and finds that\n6Pr(Y = orange|X = x) =\nexp(\u02c6\u03b1orange0 + \u02c6\u03b1orange1x)\nexp(\u02c6\u03b1orange0 + \u02c6\u03b1orange1x) + exp(\u02c6\u03b1apple0 + \u02c6\u03b1apple1x)\n.\n(a) What is the log odds of orange versus apple in your model?\n(b) What is the log odds of orange versus apple in your friend\u2019s\nmodel?\n(c) Suppose that in your model, \u02c6 \u03b20 = 2 and \u02c6 \u03b21 = \u22121. What are\nthe coefficient estimates in your friend\u2019s model? Be as specific\nas possible.\n4.8 Exercises 193\n(d) Now suppose that you and your friend fit the same two models\non a different data set. This time, your friend gets the coefficient\nestimates \u02c6\u03b1orange0 = 1.2, \u02c6\u03b1orange1 = \u22122, \u02c6\u03b1apple0 = 3, \u02c6\u03b1apple1 =\n0.6. What are the coefficient estimates in your model?\n(e) Finally, suppose you apply both models from (d) to a data set\nwith 2,000 test observations. What fraction of the time do you\nexpect the predicted class labels from your model to agree with\nthose from your friend\u2019s model? Explain your answer.\nApplied\n13. This question should be answered using the Weekly data set, which\nis part of the ISLR2 package. This data is similar in nature to the\nSmarket data from this chapter\u2019s lab, except that it contains 1, 089\nweekly returns for 21 years, from the beginning of 1990 to the end of\n2010.\n(a) Produce some numerical and graphical summaries of the Weekly\ndata. Do there appear to be any patterns?\n(b) Use the full data set to perform a logistic regression with\nDirection as the response and the five lag variables plus Volume\nas predictors. Use the summary function to print the results. Do\nany of the predictors appear to be statistically significant? If so,\nwhich ones?\n(c) Compute the confusion matrix and overall fraction of correct\npredictions. Explain what the confusion matrix is telling you\nabout the types of mistakes made by logistic regression.\n(d) Now fit the logistic regression model using a training data period\nfrom 1990 to 2008, with Lag2 as the only predictor. Compute the\nconfusion matrix and the overall fraction of correct predictions\nfor the held out data (that is, the data from 2009 and 2010).\n(e) Repeat (d) using LDA.\n(f) Repeat", "doc_id": "0995cfe8-9e82-417c-ba4f-2b505793b352", "embedding": null, "doc_hash": "24e3806221866fd42554dd7e05a8e48368f387c95bd5548b00ec2581c4a428a0", "extra_info": null, "node_info": {"start": 463218, "end": 466384, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "a252aec2-a725-4e95-bbad-b953fcf3f470", "3": "5aec5961-e2a0-4a30-8daf-1fed7a635e4a"}}, "__type__": "1"}, "5aec5961-e2a0-4a30-8daf-1fed7a635e4a": {"__data__": {"text": "and 2010).\n(e) Repeat (d) using LDA.\n(f) Repeat (d) using QDA.\n(g) Repeat (d) using KNN with K = 1.\n(h) Repeat (d) using naive Bayes.\n(i) Which of these methods appears to provide the best results on\nthis data?\n(j) Experiment with different combinations of predictors, including\npossible transformations and interactions, for each of the\nmethods. Report the variables, method, and associated confusion\nmatrix that appears to provide the best results on the held\nout data. Note that you should also experiment with values for\nK in the KNN classifier.\n194 4. Classification\n14. In this problem, you will develop a model to predict whether a given\ncar gets high or low gas mileage based on the Auto data set.\n(a) Create a binary variable, mpg01, that contains a 1 if mpg contains\na value above its median, and a 0 if mpg contains a value below\nits median. You can compute the median using the median()\nfunction. Note you may find it helpful to use the data.frame()\nfunction to create a single data set containing both mpg01 and\nthe other Auto variables.\n(b) Explore the data graphically in order to investigate the association\nbetween mpg01 and the other features. Which of the other\nfeatures seem most likely to be useful in predicting mpg01? Scatterplots\nand boxplots may be useful tools to answer this question.\nDescribe your findings.\n(c) Split the data into a training set and a test set.\n(d) Perform LDA on the training data in order to predict mpg01\nusing the variables that seemed most associated with mpg01 in\n(b). What is the test error of the model obtained?\n(e) Perform QDA on the training data in order to predict mpg01\nusing the variables that seemed most associated with mpg01 in\n(b). What is the test error of the model obtained?\n(f) Perform logistic regression on the training data in order to predict\nmpg01 using the variables that seemed most associated with\nmpg01 in (b). What is the test error of the model obtained?\n(g) Perform naive Bayes on the training data in order to predict\nmpg01 using the variables that seemed most associated with mpg01\nin (b). What is the test error of the model obtained?\n(h) Perform KNN on the training data, with several values of K, in\norder to predict mpg01. Use only the variables that seemed most\nassociated with mpg01 in (b). What test errors do you obtain?\nWhich value of K seems to perform the best on this data set?\n15. This problem involves writing functions.\n(a) Write a function, Power(), that prints out the result of raising 2\nto the 3rd power. In other words, your function should compute\n23 and print out the results.\nHint: Recall that x^a raises x to the power a. Use the print()\nfunction to output the result.\n(b) Create a new function, Power2(), that allows you to pass any\ntwo numbers, x and a, and prints out the value of x^a. You can\ndo this by beginning your function with the line\n> Power2 <- function(x, a) {\n4.8 Exercises 195\nYou should be able to call your function by entering, for instance,\n> Power2(3, 8)\non the command line. This should output the value of 38, namely,\n6, 561.\n(c) Using the Power2() function that you just wrote, compute 103,\n817, and 1313.\n(d) Now create a new function, Power3(), that actually returns the\nresult x^a as an R object, rather than simply printing it to the\nscreen. That is, if you store the value x^a in an object called\nresult within your function, then you can simply return() this\nreturn()\nresult, using the following line:\nreturn(result)\nThe line above should be the last line in your function, before\nthe } symbol.\n(e) Now using the Power3() function, create a plot of f(x) =", "doc_id": "5aec5961-e2a0-4a30-8daf-1fed7a635e4a", "embedding": null, "doc_hash": "3ee9b717f0cd891361d009544401197f4d81623baf331f57f7690f7cdd82d536", "extra_info": null, "node_info": {"start": 466416, "end": 470008, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "0995cfe8-9e82-417c-ba4f-2b505793b352", "3": "d69535b8-b87d-4f21-89f0-2a26d55fafcd"}}, "__type__": "1"}, "d69535b8-b87d-4f21-89f0-2a26d55fafcd": {"__data__": {"text": "Now using the Power3() function, create a plot of f(x) = x2.\nThe x-axis should display a range of integers from 1 to 10, and\nthe y-axis should display x2. Label the axes appropriately, and\nuse an appropriate title for the figure. Consider displaying either\nthe x-axis, the y-axis, or both on the log-scale. You can do this\nby using log = \"x\", log = \"y\", or log = \"xy\" as arguments to\nthe plot() function.\n(f) Create a function, PlotPower(), that allows you to create a plot\nof x against x^a for a fixed a and for a range of values of x. For\ninstance, if you call\n> PlotPower(1:10, 3)\nthen a plot should be created with an x-axis taking on values\n1, 2, . . . , 10, and a y-axis taking on values 13, 23, . . . , 103.\n16. Using the Boston data set, fit classification models in order to predict\nwhether a given census tract has a crime rate above or below the median.\nExplore logistic regression, LDA, naive Bayes, and KNN models\nusing various subsets of the predictors. Describe your findings.\nHint: You will have to create the response variable yourself, using the\nvariables that are contained in the Boston data set.\n5\nResampling Methods\nResampling methods are an indispensable tool in modern statistics. They\ninvolve repeatedly drawing samples from a training set and refitting a model\nof interest on each sample in order to obtain additional information about\nthe fitted model. For example, in order to estimate the variability of a linear\nregression fit, we can repeatedly draw different samples from the training\ndata, fit a linear regression to each new sample, and then examine the\nextent to which the resulting fits differ. Such an approach may allow us to\nobtain information that would not be available from fitting the model only\nonce using the original training sample.\nResampling approaches can be computationally expensive, because they\ninvolve fitting the same statistical method multiple times using different\nsubsets of the training data. However, due to recent advances in computing\npower, the computational requirements of resampling methods generally\nare not prohibitive. In this chapter, we discuss two of the most commonly\nused resampling methods, cross-validation and the bootstrap. Both methods\nare important tools in the practical application of many statistical learning\nprocedures. For example, cross-validation can be used to estimate the test\nerror associated with a given statistical learning method in order to evaluate\nits performance, or to select the appropriate level of flexibility. The process\nof evaluating a model\u2019s performance is known as model assessment, whereas\nmodel\nthe process of selecting the proper level of flexibility for a model is known as assessment\nmodel selection. The bootstrap is used in several contexts, most commonly\nmodel\nto provide a measure of accuracy of a parameter estimate or of a given selection\nstatistical learning method.\n\u00a9 Springer Science+Business Media, LLC, part of Springer Nature 2021\nG. James et al., An Introduction to Statistical Learning, Springer Texts in Statistics,\n197\nhttps://doi.org/10.1007/978-1-0716-1418-1_5\n198 5. Resampling Methods\n5.1 Cross-Validation\nIn Chapter 2 we discuss the distinction between the test error rate and the\ntraining error rate. The test error is the average error that results from using\na statistical learning method to predict the response on a new observation\u2014\nthat is, a measurement that was not used in training the method. Given\na data set, the use of a particular statistical learning method is warranted\nif it results in a low test error. The test error can be easily calculated if a\ndesignated test set is available. Unfortunately, this is usually not the case.\nIn contrast, the training error can be easily calculated by applying the\nstatistical learning method to the observations used in its training. But as\nwe saw in Chapter 2, the training error rate often is quite different from the\ntest error rate, and in particular the former can dramatically underestimate\nthe latter.\nIn the absence of a very", "doc_id": "d69535b8-b87d-4f21-89f0-2a26d55fafcd", "embedding": null, "doc_hash": "ce94f32600f9b0224ab110a13d112a3be647387afd4ddeafe40a8cb379a01b8e", "extra_info": null, "node_info": {"start": 470004, "end": 474029, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "5aec5961-e2a0-4a30-8daf-1fed7a635e4a", "3": "96588231-34a5-49fc-b60d-f0fe6135f399"}}, "__type__": "1"}, "96588231-34a5-49fc-b60d-f0fe6135f399": {"__data__": {"text": "can dramatically underestimate\nthe latter.\nIn the absence of a very large designated test set that can be used to\ndirectly estimate the test error rate, a number of techniques can be used\nto estimate this quantity using the available training data. Some methods\nmake a mathematical adjustment to the training error rate in order to\nestimate the test error rate. Such approaches are discussed in Chapter 6.\nIn this section, we instead consider a class of methods that estimate the\ntest error rate by holding out a subset of the training observations from the\nfitting process, and then applying the statistical learning method to those\nheld out observations.\nIn Sections 5.1.1\u20135.1.4, for simplicity we assume that we are interested\nin performing regression with a quantitative response. In Section 5.1.5 we\nconsider the case of classification with a qualitative response. As we will\nsee, the key concepts remain the same regardless of whether the response\nis quantitative or qualitative.\n5.1.1 The Validation Set Approach\nSuppose that we would like to estimate the test error associated with fitting\na particular statistical learning method on a set of observations. The\nvalidation set approach, displayed in Figure 5.1, is a very simple strategy\nvalidation\nfor this task. It involves randomly dividing the available set of observa- set approach\ntions into two parts, a training set and a validation set or hold-out set. The\nvalidation\nset\nhold-out set\nmodel is fit on the training set, and the fitted model is used to predict the\nresponses for the observations in the validation set. The resulting validation\nset error rate\u2014typically assessed using MSE in the case of a quantitative\nresponse\u2014provides an estimate of the test error rate.\nWe illustrate the validation set approach on the Auto data set. Recall from\nChapter 3 that there appears to be a non-linear relationship between mpg\nand horsepower, and that a model that predicts mpg using horsepower and\nhorsepower2 gives better results than a model that uses only a linear term.\nIt is natural to wonder whether a cubic or higher-order fit might provide\n5.1 Cross-Validation 199\n!\"#\"$\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"%\"\n&\"\"##\"\"!$\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"'!\"\nFIGURE 5.1. A schematic display of the validation set approach. A set of n\nobservations are randomly split into a training set (shown in blue, containing\nobservations 7, 22, and 13, among others) and a validation set (shown in beige,\nand containing observation 91, among others). The statistical learning method is\nfit on the training set, and its performance is evaluated on the validation set.\neven better results. We answer this question in Chapter 3 by looking at\nthe p-values associated with a cubic term and higher-order polynomial\nterms in a linear regression. But we could also answer this question using\nthe validation method. We randomly split the 392 observations into two\nsets, a training set containing 196 of the data points, and a validation set\ncontaining the remaining 196 observations. The validation set error rates\nthat result from fitting various regression models on the training sample\nand evaluating their performance on the validation sample, using MSE\nas a measure of validation set error, are shown in the left-hand panel of\nFigure 5.2. The validation set MSE for the quadratic fit is considerably\nsmaller than for the linear fit. However, the validation set MSE for the cubic\nfit is actually slightly larger than for the quadratic fit. This implies that\nincluding a cubic term in the regression does not lead to better prediction\nthan simply using a quadratic term.\nRecall", "doc_id": "96588231-34a5-49fc-b60d-f0fe6135f399", "embedding": null, "doc_hash": "1fe74a1e5d3d373a7bc4e0b4dc42fa341edd697eb98f6f587cc29ba53a6dabb4", "extra_info": null, "node_info": {"start": 474017, "end": 477811, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "d69535b8-b87d-4f21-89f0-2a26d55fafcd", "3": "ba996f5e-6a85-42d3-a901-fad454dd4aea"}}, "__type__": "1"}, "ba996f5e-6a85-42d3-a901-fad454dd4aea": {"__data__": {"text": "not lead to better prediction\nthan simply using a quadratic term.\nRecall that in order to create the left-hand panel of Figure 5.2, we randomly\ndivided the data set into two parts, a training set and a validation\nset. If we repeat the process of randomly splitting the sample set into two\nparts, we will get a somewhat different estimate for the test MSE. As an\nillustration, the right-hand panel of Figure 5.2 displays ten different validation\nset MSE curves from the Auto data set, produced using ten different\nrandom splits of the observations into training and validation sets. All ten\ncurves indicate that the model with a quadratic term has a dramatically\nsmaller validation set MSE than the model with only a linear term. Furthermore,\nall ten curves indicate that there is not much benefit in including\ncubic or higher-order polynomial terms in the model. But it is worth noting\nthat each of the ten curves results in a different test MSE estimate for each\nof the ten regression models considered. And there is no consensus among\nthe curves as to which model results in the smallest validation set MSE.\nBased on the variability among these curves, all that we can conclude with\nany confidence is that the linear fit is not adequate for this data.\nThe validation set approach is conceptually simple and is easy to implement.\nBut it has two potential drawbacks:\n200 5. Resampling Methods\n2 4 6 8 10\n16 18 20 22 24 26 28\nDegree of Polynomial\nMean Squared Error\n2 4 6 8 10\n16 18 20 22 24 26 28\nDegree of Polynomial\nMean Squared Error\nFIGURE 5.2. The validation set approach was used on the Auto data set in\norder to estimate the test error that results from predicting mpg using polynomial\nfunctions of horsepower. Left: Validation error estimates for a single split into\ntraining and validation data sets. Right: The validation method was repeated ten\ntimes, each time using a different random split of the observations into a training\nset and a validation set. This illustrates the variability in the estimated test MSE\nthat results from this approach.\n1. As is shown in the right-hand panel of Figure 5.2, the validation estimate\nof the test error rate can be highly variable, depending on precisely\nwhich observations are included in the training set and which\nobservations are included in the validation set.\n2. In the validation approach, only a subset of the observations\u2014those\nthat are included in the training set rather than in the validation\nset\u2014are used to fit the model. Since statistical methods tend to perform\nworse when trained on fewer observations, this suggests that the\nvalidation set error rate may tend to overestimate the test error rate\nfor the model fit on the entire data set.\nIn the coming subsections, we will present cross-validation, a refinement of\nthe validation set approach that addresses these two issues.\n5.1.2 Leave-One-Out Cross-Validation\nLeave-one-out cross-validation (LOOCV) is closely related to the validation\nleave-oneout\ncrossvalidation\nset approach of Section 5.1.1, but it attempts to address that method\u2019s\ndrawbacks.\nLike the validation set approach, LOOCV involves splitting the set of\nobservations into two parts. However, instead of creating two subsets of\ncomparable size, a single observation (x1, y1) is used for the validation\nset, and the remaining observations {(x2, y2), . . . , (xn, yn)} make up the\ntraining set. The statistical learning method is fit on the n \u2212 1 training\nobservations, and a prediction \u02c6y1 is made for the excluded observation,\n5.1 Cross-Validation", "doc_id": "ba996f5e-6a85-42d3-a901-fad454dd4aea", "embedding": null, "doc_hash": "fd7a2e10afa2fcd3f90f6ae6aaf4f9297c5d1cc1ffbc84c1c9e197ad7e88e6a8", "extra_info": null, "node_info": {"start": 477808, "end": 481340, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "96588231-34a5-49fc-b60d-f0fe6135f399", "3": "6c1b3640-93eb-4419-933d-755210ada7f4"}}, "__type__": "1"}, "6c1b3640-93eb-4419-933d-755210ada7f4": {"__data__": {"text": "is made for the excluded observation,\n5.1 Cross-Validation 201\n!\"#\"$\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"%\"\n!\"#\"$\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"%\"\n!\"#\"$\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"%\"\n!\"#\"$\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"%\"\n!\"#\"$\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"%\"\n&\"\n&\"\n&\"\nFIGURE 5.3. A schematic display of LOOCV. A set of n data points is repeatedly\nsplit into a training set (shown in blue) containing all but one observation,\nand a validation set that contains only that observation (shown in beige). The test\nerror is then estimated by averaging the n resulting MSE\u2019s. The first training set\ncontains all but observation 1, the second training set contains all but observation\n2, and so forth.\nusing its value x1. Since (x1, y1) was not used in the fitting process, MSE1 =\n(y1 \u2212 \u02c6y1)2 provides an approximately unbiased estimate for the test error.\nBut even though MSE1 is unbiased for the test error, it is a poor estimate\nbecause it is highly variable, since it is based upon a single observation\n(x1, y1).\nWe can repeat the procedure by selecting (x2, y2) for the validation\ndata, training the statistical learning procedure on the n \u2212 1 observations\n{(x1, y1), (x3, y3), . . . , (xn, yn)}, and computing MSE2 = (y2\u2212\u02c6y2)2. Repeating\nthis approach n times produces n squared errors, MSE1, . . . , MSEn.\nThe LOOCV estimate for the test MSE is the average of these n test error\nestimates:\nCV(n) =\n1\nn\n0n\ni=1\nMSEi. (5.1)\nA schematic of the LOOCV approach is illustrated in Figure 5.3.\nLOOCV has a couple of major advantages over the validation set approach.\nFirst, it has far less bias. In LOOCV, we repeatedly fit the statistical\nlearning method using training sets that contain n \u2212 1 observations,\nalmost as many as are in the entire data set. This is in contrast to\nthe validation set approach, in which the training set is typically around\nhalf the size of the original data set. Consequently, the LOOCV approach\ntends not to overestimate the test error rate as much as the validation\nset approach does. Second, in contrast to the validation approach which\nwill yield different results when applied repeatedly due to randomness in\nthe training/validation set splits, performing LOOCV multiple times will\n202 5. Resampling Methods\n2 4 6 8 10\n16 18 20 22 24 26 28\nLOOCV\nDegree of Polynomial\nMean Squared Error\n2 4 6 8 10\n16 18 20 22 24 26 28\n10\u2212fold CV\nDegree of Polynomial\nMean Squared", "doc_id": "6c1b3640-93eb-4419-933d-755210ada7f4", "embedding": null, "doc_hash": "34a45ad95ee00469ba9e9ced530d1935616943694fb31757faf2665dcfd9c156", "extra_info": null, "node_info": {"start": 481352, "end": 484208, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "ba996f5e-6a85-42d3-a901-fad454dd4aea", "3": "ec150734-214d-4e9e-bc23-895c24ae0bbe"}}, "__type__": "1"}, "ec150734-214d-4e9e-bc23-895c24ae0bbe": {"__data__": {"text": "26 28\n10\u2212fold CV\nDegree of Polynomial\nMean Squared Error\nFIGURE 5.4. Cross-validation was used on the Auto data set in order to estimate\nthe test error that results from predicting mpg using polynomial functions\nof horsepower. Left: The LOOCV error curve. Right: 10-fold CV was run nine\nseparate times, each with a different random split of the data into ten parts. The\nfigure shows the nine slightly different CV error curves.\nalways yield the same results: there is no randomness in the training/validation\nset splits.\nWe used LOOCV on the Auto data set in order to obtain an estimate\nof the test set MSE that results from fitting a linear regression model to\npredict mpg using polynomial functions of horsepower. The results are shown\nin the left-hand panel of Figure 5.4.\nLOOCV has the potential to be expensive to implement, since the model\nhas to be fit n times. This can be very time consuming if n is large, and if\neach individual model is slow to fit. With least squares linear or polynomial\nregression, an amazing shortcut makes the cost of LOOCV the same as that\nof a single model fit! The following formula holds:\nCV(n) =\n1\nn\n0n\ni=1\n*\nyi \u2212 \u02c6yi\n1 \u2212 hi\n+2\n, (5.2)\nwhere \u02c6yi is the ith fitted value from the original least squares fit, and hi is\nthe leverage defined in (3.37) on page 99.1 This is like the ordinary MSE,\nexcept the ith residual is divided by 1 \u2212 hi. The leverage lies between 1/n\nand 1, and reflects the amount that an observation influences its own fit.\nHence the residuals for high-leverage points are inflated in this formula by\nexactly the right amount for this equality to hold.\nLOOCV is a very general method, and can be used with any kind of\npredictive modeling. For example we could use it with logistic regression\n1In the case of multiple linear regression, the leverage takes a slightly more complicated\nform than (3.37), but (5.2) still holds.\n5.1 Cross-Validation 203\n!\"#\"$\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"%\"\n!!\"&'\"(\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\")&\"\n!!\"&'\"(\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\")&\"\n!!\"&'\"(\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\")&\"\n!!\"&'\"(\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\")&\"\n!!\"&'\"(\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\")&\"\nFIGURE 5.5. A schematic display of 5-fold CV. A set of n observations is\nrandomly split into five non-overlapping groups. Each of these fifths acts as a\nvalidation set (shown in beige), and the remainder as a training set (shown in\nblue). The test error", "doc_id": "ec150734-214d-4e9e-bc23-895c24ae0bbe", "embedding": null, "doc_hash": "f5b304fc95a8ab3225b643345e4c249740682bc9e6c762902087e58aeecc37ff", "extra_info": null, "node_info": {"start": 484216, "end": 487157, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "6c1b3640-93eb-4419-933d-755210ada7f4", "3": "9bcb6bf7-7609-400e-9903-d242f0c9b400"}}, "__type__": "1"}, "9bcb6bf7-7609-400e-9903-d242f0c9b400": {"__data__": {"text": "and the remainder as a training set (shown in\nblue). The test error is estimated by averaging the five resulting MSE estimates.\nor linear discriminant analysis, or any of the methods discussed in later\nchapters. The magic formula (5.2) does not hold in general, in which case\nthe model has to be refit n times.\n5.1.3 k-Fold Cross-Validation\nAn alternative to LOOCV is k-fold CV. This approach involves randomly\nk-fold CV\ndividing the set of observations into k groups, or folds, of approximately\nequal size. The first fold is treated as a validation set, and the method\nis fit on the remaining k \u2212 1 folds. The mean squared error, MSE1, is\nthen computed on the observations in the held-out fold. This procedure is\nrepeated k times; each time, a different group of observations is treated\nas a validation set. This process results in k estimates of the test error,\nMSE1,MSE2, . . . ,MSEk. The k-fold CV estimate is computed by averaging\nthese values,\nCV(k) =\n1\nk\n0k\ni=1\nMSEi. (5.3)\nFigure 5.5 illustrates the k-fold CV approach.\nIt is not hard to see that LOOCV is a special case of k-fold CV in which k\nis set to equal n. In practice, one typically performs k-fold CV using k = 5\nor k = 10. What is the advantage of using k = 5 or k = 10 rather than\nk = n? The most obvious advantage is computational. LOOCV requires\nfitting the statistical learning method n times. This has the potential to be\ncomputationally expensive (except for linear models fit by least squares,\nin which case formula (5.2) can be used). But cross-validation is a very\ngeneral approach that can be applied to almost any statistical learning\nmethod. Some statistical learning methods have computationally intensive\n204 5. Resampling Methods\n2 5 10 20\n0.0 0.5 1.0 1.5 2.0 2.5 3.0\nFlexibility\nMean Squared Error\n2 5 10 20\n0.0 0.5 1.0 1.5 2.0 2.5 3.0\nFlexibility\nMean Squared Error\n2 5 10 20\n0 5 10 15 20\nFlexibility\nMean Squared Error\nFIGURE 5.6. True and estimated test MSE for the simulated data sets in Figures\n2.9 ( left), 2.10 ( center), and 2.11 ( right). The true test MSE is shown in\nblue, the LOOCV estimate is shown as a black dashed line, and the 10-fold CV\nestimate is shown in orange. The crosses indicate the minimum of each of the\nMSE curves.\nfitting procedures, and so performing LOOCV may pose computational\nproblems, especially if n is extremely large. In contrast, performing 10-fold\nCV requires fitting the learning procedure only ten times, which may be\nmuch more feasible. As we see in Section 5.1.4, there also can be other\nnon-computational advantages to performing 5-fold or 10-fold CV, which\ninvolve the bias-variance trade-off.\nThe right-hand panel of Figure 5.4 displays nine different 10-fold CV\nestimates for the Auto data set, each resulting from a different random\nsplit of the observations into ten folds. As we can see from the figure, there\nis some variability in the CV estimates as a result of the variability in how\nthe observations are divided into ten folds. But this variability is typically\nmuch lower than the variability in the test error estimates that results from\nthe validation set approach (right-hand panel of Figure 5.2).\nWhen we examine real data, we do not know the true test MSE, and\nso it is difficult to determine the accuracy of the cross-validation estimate.\nHowever, if we examine simulated data, then we can compute the true\ntest MSE, and can thereby evaluate the accuracy of our cross-validation\nresults. In Figure 5.6, we plot the", "doc_id": "9bcb6bf7-7609-400e-9903-d242f0c9b400", "embedding": null, "doc_hash": "320c728c0ebe1d50e327f69084bf5519735bd3652296e0166ec6a80b3d9092ff", "extra_info": null, "node_info": {"start": 487147, "end": 490609, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "ec150734-214d-4e9e-bc23-895c24ae0bbe", "3": "9c7934fd-5c88-4ff3-b3fc-ada19b41324a"}}, "__type__": "1"}, "9c7934fd-5c88-4ff3-b3fc-ada19b41324a": {"__data__": {"text": "accuracy of our cross-validation\nresults. In Figure 5.6, we plot the cross-validation estimates and true test\nerror rates that result from applying smoothing splines to the simulated\ndata sets illustrated in Figures 2.9\u20132.11 of Chapter 2. The true test MSE\nis displayed in blue. The black dashed and orange solid lines respectively\nshow the estimated LOOCV and 10-fold CV estimates. In all three plots,\nthe two cross-validation estimates are very similar. In the right-hand panel\nof Figure 5.6, the true test MSE and the cross-validation curves are almost\nidentical. In the center panel of Figure 5.6, the two sets of curves are similar\nat the lower degrees of flexibility, while the CV curves overestimate the test\nset MSE for higher degrees of flexibility. In the left-hand panel of Figure 5.6,\n5.1 Cross-Validation 205\nthe CV curves have the correct general shape, but they underestimate the\ntrue test MSE.\nWhen we perform cross-validation, our goal might be to determine how\nwell a given statistical learning procedure can be expected to perform on\nindependent data; in this case, the actual estimate of the test MSE is\nof interest. But at other times we are interested only in the location of\nthe minimum point in the estimated test MSE curve. This is because we\nmight be performing cross-validation on a number of statistical learning\nmethods, or on a single method using different levels of flexibility, in order\nto identify the method that results in the lowest test error. For this purpose,\nthe location of the minimum point in the estimated test MSE curve is\nimportant, but the actual value of the estimated test MSE is not. We find\nin Figure 5.6 that despite the fact that they sometimes underestimate the\ntrue test MSE, all of the CV curves come close to identifying the correct\nlevel of flexibility\u2014that is, the flexibility level corresponding to the smallest\ntest MSE.\n5.1.4 Bias-Variance Trade-Off for k-Fold Cross-Validation\nWe mentioned in Section 5.1.3 that k-fold CV with k < n has a computational\nadvantage to LOOCV. But putting computational issues aside,\na less obvious but potentially more important advantage of k-fold CV is\nthat it often gives more accurate estimates of the test error rate than does\nLOOCV. This has to do with a bias-variance trade-off.\nIt was mentioned in Section 5.1.1 that the validation set approach can\nlead to overestimates of the test error rate, since in this approach the\ntraining set used to fit the statistical learning method contains only half\nthe observations of the entire data set. Using this logic, it is not hard to see\nthat LOOCV will give approximately unbiased estimates of the test error,\nsince each training set contains n\u22121 observations, which is almost as many\nas the number of observations in the full data set. And performing k-fold\nCV for, say, k = 5 or k = 10 will lead to an intermediate level of bias,\nsince each training set contains approximately (k \u2212 1)n/k observations\u2014\nfewer than in the LOOCV approach, but substantially more than in the\nvalidation set approach. Therefore, from the perspective of bias reduction,\nit is clear that LOOCV is to be preferred to k-fold CV.\nHowever, we know that bias is not the only source for concern in an estimating\nprocedure; we must also consider the procedure\u2019s variance. It turns\nout that LOOCV has higher variance than does k-fold CV with k < n. Why\nis this the case? When we perform LOOCV, we are in effect averaging the\noutputs of n fitted models, each of which is trained on an almost identical\nset of observations; therefore, these outputs are highly (positively) correlated\nwith each other. In contrast, when we perform k-fold CV with k < n,\nwe are averaging the outputs of k fitted models that are somewhat less\ncorrelated with each other, since the overlap between the training sets in\n206 5.", "doc_id": "9c7934fd-5c88-4ff3-b3fc-ada19b41324a", "embedding": null, "doc_hash": "b2627c1547f4ce6c630d9b557e1556201472e6431b5282fb6dd6aeff496b91e7", "extra_info": null, "node_info": {"start": 490607, "end": 494423, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "9bcb6bf7-7609-400e-9903-d242f0c9b400", "3": "f40fa376-ef7b-4b64-a694-401b88edf31e"}}, "__type__": "1"}, "f40fa376-ef7b-4b64-a694-401b88edf31e": {"__data__": {"text": "with each other, since the overlap between the training sets in\n206 5. Resampling Methods\neach model is smaller. Since the mean of many highly correlated quantities\nhas higher variance than does the mean of many quantities that are not\nas highly correlated, the test error estimate resulting from LOOCV tends\nto have higher variance than does the test error estimate resulting from\nk-fold CV.\nTo summarize, there is a bias-variance trade-off associated with the\nchoice of k in k-fold cross-validation. Typically, given these considerations,\none performs k-fold cross-validation using k = 5 or k = 10, as these values\nhave been shown empirically to yield test error rate estimates that suffer\nneither from excessively high bias nor from very high variance.\n5.1.5 Cross-Validation on Classification Problems\nIn this chapter so far, we have illustrated the use of cross-validation in the\nregression setting where the outcome Y is quantitative, and so have used\nMSE to quantify test error. But cross-validation can also be a very useful\napproach in the classification setting when Y is qualitative. In this setting,\ncross-validation works just as described earlier in this chapter, except that\nrather than using MSE to quantify test error, we instead use the number\nof misclassified observations. For instance, in the classification setting, the\nLOOCV error rate takes the form\nCV(n) =\n1\nn\n0n\ni=1\nErri, (5.4)\nwhere Erri = I(yi \u0338= \u02c6yi). The k-fold CV error rate and validation set error\nrates are defined analogously.\nAs an example, we fit various logistic regression models on the twodimensional\nclassification data displayed in Figure 2.13. In the top-left\npanel of Figure 5.7, the black solid line shows the estimated decision boundary\nresulting from fitting a standard logistic regression model to this data\nset. Since this is simulated data, we can compute the true test error rate,\nwhich takes a value of 0.201 and so is substantially larger than the Bayes\nerror rate of 0.133. Clearly logistic regression does not have enough flexibility\nto model the Bayes decision boundary in this setting. We can easily\nextend logistic regression to obtain a non-linear decision boundary by using\npolynomial functions of the predictors, as we did in the regression setting in\nSection 3.3.2. For example, we can fit a quadratic logistic regression model,\ngiven by\nlog\n*\np\n1 \u2212 p\n+\n= \u03b20 + \u03b21X1 + \u03b22X2\n1 + \u03b23X2 + \u03b24X2\n2 . (5.5)\nThe top-right panel of Figure 5.7 displays the resulting decision boundary,\nwhich is now curved. However, the test error rate has improved only slightly,\nto 0.197. A much larger improvement is apparent in the bottom-left panel\n5.1 Cross-Validation 207\nDegree=1\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no o\no\no\no\no\no\no\no\no", "doc_id": "f40fa376-ef7b-4b64-a694-401b88edf31e", "embedding": null, "doc_hash": "c26bb410db0abb6cf49b177fdf602b9e0e79def8426388188aa8bf2e059eaaec", "extra_info": null, "node_info": {"start": 494424, "end": 497360, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "9c7934fd-5c88-4ff3-b3fc-ada19b41324a", "3": "890e4e38-63f2-445f-9c85-196ece481298"}}, "__type__": "1"}, "890e4e38-63f2-445f-9c85-196ece481298": {"__data__": {"text": "o\no o\no\no\no\no\no\no\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\noo o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\nDegree=2\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no o\no\no\no\no\no\no\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\noo o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\nDegree=3\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no o\no\no\no\no\no\no\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\noo", "doc_id": "890e4e38-63f2-445f-9c85-196ece481298", "embedding": null, "doc_hash": "12a532971737453b7432d0d88123c34c5f5dbd32347002812ae9409c024fbcf0", "extra_info": null, "node_info": {"start": 497400, "end": 498264, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "f40fa376-ef7b-4b64-a694-401b88edf31e", "3": "0d38786b-6717-45b0-a497-064c63502de4"}}, "__type__": "1"}, "0d38786b-6717-45b0-a497-064c63502de4": {"__data__": {"text": "o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\nDegree=4\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no o\no o\no\no\no\no\no\no\no\no o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\noo o\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\no\nFIGURE 5.7. Logistic regression fits on the two-dimensional classification data\ndisplayed in Figure 2.13. The Bayes decision boundary is represented using a\npurple dashed line. Estimated decision boundaries from linear, quadratic, cubic\nand quartic (degrees 1\u20134) logistic regressions are displayed in black. The test error\nrates for the four logistic regression fits are respectively 0.201, 0.197, 0.160, and\n0.162, while the Bayes error rate is 0.133.\nof Figure 5.7, in which we have fit a logistic regression model involving\ncubic polynomials of the predictors. Now the test error rate has decreased\nto 0.160. Going to a quartic polynomial (bottom-right) slightly increases\nthe test error.\nIn practice, for real data, the Bayes decision boundary and the test error\nrates are unknown. So how might we decide between the four logistic\nregression models displayed in Figure 5.7? We can use cross-validation in\norder to make this decision. The left-hand panel of Figure 5.8 displays in\n208 5. Resampling Methods\n2 4 6 8 10\n0.12 0.14 0.16 0.18 0.20\nOrder of Polynomials Used\nError Rate\n0.01 0.02 0.05 0.10 0.20 0.50 1.00\n0.12 0.14 0.16 0.18 0.20\n1/K\nError Rate\nFIGURE 5.8. Test error (brown), training error (blue), and 10-fold CV error\n(black) on the two-dimensional classification data displayed in Figure 5.7. Left:\nLogistic regression using polynomial functions of the predictors. The order of\nthe polynomials used is displayed on the x-axis. Right: The KNN classifier with\ndifferent values of K, the number of neighbors used in the KNN classifier.\nblack the 10-fold CV error rates that result from fitting ten logistic regression\nmodels to the data, using polynomial functions of the predictors up\nto tenth order. The true test errors are shown in brown, and the training\nerrors are shown in blue. As we have seen", "doc_id": "0d38786b-6717-45b0-a497-064c63502de4", "embedding": null, "doc_hash": "72ad390751626e04159302a8a1bb1f37ecd26afc90d72e975de0432e87dc023e", "extra_info": null, "node_info": {"start": 498285, "end": 500600, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "890e4e38-63f2-445f-9c85-196ece481298", "3": "d1763d60-67ff-4468-bba1-c16b77796cb9"}}, "__type__": "1"}, "d1763d60-67ff-4468-bba1-c16b77796cb9": {"__data__": {"text": "errors are shown in brown, and the training\nerrors are shown in blue. As we have seen previously, the training error\ntends to decrease as the flexibility of the fit increases. (The figure indicates\nthat though the training error rate doesn\u2019t quite decrease monotonically,\nit tends to decrease on the whole as the model complexity increases.) In\ncontrast, the test error displays a characteristic U-shape. The 10-fold CV\nerror rate provides a pretty good approximation to the test error rate.\nWhile it somewhat underestimates the error rate, it reaches a minimum\nwhen fourth-order polynomials are used, which is very close to the minimum\nof the test curve, which occurs when third-order polynomials are\nused. In fact, using fourth-order polynomials would likely lead to good test\nset performance, as the true test error rate is approximately the same for\nthird, fourth, fifth, and sixth-order polynomials.\nThe right-hand panel of Figure 5.8 displays the same three curves using\nthe KNN approach for classification, as a function of the value of K\n(which in this context indicates the number of neighbors used in the KNN\nclassifier, rather than the number of CV folds used). Again the training\nerror rate declines as the method becomes more flexible, and so we see that\nthe training error rate cannot be used to select the optimal value for K.\nThough the cross-validation error curve slightly underestimates the test\nerror rate, it takes on a minimum very close to the best value for K.\n5.2 The Bootstrap 209\n5.2 The Bootstrap\nThe bootstrap is a widely applicable and extremely powerful statistical tool\nbootstrap\nthat can be used to quantify the uncertainty associated with a given estimator\nor statistical learning method. As a simple example, the bootstrap\ncan be used to estimate the standard errors of the coefficients from a linear\nregression fit. In the specific case of linear regression, this is not particularly\nuseful, since we saw in Chapter 3 that standard statistical software such as\nR outputs such standard errors automatically. However, the power of the\nbootstrap lies in the fact that it can be easily applied to a wide range of\nstatistical learning methods, including some for which a measure of variability\nis otherwise difficult to obtain and is not automatically output by\nstatistical software.\nIn this section we illustrate the bootstrap on a toy example in which we\nwish to determine the best investment allocation under a simple model.\nIn Section 5.3 we explore the use of the bootstrap to assess the variability\nassociated with the regression coefficients in a linear model fit.\nSuppose that we wish to invest a fixed sum of money in two financial\nassets that yield returns of X and Y , respectively, where X and Y are\nrandom quantities. We will invest a fraction \u03b1 of our money in X, and will\ninvest the remaining 1 \u2212 \u03b1 in Y . Since there is variability associated with\nthe returns on these two assets, we wish to choose \u03b1 to minimize the total\nrisk, or variance, of our investment. In other words, we want to minimize\nVar(\u03b1X +(1\u2212\u03b1)Y ). One can show that the value that minimizes the risk\nis given by\n\u03b1 =\n\u03c32Y\n\u2212 \u03c3XY\n\u03c32X\n+ \u03c32Y\n\u2212 2\u03c3XY\n, (5.6)\nwhere \u03c32X\n= Var(X),\u03c32Y\n= Var(Y ), and \u03c3XY = Cov(X, Y ).\nIn reality, the quantities \u03c32X\n, \u03c32Y\n, and \u03c3XY are unknown.We can compute\nestimates for these quantities, \u02c6\u03c32X\n, \u02c6\u03c32Y\n, and \u02c6\u03c3XY , using a data set that\ncontains past measurements for X and Y . We can then estimate the value\nof \u03b1 that minimizes the variance of our investment using\n\u02c6\u03b1 =\n\u02c6\u03c32Y \u2212 \u02c6\u03c3XY\n\u02c6\u03c32X\n+ \u02c6\u03c32Y\n\u2212 2\u02c6\u03c3XY\n. (5.7)\nFigure 5.9 illustrates this approach for estimating \u03b1 on a simulated data\nset. In each panel, we simulated 100 pairs of", "doc_id": "d1763d60-67ff-4468-bba1-c16b77796cb9", "embedding": null, "doc_hash": "f8582d6211acc2554e034a485b10114f2fbede428e84d30946b6d50d6545bf70", "extra_info": null, "node_info": {"start": 500531, "end": 504198, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "0d38786b-6717-45b0-a497-064c63502de4", "3": "381db9ef-1c7e-48b6-9f7f-3c80da0f89cb"}}, "__type__": "1"}, "381db9ef-1c7e-48b6-9f7f-3c80da0f89cb": {"__data__": {"text": "\u03b1 on a simulated data\nset. In each panel, we simulated 100 pairs of returns for the investments\nX and Y . We used these returns to estimate \u03c32X\n,\u03c32Y\n, and \u03c3XY , which we\nthen substituted into (5.7) in order to obtain estimates for \u03b1. The value of\n\u02c6\u03b1 resulting from each simulated data set ranges from 0.532 to 0.657.\nIt is natural to wish to quantify the accuracy of our estimate of \u03b1. To\nestimate the standard deviation of \u02c6\u03b1, we repeated the process of simulating\n100 paired observations of X and Y , and estimating \u03b1 using (5.7),\n1,000 times. We thereby obtained 1,000 estimates for \u03b1, which we can call\n210 5. Resampling Methods\n\u22122 \u22121 0 1 2\n\u22122 \u22121 0 1 2\nX\nY\n\u22122 \u22121 0 1 2\n\u22122 \u22121 0 1 2\nX\nY\n\u22123 \u22122 \u22121 0 1 2\n\u22123 \u22122 \u22121 0 1 2\nX\nY\n\u22122 \u22121 0 1 2 3\n\u22123 \u22122 \u22121 0 1 2\nX\nY\nFIGURE 5.9. Each panel displays 100 simulated returns for investments\nX and Y . From left to right and top to bottom, the resulting estimates for \u03b1\nare 0.576, 0.532, 0.657, and 0.651.\n\u02c6\u03b11, \u02c6\u03b12, . . . , \u02c6\u03b11,000. The left-hand panel of Figure 5.10 displays a histogram\nof the resulting estimates. For these simulations the parameters were set to\n\u03c32X\n= 1,\u03c32Y\n= 1.25, and \u03c3XY = 0.5, and so we know that the true value of\n\u03b1 is 0.6. We indicated this value using a solid vertical line on the histogram.\nThe mean over all 1,000 estimates for \u03b1 is\n\u00af\u03b1 =\n1\n1000\n10000\nr=1\n\u02c6\u03b1r = 0.5996,\nvery close to \u03b1 = 0.6, and the standard deviation of the estimates is\n:;;<\n1\n1000 \u2212 1\n10000\nr=1\n(\u02c6\u03b1r \u2212 \u00af\u03b1)2 = 0.083.\nThis gives us a very good idea of the accuracy of \u02c6\u03b1: SE(\u02c6\u03b1) \u2248 0.083. So\nroughly speaking, for a random sample from the population, we would\nexpect \u02c6\u03b1 to differ from \u03b1 by approximately 0.08, on average.\nIn practice, however, the procedure for estimating SE(\u02c6\u03b1) outlined above\ncannot be applied, because for real data we cannot generate new samples\n5.2 The Bootstrap 211\n0.4 0.5 0.6 0.7 0.8 0.9\n0 50 100 150 200\n0.3 0.4 0.5 0.6 0.7 0.8 0.9\n0 50 100 150 200\nTrue Bootstrap\n0.3 0.4 0.5 0.6 0.7 0.8 0.9\n\u03b1 \u03b1\n\u03b1\nFIGURE 5.10. Left: A histogram of the estimates of \u03b1 obtained by generating\n1,000 simulated data sets from the true population. Center: A histogram of the\nestimates of \u03b1 obtained from 1,000 bootstrap samples from a single data set.\nRight: The estimates of \u03b1 displayed in the left and center panels are shown as\nboxplots. In each panel, the pink line indicates the true value of \u03b1.\nfrom the original population. However, the bootstrap approach allows us\nto use a computer to emulate the process of obtaining new sample sets,\nso that we can estimate the variability of \u02c6\u03b1 without generating additional\nsamples. Rather than repeatedly obtaining independent data sets from the\npopulation, we instead obtain distinct data sets by repeatedly sampling\nobservations from the original data set.\nThis approach is illustrated in Figure 5.11 on a simple data set, which\nwe call Z, that contains only n = 3 observations. We randomly select n\nobservations from the data set in order to produce a bootstrap data set,\nZ\u22171. The sampling is performed with replacement, which", "doc_id": "381db9ef-1c7e-48b6-9f7f-3c80da0f89cb", "embedding": null, "doc_hash": "2f08c363ba905d813f78eff297f1fa5390137b73f6ca762764edcc60c5ee5977", "extra_info": null, "node_info": {"start": 504214, "end": 507224, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "d1763d60-67ff-4468-bba1-c16b77796cb9", "3": "4fb60b55-e742-439a-b320-584325c8629f"}}, "__type__": "1"}, "4fb60b55-e742-439a-b320-584325c8629f": {"__data__": {"text": "data set,\nZ\u22171. The sampling is performed with replacement, which means that the\nwith\nsame observation can occur more than once in the bootstrap data set. In replacement\nthis example, Z\u22171 contains the third observation twice, the first observation\nonce, and no instances of the second observation. Note that if an observation\nis contained in Z\u22171, then both its X and Y values are included. We can use\nZ\u22171 to produce a new bootstrap estimate for \u03b1, which we call \u02c6\u03b1\u22171. This\nprocedure is repeated B times for some large value of B, in order to produce\nB different bootstrap data sets, Z\u22171, Z\u22172, . . . ,Z\u2217B, and B corresponding \u03b1\nestimates, \u02c6\u03b1\u22171, \u02c6\u03b1\u22172, . . . , \u02c6\u03b1\u2217B. We can compute the standard error of these\nbootstrap estimates using the formula\nSEB(\u02c6\u03b1) =\n:;;<\n1\nB \u2212 1\n0B\nr=1\n>\n\u02c6\u03b1\u2217r \u2212\n1\nB\n0B\nr\u2032=1\n\u02c6\u03b1\u2217r\u2032\n?2\n. (5.8)\nThis serves as an estimate of the standard error of \u02c6\u03b1 estimated from the\noriginal data set.\nThe bootstrap approach is illustrated in the center panel of Figure 5.10,\nwhich displays a histogram of 1,000 bootstrap estimates of \u03b1, each com212\n5. Resampling Methods\n3 5.3 2.8\n2 2.1 1.1\n1 4.3 2.4\nObs X Y\n3 5.3 2.8\n1 4.3 2.4\n3 5.3 2.8\nObs X Y\n1 4.3 2.4\n3 5.3 2.8\n2 2.1 1.1\nObs X Y\n1 4.3 2.4\n2 2.1 1.1\n2 2.1 1.1\nObs X Y\nOriginal Data (Z)\n1*Z\n2*Z\nZ*B\n1*\u02c6\u03b1\n2*\u02c6\u03b1\n\u03b1\u02c6*B\n!!\n!!\n!!\n!!\n!\n!!\n!!\n!!\n!!\n!!\n!!\n!!\n!!\nFIGURE 5.11. A graphical illustration of the bootstrap approach on a small\nsample containing n = 3 observations. Each bootstrap data set contains n observations,\nsampled with replacement from the original data set. Each bootstrap data\nset is used to obtain an estimate of \u03b1.\nputed using a distinct bootstrap data set. This panel was constructed on\nthe basis of a single data set, and hence could be created using real data.\nNote that the histogram looks very similar to the left-hand panel, which\ndisplays the idealized histogram of the estimates of \u03b1 obtained by generating\n1,000 simulated data sets from the true population. In particular the\nbootstrap estimate SE(\u02c6\u03b1) from (5.8) is 0.087, very close to the estimate\nof 0.083 obtained using 1,000 simulated data sets. The right-hand panel\ndisplays the information in the center and left panels in a different way, via\nboxplots of the estimates for \u03b1 obtained by generating 1,000 simulated data\nsets from the true population and using the bootstrap approach. Again, the\nboxplots have similar spreads, indicating that the bootstrap approach can\nbe used to effectively estimate the variability associated with \u02c6\u03b1.\n5.3 Lab: Cross-Validation and the Bootstrap\nIn this lab, we explore the resampling techniques covered in this chapter.\nSome of the commands in this lab may take a while to run on your computer.\n5.3 Lab: Cross-Validation and the Bootstrap 213\n5.3.1 The Validation Set Approach\nWe explore the use of the validation set approach in order to estimate the\ntest error rates that result from fitting various linear models on the Auto\ndata set.\nBefore we begin, we use the set.seed() function in order to set a seed for\nseed\nR\u2019s random number generator, so that the reader of this book will obtain\nprecisely", "doc_id": "4fb60b55-e742-439a-b320-584325c8629f", "embedding": null, "doc_hash": "6c7f56c8f7cb838e0246843422c2e34daffd9ec224b65edde75e04b4ab9eca88", "extra_info": null, "node_info": {"start": 507224, "end": 510296, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "381db9ef-1c7e-48b6-9f7f-3c80da0f89cb", "3": "ed4d4ec8-b06b-4468-bd9f-4617e9ef5457"}}, "__type__": "1"}, "ed4d4ec8-b06b-4468-bd9f-4617e9ef5457": {"__data__": {"text": "random number generator, so that the reader of this book will obtain\nprecisely the same results as those shown below. It is generally a good idea\nto set a random seed when performing an analysis such as cross-validation\nthat contains an element of randomness, so that the results obtained can\nbe reproduced precisely at a later time.\nWe begin by using the sample() function to split the set of observations\nsample()\ninto two halves, by selecting a random subset of 196 observations out of\nthe original 392 observations. We refer to these observations as the training\nset.\n> library(ISLR2)\n> set.seed (1)\n> train <- sample (392 , 196)\n(Here we use a shortcut in the sample command; see ?sample for details.)\nWe then use the subset option in lm() to fit a linear regression using only\nthe observations corresponding to the training set.\n> lm.fit <- lm(mpg \u223c horsepower , data = Auto , subset = train)\nWe now use the predict() function to estimate the response for all 392\nobservations, and we use the mean() function to calculate the MSE of the\n196 observations in the validation set. Note that the -train index below\nselects only the observations that are not in the training set.\n> attach(Auto)\n> mean (( mpg - predict(lm.fit , Auto))[-train ]^2)\n[1] 23.27\nTherefore, the estimated test MSE for the linear regression fit is 23.27. We\ncan use the poly() function to estimate the test error for the quadratic and\ncubic regressions.\n> lm.fit2 <- lm(mpg \u223c poly(horsepower , 2), data = Auto ,\nsubset = train)\n> mean (( mpg - predict(lm.fit2 , Auto))[-train ]^2)\n[1] 18.72\n> lm.fit3 <- lm(mpg \u223c poly(horsepower , 3), data = Auto ,\nsubset = train)\n> mean (( mpg - predict(lm.fit3 , Auto))[-train ]^2)\n[1] 18.79\nThese error rates are 18.72 and 18.79, respectively. If we choose a different\ntraining set instead, then we will obtain somewhat different errors on the\nvalidation set.\n214 5. Resampling Methods\n> set.seed (2)\n> train <- sample (392 , 196)\n> lm.fit <- lm(mpg \u223c horsepower , subset = train)\n> mean (( mpg - predict(lm.fit , Auto))[-train ]^2)\n[1] 25.73\n> lm.fit2 <- lm(mpg \u223c poly(horsepower , 2), data = Auto ,\nsubset = train)\n> mean (( mpg - predict(lm.fit2 , Auto))[-train ]^2)\n[1] 20.43\n> lm.fit3 <- lm(mpg \u223c poly(horsepower , 3), data = Auto ,\nsubset = train)\n> mean (( mpg - predict(lm.fit3 , Auto))[-train ]^2)\n[1] 20.39\nUsing this split of the observations into a training set and a validation\nset, we find that the validation set error rates for the models with linear,\nquadratic, and cubic terms are 25.73, 20.43, and 20.39, respectively.\nThese results are consistent with our previous findings: a model that\npredicts mpg using a quadratic function of horsepower performs better than\na model that involves only a linear function of horsepower, and there is\nlittle evidence in favor of a model that uses a cubic function of horsepower.\n5.3.2 Leave-One-Out Cross-Validation\nThe LOOCV estimate can be automatically computed for any generalized\nlinear model using the glm() and cv.glm() functions. In the lab for Chapcv.\nglm()\nter 4, we used the glm() function to perform logistic regression by passing\nin the family = \"binomial\" argument. But if we use glm()", "doc_id": "ed4d4ec8-b06b-4468-bd9f-4617e9ef5457", "embedding": null, "doc_hash": "ae704d879f4cc12684700f8c7615bb0f404a6f0a2e40be0d1530911cb3e6c9ec", "extra_info": null, "node_info": {"start": 510286, "end": 513453, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "4fb60b55-e742-439a-b320-584325c8629f", "3": "4109bae4-5420-4489-9112-a657642c0cdd"}}, "__type__": "1"}, "4109bae4-5420-4489-9112-a657642c0cdd": {"__data__": {"text": "passing\nin the family = \"binomial\" argument. But if we use glm() to fit a model\nwithout passing in the family argument, then it performs linear regression,\njust like the lm() function. So for instance,\n> glm.fit <- glm(mpg \u223c horsepower , data = Auto)\n> coef(glm.fit)\n(Intercept) horsepower\n39.936 -0.158\nand\n> lm.fit <- lm(mpg \u223c horsepower , data = Auto)\n> coef(lm.fit)\n(Intercept) horsepower\n39.936 -0.158\nyield identical linear regression models. In this lab, we will perform linear\nregression using the glm() function rather than the lm() function because\nthe former can be used together with cv.glm(). The cv.glm() function is\npart of the boot library.\n> library(boot)\n> glm.fit <- glm(mpg \u223c horsepower , data = Auto)\n> cv.err <- cv.glm(Auto , glm.fit)\n> cv.err$delta\n5.3 Lab: Cross-Validation and the Bootstrap 215\n1 1\n24.23 24.23\nThe cv.glm() function produces a list with several components. The two\nnumbers in the delta vector contain the cross-validation results. In this\ncase the numbers are identical (up to two decimal places) and correspond\nto the LOOCV statistic given in (5.1). Below, we discuss a situation in\nwhich the two numbers differ. Our cross-validation estimate for the test\nerror is approximately 24.23.\nWe can repeat this procedure for increasingly complex polynomial fits.\nTo automate the process, we use the for() function to initiate a for loop\nfor()\nfor loop which iteratively fits polynomial regressions for polynomials of order i = 1\nto i = 10, computes the associated cross-validation error, and stores it in\nthe ith element of the vector cv.error. We begin by initializing the vector.\n> cv.error <- rep(0, 10)\n> for (i in 1:10) {\n+ glm.fit <- glm(mpg \u223c poly(horsepower , i), data = Auto)\n+ cv.error[i] <- cv.glm(Auto , glm.fit)$delta [1]\n+ }\n> cv.error\n[1] 24.23 19.25 19.33 19.42 19.03 18.98 18.83 18.96 19.07 19.49\nAs in Figure 5.4, we see a sharp drop in the estimated test MSE between\nthe linear and quadratic fits, but then no clear improvement from using\nhigher-order polynomials.\n5.3.3 k-Fold Cross-Validation\nThe cv.glm() function can also be used to implement k-fold CV. Below we\nuse k = 10, a common choice for k, on the Auto data set. We once again set\na random seed and initialize a vector in which we will store the CV errors\ncorresponding to the polynomial fits of orders one to ten.\n> set.seed (17)\n> cv.error.10 <- rep(0, 10)\n> for (i in 1:10) {\n+ glm.fit <- glm(mpg \u223c poly(horsepower , i), data = Auto)\n+ cv.error.10[i] <- cv.glm(Auto , glm.fit , K = 10)$delta [1]\n+ }\n> cv.error.10\n[1] 24.27 19.27 19.35 19.29 19.03 18.90 19.12 19.15 18.87 20.96\nNotice that the computation time is shorter than that of LOOCV. (In\nprinciple, the computation time for LOOCV for a least squares linear model\nshould be faster than for k-fold CV, due to the availability of the formula\n(5.2) for LOOCV; however, unfortunately the cv.glm() function does not\nmake use of this formula.) We still see little evidence that using cubic or\nhigher-order polynomial terms leads to lower test error than", "doc_id": "4109bae4-5420-4489-9112-a657642c0cdd", "embedding": null, "doc_hash": "f38bc49532003430d3d0182b3f79e067cd4c7533e6457d4a778143aa85101f2c", "extra_info": null, "node_info": {"start": 513467, "end": 516491, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "ed4d4ec8-b06b-4468-bd9f-4617e9ef5457", "3": "4f4179e9-e10a-4c11-b7e7-0f278fd73a4d"}}, "__type__": "1"}, "4f4179e9-e10a-4c11-b7e7-0f278fd73a4d": {"__data__": {"text": "using cubic or\nhigher-order polynomial terms leads to lower test error than simply using\na quadratic fit.\n216 5. Resampling Methods\nWe saw in Section 5.3.2 that the two numbers associated with delta are\nessentially the same when LOOCV is performed. When we instead perform\nk-fold CV, then the two numbers associated with delta differ slightly. The\nfirst is the standard k-fold CV estimate, as in (5.3). The second is a biascorrected\nversion. On this data set, the two estimates are very similar to\neach other.\n5.3.4 The Bootstrap\nWe illustrate the use of the bootstrap in the simple example of Section 5.2,\nas well as on an example involving estimating the accuracy of the linear\nregression model on the Auto data set.\nEstimating the Accuracy of a Statistic of Interest\nOne of the great advantages of the bootstrap approach is that it can be\napplied in almost all situations. No complicated mathematical calculations\nare required. Performing a bootstrap analysis in R entails only two steps.\nFirst, we must create a function that computes the statistic of interest.\nSecond, we use the boot() function, which is part of the boot library, to\nboot()\nperform the bootstrap by repeatedly sampling observations from the data\nset with replacement.\nThe Portfolio data set in the ISLR2 package is simulated data of 100\npairs of returns, generated in the fashion described in Section 5.2. To illustrate\nthe use of the bootstrap on this data, we must first create a function,\nalpha.fn(), which takes as input the (X, Y ) data as well as a vector indicating\nwhich observations should be used to estimate \u03b1. The function then\noutputs the estimate for \u03b1 based on the selected observations.\n> alpha.fn <- function(data , index) {\n+ X <- data$X[index]\n+ Y <- data$Y[index]\n+ (var(Y) - cov(X, Y)) / (var(X) + var(Y) - 2 * cov(X, Y))\n+ }\nThis function returns, or outputs, an estimate for \u03b1 based on applying\n(5.7) to the observations indexed by the argument index. For instance, the\nfollowing command tells R to estimate \u03b1 using all 100 observations.\n> alpha.fn(Portfolio , 1:100)\n[1] 0.576\nThe next command uses the sample() function to randomly select 100 observations\nfrom the range 1 to 100, with replacement. This is equivalent\nto constructing a new bootstrap data set and recomputing \u02c6\u03b1 based on the\nnew data set.\n> set.seed (7)\n> alpha.fn(Portfolio , sample (100 , 100, replace = T))\n[1] 0.539\n5.3 Lab: Cross-Validation and the Bootstrap 217\nWe can implement a bootstrap analysis by performing this command many\ntimes, recording all of the corresponding estimates for \u03b1, and computing\nthe resulting standard deviation. However, the boot() function automates\nboot()\nthis approach. Below we produce R = 1, 000 bootstrap estimates for \u03b1.\n> boot(Portfolio , alpha.fn, R = 1000)\nORDINARY NONPARAMETRIC BOOTSTRAP\nCall:\nboot(data = Portfolio , statistic = alpha.fn , R = 1000)\nBootstrap Statistics :\noriginal bias std. error\nt1* 0.5758 0.001 0.0897\nThe final output shows that using the original data, \u02c6\u03b1 = 0.5758, and that\nthe bootstrap estimate for SE(\u02c6\u03b1) is 0.0897.\nEstimating the Accuracy of a Linear Regression Model\nThe bootstrap approach can be used to assess the variability of the coefficient\nestimates and predictions from a statistical learning method. Here\nwe use the bootstrap approach in order to assess the variability of the\nestimates for \u03b20 and \u03b21, the intercept and slope terms for the linear regression\nmodel that uses horsepower to predict mpg in the Auto data set. We\nwill compare the estimates obtained using the bootstrap to those obtained\nusing the", "doc_id": "4f4179e9-e10a-4c11-b7e7-0f278fd73a4d", "embedding": null, "doc_hash": "f2deccb3272b1a3db73ccf1c505247790ff4b208dac5483ce4fbc04a44211ed6", "extra_info": null, "node_info": {"start": 516481, "end": 520036, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "4109bae4-5420-4489-9112-a657642c0cdd", "3": "40d362c3-46ab-4b0a-8a4c-32276ad1ae41"}}, "__type__": "1"}, "40d362c3-46ab-4b0a-8a4c-32276ad1ae41": {"__data__": {"text": "compare the estimates obtained using the bootstrap to those obtained\nusing the formulas for SE( \u02c6 \u03b20) and SE( \u02c6 \u03b21) described in Section 3.1.2.\nWe first create a simple function, boot.fn(), which takes in the Auto data\nset as well as a set of indices for the observations, and returns the intercept\nand slope estimates for the linear regression model. We then apply this\nfunction to the full set of 392 observations in order to compute the estimates\nof \u03b20 and \u03b21 on the entire data set using the usual linear regression\ncoefficient estimate formulas from Chapter 3. Note that we do not need the\n{ and } at the beginning and end of the function because it is only one line\nlong.\n> boot.fn <- function(data , index)\n+ coef(lm(mpg \u223c horsepower , data = data , subset = index))\n> boot.fn(Auto , 1:392)\n(Intercept) horsepower\n39.936 -0.158\nThe boot.fn() function can also be used in order to create bootstrap estimates\nfor the intercept and slope terms by randomly sampling from among\nthe observations with replacement. Here we give two examples.\n> set.seed (1)\n> boot.fn(Auto , sample (392 , 392, replace = T))\n(Intercept) horsepower\n40.341 -0.164\n218 5. Resampling Methods\n> boot.fn(Auto , sample (392 , 392, replace = T))\n(Intercept) horsepower\n40.119 -0.158\nNext, we use the boot() function to compute the standard errors of 1,000\nbootstrap estimates for the intercept and slope terms.\n> boot(Auto , boot.fn, 1000)\nORDINARY NONPARAMETRIC BOOTSTRAP\nCall:\nboot(data = Auto , statistic = boot.fn , R = 1000)\nBootstrap Statistics :\noriginal bias std. error\nt1* 39.936 0.0545 0.8413\nt2* -0.158 -0.0006 0.0073\nThis indicates that the bootstrap estimate for SE( \u02c6 \u03b20) is 0.84, and that\nthe bootstrap estimate for SE( \u02c6 \u03b21) is 0.0073. As discussed in Section 3.1.2,\nstandard formulas can be used to compute the standard errors for the\nregression coefficients in a linear model. These can be obtained using the\nsummary() function.\n> summary(lm(mpg \u223c horsepower , data = Auto))$coef\nEstimate Std. Error t value Pr(>|t|)\n(Intercept) 39.936 0.71750 55.7 1.22e-187\nhorsepower -0.158 0.00645 -24.5 7.03e-81\nThe standard error estimates for \u02c6 \u03b20 and \u02c6 \u03b21 obtained using the formulas\nfrom Section 3.1.2 are 0.717 for the intercept and 0.0064 for the slope.\nInterestingly, these are somewhat different from the estimates obtained\nusing the bootstrap. Does this indicate a problem with the bootstrap? In\nfact, it suggests the opposite. Recall that the standard formulas given in\nEquation 3.8 on page 66 rely on certain assumptions. For example, they\ndepend on the unknown parameter \u03c32, the noise variance.We then estimate\n\u03c32 using the RSS. Now although the formulas for the standard errors do not\nrely on the linear model being correct, the estimate for \u03c32 does. We see in\nFigure 3.8 on page 91 that there is a non-linear relationship in the data, and\nso the residuals from a linear fit will be inflated, and so will \u02c6\u03c32. Secondly,\nthe standard formulas assume (somewhat unrealistically) that the xi are\nfixed, and all the variability comes from the variation in the errors \u03f5i. The\nbootstrap approach does not rely on any of these assumptions, and so it is\nlikely giving a more accurate estimate of the standard errors of \u02c6 \u03b20 and \u02c6 \u03b21\nthan is the summary() function.\nBelow we compute the bootstrap standard error estimates and the standard\nlinear regression estimates that result from fitting the", "doc_id": "40d362c3-46ab-4b0a-8a4c-32276ad1ae41", "embedding": null, "doc_hash": "3e64c6ff9e7cdff18fe09d3b4fb590e2feab112d9446375378f0af89fa31cc26", "extra_info": null, "node_info": {"start": 520034, "end": 523412, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "4f4179e9-e10a-4c11-b7e7-0f278fd73a4d", "3": "4b29b19e-f806-4f51-b1bf-a1810ff2c1d0"}}, "__type__": "1"}, "4b29b19e-f806-4f51-b1bf-a1810ff2c1d0": {"__data__": {"text": "bootstrap standard error estimates and the standard\nlinear regression estimates that result from fitting the quadratic model\nto the data. Since this model provides a good fit to the data (Figure 3.8),\n5.4 Exercises 219\nthere is now a better correspondence between the bootstrap estimates and\nthe standard estimates of SE( \u02c6 \u03b20), SE( \u02c6 \u03b21) and SE( \u02c6 \u03b22).\n> boot.fn <- function(data , index)\n+ coef(\nlm(mpg \u223c horsepower + I(horsepower ^2),\ndata = data , subset = index)\n)\n> set.seed (1)\n> boot(Auto , boot.fn, 1000)\nORDINARY NONPARAMETRIC BOOTSTRAP\nCall:\nboot(data = Auto , statistic = boot.fn , R = 1000)\nBootstrap Statistics :\noriginal bias std. error\nt1* 56.9001 3.51e -02 2.0300\nt2* -0.4661 -7.08e-04 0.0324\nt3* 0.0012 2.84e -06 0.0001\n> summary(\nlm(mpg \u223c horsepower + I(horsepower ^2), data = Auto)\n)$coef\nEstimate Std. Error t value Pr(>|t|)\n(Intercept) 56.9001 1.8004 32 1.7e-109\nhorsepower -0.4662 0.0311 -15 2.3e-40\nI(horsepower ^2) 0.0012 0.0001 10 2.2e-21\n5.4 Exercises\nConceptual\n1. Using basic statistical properties of the variance, as well as singlevariable\ncalculus, derive (5.6). In other words, prove that \u03b1 given by\n(5.6) does indeed minimize Var(\u03b1X + (1 \u2212 \u03b1)Y ).\n2. We will now derive the probability that a given observation is part\nof a bootstrap sample. Suppose that we obtain a bootstrap sample\nfrom a set of n observations.\n(a) What is the probability that the first bootstrap observation is\nnot the jth observation from the original sample? Justify your\nanswer.\n(b) What is the probability that the second bootstrap observation\nis not the jth observation from the original sample?\n(c) Argue that the probability that the jth observation is not in the\nbootstrap sample is (1 \u2212 1/n)n.\n220 5. Resampling Methods\n(d) When n = 5, what is the probability that the jth observation is\nin the bootstrap sample?\n(e) When n = 100, what is the probability that the jth observation\nis in the bootstrap sample?\n(f) When n = 10, 000, what is the probability that the jth observation\nis in the bootstrap sample?\n(g) Create a plot that displays, for each integer value of n from 1\nto 100, 000, the probability that the jth observation is in the\nbootstrap sample. Comment on what you observe.\n(h) We will now investigate numerically the probability that a bootstrap\nsample of size n = 100 contains the jth observation. Here\nj = 4. We repeatedly create bootstrap samples, and each time\nwe record whether or not the fourth observation is contained in\nthe bootstrap sample.\n> store <- rep(NA, 10000)\n> for(i in 1:10000){\nstore[i] <- sum(sample (1:100 , rep=TRUE) == 4) > 0\n}\n> mean(store)\nComment on the results obtained.\n3. We now review k-fold cross-validation.\n(a) Explain how k-fold cross-validation is implemented.\n(b) What are the advantages and disadvantages of k-fold crossvalidation\nrelative to:\ni. The validation set approach?\nii. LOOCV?\n4. Suppose that we use some statistical learning method to make a prediction\nfor the response Y for a particular value of the predictor X.\nCarefully describe how we might estimate the standard deviation of\nour", "doc_id": "4b29b19e-f806-4f51-b1bf-a1810ff2c1d0", "embedding": null, "doc_hash": "ca284cd4987667ad69164d9868f50562c7ef39ab9448af1e3d5e3e509b9ccba6", "extra_info": null, "node_info": {"start": 523386, "end": 526446, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "40d362c3-46ab-4b0a-8a4c-32276ad1ae41", "3": "94869302-2194-47e9-884e-cd32d683a854"}}, "__type__": "1"}, "94869302-2194-47e9-884e-cd32d683a854": {"__data__": {"text": "X.\nCarefully describe how we might estimate the standard deviation of\nour prediction.\nApplied\n5. In Chapter 4, we used logistic regression to predict the probability of\ndefault using income and balance on the Default data set. We will\nnow estimate the test error of this logistic regression model using the\nvalidation set approach. Do not forget to set a random seed before\nbeginning your analysis.\n(a) Fit a logistic regression model that uses income and balance to\npredict default.\n5.4 Exercises 221\n(b) Using the validation set approach, estimate the test error of this\nmodel. In order to do this, you must perform the following steps:\ni. Split the sample set into a training set and a validation set.\nii. Fit a multiple logistic regression model using only the training\nobservations.\niii. Obtain a prediction of default status for each individual in\nthe validation set by computing the posterior probability of\ndefault for that individual, and classifying the individual to\nthe default category if the posterior probability is greater\nthan 0.5.\niv. Compute the validation set error, which is the fraction of\nthe observations in the validation set that are misclassified.\n(c) Repeat the process in (b) three times, using three different splits\nof the observations into a training set and a validation set. Comment\non the results obtained.\n(d) Now consider a logistic regression model that predicts the probability\nof default using income, balance, and a dummy variable\nfor student. Estimate the test error for this model using the validation\nset approach. Comment on whether or not including a\ndummy variable for student leads to a reduction in the test error\nrate.\n6. We continue to consider the use of a logistic regression model to\npredict the probability of default using income and balance on the\nDefault data set. In particular, we will now compute estimates for\nthe standard errors of the income and balance logistic regression coefficients\nin two different ways: (1) using the bootstrap, and (2) using\nthe standard formula for computing the standard errors in the glm()\nfunction. Do not forget to set a random seed before beginning your\nanalysis.\n(a) Using the summary() and glm() functions, determine the estimated\nstandard errors for the coefficients associated with income\nand balance in a multiple logistic regression model that uses\nboth predictors.\n(b) Write a function, boot.fn(), that takes as input the Default data\nset as well as an index of the observations, and that outputs\nthe coefficient estimates for income and balance in the multiple\nlogistic regression model.\n(c) Use the boot() function together with your boot.fn() function to\nestimate the standard errors of the logistic regression coefficients\nfor income and balance.\n(d) Comment on the estimated standard errors obtained using the\nglm() function and using your bootstrap function.\n222 5. Resampling Methods\n7. In Sections 5.3.2 and 5.3.3, we saw that the cv.glm() function can be\nused in order to compute the LOOCV test error estimate. Alternatively,\none could compute those quantities using just the glm() and\npredict.glm() functions, and a for loop. You will now take this approach\nin order to compute the LOOCV error for a simple logistic\nregression model on the Weekly data set. Recall that in the context\nof classification problems, the LOOCV error is given in (5.4).\n(a) Fit a logistic regression model that predicts Direction using Lag1\nand Lag2.\n(b) Fit a logistic regression model that predicts Direction using Lag1\nand Lag2 using all but the first observation.\n(c) Use the model from (b) to predict the direction of the first observation.\nYou can do this by predicting that the first observation\nwill go up if P(Direction = \"Up\"|Lag1, Lag2) > 0.5. Was this\nobservation correctly classified?\n(d) Write a for loop from i = 1 to i = n, where n is the number of\nobservations in the data", "doc_id": "94869302-2194-47e9-884e-cd32d683a854", "embedding": null, "doc_hash": "a0befab452f9003a980232da98592d79ed7436863fb46ad41907af60bb370091", "extra_info": null, "node_info": {"start": 526478, "end": 530355, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "4b29b19e-f806-4f51-b1bf-a1810ff2c1d0", "3": "41e91be3-333a-4e46-8d0b-660d272132bd"}}, "__type__": "1"}, "41e91be3-333a-4e46-8d0b-660d272132bd": {"__data__": {"text": "= 1 to i = n, where n is the number of\nobservations in the data set, that performs each of the following\nsteps:\ni. Fit a logistic regression model using all but the ith observation\nto predict Direction using Lag1 and Lag2.\nii. Compute the posterior probability of the market moving up\nfor the ith observation.\niii. Use the posterior probability for the ith observation in order\nto predict whether or not the market moves up.\niv. Determine whether or not an error was made in predicting\nthe direction for the ith observation. If an error was made,\nthen indicate this as a 1, and otherwise indicate it as a 0.\n(e) Take the average of the n numbers obtained in (d)iv in order to\nobtain the LOOCV estimate for the test error. Comment on the\nresults.\n8. We will now perform cross-validation on a simulated data set.\n(a) Generate a simulated data set as follows:\n> set.seed (1)\n> x <- rnorm (100)\n> y <- x - 2 * x^2 + rnorm (100)\nIn this data set, what is n and what is p? Write out the model\nused to generate the data in equation form.\n(b) Create a scatterplot of X against Y . Comment on what you find.\n(c) Set a random seed, and then compute the LOOCV errors that\nresult from fitting the following four models using least squares:\n5.4 Exercises 223\ni. Y = \u03b20 + \u03b21X + \u03f5\nii. Y = \u03b20 + \u03b21X + \u03b22X2 + \u03f5\niii. Y = \u03b20 + \u03b21X + \u03b22X2 + \u03b23X3 + \u03f5\niv. Y = \u03b20 + \u03b21X + \u03b22X2 + \u03b23X3 + \u03b24X4 + \u03f5.\nNote you may find it helpful to use the data.frame() function\nto create a single data set containing both X and Y .\n(d) Repeat (c) using another random seed, and report your results.\nAre your results the same as what you got in (c)? Why?\n(e) Which of the models in (c) had the smallest LOOCV error? Is\nthis what you expected? Explain your answer.\n(f) Comment on the statistical significance of the coefficient estimates\nthat results from fitting each of the models in (c) using\nleast squares. Do these results agree with the conclusions drawn\nbased on the cross-validation results?\n9. We will now consider the Boston housing data set, from the ISLR2\nlibrary.\n(a) Based on this data set, provide an estimate for the population\nmean of medv. Call this estimate \u02c6\u03bc.\n(b) Provide an estimate of the standard error of \u02c6\u03bc. Interpret this\nresult.\nHint: We can compute the standard error of the sample mean by\ndividing the sample standard deviation by the square root of the\nnumber of observations.\n(c) Now estimate the standard error of \u02c6\u03bc using the bootstrap. How\ndoes this compare to your answer from (b)?\n(d) Based on your bootstrap estimate from (c), provide a 95% confidence\ninterval for the mean of medv. Compare it to the results\nobtained using t.test(Boston$medv).\nHint: You can approximate a 95% confidence interval using the\nformula [\u02c6\u03bc \u2212 2SE(\u02c6\u03bc), \u02c6\u03bc + 2SE(\u02c6\u03bc)].\n(e) Based on this data set, provide an estimate, \u02c6\u03bcmed, for the median\nvalue of medv in the population.\n(f) We now would like to estimate the standard error of \u02c6\u03bcmed. Unfortunately,\nthere is no simple formula for computing the standard\nerror of the median. Instead, estimate the standard error of the\nmedian using the bootstrap. Comment on your findings.\n(g) Based on this data set, provide an estimate for the tenth percentile\nof medv in Boston census tracts. Call this quantity \u02c6\u03bc0.1.\n(You can use the quantile() function.)\n(h) Use the bootstrap to estimate the standard", "doc_id": "41e91be3-333a-4e46-8d0b-660d272132bd", "embedding": null, "doc_hash": "b37b2c27a317914640d2906d93bff35a5742c479d47648997872becb2b0bebe4", "extra_info": null, "node_info": {"start": 530371, "end": 533681, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "94869302-2194-47e9-884e-cd32d683a854", "3": "192b0cf2-4162-41b9-aad8-99645bc337c0"}}, "__type__": "1"}, "192b0cf2-4162-41b9-aad8-99645bc337c0": {"__data__": {"text": "use the quantile() function.)\n(h) Use the bootstrap to estimate the standard error of \u02c6\u03bc0.1. Comment\non your findings.\n6\nLinear Model Selection\nand Regularization\nIn the regression setting, the standard linear model\nY = \u03b20 + \u03b21X1 + \u00b7 \u00b7 \u00b7 + \u03b2pXp + \u03f5 (6.1)\nis commonly used to describe the relationship between a response Y and\na set of variables X1,X2, . . . ,Xp. We have seen in Chapter 3 that one\ntypically fits this model using least squares.\nIn the chapters that follow, we consider some approaches for extending\nthe linear model framework. In Chapter 7 we generalize (6.1) in order to\naccommodate non-linear, but still additive, relationships, while in Chapters\n8 and 10 we consider even more general non-linear models. However,\nthe linear model has distinct advantages in terms of inference and, on realworld\nproblems, is often surprisingly competitive in relation to non-linear\nmethods. Hence, before moving to the non-linear world, we discuss in this\nchapter some ways in which the simple linear model can be improved, by replacing\nplain least squares fitting with some alternative fitting procedures.\nWhy might we want to use another fitting procedure instead of least\nsquares? As we will see, alternative fitting procedures can yield better prediction\naccuracy and model interpretability.\n\u2022 Prediction Accuracy: Provided that the true relationship between the\nresponse and the predictors is approximately linear, the least squares\nestimates will have low bias. If n \u226b p\u2014that is, if n, the number of\nobservations, is much larger than p, the number of variables\u2014then the\nleast squares estimates tend to also have low variance, and hence will\nperform well on test observations. However, if n is not much larger\n\u00a9 Springer Science+Business Media, LLC, part of Springer Nature 2021\nG. James et al., An Introduction to Statistical Learning, Springer Texts in Statistics,\nhttps://doi.org/10.1007/978-1-0716-1418-1_6\n225\n226 6. Linear Model Selection and Regularization\nthan p, then there can be a lot of variability in the least squares fit,\nresulting in overfitting and consequently poor predictions on future\nobservations not used in model training. And if p > n, then there\nis no longer a unique least squares coefficient estimate: the variance\nis infinite so the method cannot be used at all. By constraining or\nshrinking the estimated coefficients, we can often substantially reduce\nthe variance at the cost of a negligible increase in bias. This can\nlead to substantial improvements in the accuracy with which we can\npredict the response for observations not used in model training.\n\u2022 Model Interpretability: It is often the case that some or many of the\nvariables used in a multiple regression model are in fact not associated\nwith the response. Including such irrelevant variables leads to\nunnecessary complexity in the resulting model. By removing these\nvariables\u2014that is, by setting the corresponding coefficient estimates\nto zero\u2014we can obtain a model that is more easily interpreted. Now\nleast squares is extremely unlikely to yield any coefficient estimates\nthat are exactly zero. In this chapter, we see some approaches for automatically\nperforming feature selection or variable selection\u2014that is,\nfeature\nselection\nvariable\nselection\nfor excluding irrelevant variables from a multiple regression model.\nThere are many alternatives, both classical and modern, to using least\nsquares to fit (6.1). In this chapter, we discuss three important classes of\nmethods.\n\u2022 Subset Selection. This approach involves identifying a subset of the p\npredictors that we believe to be related to the response. We then fit\na model using least squares on the reduced set of variables.\n\u2022 Shrinkage. This approach involves fitting a model involving all p predictors.\nHowever, the estimated coefficients are shrunken towards zero\nrelative to the least squares estimates. This shrinkage (also known", "doc_id": "192b0cf2-4162-41b9-aad8-99645bc337c0", "embedding": null, "doc_hash": "cc12a6c331f774b507596a5d57283761fa560b29b7da7f9d3b58d874398a95cc", "extra_info": null, "node_info": {"start": 533665, "end": 537555, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "41e91be3-333a-4e46-8d0b-660d272132bd", "3": "f1a5a5d7-0144-4b6d-8c83-fba4109e613b"}}, "__type__": "1"}, "f1a5a5d7-0144-4b6d-8c83-fba4109e613b": {"__data__": {"text": "zero\nrelative to the least squares estimates. This shrinkage (also known as\nregularization) has the effect of reducing variance. Depending on what\ntype of shrinkage is performed, some of the coefficients may be estimated\nto be exactly zero. Hence, shrinkage methods can also perform\nvariable selection.\n\u2022 Dimension Reduction. This approach involves projecting the p predictors\ninto an M-dimensional subspace, whereM <p. This is achieved\nby computing M different linear combinations, or projections, of the\nvariables. Then these M projections are used as predictors to fit a\nlinear regression model by least squares.\nIn the following sections we describe each of these approaches in greater detail,\nalong with their advantages and disadvantages. Although this chapter\ndescribes extensions and modifications to the linear model for regression\nseen in Chapter 3, the same concepts apply to other methods, such as the\nclassification models seen in Chapter 4.\n6.1 Subset Selection 227\n6.1 Subset Selection\nIn this section we consider some methods for selecting subsets of predictors.\nThese include best subset and stepwise model selection procedures.\n6.1.1 Best Subset Selection\nTo perform best subset selection, we fit a separate least squares regression\nbest subset\nfor each possible combination of the p predictors. That is, we fit all p models selection\nthat contain exactly one predictor, all\n'p\n2\n(\n= p(p\u22121)/2 models that contain\nexactly two predictors, and so forth. We then look at all of the resulting\nmodels, with the goal of identifying the one that is best.\nThe problem of selecting the best model from among the 2p possibilities\nconsidered by best subset selection is not trivial. This is usually broken up\ninto two stages, as described in Algorithm 6.1.\nAlgorithm 6.1 Best subset selection\n1. Let M0 denote the null model , which contains no predictors. This\nmodel simply predicts the sample mean for each observation.\n2. For k = 1, 2, . . . p:\n(a) Fit all\n'p\nk\n(\nmodels that contain exactly k predictors.\n(b) Pick the best among these\n'p\nk\n(\nmodels, and call itMk. Here best\nis defined as having the smallest RSS, or equivalently largest R2.\n3. Select a single best model from among M0, . . . ,Mp using crossvalidated\nprediction error, Cp (AIC), BIC, or adjusted R2.\nIn Algorithm 6.1, Step 2 identifies the best model (on the training data)\nfor each subset size, in order to reduce the problem from one of 2p possible\nmodels to one of p + 1 possible models. In Figure 6.1, these models form\nthe lower frontier depicted in red.\nNow in order to select a single best model, we must simply choose among\nthese p + 1 options. This task must be performed with care, because the\nRSS of these p + 1 models decreases monotonically, and the R2 increases\nmonotonically, as the number of features included in the models increases.\nTherefore, if we use these statistics to select the best model, then we will\nalways end up with a model involving all of the variables. The problem is\nthat a low RSS or a high R2 indicates a model with a low training error,\nwhereas we wish to choose a model that has a low test error. (As shown\nin Chapter 2 in Figures 2.9\u20132.11, training error tends to be quite a bit\nsmaller than test error, and a low training error by no means guarantees\na low test error.) Therefore, in Step 3, we use cross-validated prediction\n228 6. Linear Model Selection and Regularization\n2 4 6 8 10\n2e+07 4e+07 6e+07 8e+07\nNumber of Predictors\nResidual Sum of Squares\n2 4 6 8 10\n0.0 0.2 0.4 0.6 0.8 1.0\nNumber of Predictors\nR2\nFIGURE 6.1. For each possible model containing", "doc_id": "f1a5a5d7-0144-4b6d-8c83-fba4109e613b", "embedding": null, "doc_hash": "003bd35fba795e650fab9edb668c5553341a406be0cb7a5ce560e79a9fa739e2", "extra_info": null, "node_info": {"start": 537559, "end": 541137, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "192b0cf2-4162-41b9-aad8-99645bc337c0", "3": "b0c9a07e-1d32-417a-b31a-4e1d71f17124"}}, "__type__": "1"}, "b0c9a07e-1d32-417a-b31a-4e1d71f17124": {"__data__": {"text": "of Predictors\nR2\nFIGURE 6.1. For each possible model containing a subset of the ten predictors\nin the Credit data set, the RSS and R2 are displayed. The red frontier tracks the\nbest model for a given number of predictors, according to RSS and R2. Though\nthe data set contains only ten predictors, the x-axis ranges from 1 to 11, since one\nof the variables is categorical and takes on three values, leading to the creation of\ntwo dummy variables.\nerror, Cp, BIC, or adjusted R2 in order to select among M0,M1, . . . ,Mp.\nThese approaches are discussed in Section 6.1.3.\nAn application of best subset selection is shown in Figure 6.1. Each\nplotted point corresponds to a least squares regression model fit using a\ndifferent subset of the 10 predictors in the Credit data set, discussed in\nChapter 3. Here the variable region is a three-level qualitative variable,\nand so is represented by two dummy variables, which are selected separately\nin this case. Hence, there are a total of 11 possible variables which\ncan be included in the model. We have plotted the RSS and R2 statistics\nfor each model, as a function of the number of variables. The red curves\nconnect the best models for each model size, according to RSS or R2. The\nfigure shows that, as expected, these quantities improve as the number of\nvariables increases; however, from the three-variable model on, there is little\nimprovement in RSS and R2 as a result of including additional predictors.\nAlthough we have presented best subset selection here for least squares\nregression, the same ideas apply to other types of models, such as logistic\nregression. In the case of logistic regression, instead of ordering models by\nRSS in Step 2 of Algorithm 6.1, we instead use the deviance, a measure\ndeviance\nthat plays the role of RSS for a broader class of models. The deviance is\nnegative two times the maximized log-likelihood; the smaller the deviance,\nthe better the fit.\nWhile best subset selection is a simple and conceptually appealing approach,\nit suffers from computational limitations. The number of possible\nmodels that must be considered grows rapidly as p increases. In general,\n6.1 Subset Selection 229\nthere are 2p models that involve subsets of p predictors. So if p = 10,\nthen there are approximately 1,000 possible models to be considered, and if\np = 20, then there are over one million possibilities! Consequently, best subset\nselection becomes computationally infeasible for values of p greater than\naround 40, even with extremely fast modern computers. There are computational\nshortcuts\u2014so called branch-and-bound techniques\u2014for eliminating\nsome choices, but these have their limitations as p gets large. They also\nonly work for least squares linear regression. We present computationally\nefficient alternatives to best subset selection next.\n6.1.2 Stepwise Selection\nFor computational reasons, best subset selection cannot be applied with\nvery large p. Best subset selection may also suffer from statistical problems\nwhen p is large. The larger the search space, the higher the chance of finding\nmodels that look good on the training data, even though they might not\nhave any predictive power on future data. Thus an enormous search space\ncan lead to overfitting and high variance of the coefficient estimates.\nFor both of these reasons, stepwise methods, which explore a far more\nrestricted set of models, are attractive alternatives to best subset selection.\nForward Stepwise Selection\nForward stepwise selection is a computationally efficient alternative to best\nforward\nstepwise\nselection\nsubset selection. While the best subset selection procedure considers all\n2p possible models containing subsets of the p predictors, forward stepwise\nconsiders a much smaller set of models. Forward stepwise selection\nbegins with a model containing no predictors, and then adds predictors\nto the model, one-at-a-time, until all of the predictors are in the model.\nIn particular, at", "doc_id": "b0c9a07e-1d32-417a-b31a-4e1d71f17124", "embedding": null, "doc_hash": "d1ac6682cad64feb73b23012c044883cffdfbed770a16927ec4f3bb683089a4c", "extra_info": null, "node_info": {"start": 541145, "end": 545093, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "f1a5a5d7-0144-4b6d-8c83-fba4109e613b", "3": "319ab550-079a-48c5-bccc-0537747da450"}}, "__type__": "1"}, "319ab550-079a-48c5-bccc-0537747da450": {"__data__": {"text": "until all of the predictors are in the model.\nIn particular, at each step the variable that gives the greatest additional\nimprovement to the fit is added to the model. More formally, the forward\nstepwise selection procedure is given in Algorithm 6.2.\nUnlike best subset selection, which involved fitting 2p models, forward\nstepwise selection involves fitting one null model, along with p \u2212 k models\nin the kth ) iteration, for k = 0, . . . , p \u2212 1. This amounts to a total of 1 + p\u22121\nk=0(p\u2212k) = 1+p(p+1)/2 models. This is a substantial difference: when\np = 20, best subset selection requires fitting 1,048,576 models, whereas\nforward stepwise selection requires fitting only 211 models.1\n1Though forward stepwise selection considers p(p + 1)/2 + 1 models, it performs a\nguided search over model space, and so the effective model space considered contains\nsubstantially more than p(p + 1)/2 + 1 models.\n230 6. Linear Model Selection and Regularization\nAlgorithm 6.2 Forward stepwise selection\n1. Let M0 denote the null model, which contains no predictors.\n2. For k = 0, . . . ,p \u2212 1:\n(a) Consider all p \u2212 k models that augment the predictors in Mk\nwith one additional predictor.\n(b) Choose the best among these p \u2212 k models, and call it Mk+1.\nHere best is defined as having smallest RSS or highest R2.\n3. Select a single best model from among M0, . . . ,Mp using crossvalidated\nprediction error, Cp (AIC), BIC, or adjusted R2.\nIn Step 2(b) of Algorithm 6.2, we must identify the best model from\namong those p\u2212k that augmentMk with one additional predictor. We can\ndo this by simply choosing the model with the lowest RSS or the highest\nR2. However, in Step 3, we must identify the best model among a set of\nmodels with different numbers of variables. This is more challenging, and\nis discussed in Section 6.1.3.\nForward stepwise selection\u2019s computational advantage over best subset\nselection is clear. Though forward stepwise tends to do well in practice,\nit is not guaranteed to find the best possible model out of all 2p models\ncontaining subsets of the p predictors. For instance, suppose that in a\ngiven data set with p = 3 predictors, the best possible one-variable model\ncontains X1, and the best possible two-variable model instead contains X2\nand X3. Then forward stepwise selection will fail to select the best possible\ntwo-variable model, because M1 will contain X1, so M2 must also contain\nX1 together with one additional variable.\nTable 6.1, which shows the first four selected models for best subset\nand forward stepwise selection on the Credit data set, illustrates this phenomenon.\nBoth best subset selection and forward stepwise selection choose\nrating for the best one-variable model and then include income and student\nfor the two- and three-variable models. However, best subset selection replaces\nrating by cards in the four-variable model, while forward stepwise\nselection must maintain rating in its four-variable model. In this example,\nFigure 6.1 indicates that there is not much difference between the threeand\nfour-variable models in terms of RSS, so either of the four-variable\nmodels will likely be adequate.\nForward stepwise selection can be applied even in the high-dimensional\nsetting where n < p; however, in this case, it is possible to construct submodels\nM0, . . . ,Mn\u22121 only, since each submodel is fit using least squares,\nwhich will not yield a unique solution if p \u2265 n.\n6.1 Subset Selection 231\n# Variables Best subset Forward stepwise\nOne rating rating\nTwo rating, income rating, income\nThree rating, income, student rating, income, student\nFour cards, income rating, income,\nstudent, limit student, limit\nTABLE 6.1. The first four selected models for best subset selection and forward\nstepwise selection on the Credit data set. The first three models are", "doc_id": "319ab550-079a-48c5-bccc-0537747da450", "embedding": null, "doc_hash": "d1ae00d3efa2e3d78161f6e95dd944c64adde4e9551b503fcd3a9ddbb3194032", "extra_info": null, "node_info": {"start": 545097, "end": 548891, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "b0c9a07e-1d32-417a-b31a-4e1d71f17124", "3": "52b8fc11-6573-46fc-b500-044077840daf"}}, "__type__": "1"}, "52b8fc11-6573-46fc-b500-044077840daf": {"__data__": {"text": "subset selection and forward\nstepwise selection on the Credit data set. The first three models are identical but\nthe fourth models differ.\nBackward Stepwise Selection\nLike forward stepwise selection, backward stepwise selection provides an efbackward\nstepwise\nselection\nficient alternative to best subset selection. However, unlike forward stepwise\nselection, it begins with the full least squares model containing all p predictors,\nand then iteratively removes the least useful predictor, one-at-a-time.\nDetails are given in Algorithm 6.3.\nAlgorithm 6.3 Backward stepwise selection\n1. Let Mp denote the full model, which contains all p predictors.\n2. For k = p, p \u2212 1, . . . , 1:\n(a) Consider all k models that contain all but one of the predictors\nin Mk, for a total of k \u2212 1 predictors.\n(b) Choose the best among these k models, and call it Mk\u22121. Here\nbest is defined as having smallest RSS or highest R2.\n3. Select a single best model from among M0, . . . ,Mp using crossvalidated\nprediction error, Cp (AIC), BIC, or adjusted R2.\nLike forward stepwise selection, the backward selection approach searches\nthrough only 1+p(p+1)/2 models, and so can be applied in settings where\np is too large to apply best subset selection.2 Also like forward stepwise\nselection, backward stepwise selection is not guaranteed to yield the best\nmodel containing a subset of the p predictors.\nBackward selection requires that the number of samples n is larger than\nthe number of variables p (so that the full model can be fit). In contrast,\nforward stepwise can be used even when n < p, and so is the only viable\nsubset method when p is very large.\n2Like forward stepwise selection, backward stepwise selection performs a guided\nsearch over model space, and so effectively considers substantially more than 1+p(p+1)/2\nmodels.\n232 6. Linear Model Selection and Regularization\nHybrid Approaches\nThe best subset, forward stepwise, and backward stepwise selection approaches\ngenerally give similar but not identical models. As another alternative,\nhybrid versions of forward and backward stepwise selection are\navailable, in which variables are added to the model sequentially, in analogy\nto forward selection. However, after adding each new variable, the method\nmay also remove any variables that no longer provide an improvement in\nthe model fit. Such an approach attempts to more closely mimic best subset\nselection while retaining the computational advantages of forward and\nbackward stepwise selection.\n6.1.3 Choosing the Optimal Model\nBest subset selection, forward selection, and backward selection result in\nthe creation of a set of models, each of which contains a subset of the p\npredictors. To apply these methods, we need a way to determine which of\nthese models is best. As we discussed in Section 6.1.1, the model containing\nall of the predictors will always have the smallest RSS and the largest R2,\nsince these quantities are related to the training error. Instead, we wish to\nchoose a model with a low test error. As is evident here, and as we show\nin Chapter 2, the training error can be a poor estimate of the test error.\nTherefore, RSS and R2 are not suitable for selecting the best model among\na collection of models with different numbers of predictors.\nIn order to select the best model with respect to test error, we need to\nestimate this test error. There are two common approaches:\n1. We can indirectly estimate test error by making an adjustment to the\ntraining error to account for the bias due to overfitting.\n2. We can directly estimate the test error, using either a validation set\napproach or a cross-validation approach, as discussed in Chapter 5.\nWe consider both of these approaches below.\nCp, AIC, BIC, and Adjusted R2\nWe show in Chapter 2 that the training set MSE is generally an underestimate\nof the test MSE. (Recall that MSE = RSS/n.) This is", "doc_id": "52b8fc11-6573-46fc-b500-044077840daf", "embedding": null, "doc_hash": "dd2d385c9edb6c819463f0a73d1d47a7bd915b44aa303ebb90810079d721dc4b", "extra_info": null, "node_info": {"start": 548861, "end": 552724, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "319ab550-079a-48c5-bccc-0537747da450", "3": "907c8a0e-89f4-4fd2-9140-4e6477a4bca6"}}, "__type__": "1"}, "907c8a0e-89f4-4fd2-9140-4e6477a4bca6": {"__data__": {"text": "the test MSE. (Recall that MSE = RSS/n.) This is because\nwhen we fit a model to the training data using least squares, we specifically\nestimate the regression coefficients such that the training RSS (but\nnot the test RSS) is as small as possible. In particular, the training error\nwill decrease as more variables are included in the model, but the test error\nmay not. Therefore, training set RSS and training set R2 cannot be used\nto select from among a set of models with different numbers of variables.\nHowever, a number of techniques for adjusting the training error for the\nmodel size are available. These approaches can be used to select among a set\n6.1 Subset Selection 233\n2 4 6 8 10\n10000 15000 20000 25000 30000\nNumber of Predictors\nCp\n2 4 6 8 10\n10000 15000 20000 25000 30000\nNumber of Predictors\nBIC\n2 4 6 8 10\n0.86 0.88 0.90 0.92 0.94 0.96\nNumber of Predictors\nAdjusted R2\nFIGURE 6.2. Cp, BIC, and adjusted R2 are shown for the best models of each\nsize for the Credit data set (the lower frontier in Figure 6.1). Cp and BIC are\nestimates of test MSE. In the middle plot we see that the BIC estimate of test\nerror shows an increase after four variables are selected. The other two plots are\nrather flat after four variables are included.\nof models with different numbers of variables. We now consider four such\napproaches: Cp, Akaike information criterion (AIC), Bayesian information\nCp\nAkaike\ninformation\ncriterion\ncriterion (BIC), and adjusted R2. Figure 6.2 displays Cp, BIC, and adjusted\nBayesian\ninformation\ncriterion\nadjusted R2\nR2 for the best model of each size produced by best subset selection on the\nCredit data set.\nFor a fitted least squares model containing d predictors, the Cp estimate\nof test MSE is computed using the equation\nCp =\n1\nn\n'\nRSS + 2d\u02c6\u03c32(\n, (6.2)\nwhere \u02c6\u03c32 is an estimate of the variance of the error \u03f5 associated with each\nresponse measurement in (6.1).3 Typically \u02c6\u03c32 is estimated using the full\nmodel containing all predictors. Essentially, the Cp statistic adds a penalty\nof 2d\u02c6\u03c32 to the training RSS in order to adjust for the fact that the training\nerror tends to underestimate the test error. Clearly, the penalty increases as\nthe number of predictors in the model increases; this is intended to adjust\nfor the corresponding decrease in training RSS. Though it is beyond the\nscope of this book, one can show that if \u02c6\u03c32 is an unbiased estimate of \u03c32 in\n(6.2), then Cp is an unbiased estimate of test MSE. As a consequence, the\nCp statistic tends to take on a small value for models with a low test error,\nso when determining which of a set of models is best, we choose the model\nwith the lowest Cp value. In Figure 6.2, Cp selects the six-variable model\ncontaining the predictors income, limit, rating, cards, age and student.\n3Mallow\u2019s Cp is sometimes defined as C\u2032p = RSS/\u02c6\u03c32 + 2d \u2212 n. This is equivalent to\nthe definition given above in the sense that Cp = 1\nn \u02c6\u03c32(C\u2032p + n), and so the model with\nsmallest Cp also has smallest C\u2032p .\n234 6. Linear Model Selection and Regularization\nThe AIC criterion is defined for a large class of models fit by maximum\nlikelihood. In the case of the model (6.1) with Gaussian errors, maximum\nlikelihood and least squares are the same thing. In this case AIC is given by\nAIC =\n1\nn\n'\nRSS + 2d\u02c6\u03c32(\n,\nwhere, for simplicity, we have omitted irrelevant constants.4 Hence for least\nsquares models, Cp and AIC are proportional to each", "doc_id": "907c8a0e-89f4-4fd2-9140-4e6477a4bca6", "embedding": null, "doc_hash": "7de87cabd5d68839af65e037f567c3b5beafd9e2d50906280fd9e50c76e26455", "extra_info": null, "node_info": {"start": 552770, "end": 556182, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "52b8fc11-6573-46fc-b500-044077840daf", "3": "243e6d62-f1b3-4a21-8f25-c7b69c9d3675"}}, "__type__": "1"}, "243e6d62-f1b3-4a21-8f25-c7b69c9d3675": {"__data__": {"text": "for least\nsquares models, Cp and AIC are proportional to each other, and so only\nCp is displayed in Figure 6.2.\nBIC is derived from a Bayesian point of view, but ends up looking similar\nto Cp (and AIC) as well. For the least squares model with d predictors, the\nBIC is, up to irrelevant constants, given by\nBIC =\n1\nn\n'\nRSS + log(n)d\u02c6\u03c32(\n. (6.3)\nLike Cp, the BIC will tend to take on a small value for a model with a\nlow test error, and so generally we select the model that has the lowest\nBIC value. Notice that BIC replaces the 2d\u02c6\u03c32 used by Cp with a log(n)d\u02c6\u03c32\nterm, where n is the number of observations. Since logn > 2 for any n > 7,\nthe BIC statistic generally places a heavier penalty on models with many\nvariables, and hence results in the selection of smaller models than Cp.\nIn Figure 6.2, we see that this is indeed the case for the Credit data set;\nBIC chooses a model that contains only the four predictors income, limit,\ncards, and student. In this case the curves are very flat and so there does\nnot appear to be much difference in accuracy between the four-variable and\nsix-variable models.\nThe adjusted R2 statistic is another popular approach for selecting among\na set of models that contain different numbers of variables. Recall from\nC)hapter 3 that the usual R2 is defined as 1 \u2212 RSS/TSS, where TSS =\n(yi \u2212 y)2 is the total sum of squares for the response. Since RSS always\ndecreases as more variables are added to the model, the R2 always increases\nas more variables are added. For a least squares model with d variables,\nthe adjusted R2 statistic is calculated as\nAdjusted R2 = 1\u2212\nRSS/(n \u2212 d \u2212 1)\nTSS/(n \u2212 1)\n. (6.4)\nUnlike Cp, AIC, and BIC, for which a small value indicates a model with\na low test error, a large value of adjusted R2 indicates a model with a\n4There are two formulas for AIC for least squares regression. The formula that we\nprovide here requires an expression for \u03c32, which we obtain using the full model containing\nall predictors. The second formula is appropriate when \u03c32 is unknown and we do\nnot want to explicitly estimate it; that formula has a log(RSS) term instead of an RSS\nterm. Detailed derivations of these two formulas are outside of the scope of this book.\n6.1 Subset Selection 235\nsmall test error. Maximizing the adjusted R2 is equivalent to minimizing\nRSS\nn\u2212d\u22121 . While RSS always decreases as the number of variables in the model\nincreases, RSS\nn\u2212d\u22121 may increase or decrease, due to the presence of d in the\ndenominator.\nThe intuition behind the adjusted R2 is that once all of the correct\nvariables have been included in the model, adding additional noise variables\nwill lead to only a very small decrease in RSS. Since adding noise variables\nleads to an increase in d, such variables will lead to an increase in RSS\nn\u2212d\u22121 ,\nand consequently a decrease in the adjusted R2. Therefore, in theory, the\nmodel with the largest adjusted R2 will have only correct variables and\nno noise variables. Unlike the R2 statistic, the adjusted R2 statistic pays\na price for the inclusion of unnecessary variables in the model. Figure 6.2\ndisplays the adjusted R2 for the Credit data set. Using this statistic results\nin the selection of a model that contains seven variables, adding own to the\nmodel selected by Cp and AIC.\nCp, AIC, and BIC all have rigorous theoretical justifications that are\nbeyond the scope of this book. These justifications rely on asymptotic arguments\n(scenarios where the sample size n is very large). Despite its popularity,\nand even though it", "doc_id": "243e6d62-f1b3-4a21-8f25-c7b69c9d3675", "embedding": null, "doc_hash": "4c082185f14ff14e615d7236fdb30eea3da581ad1b5137f56858532f57470926", "extra_info": null, "node_info": {"start": 556170, "end": 559685, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "907c8a0e-89f4-4fd2-9140-4e6477a4bca6", "3": "4384ed07-1b67-4025-8809-07d3a03dde04"}}, "__type__": "1"}, "4384ed07-1b67-4025-8809-07d3a03dde04": {"__data__": {"text": "where the sample size n is very large). Despite its popularity,\nand even though it is quite intuitive, the adjusted R2 is not as well\nmotivated in statistical theory as AIC, BIC, and Cp. All of these measures\nare simple to use and compute. Here we have presented their formulas in\nthe case of a linear model fit using least squares; however, AIC and BIC\ncan also be defined for more general types of models.\nValidation and Cross-Validation\nAs an alternative to the approaches just discussed, we can directly estimate\nthe test error using the validation set and cross-validation methods\ndiscussed in Chapter 5. We can compute the validation set error or the\ncross-validation error for each model under consideration, and then select\nthe model for which the resulting estimated test error is smallest. This procedure\nhas an advantage relative to AIC, BIC, Cp, and adjusted R2, in that\nit provides a direct estimate of the test error, and makes fewer assumptions\nabout the true underlying model. It can also be used in a wider range of\nmodel selection tasks, even in cases where it is hard to pinpoint the model\ndegrees of freedom (e.g. the number of predictors in the model) or hard to\nestimate the error variance \u03c32.\nIn the past, performing cross-validation was computationally prohibitive\nfor many problems with large p and/or large n, and so AIC, BIC, Cp,\nand adjusted R2 were more attractive approaches for choosing among a\nset of models. However, nowadays with fast computers, the computations\nrequired to perform cross-validation are hardly ever an issue. Thus, crossvalidation\nis a very attractive approach for selecting from among a number\nof models under consideration.\n236 6. Linear Model Selection and Regularization\n2 4 6 8 10\n100 120 140 160 180 200 220\nNumber of Predictors\nSquare Root of BIC\n2 4 6 8 10\n100 120 140 160 180 200 220\nNumber of Predictors\nValidation Set Error\n2 4 6 8 10\n100 120 140 160 180 200 220\nNumber of Predictors\nCross\u2212Validation Error\nFIGURE 6.3. For the Credit data set, three quantities are displayed for the\nbest model containing d predictors, for d ranging from 1 to 11. The overall best\nmodel, based on each of these quantities, is shown as a blue cross. Left: Square\nroot of BIC. Center: Validation set errors. Right: Cross-validation errors.\nFigure 6.3 displays, as a function of d, the BIC, validation set errors, and\ncross-validation errors on the Credit data, for the best d-variable model.\nThe validation errors were calculated by randomly selecting three-quarters\nof the observations as the training set, and the remainder as the validation\nset. The cross-validation errors were computed using k = 10 folds.\nIn this case, the validation and cross-validation methods both result in a\nsix-variable model. However, all three approaches suggest that the four-,\nfive-, and six-variable models are roughly equivalent in terms of their test\nerrors.\nIn fact, the estimated test error curves displayed in the center and righthand\npanels of Figure 6.3 are quite flat. While a three-variable model clearly\nhas lower estimated test error than a two-variable model, the estimated test\nerrors of the 3- to 11-variable models are quite similar. Furthermore, if we\nrepeated the validation set approach using a different split of the data into\na training set and a validation set, or if we repeated cross-validation using\na different set of cross-validation folds, then the precise model with the\nlowest estimated test error would surely change. In this setting, we can\nselect a model using the one-standard-error rule. We first calculate the onestandarderror\nrule\nstandard error of the estimated test MSE for each model size, and then\nselect the smallest model for which the estimated test error is within one\nstandard error of the lowest point on the curve. The rationale here is that\nif a set of models appear to be more or less equally good, then we might\nas well choose the simplest model\u2014that", "doc_id": "4384ed07-1b67-4025-8809-07d3a03dde04", "embedding": null, "doc_hash": "598e081451befdf1d94c8e394fd6521fe0345ef9e948fc69bfadcc1cb52e3cc2", "extra_info": null, "node_info": {"start": 559669, "end": 563596, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "243e6d62-f1b3-4a21-8f25-c7b69c9d3675", "3": "e660c20d-1c2d-4d14-ad0c-5da0fd198711"}}, "__type__": "1"}, "e660c20d-1c2d-4d14-ad0c-5da0fd198711": {"__data__": {"text": "less equally good, then we might\nas well choose the simplest model\u2014that is, the model with the smallest\nnumber of predictors. In this case, applying the one-standard-error rule\nto the validation set or cross-validation approach leads to selection of the\nthree-variable model.\n6.2 Shrinkage Methods 237\n6.2 Shrinkage Methods\nThe subset selection methods described in Section 6.1 involve using least\nsquares to fit a linear model that contains a subset of the predictors. As an\nalternative, we can fit a model containing all p predictors using a technique\nthat constrains or regularizes the coefficient estimates, or equivalently, that\nshrinks the coefficient estimates towards zero. It may not be immediately\nobvious why such a constraint should improve the fit, but it turns out that\nshrinking the coefficient estimates can significantly reduce their variance.\nThe two best-known techniques for shrinking the regression coefficients\ntowards zero are ridge regression and the lasso.\n6.2.1 Ridge Regression\nRecall from Chapter 3 that the least squares fitting procedure estimates\n\u03b20,\u03b21, . . . ,\u03b2p using the values that minimize\nRSS =\n0n\ni=1\n\u239b\n\u239dyi \u2212 \u03b20 \u2212\n0p\nj=1\n\u03b2jxij\n\u239e\n\u23a0\n2\n.\nRidge regression is very similar to least squares, except that the coefficients\nridge\nare estimated by minimizing a slightly different quantity. In particular, the regression\nridge regression coefficient estimates \u02c6 \u03b2R are the values that minimize\n0n\ni=1\n\u239b\n\u239dyi \u2212 \u03b20 \u2212\n0p\nj=1\n\u03b2jxij\n\u239e\n\u23a0\n2\n+ \u03bb\n0p\nj=1\n\u03b22\nj = RSS + \u03bb\n0p\nj=1\n\u03b22\nj , (6.5)\nwhere \u03bb \u2265 0 is a tuning parameter, to be determined separately. Equatuning\ntion 6.5 trades off two different criteria. As with least squares, ridge regres- parameter\nsion seeks coefficient estimates that fit the data well, by making the RSS\nsmall. However, the second term, \u03bb\n)\nj \u03b22\nj , called a shrinkage penalty, is\nshrinkage\nsmall when \u03b21, . . . , \u03b2p are close to zero, and so it has the effect of shrinking penalty\nthe estimates of \u03b2j towards zero. The tuning parameter \u03bb serves to control\nthe relative impact of these two terms on the regression coefficient estimates.\nWhen \u03bb = 0, the penalty term has no effect, and ridge regression\nwill produce the least squares estimates. However, as \u03bb\u2192\u221e, the impact of\nthe shrinkage penalty grows, and the ridge regression coefficient estimates\nwill approach zero. Unlike least squares, which generates only one set of coefficient\nestimates, ridge regression will produce a different set of coefficient\nestimates, \u02c6 \u03b2R\n\u03bb , for each value of \u03bb. Selecting a good value for \u03bb is critical;\nwe defer this discussion to Section 6.2.3, where we use cross-validation.\nNote that in (6.5), the shrinkage penalty is applied to \u03b21, . . . ,\u03b2p, but\nnot to the intercept \u03b20. We want to shrink the estimated association of\n238 6. Linear Model Selection and Regularization\n1e\u221202 1e+00 1e+02 1e+04\n\u2212300 \u2212100 0 100 200 300 400\nStandardized Coefficients\nIncome\nLimit\nRating\nStudent\n0.0 0.2 0.4 0.6 0.8 1.0\n\u2212300 \u2212100 0 100 200 300 400\nStandardized Coefficients\n\u03bb \u2225\u02c6 \u03b2R\n\u03bb \u22252/\u2225\u02c6 \u03b2\u22252\nFIGURE 6.4. The standardized ridge regression coefficients are displayed for\nthe Credit data set, as a function of \u03bb and \u2225\u02c6\u03b2R\n\u03bb", "doc_id": "e660c20d-1c2d-4d14-ad0c-5da0fd198711", "embedding": null, "doc_hash": "8e0c2ddd38167000f182ffded4266433fe5a91f7c6c840a29e8ee8eb04f9cf6f", "extra_info": null, "node_info": {"start": 563605, "end": 566741, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "4384ed07-1b67-4025-8809-07d3a03dde04", "3": "241fef15-a22e-4bef-b628-5db30369c15e"}}, "__type__": "1"}, "241fef15-a22e-4bef-b628-5db30369c15e": {"__data__": {"text": "Credit data set, as a function of \u03bb and \u2225\u02c6\u03b2R\n\u03bb \u22252/\u2225\u02c6\u03b2\u22252.\neach variable with the response; however, we do not want to shrink the\nintercept, which is simply a measure of the mean value of the response\nwhen xi1 = xi2 = . . . = xip = 0. If we assume that the variables\u2014that is,\nthe columns of the data matrix X\u2014have been centered to have mean zero\nbefore ridge regression is performed, then the estimated intercept will take\nthe form \u02c6 \u03b20 = \u00afy =\n)n\ni=1 yi/n.\nAn Application to the Credit Data\nIn Figure 6.4, the ridge regression coefficient estimates for the Credit data\nset are displayed. In the left-hand panel, each curve corresponds to the\nridge regression coefficient estimate for one of the ten variables, plotted\nas a function of \u03bb. For example, the black solid line represents the ridge\nregression estimate for the income coefficient, as \u03bb is varied. At the extreme\nleft-hand side of the plot, \u03bb is essentially zero, and so the corresponding\nridge coefficient estimates are the same as the usual least squares estimates.\nBut as \u03bb increases, the ridge coefficient estimates shrink towards\nzero. When \u03bb is extremely large, then all of the ridge coefficient estimates\nare basically zero; this corresponds to the null model that contains no predictors.\nIn this plot, the income, limit, rating, and student variables are\ndisplayed in distinct colors, since these variables tend to have by far the\nlargest coefficient estimates. While the ridge coefficient estimates tend to\ndecrease in aggregate as \u03bb increases, individual coefficients, such as rating\nand income, may occasionally increase as \u03bb increases.\nThe right-hand panel of Figure 6.4 displays the same ridge coefficient\nestimates as the left-hand panel, but instead of displaying \u03bb on the x-axis,\nwe now display \u2225\u02c6 \u03b2R\n\u03bb \u22252/\u2225\u02c6 \u03b2\u22252, where \u02c6 \u03b2 denotes the vector of least squares\ncoefficient estimates. The notation \u2225\u03b2\u22252 denotes the \u21132 norm (pronounced\n\u21132 norm\n\u201cell 2\u201d) of a vector, and is defined as \u2225\u03b2\u22252 =\nG)p\nj=1 \u03b2j\n2. It measures\n6.2 Shrinkage Methods 239\nthe distance of \u03b2 from zero. As \u03bb increases, the \u21132 norm of \u02c6 \u03b2R\n\u03bb will always\ndecrease, and so will \u2225\u02c6 \u03b2R\n\u03bb \u22252/\u2225\u02c6 \u03b2\u22252. The latter quantity ranges from 1 (when\n\u03bb = 0, in which case the ridge regression coefficient estimate is the same\nas the least squares estimate, and so their \u21132 norms are the same) to 0\n(when \u03bb = \u221e, in which case the ridge regression coefficient estimate is a\nvector of zeros, with \u21132 norm equal to zero). Therefore, we can think of the\nx-axis in the right-hand panel of Figure 6.4 as the amount that the ridge\nregression coefficient estimates have been shrunken towards zero; a small\nvalue indicates that they have been shrunken very close to zero.\nThe standard least squares coefficient estimates discussed in Chapter 3\nare scale equivariant: multiplying Xj by a constant c simply leads to a\nscale\nscaling of the least squares coefficient estimates by a factor of 1/c. In other equivariant\nwords, regardless of how the jth predictor is scaled, Xj \u02c6 \u03b2j will remain the\nsame. In contrast, the ridge regression coefficient estimates can change substantially\nwhen multiplying a given predictor by a constant. For instance,\nconsider the income variable, which is measured in dollars. One could reasonably\nhave measured income in thousands of dollars, which would result\nin a reduction in the observed values of income by a factor of 1,000. Now due\nto the sum of squared coefficients term in the ridge regression formulation\n(6.5), such a", "doc_id": "241fef15-a22e-4bef-b628-5db30369c15e", "embedding": null, "doc_hash": "c2b76862421869fddf78c6b886f62d35442abc3e1b83b26f1c2694f15132767a", "extra_info": null, "node_info": {"start": 566766, "end": 570234, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "e660c20d-1c2d-4d14-ad0c-5da0fd198711", "3": "19952d28-562d-4bad-8415-0b682240d1b3"}}, "__type__": "1"}, "19952d28-562d-4bad-8415-0b682240d1b3": {"__data__": {"text": "squared coefficients term in the ridge regression formulation\n(6.5), such a change in scale will not simply cause the ridge regression coefficient\nestimate for income to change by a factor of 1,000. In other words,\nXj \u02c6 \u03b2R\nj,\u03bb will depend not only on the value of \u03bb, but also on the scaling of the\njth predictor. In fact, the value of Xj \u02c6 \u03b2R\nj,\u03bb may even depend on the scaling\nof the other predictors! Therefore, it is best to apply ridge regression after\nstandardizing the predictors, using the formula\n\u02dcxij =\nG xij\n1n\n)n\ni=1(xij \u2212 xj)2\n, (6.6)\nso that they are all on the same scale. In (6.6), the denominator is the\nestimated standard deviation of the jth predictor. Consequently, all of the\nstandardized predictors will have a standard deviation of one. As a result\nthe final fit will not depend on the scale on which the predictors are\nmeasured. In Figure 6.4, the y-axis displays the standardized ridge regression\ncoefficient estimates\u2014that is, the coefficient estimates that result from\nperforming ridge regression using standardized predictors.\nWhy Does Ridge Regression Improve Over Least Squares?\nRidge regression\u2019s advantage over least squares is rooted in the bias-variance\ntrade-off. As \u03bb increases, the flexibility of the ridge regression fit decreases,\nleading to decreased variance but increased bias. This is illustrated in the\nleft-hand panel of Figure 6.5, using a simulated data set containing p = 45\npredictors and n = 50 observations. The green curve in the left-hand panel\nof Figure 6.5 displays the variance of the ridge regression predictions as a\n240 6. Linear Model Selection and Regularization\n1e\u221201 1e+01 1e+03\n0 10 20 30 40 50 60\nMean Squared Error\n0.0 0.2 0.4 0.6 0.8 1.0\n0 10 20 30 40 50 60\nMean Squared Error\n\u03bb \u2225\u02c6 \u03b2R\n\u03bb \u22252/\u2225\u02c6 \u03b2\u22252\nFIGURE 6.5. Squared bias (black), variance (green), and test mean squared\nerror (purple) for the ridge regression predictions on a simulated data set, as a\nfunction of \u03bb and \u2225\u02c6\u03b2R\n\u03bb \u22252/\u2225\u02c6\u03b2\u22252. The horizontal dashed lines indicate the minimum\npossible MSE. The purple crosses indicate the ridge regression models for which\nthe MSE is smallest.\nfunction of \u03bb. At the least squares coefficient estimates, which correspond\nto ridge regression with \u03bb = 0, the variance is high but there is no bias. But\nas \u03bb increases, the shrinkage of the ridge coefficient estimates leads to a\nsubstantial reduction in the variance of the predictions, at the expense of a\nslight increase in bias. Recall that the test mean squared error (MSE), plotted\nin purple, is closely related to the variance plus the squared bias. For\nvalues of \u03bb up to about 10, the variance decreases rapidly, with very little\nincrease in bias, plotted in black. Consequently, the MSE drops considerably\nas \u03bb increases from 0 to 10. Beyond this point, the decrease in variance\ndue to increasing \u03bb slows, and the shrinkage on the coefficients causes them\nto be significantly underestimated, resulting in a large increase in the bias.\nThe minimum MSE is achieved at approximately \u03bb = 30. Interestingly,\nbecause of its high variance, the MSE associated with the least squares\nfit, when \u03bb = 0, is almost as high as that of the null model for which all\ncoefficient estimates are zero, when \u03bb = \u221e. However, for an intermediate\nvalue of \u03bb, the MSE is considerably lower.\nThe right-hand panel of Figure 6.5 displays the same curves as the lefthand\npanel, this time plotted against the \u21132 norm of the ridge regression\ncoefficient", "doc_id": "19952d28-562d-4bad-8415-0b682240d1b3", "embedding": null, "doc_hash": "a532d70605d0ab52634e68ac1f335c8d00e5ffe662f37556102ab314a3cbd9c4", "extra_info": null, "node_info": {"start": 570206, "end": 573642, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "241fef15-a22e-4bef-b628-5db30369c15e", "3": "a09f3677-6c4b-4e3d-a2e6-94660c7a40b9"}}, "__type__": "1"}, "a09f3677-6c4b-4e3d-a2e6-94660c7a40b9": {"__data__": {"text": "this time plotted against the \u21132 norm of the ridge regression\ncoefficient estimates divided by the \u21132 norm of the least squares estimates.\nNow as we move from left to right, the fits become more flexible, and so\nthe bias decreases and the variance increases.\nIn general, in situations where the relationship between the response\nand the predictors is close to linear, the least squares estimates will have\nlow bias but may have high variance. This means that a small change in\nthe training data can cause a large change in the least squares coefficient\nestimates. In particular, when the number of variables p is almost as large\nas the number of observations n, as in the example in Figure 6.5, the\nleast squares estimates will be extremely variable. And if p > n, then the\n6.2 Shrinkage Methods 241\nleast squares estimates do not even have a unique solution, whereas ridge\nregression can still perform well by trading off a small increase in bias for a\nlarge decrease in variance. Hence, ridge regression works best in situations\nwhere the least squares estimates have high variance.\nRidge regression also has substantial computational advantages over best\nsubset selection, which requires searching through 2p models. As we discussed\npreviously, even for moderate values of p, such a search can be\ncomputationally infeasible. In contrast, for any fixed value of \u03bb, ridge regression\nonly fits a single model, and the model-fitting procedure can be\nperformed quite quickly. In fact, one can show that the computations required\nto solve (6.5), simultaneously for all values of \u03bb, are almost identical\nto those for fitting a model using least squares.\n6.2.2 The Lasso\nRidge regression does have one obvious disadvantage. Unlike best subset,\nforward stepwise, and backward stepwise selection, which will generally\nselect models that involve just a subset of the variables, ridge regression\nwill include all p predictors in the final model. The penalty \u03bb\n)\n\u03b22\nj in (6.5)\nwill shrink all of the coefficients towards zero, but it will not set any of them\nexactly to zero (unless \u03bb = \u221e). This may not be a problem for prediction\naccuracy, but it can create a challenge in model interpretation in settings in\nwhich the number of variables p is quite large. For example, in the Credit\ndata set, it appears that the most important variables are income, limit,\nrating, and student. So we might wish to build a model including just\nthese predictors. However, ridge regression will always generate a model\ninvolving all ten predictors. Increasing the value of \u03bb will tend to reduce\nthe magnitudes of the coefficients, but will not result in exclusion of any of\nthe variables.\nThe lasso is a relatively recent alternative to ridge regression that overlasso\ncomes this disadvantage. The lasso coefficients, \u02c6 \u03b2L\n\u03bb , minimize the quantity\n0n\ni=1\n\u239b\n\u239dyi \u2212 \u03b20 \u2212\n0p\nj=1\n\u03b2jxij\n\u239e\n\u23a0\n2\n+ \u03bb\n0p\nj=1\n|\u03b2j | = RSS + \u03bb\n0p\nj=1\n|\u03b2j |. (6.7)\nComparing (6.7) to (6.5), we see that the lasso and ridge regression have\nsimilar formulations. The only difference is that the \u03b22\nj term in the ridge\nregression penalty (6.5) has been replaced by |\u03b2j | in the lasso penalty (6.7).\nIn statistical parlance, the lasso uses an \u21131 (pronounced \u201cell 1\u201d) penalty\ninstead of an \u21132 penalty. The \u21131 norm of a coefficient vector \u03b2 is given by\n\u2225\u03b2\u22251 =\n)\n|\u03b2j |.\nAs with ridge regression, the lasso shrinks the coefficient estimates towards\nzero. However, in the case of the lasso, the \u21131 penalty has the effect\nof forcing some of the coefficient estimates to", "doc_id": "a09f3677-6c4b-4e3d-a2e6-94660c7a40b9", "embedding": null, "doc_hash": "aef6e9d07c714e973b11c46348fe0b55e27731e821ab775708017fa1d8abbbb2", "extra_info": null, "node_info": {"start": 573646, "end": 577149, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "19952d28-562d-4bad-8415-0b682240d1b3", "3": "675d5242-18ac-4d68-9b5f-e50ed7537571"}}, "__type__": "1"}, "675d5242-18ac-4d68-9b5f-e50ed7537571": {"__data__": {"text": "\u21131 penalty has the effect\nof forcing some of the coefficient estimates to be exactly equal to zero when\n242 6. Linear Model Selection and Regularization\nthe tuning parameter \u03bb is sufficiently large. Hence, much like best subset selection,\nthe lasso performs variable selection. As a result, models generated\nfrom the lasso are generally much easier to interpret than those produced\nby ridge regression. We say that the lasso yields sparse models\u2014that is, sparse\nmodels that involve only a subset of the variables. As in ridge regression,\nselecting a good value of \u03bb for the lasso is critical; we defer this discussion\nto Section 6.2.3, where we use cross-validation.\nAs an example, consider the coefficient plots in Figure 6.6, which are generated\nfrom applying the lasso to the Credit data set. When \u03bb = 0, then\nthe lasso simply gives the least squares fit, and when \u03bb becomes sufficiently\nlarge, the lasso gives the null model in which all coefficient estimates equal\nzero. However, in between these two extremes, the ridge regression and\nlasso models are quite different from each other. Moving from left to right\nin the right-hand panel of Figure 6.6, we observe that at first the lasso results\nin a model that contains only the rating predictor. Then student and\nlimit enter the model almost simultaneously, shortly followed by income.\nEventually, the remaining variables enter the model. Hence, depending on\nthe value of \u03bb, the lasso can produce a model involving any number of variables.\nIn contrast, ridge regression will always include all of the variables in\nthe model, although the magnitude of the coefficient estimates will depend\non \u03bb.\n20 50 100 200 500 2000 5000\n\u2212200 0 100 200 300 400\nStandardized Coefficients\n0.0 0.2 0.4 0.6 0.8 1.0\n\u2212300 \u2212100 0 100 200 300 400\nStandardized Coefficients\nIncome\nLimit\nRating\nStudent\n\u03bb \u2225\u02c6 \u03b2L\n\u03bb \u22251/\u2225\u02c6 \u03b2\u22251\nFIGURE 6.6. The standardized lasso coefficients on the Credit data set are\nshown as a function of \u03bb and \u2225\u02c6\u03b2L\n\u03bb \u22251/\u2225\u02c6\u03b2\u22251.\n6.2 Shrinkage Methods 243\nAnother Formulation for Ridge Regression and the Lasso\nOne can show that the lasso and ridge regression coefficient estimates solve\nthe problems\nminimize\n\u03b2\n\u23a7\u23aa\u23a8\n\u23aa\u23a9\n0n\ni=1\n\u239b\n\u239dyi \u2212 \u03b20 \u2212\n0p\nj=1\n\u03b2jxij\n\u239e\n\u23a0\n2\n\u23ab\u23aa\u23ac\n\u23aa\u23ad\nsubject to\n0p\nj=1\n|\u03b2j| \u2264 s\n(6.8)\nand\nminimize\n\u03b2\n\u23a7\u23aa\u23a8\n\u23aa\u23a9\n0n\ni=1\n\u239b\n\u239dyi \u2212 \u03b20 \u2212\n0p\nj=1\n\u03b2jxij\n\u239e\n\u23a0\n2\n\u23ab\u23aa\u23ac\n\u23aa\u23ad\nsubject to\n0p\nj=1\n\u03b22\nj \u2264 s,\n(6.9)\nrespectively. In other words, for every value of \u03bb, there is some s such that\nthe Equations (6.7) and (6.8) will give the same lasso coefficient estimates.\nSimilarly, for every value of \u03bb there is a corresponding s such that Equations\n(6.5) and (6.9) will give the same ridge regression coefficient estimates.\nWhen p = 2, then (6.8) indicates that the lasso coefficient estimates have\nthe smallest RSS out of all points that lie within the diamond defined by\n|\u03b21| + |\u03b22| \u2264 s. Similarly, the ridge regression estimates have the smallest\nRSS out of all points that lie within the circle defined by \u03b22\n1 + \u03b22\n2 \u2264 s.\nWe can think of (6.8) as follows. When we perform the", "doc_id": "675d5242-18ac-4d68-9b5f-e50ed7537571", "embedding": null, "doc_hash": "ce5b2fc4a46dacef894880b875f44364b299a494c3019fd0ece6cc048ee1f8ed", "extra_info": null, "node_info": {"start": 577151, "end": 580161, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "a09f3677-6c4b-4e3d-a2e6-94660c7a40b9", "3": "8763dfff-1300-4ae4-809b-8c79dda2853d"}}, "__type__": "1"}, "8763dfff-1300-4ae4-809b-8c79dda2853d": {"__data__": {"text": "can think of (6.8) as follows. When we perform the lasso we are trying\nto find the set of coefficient estimates that lead to the smallest RSS, subject\nto the constraint that there is a budget s for how large\n)p\nj=1 |\u03b2j | can be.\nWhen s is extremely large, then this budget is not very restrictive, and so\nthe coefficient estimates can be large. In fact, if s is large enough that the\nleast squares solution falls within the budget, then (6.8) will simply yield\nthe least squares solution. In contrast, if s is small, then\n)p\nj=1 |\u03b2j | must be\nsmall in order to avoid violating the budget. Similarly, (6.9) indicates that\nwhen we perform ridge regression, we seek a set of coefficient estimates\ns)uch that the RSS is as small as possible, subject to the requirement that p\nj=1 \u03b22\nj not exceed the budget s.\nThe formulations (6.8) and (6.9) reveal a close connection between the\nlasso, ridge regression, and best subset selection. Consider the problem\nminimize\n\u03b2\n\u23a7\u23aa\u23a8\n\u23aa\u23a9\n0n\ni=1\n\u239b\n\u239dyi \u2212 \u03b20 \u2212\n0p\nj=1\n\u03b2jxij\n\u239e\n\u23a0\n2\n\u23ab\u23aa\u23ac\n\u23aa\u23ad\nsubject to\n0p\nj=1\nI(\u03b2j \u0338= 0) \u2264 s.\n(6.10)\nHere I(\u03b2j \u0338= 0) is an indicator variable: it takes on a value of 1 if \u03b2j \u0338= 0, and\nequals zero otherwise. Then (6.10) amounts to finding a set of coefficient\nestimates such that RSS is as small as possible, subject to the constraint\nthat no more than s coefficients can be nonzero. The problem (6.10) is\n244 6. Linear Model Selection and Regularization\nFIGURE 6.7. Contours of the error and constraint functions for the lasso\n(left) and ridge regression (right). The solid blue areas are the constraint regions,\n|\u03b21| + |\u03b22| \u2264 s and \u03b22\n1 + \u03b22\n2 \u2264 s, while the red ellipses are the contours of\nthe RSS.\nequivalent to best subset selection. Unfortunately, solving (6.10) is computationally\ninfeasible when p is large, since it requires considering all\n'p\ns\n(\nmodels containing s predictors. Therefore, we can interpret ridge regression\nand the lasso as computationally feasible alternatives to best subset selection\nthat replace the intractable form of the budget in (6.10) with forms\nthat are much easier to solve. Of course, the lasso is much more closely\nrelated to best subset selection, since the lasso performs feature selection\nfor s sufficiently small in (6.8), while ridge regression does not.\nThe Variable Selection Property of the Lasso\nWhy is it that the lasso, unlike ridge regression, results in coefficient estimates\nthat are exactly equal to zero? The formulations (6.8) and (6.9) can\nbe used to shed light on the issue. Figure 6.7 illustrates the situation. The\nleast squares solution is marked as \u02c6 \u03b2, while the blue diamond and circle\nrepresent the lasso and ridge regression constraints in (6.8) and (6.9), respectively.\nIf s is sufficiently large, then the constraint regions will contain\n\u02c6 \u03b2, and so the ridge regression and lasso estimates will be the same as the\nleast squares estimates. (Such a large value of s corresponds to \u03bb = 0 in\n(6.5) and (6.7).) However, in Figure 6.7 the least squares estimates lie outside\nof the diamond and the circle, and so the least squares estimates are\nnot the same as the lasso and ridge regression estimates.\nEach of the ellipses centered around \u02c6 \u03b2 represents a contour: this means\ncontour\nthat all of", "doc_id": "8763dfff-1300-4ae4-809b-8c79dda2853d", "embedding": null, "doc_hash": "e631379e094985f9221418ae96df9bea90f12b271d552d9e476a9089e0a0a976", "extra_info": null, "node_info": {"start": 580183, "end": 583398, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "675d5242-18ac-4d68-9b5f-e50ed7537571", "3": "c3234f86-a66c-42f3-aa26-28806439a34f"}}, "__type__": "1"}, "c3234f86-a66c-42f3-aa26-28806439a34f": {"__data__": {"text": "around \u02c6 \u03b2 represents a contour: this means\ncontour\nthat all of the points on a particular ellipse have the same RSS value. As\n6.2 Shrinkage Methods 245\n0.02 0.10 0.50 2.00 10.00 50.00\n0 10 20 30 40 50 60\nMean Squared Error\n0.0 0.2 0.4 0.6 0.8 1.0\n0 10 20 30 40 50 60\nR2 on Training Data\nMean Squared Error\n\u03bb\nFIGURE 6.8. Left: Plots of squared bias (black), variance (green), and test MSE\n(purple) for the lasso on a simulated data set. Right: Comparison of squared bias,\nvariance, and test MSE between lasso (solid) and ridge (dotted). Both are plotted\nagainst their R2 on the training data, as a common form of indexing. The crosses\nin both plots indicate the lasso model for which the MSE is smallest.\nthe ellipses expand away from the least squares coefficient estimates, the\nRSS increases. Equations (6.8) and (6.9) indicate that the lasso and ridge\nregression coefficient estimates are given by the first point at which an\nellipse contacts the constraint region. Since ridge regression has a circular\nconstraint with no sharp points, this intersection will not generally occur on\nan axis, and so the ridge regression coefficient estimates will be exclusively\nnon-zero. However, the lasso constraint has corners at each of the axes, and\nso the ellipse will often intersect the constraint region at an axis. When this\noccurs, one of the coefficients will equal zero. In higher dimensions, many of\nthe coefficient estimates may equal zero simultaneously. In Figure 6.7, the\nintersection occurs at \u03b21 = 0, and so the resulting model will only include\n\u03b22.\nIn Figure 6.7, we considered the simple case of p = 2. When p = 3,\nthen the constraint region for ridge regression becomes a sphere, and the\nconstraint region for the lasso becomes a polyhedron. When p > 3, the\nconstraint for ridge regression becomes a hypersphere, and the constraint\nfor the lasso becomes a polytope. However, the key ideas depicted in Figure\n6.7 still hold. In particular, the lasso leads to feature selection when\np > 2 due to the sharp corners of the polyhedron or polytope.\nComparing the Lasso and Ridge Regression\nIt is clear that the lasso has a major advantage over ridge regression, in\nthat it produces simpler and more interpretable models that involve only a\nsubset of the predictors. However, which method leads to better prediction\naccuracy? Figure 6.8 displays the variance, squared bias, and test MSE of\nthe lasso applied to the same simulated data as in Figure 6.5. Clearly the\nlasso leads to qualitatively similar behavior to ridge regression, in that as \u03bb\n246 6. Linear Model Selection and Regularization\n0.02 0.10 0.50 2.00 10.00 50.00\n0 20 40 60 80 100\nMean Squared Error\n0.4 0.5 0.6 0.7 0.8 0.9 1.0\n0 20 40 60 80 100\nR2 on Training Data\nMean Squared Error\n\u03bb\nFIGURE 6.9. Left: Plots of squared bias (black), variance (green), and test MSE\n(purple) for the lasso. The simulated data is similar to that in Figure 6.8, except\nthat now only two predictors are related to the response. Right: Comparison of\nsquared bias, variance, and test MSE between lasso (solid) and ridge (dotted).\nBoth are plotted against their R2 on the training data, as a common form of\nindexing. The crosses in both plots indicate the lasso model for which the MSE is\nsmallest.\nincreases, the variance decreases and the bias increases. In the right-hand\npanel of Figure 6.8, the dotted lines represent the ridge regression fits.\nHere we plot both against their", "doc_id": "c3234f86-a66c-42f3-aa26-28806439a34f", "embedding": null, "doc_hash": "e354d4f6256a2779d12ec4be0a93278b765637c2ee03e64768d437d77b54186d", "extra_info": null, "node_info": {"start": 583386, "end": 586811, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "8763dfff-1300-4ae4-809b-8c79dda2853d", "3": "872e2a71-b8da-405a-ae5e-8fce5146b5b4"}}, "__type__": "1"}, "872e2a71-b8da-405a-ae5e-8fce5146b5b4": {"__data__": {"text": "the dotted lines represent the ridge regression fits.\nHere we plot both against their R2 on the training data. This is another\nuseful way to index models, and can be used to compare models with\ndifferent types of regularization, as is the case here. In this example, the\nlasso and ridge regression result in almost identical biases. However, the\nvariance of ridge regression is slightly lower than the variance of the lasso.\nConsequently, the minimum MSE of ridge regression is slightly smaller than\nthat of the lasso.\nHowever, the data in Figure 6.8 were generated in such a way that all 45\npredictors were related to the response\u2014that is, none of the true coefficients\n\u03b21, . . . ,\u03b245 equaled zero. The lasso implicitly assumes that a number of the\ncoefficients truly equal zero. Consequently, it is not surprising that ridge\nregression outperforms the lasso in terms of prediction error in this setting.\nFigure 6.9 illustrates a similar situation, except that now the response is a\nfunction of only 2 out of 45 predictors. Now the lasso tends to outperform\nridge regression in terms of bias, variance, and MSE.\nThese two examples illustrate that neither ridge regression nor the lasso\nwill universally dominate the other. In general, one might expect the lasso\nto perform better in a setting where a relatively small number of predictors\nhave substantial coefficients, and the remaining predictors have coefficients\nthat are very small or that equal zero. Ridge regression will perform better\nwhen the response is a function of many predictors, all with coefficients of\nroughly equal size. However, the number of predictors that is related to the\nresponse is never known a priori for real data sets. A technique such as\n6.2 Shrinkage Methods 247\ncross-validation can be used in order to determine which approach is better\non a particular data set.\nAs with ridge regression, when the least squares estimates have excessively\nhigh variance, the lasso solution can yield a reduction in variance\nat the expense of a small increase in bias, and consequently can generate\nmore accurate predictions. Unlike ridge regression, the lasso performs\nvariable selection, and hence results in models that are easier to interpret.\nThere are very efficient algorithms for fitting both ridge and lasso models;\nin both cases the entire coefficient paths can be computed with about the\nsame amount of work as a single least squares fit. We will explore this\nfurther in the lab at the end of this chapter.\nA Simple Special Case for Ridge Regression and the Lasso\nIn order to obtain a better intuition about the behavior of ridge regression\nand the lasso, consider a simple special case with n = p, and X a diagonal\nmatrix with 1\u2019s on the diagonal and 0\u2019s in all off-diagonal elements.\nTo simplify the problem further, assume also that we are performing regression\nwithout an intercept. With these assumptions, the usual least squares\nproblem simplifies to finding \u03b21, . . . ,\u03b2p that minimize\n0p\nj=1\n(yj \u2212 \u03b2j)2. (6.11)\nIn this case, the least squares solution is given by\n\u02c6 \u03b2j = yj .\nAnd in this setting, ridge regression amounts to finding \u03b21, . . . ,\u03b2p such that\n0p\nj=1\n(yj \u2212 \u03b2j)2 + \u03bb\n0p\nj=1\n\u03b22\nj (6.12)\nis minimized, and the lasso amounts to finding the coefficients such that\n0p\nj=1\n(yj \u2212 \u03b2j)2 + \u03bb\n0p\nj=1\n|\u03b2j | (6.13)\nis minimized. One can show that in this setting, the ridge regression estimates\ntake the form\n\u02c6 \u03b2R\nj = yj/(1 + \u03bb), (6.14)\nand the lasso estimates take the form\n\u02c6 \u03b2L\nj =\n\u23a7\u23aa\u23a8\n\u23aa\u23a9\nyj \u2212 \u03bb/2 if yj > \u03bb/2;\nyj +", "doc_id": "872e2a71-b8da-405a-ae5e-8fce5146b5b4", "embedding": null, "doc_hash": "16120897c94eafa68425062c54973aafa68629270fcd7275446fa6f3eb809354", "extra_info": null, "node_info": {"start": 586793, "end": 590297, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "c3234f86-a66c-42f3-aa26-28806439a34f", "3": "d6690399-8d4d-4c0c-9218-c6f59defe403"}}, "__type__": "1"}, "d6690399-8d4d-4c0c-9218-c6f59defe403": {"__data__": {"text": "\u2212 \u03bb/2 if yj > \u03bb/2;\nyj + \u03bb/2 if yj < \u2212\u03bb/2;\n0 if |yj| \u2264 \u03bb/2.\n(6.15)\n248 6. Linear Model Selection and Regularization\n\u22121.5 \u22120.5 0.0 0.5 1.0 1.5\n\u22121.5 \u22120.5 0.5 1.5\nCoefficient Estimate\nRidge\nLeast Squares\n\u22121.5 \u22120.5 0.0 0.5 1.0 1.5\n\u22121.5 \u22120.5 0.5 1.5\nCoefficient Estimate\nLasso\nLeast Squares\nyj yj\nFIGURE 6.10. The ridge regression and lasso coefficient estimates for a simple\nsetting with n = p and X a diagonal matrix with 1\u2019s on the diagonal. Left: The\nridge regression coefficient estimates are shrunken proportionally towards zero,\nrelative to the least squares estimates. Right: The lasso coefficient estimates are\nsoft-thresholded towards zero.\nFigure 6.10 displays the situation. We can see that ridge regression and\nthe lasso perform two very different types of shrinkage. In ridge regression,\neach least squares coefficient estimate is shrunken by the same proportion.\nIn contrast, the lasso shrinks each least squares coefficient towards zero by\na constant amount, \u03bb/2; the least squares coefficients that are less than\n\u03bb/2 in absolute value are shrunken entirely to zero. The type of shrinkage\nperformed by the lasso in this simple setting (6.15) is known as softthresholding.\nThe fact that some lasso coefficients are shrunken entirely to\nsoftzero\nexplains why the lasso performs feature selection. thresholding\nIn the case of a more general data matrix X, the story is a little more\ncomplicated than what is depicted in Figure 6.10, but the main ideas still\nhold approximately: ridge regression more or less shrinks every dimension\nof the data by the same proportion, whereas the lasso more or less shrinks\nall coefficients toward zero by a similar amount, and sufficiently small coefficients\nare shrunken all the way to zero.\nBayesian Interpretation for Ridge Regression and the Lasso\nWe now show that one can view ridge regression and the lasso through\na Bayesian lens. A Bayesian viewpoint for regression assumes that the\ncoefficient vector \u03b2 has some prior distribution, say p(\u03b2), where \u03b2 =\n(\u03b20,\u03b21, . . . ,\u03b2p)T . The likelihood of the data can be written as f(Y |X, \u03b2),\nwhere X = (X1, . . . ,Xp). Multiplying the prior distribution by the likelihood\ngives us (up to a proportionality constant) the posterior distribution,\nposterior\nwhich takes the form distribution\np(\u03b2|X, Y ) \u221d f(Y |X, \u03b2)p(\u03b2|X) = f(Y |X, \u03b2)p(\u03b2),\n6.2 Shrinkage Methods 249\n\u22123 \u22122 \u22121 0 1 2 3\n0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7\n\u22123 \u22122 \u22121 0 1 2 3\n0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7\n\u03b2j \u03b2j\ng(\u03b2j)\ng(\u03b2j)\nFIGURE 6.11. Left: Ridge regression is the posterior mode for \u03b2 under a Gaussian\nprior. Right: The lasso is the posterior mode for \u03b2 under a double-exponential\nprior.\nwhere the proportionality above follows from Bayes\u2019 theorem, and the\nequality above follows from the assumption that X is fixed.\nWe assume the usual linear model,\nY = \u03b20 + X1\u03b21 + \u00b7 \u00b7 \u00b7 + Xp\u03b2p + \u03f5,\nand suppose that the errors are independent and drawn from a normal distribution.\nFurthermore, assume that p(\u03b2) =\nFp\nj=1 g(\u03b2j ), for some density\nfunction g. It turns out that ridge regression and", "doc_id": "d6690399-8d4d-4c0c-9218-c6f59defe403", "embedding": null, "doc_hash": "59b6aed9e165ca36b2aa3a31835d166b39bc16b9e3015863453509c0c82a5a6d", "extra_info": null, "node_info": {"start": 590354, "end": 593381, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "872e2a71-b8da-405a-ae5e-8fce5146b5b4", "3": "76ac472a-532c-4781-9367-24153497750a"}}, "__type__": "1"}, "76ac472a-532c-4781-9367-24153497750a": {"__data__": {"text": "), for some density\nfunction g. It turns out that ridge regression and the lasso follow naturally\nfrom two special cases of g:\n\u2022 If g is a Gaussian distribution with mean zero and standard deviation\na function of \u03bb, then it follows that the posterior mode for \u03b2\u2014that\nposterior\nis, the most likely value for \u03b2, given the data\u2014is given by the ridge mode\nregression solution. (In fact, the ridge regression solution is also the\nposterior mean.)\n\u2022 If g is a double-exponential (Laplace) distribution with mean zero\nand scale parameter a function of \u03bb, then it follows that the posterior\nmode for \u03b2 is the lasso solution. (However, the lasso solution is not\nthe posterior mean, and in fact, the posterior mean does not yield a\nsparse coefficient vector.)\nThe Gaussian and double-exponential priors are displayed in Figure 6.11.\nTherefore, from a Bayesian viewpoint, ridge regression and the lasso follow\ndirectly from assuming the usual linear model with normal errors, together\nwith a simple prior distribution for \u03b2. Notice that the lasso prior is steeply\npeaked at zero, while the Gaussian is flatter and fatter at zero. Hence, the\nlasso expects a priori that many of the coefficients are (exactly) zero, while\nridge assumes the coefficients are randomly distributed about zero.\n250 6. Linear Model Selection and Regularization\n5e\u221203 5e\u221202 5e\u221201 5e+00\n25.0 25.2 25.4 25.6\nCross\u2212Validation Error\n5e\u221203 5e\u221202 5e\u221201 5e+00\n\u2212300 \u2212100 0 100 300\nStandardized Coefficients\n\u03bb \u03bb\nFIGURE 6.12. Left: Cross-validation errors that result from applying ridge\nregression to the Credit data set with various values of \u03bb. Right: The coefficient\nestimates as a function of \u03bb. The vertical dashed lines indicate the value of \u03bb\nselected by cross-validation.\n6.2.3 Selecting the Tuning Parameter\nJust as the subset selection approaches considered in Section 6.1 require\na method to determine which of the models under consideration is best,\nimplementing ridge regression and the lasso requires a method for selecting\na value for the tuning parameter \u03bb in (6.5) and (6.7), or equivalently, the\nvalue of the constraint s in (6.9) and (6.8). Cross-validation provides a simple\nway to tackle this problem. We choose a grid of \u03bb values, and compute\nthe cross-validation error for each value of \u03bb, as described in Chapter 5. We\nthen select the tuning parameter value for which the cross-validation error\nis smallest. Finally, the model is re-fit using all of the available observations\nand the selected value of the tuning parameter.\nFigure 6.12 displays the choice of \u03bb that results from performing leaveone-\nout cross-validation on the ridge regression fits from the Credit data\nset. The dashed vertical lines indicate the selected value of \u03bb. In this case\nthe value is relatively small, indicating that the optimal fit only involves a\nsmall amount of shrinkage relative to the least squares solution. In addition,\nthe dip is not very pronounced, so there is rather a wide range of values\nthat would give a very similar error. In a case like this we might simply use\nthe least squares solution.\nFigure 6.13 provides an illustration of ten-fold cross-validation applied to\nthe lasso fits on the sparse simulated data from Figure 6.9. The left-hand\npanel of Figure 6.13 displays the cross-validation error, while the right-hand\npanel displays the coefficient estimates. The vertical dashed lines indicate\nthe point at which the cross-validation error is smallest. The two colored\nlines in the right-hand panel of Figure 6.13 represent the two predictors\nthat are related to the response, while the grey lines represent the unrelated\npredictors; these are often referred to as signal and noise variables,\nsignal\nrespectively. Not only has the lasso correctly given much larger coeffi6.3\nDimension Reduction", "doc_id": "76ac472a-532c-4781-9367-24153497750a", "embedding": null, "doc_hash": "cdbdf28a339abe91d1ae3dcb7fb41e1de82fe71885f9e8bd15b734b449615093", "extra_info": null, "node_info": {"start": 593340, "end": 597115, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "d6690399-8d4d-4c0c-9218-c6f59defe403", "3": "ba66fc38-9864-4479-80a8-74f974d2bb6d"}}, "__type__": "1"}, "ba66fc38-9864-4479-80a8-74f974d2bb6d": {"__data__": {"text": "the lasso correctly given much larger coeffi6.3\nDimension Reduction Methods 251\n0.0 0.2 0.4 0.6 0.8 1.0\n0 200 600 1000 1400\nCross\u2212Validation Error\n0.0 0.2 0.4 0.6 0.8 1.0\n\u22125 0 5 10 15\nStandardized Coefficients\n\u2225 \u02c6 \u03b2L\n\u2225 \u03bb \u22251/\u2225\u03b2\u02c6\u22251 \u02c6 \u03b2L\n\u03bb \u22251/\u2225 \u02c6 \u03b2\u22251\nFIGURE 6.13. Left: Ten-fold cross-validation MSE for the lasso, applied to\nthe sparse simulated data set from Figure 6.9. Right: The corresponding lasso\ncoefficient estimates are displayed. The two signal variables are shown in color,\nand the noise variables are in gray. The vertical dashed lines indicate the lasso\nfit for which the cross-validation error is smallest.\ncient estimates to the two signal predictors, but also the minimum crossvalidation\nerror corresponds to a set of coefficient estimates for which only\nthe signal variables are non-zero. Hence cross-validation together with the\nlasso has correctly identified the two signal variables in the model, even\nthough this is a challenging setting, with p = 45 variables and only n = 50\nobservations. In contrast, the least squares solution\u2014displayed on the far\nright of the right-hand panel of Figure 6.13\u2014assigns a large coefficient\nestimate to only one of the two signal variables.\n6.3 Dimension Reduction Methods\nThe methods that we have discussed so far in this chapter have controlled\nvariance in two different ways, either by using a subset of the original variables,\nor by shrinking their coefficients toward zero. All of these methods\nare defined using the original predictors, X1,X2, . . . ,Xp. We now explore\na class of approaches that transform the predictors and then fit a least\nsquares model using the transformed variables. We will refer to these techniques\nas dimension reduction methods.\ndimension\nLet Z1,Z2, . . . ,ZM represent M < p linear combinations of our original reduction\nlinear\ncombination\np predictors. That is,\nZm =\n0p\nj=1\n\u03c6jmXj (6.16)\n252 6. Linear Model Selection and Regularization\nfor some constants \u03c61m,\u03c62m . . . ,\u03c6pm, m = 1, . . . ,M. We can then fit the\nlinear regression model\nyi = \u03b80 +\nM0\nm=1\n\u03b8mzim + \u03f5i, i= 1, . . . , n, (6.17)\nusing least squares. Note that in (6.17), the regression coefficients are given\nby \u03b80, \u03b81, . . . , \u03b8M. If the constants \u03c61m,\u03c62m, . . . ,\u03c6pm are chosen wisely, then\nsuch dimension reduction approaches can often outperform least squares\nregression. In other words, fitting (6.17) using least squares can lead to\nbetter results than fitting (6.1) using least squares.\nThe term dimension reduction comes from the fact that this approach\nreduces the problem of estimating the p+1 coefficients \u03b20,\u03b21, . . . ,\u03b2p to the\nsimpler problem of estimating the M + 1 coefficients \u03b80, \u03b81, . . . , \u03b8M, where\nM < p. In other words, the dimension of the problem has been reduced\nfrom p + 1 to M + 1.\nNotice that from (6.16),\nM0\nm=1\n\u03b8mzim =\nM0\nm=1\n\u03b8m\n0p\nj=1\n\u03c6jmxij =\n0p\nj=1\nM0\nm=1\n\u03b8m\u03c6jmxij =\n0p\nj=1\n\u03b2jxij ,\nwhere\n\u03b2j =\nM0\nm=1\n\u03b8m\u03c6jm. (6.18)\nHence (6.17) can be thought of as", "doc_id": "ba66fc38-9864-4479-80a8-74f974d2bb6d", "embedding": null, "doc_hash": "db867547d22b31656aa1a1a7f61efd6f1bb8cef036b119831d345bf5ca846627", "extra_info": null, "node_info": {"start": 597115, "end": 600044, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "76ac472a-532c-4781-9367-24153497750a", "3": "d50bd706-4d5b-402d-9957-a64b602e9f2e"}}, "__type__": "1"}, "d50bd706-4d5b-402d-9957-a64b602e9f2e": {"__data__": {"text": "(6.18)\nHence (6.17) can be thought of as a special case of the original linear\nregression model given by (6.1). Dimension reduction serves to constrain\nthe estimated \u03b2j coefficients, since now they must take the form (6.18).\nThis constraint on the form of the coefficients has the potential to bias the\ncoefficient estimates. However, in situations where p is large relative to n,\nselecting a value of M \u226a p can significantly reduce the variance of the fitted\ncoefficients. If M = p, and all the Zm are linearly independent, then (6.18)\nposes no constraints. In this case, no dimension reduction occurs, and so\nfitting (6.17) is equivalent to performing least squares on the original p\npredictors.\nAll dimension reduction methods work in two steps. First, the transformed\npredictors Z1, Z2, . . . ,ZM are obtained. Second, the model is fit\nusing these M predictors. However, the choice of Z1, Z2, . . . ,ZM, or equivalently,\nthe selection of the \u03c6jm\u2019s, can be achieved in different ways. In this\nchapter, we will consider two approaches for this task: principal components\nand partial least squares.\n6.3.1 Principal Components Regression\nPrincipal components analysis (PCA) is a popular approach for deriving\nprincipal\ncomponents\nanalysis\n6.3 Dimension Reduction Methods 253\n10 20 30 40 50 60 70\n0 5 10 15 20 25 30 35\nPopulation\nAd Spending\nFIGURE 6.14. The population size (pop) and ad spending (ad) for 100 different\ncities are shown as purple circles. The green solid line indicates the first principal\ncomponent, and the blue dashed line indicates the second principal component.\na low-dimensional set of features from a large set of variables. PCA is\ndiscussed in greater detail as a tool for unsupervised learning in Chapter 12.\nHere we describe its use as a dimension reduction technique for regression.\nAn Overview of Principal Components Analysis\nPCA is a technique for reducing the dimension of an n\u00d7p data matrix X.\nThe first principal component direction of the data is that along which the\nobservations vary the most. For instance, consider Figure 6.14, which shows\npopulation size (pop) in tens of thousands of people, and ad spending for a\nparticular company (ad) in thousands of dollars, for 100 cities5. The green\nsolid line represents the first principal component direction of the data. We\ncan see by eye that this is the direction along which there is the greatest\nvariability in the data. That is, if we projected the 100 observations onto\nthis line (as shown in the left-hand panel of Figure 6.15), then the resulting\nprojected observations would have the largest possible variance; projecting\nthe observations onto any other line would yield projected observations\nwith lower variance. Projecting a point onto a line simply involves finding\nthe location on the line which is closest to the point.\nThe first principal component is displayed graphically in Figure 6.14, but\nhow can it be summarized mathematically? It is given by the formula\nZ1 = 0.839 \u00d7 (pop \u2212 pop) + 0.544 \u00d7 (ad \u2212 ad). (6.19)\n5This dataset is distinct from the Advertising data discussed in Chapter 3.\n254 6. Linear Model Selection and Regularization\n20 30 40 50\n5 10 15 20 25 30\nPopulation\nAd Spending\n\u221220 \u221210 0 10 20\n\u221210 \u22125 0 5 10\n1st Principal Component\n2nd Principal Component\nFIGURE 6.15. A subset of the advertising data. The mean pop and ad budgets\nare indicated with a blue circle. Left: The first principal component direction is\nshown in green. It is the dimension along which the data vary the most, and it also\ndefines the line that is closest to all n of the observations. The distances from each\nobservation to the principal component are represented using the black dashed line\nsegments. The blue dot represents", "doc_id": "d50bd706-4d5b-402d-9957-a64b602e9f2e", "embedding": null, "doc_hash": "d26da4ed625893088e17c3049dd79b7d435979d0b2da6335bd03157e9482ca06", "extra_info": null, "node_info": {"start": 600071, "end": 603787, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "ba66fc38-9864-4479-80a8-74f974d2bb6d", "3": "02ba2420-4cd0-4e95-9db3-5a58b76afdfe"}}, "__type__": "1"}, "02ba2420-4cd0-4e95-9db3-5a58b76afdfe": {"__data__": {"text": "component are represented using the black dashed line\nsegments. The blue dot represents (pop, ad). Right: The left-hand panel has been\nrotated so that the first principal component direction coincides with the x-axis.\nHere \u03c611 = 0.839 and \u03c621 = 0.544 are the principal component loadings,\nwhich define the direction referred to above. In (6.19), pop indicates the\nmean of all pop values in this data set, and ad indicates the mean of all advertising\nspending. The idea is that out of every possible linear combination\nof pop and ad such that \u03c62\n11 + \u03c62\n21 = 1, this particular linear combination\nyields the highest variance: i.e. this is the linear combination for which\nVar(\u03c611 \u00d7 (pop \u2212 pop) + \u03c621 \u00d7 (ad \u2212 ad)) is maximized. It is necessary to\nconsider only linear combinations of the form \u03c62\n11+\u03c62\n21 = 1, since otherwise\nwe could increase \u03c611 and \u03c621 arbitrarily in order to blow up the variance.\nIn (6.19), the two loadings are both positive and have similar size, and so\nZ1 is almost an average of the two variables.\nSince n = 100, pop and ad are vectors of length 100, and so is Z1 in\n(6.19). For instance,\nzi1 = 0.839 \u00d7 (popi \u2212 pop) + 0.544 \u00d7 (adi \u2212 ad). (6.20)\nThe values of z11, . . . , zn1 are known as the principal component scores, and\ncan be seen in the right-hand panel of Figure 6.15.\nThere is also another interpretation for PCA: the first principal component\nvector defines the line that is as close as possible to the data. For\ninstance, in Figure 6.14, the first principal component line minimizes the\nsum of the squared perpendicular distances between each point and the\nline. These distances are plotted as dashed line segments in the left-hand\npanel of Figure 6.15, in which the crosses represent the projection of each\npoint onto the first principal component line. The first principal component\nhas been chosen so that the projected observations are as close as possible\nto the original observations.\n6.3 Dimension Reduction Methods 255\n\u22123 \u22122 \u22121 0 1 2 3\n20 30 40 50 60\n1st Principal Component\nPopulation\n\u22123 \u22122 \u22121 0 1 2 3\n5 10 15 20 25 30\n1st Principal Component\nAd Spending\nFIGURE 6.16. Plots of the first principal component scores zi1 versus pop and\nad. The relationships are strong.\nIn the right-hand panel of Figure 6.15, the left-hand panel has been\nrotated so that the first principal component direction coincides with the\nx-axis. It is possible to show that the first principal component score for\nthe ith observation, given in (6.20), is the distance in the x-direction of the\nith cross from zero. So for example, the point in the bottom-left corner of\nthe left-hand panel of Figure 6.15 has a large negative principal component\nscore, zi1 = \u221226.1, while the point in the top-right corner has a large\npositive score, zi1 = 18.7. These scores can be computed directly using\n(6.20).\nWe can think of the values of the principal component Z1 as singlenumber\nsummaries of the joint pop and ad budgets for each location. In\nthis example, if zi1 = 0.839 \u00d7 (popi \u2212 pop) + 0.544 \u00d7 (adi \u2212 ad) < 0,\nthen this indicates a city with below-average population size and belowaverage\nad spending. A positive score suggests the opposite. How well can a\nsingle number represent both pop and ad? In this case, Figure 6.14 indicates\nthat pop and ad have approximately a linear relationship, and so we might\nexpect that a single-number summary will work well. Figure 6.16 displays\nzi1 versus both pop and ad.6 The plots show a strong relationship between\nthe first principal component and the two features. In other words, the first\nprincipal", "doc_id": "02ba2420-4cd0-4e95-9db3-5a58b76afdfe", "embedding": null, "doc_hash": "9ba630c884a5676c7687853f0c55d4ed165fe024b24e79da037e2c1638325cbc", "extra_info": null, "node_info": {"start": 603746, "end": 607300, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "d50bd706-4d5b-402d-9957-a64b602e9f2e", "3": "593adb84-6605-4d25-aca9-977e60b714ae"}}, "__type__": "1"}, "593adb84-6605-4d25-aca9-977e60b714ae": {"__data__": {"text": "first principal component and the two features. In other words, the first\nprincipal component appears to capture most of the information contained\nin the pop and ad predictors.\nSo far we have concentrated on the first principal component. In general,\none can construct up to p distinct principal components. The second\nprincipal component Z2 is a linear combination of the variables that is uncorrelated\nwith Z1, and has largest variance subject to this constraint. The\nsecond principal component direction is illustrated as a dashed blue line in\n6The principal components were calculated after first standardizing both pop and\nad, a common approach. Hence, the x-axes on Figures 6.15 and 6.16 are not on the same\nscale.\n256 6. Linear Model Selection and Regularization\n\u22121.0 \u22120.5 0.0 0.5 1.0\n20 30 40 50 60\n2nd Principal Component\nPopulation\n\u22121.0 \u22120.5 0.0 0.5 1.0\n5 10 15 20 25 30\n2nd Principal Component\nAd Spending\nFIGURE 6.17. Plots of the second principal component scores zi2 versus pop\nand ad. The relationships are weak.\nFigure 6.14. It turns out that the zero correlation condition of Z1 with Z2\nis equivalent to the condition that the direction must be perpendicular, or perpenorthogonal,\nto the first principal component direction. The second principal dicular\ncomponent is given by the formula orthogonal\nZ2 = 0.544 \u00d7 (pop \u2212 pop) \u2212 0.839 \u00d7 (ad \u2212 ad).\nSince the advertising data has two predictors, the first two principal components\ncontain all of the information that is in pop and ad. However, by\nconstruction, the first component will contain the most information. Consider,\nfor example, the much larger variability of zi1 (the x-axis) versus\nzi2 (the y-axis) in the right-hand panel of Figure 6.15. The fact that the\nsecond principal component scores are much closer to zero indicates that\nthis component captures far less information. As another illustration, Figure\n6.17 displays zi2 versus pop and ad. There is little relationship between\nthe second principal component and these two predictors, again suggesting\nthat in this case, one only needs the first principal component in order to\naccurately represent the pop and ad budgets.\nWith two-dimensional data, such as in our advertising example, we can\nconstruct at most two principal components. However, if we had other\npredictors, such as population age, income level, education, and so forth,\nthen additional components could be constructed. They would successively\nmaximize variance, subject to the constraint of being uncorrelated with the\npreceding components.\nThe Principal Components Regression Approach\nThe principal components regression (PCR) approach involves constructprincipal\ncomponents\nregression\ning the first M principal components, Z1, . . . ,ZM, and then using these\ncomponents as the predictors in a linear regression model that is fit using\nleast squares. The key idea is that often a small number of principal\ncomponents suffice to explain most of the variability in the data, as well\n6.3 Dimension Reduction Methods 257\n0 10 20 30 40\n0 10 20 30 40 50 60 70\nNumber of Components\nMean Squared Error\n0 10 20 30 40\n0 50 100 150\nNumber of Components\nMean Squared Error\nSquared Bias\nTest MSE\nVariance\nFIGURE 6.18. PCR was applied to two simulated data sets. In each panel, the\nhorizontal dashed line represents the irreducible error. Left: Simulated data from\nFigure 6.8. Right: Simulated data from Figure 6.9.\nas the relationship with the response. In other words, we assume that the\ndirections in which X1, . . . ,Xp show the most variation are the directions\nthat are associated with Y . While this assumption is not guaranteed to be\ntrue, it often turns out to be a reasonable enough approximation to give\ngood results.\nIf the assumption", "doc_id": "593adb84-6605-4d25-aca9-977e60b714ae", "embedding": null, "doc_hash": "24574cef37093d520fac4ce54dbd9fae718ebc9320d1f4f423d1dfb8818b2452", "extra_info": null, "node_info": {"start": 607305, "end": 611034, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "02ba2420-4cd0-4e95-9db3-5a58b76afdfe", "3": "dfd3266d-954b-4afb-9436-5d447e330411"}}, "__type__": "1"}, "dfd3266d-954b-4afb-9436-5d447e330411": {"__data__": {"text": "out to be a reasonable enough approximation to give\ngood results.\nIf the assumption underlying PCR holds, then fitting a least squares\nmodel to Z1, . . . ,ZM will lead to better results than fitting a least squares\nmodel to X1, . . . ,Xp, since most or all of the information in the data that\nrelates to the response is contained in Z1, . . . ,ZM, and by estimating only\nM \u226a p coefficients we can mitigate overfitting. In the advertising data, the\nfirst principal component explains most of the variance in both pop and ad,\nso a principal component regression that uses this single variable to predict\nsome response of interest, such as sales, will likely perform quite well.\nFigure 6.18 displays the PCR fits on the simulated data sets from Figures\n6.8 and 6.9. Recall that both data sets were generated using n = 50\nobservations and p = 45 predictors. However, while the response in the\nfirst data set was a function of all the predictors, the response in the second\ndata set was generated using only two of the predictors. The curves are\nplotted as a function of M, the number of principal components used as\npredictors in the regression model. As more principal components are used\nin the regression model, the bias decreases, but the variance increases. This\nresults in a typical U-shape for the mean squared error. When M = p = 45,\nthen PCR amounts simply to a least squares fit using all of the original\npredictors. The figure indicates that performing PCR with an appropriate\nchoice of M can result in a substantial improvement over least squares, especially\nin the left-hand panel. However, by examining the ridge regression\nand lasso results in Figures 6.5, 6.8, and 6.9, we see that PCR does not\nperform as well as the two shrinkage methods in this example.\n258 6. Linear Model Selection and Regularization\n0 10 20 30 40\n0 10 20 30 40 50 60 70\nPCR\nNumber of Components\nMean Squared Error\nSquared Bias\nTest MSE\nVariance\n0.0 0.2 0.4 0.6 0.8 1.0\n0 10 20 30 40 50 60 70\nRidge Regression and Lasso\nShrinkage Factor\nMean Squared Error\nFIGURE 6.19. PCR, ridge regression, and the lasso were applied to a simulated\ndata set in which the first five principal components of X contain all the information\nabout the response Y . In each panel, the irreducible error Var(\u03f5) is shown as\na horizontal dashed line. Left: Results for PCR. Right: Results for lasso (solid)\nand ridge regression (dotted). The x-axis displays the shrinkage factor of the coefficient\nestimates, defined as the \u21132 norm of the shrunken coefficient estimates\ndivided by the \u21132 norm of the least squares estimate.\nThe relatively worse performance of PCR in Figure 6.18 is a consequence\nof the fact that the data were generated in such a way that many principal\ncomponents are required in order to adequately model the response.\nIn contrast, PCR will tend to do well in cases when the first few principal\ncomponents are sufficient to capture most of the variation in the predictors\nas well as the relationship with the response. The left-hand panel of Figure\n6.19 illustrates the results from another simulated data set designed to\nbe more favorable to PCR. Here the response was generated in such a way\nthat it depends exclusively on the first five principal components. Now the\nbias drops to zero rapidly as M, the number of principal components used\nin PCR, increases. The mean squared error displays a clear minimum at\nM = 5. The right-hand panel of Figure 6.19 displays the results on these\ndata using ridge regression and the lasso. All three methods offer a significant\nimprovement over least squares. However, PCR and ridge regression\nslightly outperform the lasso.\nWe note that even though PCR provides a simple way to perform", "doc_id": "dfd3266d-954b-4afb-9436-5d447e330411", "embedding": null, "doc_hash": "15fab55ac3e0421f6c2a3d843fb55202e92f14a2ea5e34dd0738cd9d07a860c7", "extra_info": null, "node_info": {"start": 611035, "end": 614738, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "593adb84-6605-4d25-aca9-977e60b714ae", "3": "d4edde6c-d111-4ce2-8bbe-c518d7604a67"}}, "__type__": "1"}, "d4edde6c-d111-4ce2-8bbe-c518d7604a67": {"__data__": {"text": "the lasso.\nWe note that even though PCR provides a simple way to perform regression\nusing M <p predictors, it is not a feature selection method. This\nis because each of the M principal components used in the regression is a\nlinear combination of all p of the original features. For instance, in (6.19),\nZ1 was a linear combination of both pop and ad. Therefore, while PCR often\nperforms quite well in many practical settings, it does not result in the\ndevelopment of a model that relies upon a small set of the original features.\nIn this sense, PCR is more closely related to ridge regression than to the\nlasso. In fact, one can show that PCR and ridge regression are very closely\n6.3 Dimension Reduction Methods 259\n2 4 6 8 10\n\u2212300 \u2212100 0 100 200 300 400\nNumber of Components\nStandardized Coefficients\nIncome\nLimit\nRating\nStudent\n2 4 6 8 10\n20000 40000 60000 80000\nNumber of Components\nCross\u2212Validation MSE\nFIGURE 6.20. Left: PCR standardized coefficient estimates on the Credit data\nset for different values of M. Right: The ten-fold cross-validation MSE obtained\nusing PCR, as a function of M.\nrelated. One can even think of ridge regression as a continuous version of\nPCR!7\nIn PCR, the number of principal components, M, is typically chosen by\ncross-validation. The results of applying PCR to the Credit data set are\nshown in Figure 6.20; the right-hand panel displays the cross-validation errors\nobtained, as a function of M. On these data, the lowest cross-validation\nerror occurs when there are M = 10 components; this corresponds to almost\nno dimension reduction at all, since PCR with M = 11 is equivalent\nto simply performing least squares.\nWhen performing PCR, we generally recommend standardizing each predictor,\nusing (6.6), prior to generating the principal components. This standardization\nensures that all variables are on the same scale. In the absence\nof standardization, the high-variance variables will tend to play a larger\nrole in the principal components obtained, and the scale on which the variables\nare measured will ultimately have an effect on the final PCR model.\nHowever, if the variables are all measured in the same units (say, kilograms,\nor inches), then one might choose not to standardize them.\n6.3.2 Partial Least Squares\nThe PCR approach that we just described involves identifying linear combinations,\nor directions, that best represent the predictors X1, . . . ,Xp. These\ndirections are identified in an unsupervised way, since the response Y is not\nused to help determine the principal component directions. That is, the\nresponse does not supervise the identification of the principal components.\n7More details can be found in Section 3.5 of The Elements of Statistical Learning by\nHastie, Tibshirani, and Friedman.\n260 6. Linear Model Selection and Regularization\n20 30 40 50 60\n5 10 15 20 25 30\nPopulation\nAd Spending\nFIGURE 6.21. For the advertising data, the first PLS direction (solid line) and\nfirst PCR direction (dotted line) are shown.\nConsequently, PCR suffers from a drawback: there is no guarantee that the\ndirections that best explain the predictors will also be the best directions\nto use for predicting the response. Unsupervised methods are discussed\nfurther in Chapter 12.\nWe now present partial least squares (PLS), a supervised alternative to\npartial least\nPCR. Like PCR, PLS is a dimension reduction method, which first identifies squares\na new set of features Z1, . . . ,ZM that are linear combinations of the original\nfeatures, and then fits a linear model via least squares using these M new\nfeatures. But unlike PCR, PLS identifies these new features in a supervised\nway\u2014that is, it makes use of the response Y in order to identify new\nfeatures that not only approximate the old features well, but also that are\nrelated", "doc_id": "d4edde6c-d111-4ce2-8bbe-c518d7604a67", "embedding": null, "doc_hash": "de1042a82fba126838c9604b4adaef6800812cf5288c555c6211df8de1aa418f", "extra_info": null, "node_info": {"start": 614751, "end": 618534, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "dfd3266d-954b-4afb-9436-5d447e330411", "3": "a7d7aea5-c2fd-4870-8997-9bd621db7cf7"}}, "__type__": "1"}, "a7d7aea5-c2fd-4870-8997-9bd621db7cf7": {"__data__": {"text": "new\nfeatures that not only approximate the old features well, but also that are\nrelated to the response. Roughly speaking, the PLS approach attempts to\nfind directions that help explain both the response and the predictors.\nWe now describe how the first PLS direction is computed. After standardizing\nthe p predictors, PLS computes the first direction Z1 by setting\neach \u03c6j1 in (6.16) equal to the coefficient from the simple linear regression\nof Y onto Xj . One can show that this coefficient is proportional to the correlation\nbetween Y and Xj . Hence, in computing Z1 =\n)p\nj=1 \u03c6j1Xj , PLS\nplaces the highest weight on the variables that are most strongly related\nto the response.\nFigure 6.21 displays an example of PLS on a synthetic dataset with Sales\nin each of 100 regions as the response, and two predictors; Population Size\nand Advertising Spending. The solid green line indicates the first PLS direction,\nwhile the dotted line shows the first principal component direction.\nPLS has chosen a direction that has less change in the ad dimension per\nunit change in the pop dimension, relative to PCA. This suggests that pop\nis more highly correlated with the response than is ad. The PLS direction\n6.4 Considerations in High Dimensions 261\ndoes not fit the predictors as closely as does PCA, but it does a better job\nexplaining the response.\nTo identify the second PLS direction we first adjust each of the variables\nfor Z1, by regressing each variable on Z1 and taking residuals. These residuals\ncan be interpreted as the remaining information that has not been\nexplained by the first PLS direction. We then compute Z2 using this orthogonalized\ndata in exactly the same fashion as Z1 was computed based\non the original data. This iterative approach can be repeated M times to\nidentify multiple PLS components Z1, . . . ,ZM. Finally, at the end of this\nprocedure, we use least squares to fit a linear model to predict Y using\nZ1, . . . ,ZM in exactly the same fashion as for PCR.\nAs with PCR, the number M of partial least squares directions used in\nPLS is a tuning parameter that is typically chosen by cross-validation. We\ngenerally standardize the predictors and response before performing PLS.\nPLS is popular in the field of chemometrics, where many variables arise\nfrom digitized spectrometry signals. In practice it often performs no better\nthan ridge regression or PCR. While the supervised dimension reduction\nof PLS can reduce bias, it also has the potential to increase variance, so\nthat the overall benefit of PLS relative to PCR is a wash.\n6.4 Considerations in High Dimensions\n6.4.1 High-Dimensional Data\nMost traditional statistical techniques for regression and classification are\nintended for the low-dimensional setting in which n, the number of oblowservations,\nis much greater than p, the number of features. This is due in dimensional\npart to the fact that throughout most of the field\u2019s history, the bulk of scientific\nproblems requiring the use of statistics have been low-dimensional.\nFor instance, consider the task of developing a model to predict a patient\u2019s\nblood pressure on the basis of his or her age, sex, and body mass index\n(BMI). There are three predictors, or four if an intercept is included in\nthe model, and perhaps several thousand patients for whom blood pressure\nand age, sex, and BMI are available. Hence n \u226b p, and so the problem is\nlow-dimensional. (By dimension here we are referring to the size of p.)\nIn the past 20 years, new technologies have changed the way that data\nare collected in fields as diverse as finance, marketing, and medicine. It is\nnow commonplace to collect an almost unlimited number of feature measurements\n(p very large). While p can be extremely large, the number of\nobservations n is often limited due to cost, sample availability, or other\nconsiderations. Two examples are as follows:\n1. Rather than predicting blood", "doc_id": "a7d7aea5-c2fd-4870-8997-9bd621db7cf7", "embedding": null, "doc_hash": "d48404ff04ecb08970e492916fae186b8c440bb0fcd7a30ff06ab1f1a91c7705", "extra_info": null, "node_info": {"start": 618520, "end": 622412, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "d4edde6c-d111-4ce2-8bbe-c518d7604a67", "3": "d9b27440-4bd2-4bcb-bd3a-ae83d25f9064"}}, "__type__": "1"}, "d9b27440-4bd2-4bcb-bd3a-ae83d25f9064": {"__data__": {"text": "Two examples are as follows:\n1. Rather than predicting blood pressure on the basis of just age, sex,\nand BMI, one might also collect measurements for half a million sin262\n6. Linear Model Selection and Regularization\ngle nucleotide polymorphisms (SNPs; these are individual DNA mutations\nthat are relatively common in the population) for inclusion in\nthe predictive model. Then n \u2248 200 and p \u2248 500,000.\n2. A marketing analyst interested in understanding people\u2019s online shopping\npatterns could treat as features all of the search terms entered\nby users of a search engine. This is sometimes known as the \u201cbag-ofwords\u201d\nmodel. The same researcher might have access to the search\nhistories of only a few hundred or a few thousand search engine users\nwho have consented to share their information with the researcher.\nFor a given user, each of the p search terms is scored present (0) or\nabsent (1), creating a large binary feature vector. Then n \u2248 1,000\nand p is much larger.\nData sets containing more features than observations are often referred\nto as high-dimensional. Classical approaches such as least squares linear\nhighregression\nare not appropriate in this setting. Many of the issues that arise dimensional\nin the analysis of high-dimensional data were discussed earlier in this book,\nsince they apply also when n > p: these include the role of the bias-variance\ntrade-off and the danger of overfitting. Though these issues are always relevant,\nthey can become particularly important when the number of features\nis very large relative to the number of observations.\nWe have defined the high-dimensional setting as the case where the number\nof features p is larger than the number of observations n. But the considerations\nthat we will now discuss certainly also apply if p is slightly\nsmaller than n, and are best always kept in mind when performing supervised\nlearning.\n6.4.2 What Goes Wrong in High Dimensions?\nIn order to illustrate the need for extra care and specialized techniques\nfor regression and classification when p > n, we begin by examining what\ncan go wrong if we apply a statistical technique not intended for the highdimensional\nsetting. For this purpose, we examine least squares regression.\nBut the same concepts apply to logistic regression, linear discriminant analysis,\nand other classical statistical approaches.\nWhen the number of features p is as large as, or larger than, the number\nof observations n, least squares as described in Chapter 3 cannot (or rather,\nshould not) be performed. The reason is simple: regardless of whether or\nnot there truly is a relationship between the features and the response,\nleast squares will yield a set of coefficient estimates that result in a perfect\nfit to the data, such that the residuals are zero.\nAn example is shown in Figure 6.22 with p = 1 feature (plus an intercept)\nin two cases: when there are 20 observations, and when there are only\ntwo observations. When there are 20 observations, n > p and the least\n6.4 Considerations in High Dimensions 263\n\u22121.5 \u22121.0 \u22120.5 0.0 0.5 1.0\n\u221210 \u22125 0 5 10\n\u22121.5 \u22121.0 \u22120.5 0.0 0.5 1.0\n\u221210 \u22125 0 5 10\nX X\nY\nY\nFIGURE 6.22. Left: Least squares regression in the low-dimensional setting.\nRight: Least squares regression with n = 2 observations and two parameters to be\nestimated (an intercept and a coefficient).\nsquares regression line does not perfectly fit the data; instead, the regression\nline seeks to approximate the 20 observations as well as possible. On the\nother hand, when there are only two observations, then regardless of the\nvalues of those observations, the regression line will fit the data exactly.\nThis is problematic because this perfect fit will almost certainly lead to\noverfitting of the data. In other words, though it is possible to perfectly fit\nthe training data in the high-dimensional setting, the resulting linear model\nwill perform extremely", "doc_id": "d9b27440-4bd2-4bcb-bd3a-ae83d25f9064", "embedding": null, "doc_hash": "112071f56633dda45336fbe0aada26c224b05bb0fd889d0d171ca19a362ef25d", "extra_info": null, "node_info": {"start": 622436, "end": 626314, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "a7d7aea5-c2fd-4870-8997-9bd621db7cf7", "3": "38271f51-2742-425d-a117-6e1b0eeec411"}}, "__type__": "1"}, "38271f51-2742-425d-a117-6e1b0eeec411": {"__data__": {"text": "training data in the high-dimensional setting, the resulting linear model\nwill perform extremely poorly on an independent test set, and therefore\ndoes not constitute a useful model. In fact, we can see that this happened\nin Figure 6.22: the least squares line obtained in the right-hand panel will\nperform very poorly on a test set comprised of the observations in the lefthand\npanel. The problem is simple: when p > n or p \u2248 n, a simple least\nsquares regression line is too flexible and hence overfits the data.\nFigure 6.23 further illustrates the risk of carelessly applying least squares\nwhen the number of features p is large. Data were simulated with n = 20\nobservations, and regression was performed with between 1 and 20 features,\neach of which was completely unrelated to the response. As shown in the\nfigure, the model R2 increases to 1 as the number of features included in the\nmodel increases, and correspondingly the training set MSE decreases to 0\nas the number of features increases, even though the features are completely\nunrelated to the response. On the other hand, the MSE on an independent\ntest set becomes extremely large as the number of features included in the\nmodel increases, because including the additional predictors leads to a vast\nincrease in the variance of the coefficient estimates. Looking at the test\nset MSE, it is clear that the best model contains at most a few variables.\nHowever, someone who carelessly examines only the R2 or the training set\nMSE might erroneously conclude that the model with the greatest number\n264 6. Linear Model Selection and Regularization\n5 10 15\n0.2 0.4 0.6 0.8 1.0\nNumber of Variables\nR2\n5 10 15\n0.0 0.2 0.4 0.6 0.8\nNumber of Variables\nTraining MSE\n5 10 15\n1 5 50 500\nNumber of Variables\nTest MSE\nFIGURE 6.23. On a simulated example with n = 20 training observations,\nfeatures that are completely unrelated to the outcome are added to the model.\nLeft: The R2 increases to 1 as more features are included. Center: The training\nset MSE decreases to 0 as more features are included. Right: The test set MSE\nincreases as more features are included.\nof variables is best. This indicates the importance of applying extra care\nwhen analyzing data sets with a large number of variables, and of always\nevaluating model performance on an independent test set.\nIn Section 6.1.3, we saw a number of approaches for adjusting the training\nset RSS or R2 in order to account for the number of variables used to fit\na least squares model. Unfortunately, the Cp, AIC, and BIC approaches\nare not appropriate in the high-dimensional setting, because estimating \u02c6\u03c32\nis problematic. (For instance, the formula for \u02c6\u03c32 from Chapter 3 yields an\nestimate \u02c6\u03c32 = 0 in this setting.) Similarly, problems arise in the application\nof adjusted R2 in the high-dimensional setting, since one can easily obtain\na model with an adjusted R2 value of 1. Clearly, alternative approaches\nthat are better-suited to the high-dimensional setting are required.\n6.4.3 Regression in High Dimensions\nIt turns out that many of the methods seen in this chapter for fitting\nless flexible least squares models, such as forward stepwise selection, ridge\nregression, the lasso, and principal components regression, are particularly\nuseful for performing regression in the high-dimensional setting. Essentially,\nthese approaches avoid overfitting by using a less flexible fitting approach\nthan least squares.\nFigure 6.24 illustrates the performance of the lasso in a simple simulated\nexample. There are p = 20, 50, or 2,000 features, of which 20 are truly\nassociated with the outcome. The lasso was performed on n = 100 training\nobservations, and the mean squared error was evaluated on an independent\ntest set. As the number of features increases, the test set error increases.\nWhen p = 20, the lowest validation set error was achieved when \u03bb in\n(6.7) was", "doc_id": "38271f51-2742-425d-a117-6e1b0eeec411", "embedding": null, "doc_hash": "d035efc3567252141d29bfb6431f89ef74dc938b7c309778f937ac1a019b4e8b", "extra_info": null, "node_info": {"start": 626282, "end": 630153, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "d9b27440-4bd2-4bcb-bd3a-ae83d25f9064", "3": "fc86198a-d1d9-44d1-abec-e7c14fd9737f"}}, "__type__": "1"}, "fc86198a-d1d9-44d1-abec-e7c14fd9737f": {"__data__": {"text": "the lowest validation set error was achieved when \u03bb in\n(6.7) was small; however, when p was larger then the lowest validation\n6.4 Considerations in High Dimensions 265\n1 16 21\n0 1 2 3 4 5\n1 28 51\n0 1 2 3 4 5\n1 70 111\n0 1 2 3 4 5\np = 20 p = 50 p = 2000\nDegrees of Freedom Degrees of Freedom Degrees of Freedom\nFIGURE 6.24. The lasso was performed with n = 100 observations and three\nvalues of p, the number of features. Of the p features, 20 were associated with\nthe response. The boxplots show the test MSEs that result using three different\nvalues of the tuning parameter \u03bb in (6.7). For ease of interpretation, rather than\nreporting \u03bb, the degrees of freedom are reported; for the lasso this turns out\nto be simply the number of estimated non-zero coefficients. When p = 20, the\nlowest test MSE was obtained with the smallest amount of regularization. When\np = 50, the lowest test MSE was achieved when there is a substantial amount\nof regularization. When p = 2,000 the lasso performed poorly regardless of the\namount of regularization, due to the fact that only 20 of the 2,000 features truly\nare associated with the outcome.\nset error was achieved using a larger value of \u03bb. In each boxplot, rather\nthan reporting the values of \u03bb used, the degrees of freedom of the resulting\nlasso solution is displayed; this is simply the number of non-zero coefficient\nestimates in the lasso solution, and is a measure of the flexibility of the\nlasso fit. Figure 6.24 highlights three important points: (1) regularization\nor shrinkage plays a key role in high-dimensional problems, (2) appropriate\ntuning parameter selection is crucial for good predictive performance, and\n(3) the test error tends to increase as the dimensionality of the problem\n(i.e. the number of features or predictors) increases, unless the additional\nfeatures are truly associated with the response.\nThe third point above is in fact a key principle in the analysis of highdimensional\ndata, which is known as the curse of dimensionality. One might\ncurse of dithink\nthat as the number of features used to fit a model increases, the mensionality\nquality of the fitted model will increase as well. However, comparing the\nleft-hand and right-hand panels in Figure 6.24, we see that this is not\nnecessarily the case: in this example, the test set MSE almost doubles as\np increases from 20 to 2,000. In general, adding additional signal features\nthat are truly associated with the response will improve the fitted model,\nin the sense of leading to a reduction in test set error. However, adding\n266 6. Linear Model Selection and Regularization\nnoise features that are not truly associated with the response will lead\nto a deterioration in the fitted model, and consequently an increased test\nset error. This is because noise features increase the dimensionality of the\nproblem, exacerbating the risk of overfitting (since noise features may be\nassigned nonzero coefficients due to chance associations with the response\non the training set) without any potential upside in terms of improved test\nset error. Thus, we see that new technologies that allow for the collection\nof measurements for thousands or millions of features are a double-edged\nsword: they can lead to improved predictive models if these features are in\nfact relevant to the problem at hand, but will lead to worse results if the\nfeatures are not relevant. Even if they are relevant, the variance incurred\nin fitting their coefficients may outweigh the reduction in bias that they\nbring.\n6.4.4 Interpreting Results in High Dimensions\nWhen we perform the lasso, ridge regression, or other regression procedures\nin the high-dimensional setting, we must be quite cautious in the way\nthat we report the results obtained. In Chapter 3, we learned about multicollinearity,\nthe concept that the variables in a regression might be correlated\nwith each other. In the high-dimensional setting, the multicollinearity\nproblem is extreme: any", "doc_id": "fc86198a-d1d9-44d1-abec-e7c14fd9737f", "embedding": null, "doc_hash": "2152199bd5558462133a010cd2c93c2eef8075136fde7d3cc64b9281be88b1e9", "extra_info": null, "node_info": {"start": 630185, "end": 634137, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "38271f51-2742-425d-a117-6e1b0eeec411", "3": "83903220-9ce7-4cc1-af3b-a9ad74c529cf"}}, "__type__": "1"}, "83903220-9ce7-4cc1-af3b-a9ad74c529cf": {"__data__": {"text": "In the high-dimensional setting, the multicollinearity\nproblem is extreme: any variable in the model can be written as a linear\ncombination of all of the other variables in the model. Essentially, this\nmeans that we can never know exactly which variables (if any) truly are\npredictive of the outcome, and we can never identify the best coefficients\nfor use in the regression. At most, we can hope to assign large regression\ncoefficients to variables that are correlated with the variables that truly are\npredictive of the outcome.\nFor instance, suppose that we are trying to predict blood pressure on the\nbasis of half a million SNPs, and that forward stepwise selection indicates\nthat 17 of those SNPs lead to a good predictive model on the training data.\nIt would be incorrect to conclude that these 17 SNPs predict blood pressure\nmore effectively than the other SNPs not included in the model. There are\nlikely to be many sets of 17 SNPs that would predict blood pressure just\nas well as the selected model. If we were to obtain an independent data set\nand perform forward stepwise selection on that data set, we would likely\nobtain a model containing a different, and perhaps even non-overlapping,\nset of SNPs. This does not detract from the value of the model obtained\u2014\nfor instance, the model might turn out to be very effective in predicting\nblood pressure on an independent set of patients, and might be clinically\nuseful for physicians. But we must be careful not to overstate the results\nobtained, and to make it clear that what we have identified is simply one\nof many possible models for predicting blood pressure, and that it must be\nfurther validated on independent data sets.\n6.5 Lab: Linear Models and Regularization Methods 267\nIt is also important to be particularly careful in reporting errors and\nmeasures of model fit in the high-dimensional setting. We have seen that\nwhen p > n, it is easy to obtain a useless model that has zero residuals.\nTherefore, one should never use sum of squared errors, p-values, R2\nstatistics, or other traditional measures of model fit on the training data as\nevidence of a good model fit in the high-dimensional setting. For instance,\nas we saw in Figure 6.23, one can easily obtain a model with R2 = 1 when\np > n. Reporting this fact might mislead others into thinking that a statistically\nvalid and useful model has been obtained, whereas in fact this\nprovides absolutely no evidence of a compelling model. It is important to\ninstead report results on an independent test set, or cross-validation errors.\nFor instance, the MSE or R2 on an independent test set is a valid measure\nof model fit, but the MSE on the training set certainly is not.\n6.5 Lab: Linear Models and Regularization\nMethods\n6.5.1 Subset Selection Methods\nBest Subset Selection\nHere we apply the best subset selection approach to the Hitters data. We\nwish to predict a baseball player\u2019s Salary on the basis of various statistics\nassociated with performance in the previous year.\nFirst of all, we note that the Salary variable is missing for some of the\nplayers. The is.na() function can be used to identify the missing observais.\nna()\ntions. It returns a vector of the same length as the input vector, with a TRUE\nfor any elements that are missing, and a FALSE for non-missing elements.\nThe sum() function can then be used to count all of the missing elements.\nsum()\n> library(ISLR2)\n> View(Hitters)\n> names(Hitters)\n[1] \"AtBat\" \"Hits\" \"HmRun\" \"Runs\" \"RBI\"\n[6] \"Walks\" \"Years\" \"CAtBat\" \"CHits\" \"CHmRun\"\n[11] \"CRuns\" \"CRBI\" \"CWalks\" \"League\" \"Division\"\n[16] \"PutOuts\" \"Assists\" \"Errors\" \"Salary\" \"NewLeague\"\n> dim(Hitters)\n[1] 322 20\n> sum(is.na(Hitters$Salary))\n[1] 59\nHence we see that Salary is missing for 59 players. The", "doc_id": "83903220-9ce7-4cc1-af3b-a9ad74c529cf", "embedding": null, "doc_hash": "bf239a37cc2bcf6789d7bfabb76dfa6c709afe91f03543f3abbcfc93a43f7ca2", "extra_info": null, "node_info": {"start": 634122, "end": 637868, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "fc86198a-d1d9-44d1-abec-e7c14fd9737f", "3": "cee7fcd4-5a32-411d-9567-d78c007e3d4e"}}, "__type__": "1"}, "cee7fcd4-5a32-411d-9567-d78c007e3d4e": {"__data__": {"text": "59\nHence we see that Salary is missing for 59 players. The na.omit() function\nremoves all of the rows that have missing values in any variable.\n> Hitters <- na.omit(Hitters)\n> dim(Hitters)\n[1] 263 20\n268 6. Linear Model Selection and Regularization\n> sum(is.na(Hitters))\n[1] 0\nThe regsubsets() function (part of the leaps library) performs best subregsubsets()\nset selection by identifying the best model that contains a given number\nof predictors, where best is quantified using RSS. The syntax is the same\nas for lm(). The summary() command outputs the best set of variables for\neach model size.\n> library(leaps)\n> regfit.full <- regsubsets(Salary \u223c ., Hitters)\n> summary(regfit.full)\nSubset selection object\nCall: regsubsets.formula(Salary \u223c ., Hitters)\n19 Variables (and intercept)\n...\n1 subsets of each size up to 8\nSelection Algorithm: exhaustive\nAtBat Hits HmRun Runs RBI Walks Years CAtBat CHits\n1 ( 1 ) \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \"\n2 ( 1 ) \" \" \"*\" \" \" \" \" \" \" \" \" \" \" \" \" \" \"\n3 ( 1 ) \" \" \"*\" \" \" \" \" \" \" \" \" \" \" \" \" \" \"\n4 ( 1 ) \" \" \"*\" \" \" \" \" \" \" \" \" \" \" \" \" \" \"\n5 ( 1 ) \"*\" \"*\" \" \" \" \" \" \" \" \" \" \" \" \" \" \"\n6 ( 1 ) \"*\" \"*\" \" \" \" \" \" \" \"*\" \" \" \" \" \" \"\n7 ( 1 ) \" \" \"*\" \" \" \" \" \" \" \"*\" \" \" \"*\" \"*\"\n8 ( 1 ) \"*\" \"*\" \" \" \" \" \" \" \"*\" \" \" \" \" \" \"\nCHmRun CRuns CRBI CWalks LeagueN DivisionW PutOuts\n1 ( 1 ) \" \" \" \" \"*\" \" \" \" \" \" \" \" \"\n2 ( 1 ) \" \" \" \" \"*\" \" \" \" \" \" \" \" \"\n3 ( 1 ) \" \" \" \" \"*\" \" \" \" \" \" \" \"*\"\n4 ( 1 ) \" \" \" \" \"*\" \" \" \" \" \"*\" \"*\"\n5 ( 1 ) \" \" \" \" \"*\" \" \" \" \" \"*\" \"*\"\n6 ( 1 ) \" \" \" \" \"*\" \" \" \" \" \"*\" \"*\"\n7 ( 1 ) \"*\" \" \" \" \" \" \" \" \" \"*\" \"*\"\n8 ( 1 ) \"*\" \"*\" \" \" \"*\" \" \" \"*\" \"*\"\nAssists Errors NewLeagueN\n1 ( 1 ) \" \" \" \" \" \"\n2 ( 1 ) \" \" \" \" \" \"\n3 ( 1 ) \" \" \" \" \" \"\n4 ( 1 ) \" \" \" \" \" \"\n5 ( 1 ) \" \" \" \" \" \"\n6 ( 1 ) \" \" \" \" \" \"\n7 ( 1 ) \" \" \" \" \" \"\n8 ( 1 ) \" \" \" \" \" \"\nAn asterisk indicates that a given variable is included in the corresponding\nmodel. For instance, this output indicates that the best two-variable model\ncontains only Hits and CRBI. By default, regsubsets() only reports results\nup to the best eight-variable model. But the nvmax option can be used\nin order to return as many variables as are desired. Here we fit up to a\n19-variable model.\n6.5 Lab: Linear Models and Regularization Methods 269\n> regfit.full <- regsubsets(Salary \u223c ., data = Hitters ,\nnvmax = 19)\n> reg.summary <- summary(regfit.full)\nThe summary() function also returns R2, RSS, adjusted R2, Cp, and BIC.\nWe can examine these to try to select the best overall model.\n> names(reg.summary)\n[1] \"which\" \"rsq\" \"rss\" \"adjr2\" \"cp\" \"bic\"\n[7] \"outmat\" \"obj\"\nFor instance, we see that the R2", "doc_id": "cee7fcd4-5a32-411d-9567-d78c007e3d4e", "embedding": null, "doc_hash": "4d8bd2b18e142c658777dbeafdf6acf8cc9bd3580dcb06f483e370f69c263189", "extra_info": null, "node_info": {"start": 637891, "end": 640471, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "83903220-9ce7-4cc1-af3b-a9ad74c529cf", "3": "196c5a6c-b58d-40aa-8c95-cc1f1970662e"}}, "__type__": "1"}, "196c5a6c-b58d-40aa-8c95-cc1f1970662e": {"__data__": {"text": "\"outmat\" \"obj\"\nFor instance, we see that the R2 statistic increases from 32 %, when only\none variable is included in the model, to almost 55 %, when all variables\nare included. As expected, the R2 statistic increases monotonically as more\nvariables are included.\n> reg.summary$rsq\n[1] 0.321 0.425 0.451 0.475 0.491 0.509 0.514 0.529 0.535\n[10] 0.540 0.543 0.544 0.544 0.545 0.545 0.546 0.546 0.546\n[19] 0.546\nPlotting RSS, adjusted R2, Cp, and BIC for all of the models at once will\nhelp us decide which model to select. Note the type = \"l\" option tells R to\nconnect the plotted points with lines.\n> par(mfrow = c(2, 2))\n> plot(reg.summary$rss , xlab = \"Number of Variables\",\nylab = \"RSS\", type = \"l\")\n> plot(reg.summary$adjr2 , xlab = \"Number of Variables\",\nylab = \"Adjusted RSq\", type = \"l\")\nThe points() command works like the plot() command, except that it\npoints()\nputs points on a plot that has already been created, instead of creating a\nnew plot. The which.max() function can be used to identify the location of\nthe maximum point of a vector. We will now plot a red dot to indicate the\nmodel with the largest adjusted R2 statistic.\n> which.max(reg.summary$adjr2)\n[1] 11\n> points (11, reg.summary$adjr2 [11] , col = \"red\", cex = 2,\npch = 20)\nIn a similar fashion we can plot the Cp and BIC statistics, and indicate the\nmodels with the smallest statistic using which.min().\nwhich.min()\n> plot(reg.summary$cp, xlab = \"Number of Variables\",\nylab = \"Cp\", type = \"l\")\n> which.min(reg.summary$cp)\n[1] 10\n> points (10, reg.summary$cp[10] , col = \"red\", cex = 2,\npch = 20)\n> which.min(reg.summary$bic)\n[1] 6\n> plot(reg.summary$bic , xlab = \"Number of Variables\",\nylab = \"BIC\", type = \"l\")\n270 6. Linear Model Selection and Regularization\n> points (6, reg.summary$bic [6], col = \"red\", cex = 2,\npch = 20)\nThe regsubsets() function has a built-in plot() command which can\nbe used to display the selected variables for the best model with a given\nnumber of predictors, ranked according to the BIC, Cp, adjusted R2, or\nAIC. To find out more about this function, type ?plot.regsubsets.\n> plot(regfit.full , scale = \"r2\")\n> plot(regfit.full , scale = \"adjr2\")\n> plot(regfit.full , scale = \"Cp\")\n> plot(regfit.full , scale = \"bic\")\nThe top row of each plot contains a black square for each variable selected\naccording to the optimal model associated with that statistic. For instance,\nwe see that several models share a BIC close to \u2212150. However, the model\nwith the lowest BIC is the six-variable model that contains only AtBat,\nHits, Walks, CRBI, DivisionW, and PutOuts. We can use the coef() function\nto see the coefficient estimates associated with this model.\n> coef(regfit.full , 6)\n(Intercept) AtBat Hits Walks CRBI\n91.512 -1.869 7.604 3.698 0.643\nDivisionW PutOuts\n-122.952 0.264\nForward and Backward Stepwise Selection\nWe can also use the regsubsets() function to perform forward stepwise\nor backward stepwise selection, using the argument method = \"forward\" or\nmethod = \"backward\".\n> regfit.fwd <- regsubsets(Salary \u223c ., data = Hitters ,\nnvmax = 19, method =", "doc_id": "196c5a6c-b58d-40aa-8c95-cc1f1970662e", "embedding": null, "doc_hash": "0bd826ea8cb7d8ff44161d7e8037f1fd8ad6c2cc60669b15bc68058eb24fad00", "extra_info": null, "node_info": {"start": 640480, "end": 643540, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "cee7fcd4-5a32-411d-9567-d78c007e3d4e", "3": "b9ff4a66-9c57-49a4-b7f2-eaf03145b21e"}}, "__type__": "1"}, "b9ff4a66-9c57-49a4-b7f2-eaf03145b21e": {"__data__": {"text": "\u223c ., data = Hitters ,\nnvmax = 19, method = \"forward\")\n> summary(regfit.fwd)\n> regfit.bwd <- regsubsets(Salary \u223c ., data = Hitters ,\nnvmax = 19, method = \"backward\")\n> summary(regfit.bwd)\nFor instance, we see that using forward stepwise selection, the best onevariable\nmodel contains only CRBI, and the best two-variable model additionally\nincludes Hits. For this data, the best one-variable through sixvariable\nmodels are each identical for best subset and forward selection.\nHowever, the best seven-variable models identified by forward stepwise selection,\nbackward stepwise selection, and best subset selection are different.\n> coef(regfit.full , 7)\n(Intercept) Hits Walks CAtBat CHits\n79.451 1.283 3.227 -0.375 1.496\nCHmRun DivisionW PutOuts\n1.442 -129.987 0.237\n> coef(regfit.fwd , 7)\n6.5 Lab: Linear Models and Regularization Methods 271\n(Intercept) AtBat Hits Walks CRBI\n109.787 -1.959 7.450 4.913 0.854\nCWalks DivisionW PutOuts\n-0.305 -127.122 0.253\n> coef(regfit.bwd , 7)\n(Intercept) AtBat Hits Walks CRuns\n105.649 -1.976 6.757 6.056 1.129\nCWalks DivisionW PutOuts\n-0.716 -116.169 0.303\nChoosing Among Models Using the Validation-Set Approach and\nCross-Validation\nWe just saw that it is possible to choose among a set of models of different\nsizes using Cp, BIC, and adjusted R2. We will now consider how to do this\nusing the validation set and cross-validation approaches.\nIn order for these approaches to yield accurate estimates of the test\nerror, we must use only the training observations to perform all aspects of\nmodel-fitting\u2014including variable selection. Therefore, the determination of\nwhich model of a given size is best must be made using only the training\nobservations. This point is subtle but important. If the full data set is used\nto perform the best subset selection step, the validation set errors and\ncross-validation errors that we obtain will not be accurate estimates of the\ntest error.\nIn order to use the validation set approach, we begin by splitting the\nobservations into a training set and a test set. We do this by creating\na random vector, train, of elements equal to TRUE if the corresponding\nobservation is in the training set, and FALSE otherwise. The vector test has\na TRUE if the observation is in the test set, and a FALSE otherwise. Note the\n! in the command to create test causes TRUEs to be switched to FALSEs and\nvice versa. We also set a random seed so that the user will obtain the same\ntraining set/test set split.\n> set.seed (1)\n> train <- sample(c(TRUE , FALSE), nrow(Hitters),\nreplace = TRUE)\n> test <- (!train)\nNow, we apply regsubsets() to the training set in order to perform best\nsubset selection.\n> regfit.best <- regsubsets(Salary \u223c .,\ndata = Hitters[train , ], nvmax = 19)\nNotice that we subset the Hitters data frame directly in the call in order\nto access only the training subset of the data, using the expression\nHitters[train, ]. We now compute the validation set error for the best\nmodel of each model size. We first make a model matrix from the test\ndata.\n272 6. Linear Model Selection and Regularization\n> test.mat <- model.matrix(Salary \u223c ., data = Hitters[test , ])\nThe model.matrix() function is used in many regression packages for buildmodel.\nmatrix()\ning an \u201cX\u201d matrix from data. Now we run a loop, and for each size i, we\nextract the coefficients from regfit.best for the best model of that size,\nmultiply them into the appropriate columns of", "doc_id": "b9ff4a66-9c57-49a4-b7f2-eaf03145b21e", "embedding": null, "doc_hash": "8a9e0048657af72c11d34954b0345535db3ae5916969d58afde35f3ba92f2668", "extra_info": null, "node_info": {"start": 643548, "end": 646965, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "196c5a6c-b58d-40aa-8c95-cc1f1970662e", "3": "3dc4a125-9893-4b81-913b-5ba33dd0f0d8"}}, "__type__": "1"}, "3dc4a125-9893-4b81-913b-5ba33dd0f0d8": {"__data__": {"text": "for the best model of that size,\nmultiply them into the appropriate columns of the test model matrix to\nform the predictions, and compute the test MSE.\n> val.errors <- rep(NA, 19)\n> for (i in 1:19) {\n+ coefi <- coef(regfit.best , id = i)\n+ pred <- test.mat[, names(coefi)] %*% coefi\n+ val.errors[i] <- mean (( Hitters$Salary[test] - pred)^2)\n}\nWe find that the best model is the one that contains seven variables.\n> val.errors\n[1] 164377 144405 152176 145198 137902 139176 126849 136191\n[9] 132890 135435 136963 140695 140691 141951 141508 142164\n[17] 141767 142340 142238\n> which.min(val.errors)\n[1] 7\n> coef(regfit.best , 7)\n(Intercept) AtBat Hits Walks CRuns\n67.109 -2.146 7.015 8.072 1.243\nCWalks DivisionW PutOuts\n-0.834 -118.436 0.253\nThis was a little tedious, partly because there is no predict() method\nfor regsubsets(). Since we will be using this function again, we can capture\nour steps above and write our own predict method.\n> predict.regsubsets <- function(object , newdata , id, ...) {\n+ form <- as.formula(object$call [[2]])\n+ mat <- model.matrix(form , newdata)\n+ coefi <- coef(object , id = id)\n+ xvars <- names(coefi)\n+ mat[, xvars] %*% coefi\n+ }\nOur function pretty much mimics what we did above. The only complex\npart is how we extracted the formula used in the call to regsubsets(). We\ndemonstrate how we use this function below, when we do cross-validation.\nFinally, we perform best subset selection on the full data set, and select\nthe best seven-variable model. It is important that we make use of the\nfull data set in order to obtain more accurate coefficient estimates. Note\nthat we perform best subset selection on the full data set and select the\nbest seven-variable model, rather than simply using the variables that were\nobtained from the training set, because the best seven-variable model on\nthe full data set may differ from the corresponding model on the training\nset.\n6.5 Lab: Linear Models and Regularization Methods 273\n> regfit.best <- regsubsets(Salary \u223c ., data = Hitters ,\nnvmax = 19)\n> coef(regfit.best , 7)\n(Intercept) Hits Walks CAtBat CHits\n79.451 1.283 3.227 -0.375 1.496\nCHmRun DivisionW PutOuts\n1.442 -129.987 0.237\nIn fact, we see that the best seven-variable model on the full data set has a\ndifferent set of variables than the best seven-variable model on the training\nset.\nWe now try to choose among the models of different sizes using crossvalidation.\nThis approach is somewhat involved, as we must perform best\nsubset selection within each of the k training sets. Despite this, we see that\nwith its clever subsetting syntax, R makes this job quite easy. First, we\ncreate a vector that allocates each observation to one of k = 10 folds, and\nwe create a matrix in which we will store the results.\n> k <- 10\n> n <- nrow(Hitters)\n> set.seed (1)\n> folds <- sample(rep (1:k, length = n))\n> cv.errors <- matrix(NA, k, 19,\ndimnames = list(NULL , paste (1:19)))\nNow we write a for loop that performs cross-validation. In the jth fold, the\nelements of folds that equal j are in the test set, and the remainder are in\nthe training set.We make our predictions for each model size (using our new\npredict() method), compute the test errors", "doc_id": "3dc4a125-9893-4b81-913b-5ba33dd0f0d8", "embedding": null, "doc_hash": "b4d51911025e42439780e1232282e38dbf98a2ad80e556e9749f82010d194eaf", "extra_info": null, "node_info": {"start": 646933, "end": 650114, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "b9ff4a66-9c57-49a4-b7f2-eaf03145b21e", "3": "bda1d698-b8a8-400c-b41a-918ebef0aa44"}}, "__type__": "1"}, "bda1d698-b8a8-400c-b41a-918ebef0aa44": {"__data__": {"text": "for each model size (using our new\npredict() method), compute the test errors on the appropriate subset, and\nstore them in the appropriate slot in the matrix cv.errors. Note that in the\nfollowing code R will automatically use our predict.regsubsets() function\nwhen we call predict() because the best.fit object has class regsubsets.\n> for (j in 1:k) {\n+ best.fit <- regsubsets(Salary \u223c .,\ndata = Hitters[folds != j, ],\nnvmax = 19)\n+ for (i in 1:19) {\n+ pred <- predict(best.fit , Hitters[folds == j, ], id = i)\n+ cv. errors [j, i] <-\nmean (( Hitters$Salary[folds == j] - pred)^2)\n+ }\n+ }\nThis has given us a 10\u00d719 matrix, of which the (j, i)th element corresponds\nto the test MSE for the jth cross-validation fold for the best i-variable\nmodel. We use the apply() function to average over the columns of this\napply()\nmatrix in order to obtain a vector for which the ith element is the crossvalidation\nerror for the i-variable model.\n> mean.cv.errors <- apply(cv.errors , 2, mean)\n> mean.cv.errors\n274 6. Linear Model Selection and Regularization\n1 2 3 4 5 6 7 8\n143440 126817 134214 131783 130766 120383 121443 114364\n9 10 11 12 13 14 15 16\n115163 109366 112738 113617 115558 115853 115631 116050\n17 18 19\n116117 116419 116299\n> par(mfrow = c(1, 1))\n> plot(mean.cv.errors , type = \"b\")\nWe see that cross-validation selects a 10-variable model. We now perform\nbest subset selection on the full data set in order to obtain the 10-variable\nmodel.\n> reg.best <- regsubsets(Salary \u223c ., data = Hitters ,\nnvmax = 19)\n> coef(reg.best , 10)\n(Intercept) AtBat Hits Walks CAtBat\n162.535 -2.169 6.918 5.773 -0.130\nCRuns CRBI CWalks DivisionW PutOuts\n1.408 0.774 -0.831 -112.380 0.297\nAssists\n0.283\n6.5.2 Ridge Regression and the Lasso\nWe will use the glmnet package in order to perform ridge regression and\nthe lasso. The main function in this package is glmnet(), which can be used\nglmnet()\nto fit ridge regression models, lasso models, and more. This function has\nslightly different syntax from other model-fitting functions that we have\nencountered thus far in this book. In particular, we must pass in an x\nmatrix as well as a y vector, and we do not use the y \u223c x syntax. We will\nnow perform ridge regression and the lasso in order to predict Salary on\nthe Hitters data. Before proceeding ensure that the missing values have\nbeen removed from the data, as described in Section 6.5.1.\n> x <- model.matrix(Salary \u223c ., Hitters)[, -1]\n> y <- Hitters$Salary\nThe model.matrix() function is particularly useful for creating x; not only\ndoes it produce a matrix corresponding to the 19 predictors but it also\nautomatically transforms any qualitative variables into dummy variables.\nThe latter property is important because glmnet() can only take numerical,\nquantitative inputs.\nRidge Regression\nThe glmnet() function has an alpha argument that determines what type\nof model is fit. If alpha=0 then a ridge regression model is fit, and if alpha=1\nthen a lasso model is fit. We first fit a ridge regression model.\n6.5 Lab: Linear Models and Regularization Methods 275\n> library(glmnet)\n> grid <- 10^seq(10, -2, length = 100)\n> ridge.mod <- glmnet(x, y, alpha = 0, lambda =", "doc_id": "bda1d698-b8a8-400c-b41a-918ebef0aa44", "embedding": null, "doc_hash": "6d6b155901f48a120877e3411a41bab864598b4ab62fd3f134b23655aba4f3e7", "extra_info": null, "node_info": {"start": 650115, "end": 653270, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "3dc4a125-9893-4b81-913b-5ba33dd0f0d8", "3": "824f46c9-0480-46e9-a3b5-ac0bd1401e19"}}, "__type__": "1"}, "824f46c9-0480-46e9-a3b5-ac0bd1401e19": {"__data__": {"text": "ridge.mod <- glmnet(x, y, alpha = 0, lambda = grid)\nBy default the glmnet() function performs ridge regression for an automatically\nselected range of \u03bb values. However, here we have chosen to implement\nthe function over a grid of values ranging from \u03bb = 1010 to \u03bb = 10\u22122, essentially\ncovering the full range of scenarios from the null model containing\nonly the intercept, to the least squares fit. As we will see, we can also compute\nmodel fits for a particular value of \u03bb that is not one of the original\ngrid values. Note that by default, the glmnet() function standardizes the\nvariables so that they are on the same scale. To turn off this default setting,\nuse the argument standardize = FALSE.\nAssociated with each value of \u03bb is a vector of ridge regression coefficients,\nstored in a matrix that can be accessed by coef(). In this case, it is a 20\u00d7100\nmatrix, with 20 rows (one for each predictor, plus an intercept) and 100\ncolumns (one for each value of \u03bb).\n> dim(coef(ridge.mod))\n[1] 20 100\nWe expect the coefficient estimates to be much smaller, in terms of \u21132 norm,\nwhen a large value of \u03bb is used, as compared to when a small value of \u03bb is\nused. These are the coefficients when \u03bb = 11,498, along with their \u21132 norm:\n> ridge.mod$lambda[50]\n[1] 11498\n> coef(ridge.mod)[, 50]\n(Intercept) AtBat Hits HmRun Runs\n407.356 0.037 0.138 0.525 0.231\nRBI Walks Years CAtBat CHits\n0.240 0.290 1.108 0.003 0.012\nCHmRun CRuns CRBI CWalks LeagueN\n0.088 0.023 0.024 0.025 0.085\nDivisionW PutOuts Assists Errors NewLeagueN\n-6.215 0.016 0.003 -0.021 0.301\n> sqrt(sum(coef(ridge.mod)[-1, 50]^2))\n[1] 6.36\nIn contrast, here are the coefficients when \u03bb = 705, along with their \u21132\nnorm. Note the much larger \u21132 norm of the coefficients associated with this\nsmaller value of \u03bb.\n> ridge.mod$lambda[60]\n[1] 705\n> coef(ridge.mod)[, 60]\n(Intercept) AtBat Hits HmRun Runs\n54.325 0.112 0.656 1.180 0.938\nRBI Walks Years CAtBat CHits\n0.847 1.320 2.596 0.011 0.047\nCHmRun CRuns CRBI CWalks LeagueN\n0.338 0.094 0.098 0.072 13.684\n276 6. Linear Model Selection and Regularization\nDivisionW PutOuts Assists Errors NewLeagueN\n-54.659 0.119 0.016 -0.704 8.612\n> sqrt(sum(coef(ridge.mod)[-1, 60]^2))\n[1] 57.1\nWe can use the predict() function for a number of purposes. For instance,\nwe can obtain the ridge regression coefficients for a new value of \u03bb, say 50:\n> predict(ridge.mod , s = 50, type = \"coefficients\")[1:20, ]\n(Intercept) AtBat Hits HmRun Runs\n48.766 -0.358 1.969 -1.278 1.146\nRBI Walks Years CAtBat CHits\n0.804 2.716 -6.218 0.005 0.106\nCHmRun CRuns CRBI CWalks LeagueN\n0.624 0.221 0.219 -0.150 45.926\nDivisionW PutOuts Assists Errors NewLeagueN\n-118.201 0.250 0.122 -3.279 -9.497\nWe now split the samples into a training set and a test set in order\nto estimate the test error of ridge regression and the lasso. There are two\ncommon ways to randomly split a data set. The first is to produce a random\nvector of TRUE, FALSE elements and select the", "doc_id": "824f46c9-0480-46e9-a3b5-ac0bd1401e19", "embedding": null, "doc_hash": "9388563d2516465d8b436fc517430a9fc8ab62a467d14ace1054d50dca9b5bf1", "extra_info": null, "node_info": {"start": 653300, "end": 656229, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "bda1d698-b8a8-400c-b41a-918ebef0aa44", "3": "9ea0a5a8-e437-4b5e-a367-9ed4f3337afc"}}, "__type__": "1"}, "9ea0a5a8-e437-4b5e-a367-9ed4f3337afc": {"__data__": {"text": "first is to produce a random\nvector of TRUE, FALSE elements and select the observations corresponding to\nTRUE for the training data. The second is to randomly choose a subset of\nnumbers between 1 and n; these can then be used as the indices for the\ntraining observations. The two approaches work equally well. We used the\nformer method in Section 6.5.1. Here we demonstrate the latter approach.\nWe first set a random seed so that the results obtained will be reproducible.\n> set.seed (1)\n> train <- sample (1: nrow(x), nrow(x) / 2)\n> test <- (-train)\n> y.test <- y[test]\nNext we fit a ridge regression model on the training set, and evaluate\nits MSE on the test set, using \u03bb = 4. Note the use of the predict()\nfunction again. This time we get predictions for a test set, by replacing\ntype=\"coefficients\" with the newx argument.\n> ridge.mod <- glmnet(x[train , ], y[train], alpha = 0,\nlambda = grid , thresh = 1e -12)\n> ridge.pred <- predict(ridge.mod , s = 4, newx = x[test , ])\n> mean (( ridge.pred - y.test)^2)\n[1] 142199\nThe test MSE is 142,199. Note that if we had instead simply fit a model\nwith just an intercept, we would have predicted each test observation using\nthe mean of the training observations. In that case, we could compute the\ntest set MSE like this:\n> mean (( mean(y[train ]) - y.test)^2)\n[1] 224670\n6.5 Lab: Linear Models and Regularization Methods 277\nWe could also get the same result by fitting a ridge regression model with\na very large value of \u03bb. Note that 1e10 means 1010.\n> ridge.pred <- predict(ridge.mod , s = 1e10 , newx = x[test , ])\n> mean (( ridge.pred - y.test)^2)\n[1] 224670\nSo fitting a ridge regression model with \u03bb = 4 leads to a much lower test\nMSE than fitting a model with just an intercept. We now check whether\nthere is any benefit to performing ridge regression with \u03bb = 4 instead of\njust performing least squares regression. Recall that least squares is simply\nridge regression with \u03bb = 0.8\n> ridge.pred <- predict(ridge.mod , s = 0, newx = x[test , ],\nexact = T, x = x[train , ], y = y[train ])\n> mean (( ridge.pred - y.test)^2)\n[1] 168589\n> lm(y \u223c x, subset = train)\n> predict(ridge.mod , s = 0, exact = T, type = \"coefficients\",\nx = x[train, ], y = y[train])[1:20, ]\nIn general, if we want to fit a (unpenalized) least squares model, then\nwe should use the lm() function, since that function provides more useful\noutputs, such as standard errors and p-values for the coefficients.\nIn general, instead of arbitrarily choosing \u03bb = 4, it would be better to\nuse cross-validation to choose the tuning parameter \u03bb. We can do this using\nthe built-in cross-validation function, cv.glmnet(). By default, the function\ncv.glmnet()\nperforms ten-fold cross-validation, though this can be changed using the\nargument nfolds. Note that we set a random seed first so our results will\nbe reproducible, since the choice of the cross-validation folds is random.\n> set.seed (1)\n> cv.out <- cv.glmnet(x[train , ], y[train], alpha = 0)\n> plot(cv.out)\n> bestlam <- cv.out$lambda.min\n> bestlam\n[1] 326\nTherefore, we see that the value of \u03bb that results in the smallest crossvalidation\nerror is 326. What is the test MSE associated with this value of\n\u03bb?\n> ridge.pred <- predict(ridge.mod , s =", "doc_id": "9ea0a5a8-e437-4b5e-a367-9ed4f3337afc", "embedding": null, "doc_hash": "1844fea349509b256a6f6d4c6177cc4f4c037f72a243415d3fbb43b08f08b5c0", "extra_info": null, "node_info": {"start": 656205, "end": 659422, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "824f46c9-0480-46e9-a3b5-ac0bd1401e19", "3": "2b4782fa-0412-40b1-97ca-d7ffd3255c8c"}}, "__type__": "1"}, "2b4782fa-0412-40b1-97ca-d7ffd3255c8c": {"__data__": {"text": "of\n\u03bb?\n> ridge.pred <- predict(ridge.mod , s = bestlam ,\nnewx = x[test , ])\n8In order for glmnet() to yield the exact least squares coefficients when \u03bb = 0,\nwe use the argument exact = T when calling the predict() function. Otherwise,\nthe predict() function will interpolate over the grid of \u03bb values used in fitting the\nglmnet() model, yielding approximate results. When we use exact = T, there remains\na slight discrepancy in the third decimal place between the output of glmnet() when\n\u03bb = 0 and the output of lm(); this is due to numerical approximation on the part of\nglmnet().\n278 6. Linear Model Selection and Regularization\n> mean (( ridge.pred - y.test)^2)\n[1] 139857\nThis represents a further improvement over the test MSE that we got using\n\u03bb = 4. Finally, we refit our ridge regression model on the full data set,\nusing the value of \u03bb chosen by cross-validation, and examine the coefficient\nestimates.\n> out <- glmnet(x, y, alpha = 0)\n> predict(out , type = \"coefficients\", s = bestlam)[1:20, ]\n(Intercept) AtBat Hits HmRun Runs\n15.44 0.08 0.86 0.60 1.06\nRBI Walks Years CAtBat CHits\n0.88 1.62 1.35 0.01 0.06\nCHmRun CRuns CRBI CWalks LeagueN\n0.41 0.11 0.12 0.05 22.09\nDivisionW PutOuts Assists Errors NewLeagueN\n-79.04 0.17 0.03 -1.36 9.12\nAs expected, none of the coefficients are zero\u2014ridge regression does not\nperform variable selection!\nThe Lasso\nWe saw that ridge regression with a wise choice of \u03bb can outperform least\nsquares as well as the null model on the Hitters data set. We now ask\nwhether the lasso can yield either a more accurate or a more interpretable\nmodel than ridge regression. In order to fit a lasso model, we once again\nuse the glmnet() function; however, this time we use the argument alpha=1.\nOther than that change, we proceed just as we did in fitting a ridge model.\n> lasso.mod <- glmnet(x[train , ], y[train], alpha = 1,\nlambda = grid)\n> plot(lasso.mod)\nWe can see from the coefficient plot that depending on the choice of tuning\nparameter, some of the coefficients will be exactly equal to zero. We now\nperform cross-validation and compute the associated test error.\n> set.seed (1)\n> cv.out <- cv.glmnet(x[train , ], y[train], alpha = 1)\n> plot(cv.out)\n> bestlam <- cv.out$lambda.min\n> lasso.pred <- predict(lasso.mod , s = bestlam ,\nnewx = x[test , ])\n> mean (( lasso.pred - y.test)^2)\n[1] 143674\nThis is substantially lower than the test set MSE of the null model and of\nleast squares, and very similar to the test MSE of ridge regression with \u03bb\nchosen by cross-validation.\nHowever, the lasso has a substantial advantage over ridge regression in\nthat the resulting coefficient estimates are sparse. Here we see that 8 of the\n6.5 Lab: Linear Models and Regularization Methods 279\n19 coefficient estimates are exactly zero. So the lasso model with \u03bb chosen\nby cross-validation contains only eleven variables.\n> out <- glmnet(x, y, alpha = 1, lambda = grid)\n> lasso.coef <- predict(out , type = \"coefficients\",\ns = bestlam)[1:20, ]\n> lasso.coef\n(Intercept) AtBat Hits HmRun Runs\n1.27 -0.05 2.18 0.00 0.00\nRBI Walks Years CAtBat CHits\n0.00 2.29 -0.34 0.00", "doc_id": "2b4782fa-0412-40b1-97ca-d7ffd3255c8c", "embedding": null, "doc_hash": "dead45527ace6bd380895f67a1f83a8d79a906ea521bccc1c0698120712af71a", "extra_info": null, "node_info": {"start": 659446, "end": 662539, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "9ea0a5a8-e437-4b5e-a367-9ed4f3337afc", "3": "9d832c29-abd2-46d8-8da9-b5dd8286f820"}}, "__type__": "1"}, "9d832c29-abd2-46d8-8da9-b5dd8286f820": {"__data__": {"text": "Years CAtBat CHits\n0.00 2.29 -0.34 0.00 0.00\nCHmRun CRuns CRBI CWalks LeagueN\n0.03 0.22 0.42 0.00 20.29\nDivisionW PutOuts Assists Errors NewLeagueN\n-116.17 0.24 0.00 -0.86 0.00\n> lasso.coef[lasso.coef != 0]\n(Intercept) AtBat Hits Walks Years\n1.27 -0.05 2.18 2.29 -0.34\nCHmRun CRuns CRBI LeagueN DivisionW\n0.03 0.22 0.42 20.29 -116.17\nPutOuts Errors\n0.24 -0.86\n6.5.3 PCR and PLS Regression\nPrincipal Components Regression\nPrincipal components regression (PCR) can be performed using the pcr()\npcr()\nfunction, which is part of the pls library.We now apply PCR to the Hitters\ndata, in order to predict Salary. Again, we ensure that the missing values\nhave been removed from the data, as described in Section 6.5.1.\n> library(pls)\n> set.seed (2)\n> pcr.fit <- pcr(Salary \u223c ., data = Hitters , scale = TRUE ,\nvalidation = \"CV\")\nThe syntax for the pcr() function is similar to that for lm(), with a few\nadditional options. Setting scale = TRUE has the effect of standardizing each\npredictor, using (6.6), prior to generating the principal components, so that\nthe scale on which each variable is measured will not have an effect. Setting\nvalidation = \"CV\" causes pcr() to compute the ten-fold cross-validation\nerror for each possible value of M, the number of principal components\nused. The resulting fit can be examined using summary().\n> summary(pcr.fit)\nData: X dimension: 263 19\nY dimension: 263 1\nFit method: svdpc\nNumber of components considered: 19\nVALIDATION: RMSEP\n280 6. Linear Model Selection and Regularization\nCross -validated using 10 random segments.\n(Intercept) 1 comps 2 comps 3 comps 4 comps\nCV 452 351.9 353.2 355.0 352.8\nadjCV 452 351.6 352.7 354.4 352.1\n...\nTRAINING: % variance explained\n1 comps 2 comps 3 comps 4 comps 5 comps\nX 38.31 60.16 70.84 79.03 84.29\nSalary 40.63 41.58 42.17 43.22 44.90\n...\nThe CV score is provided for each possible number of components, ranging\nfrom M = 0 onwards. (We have printed the CV output only up to M = 4.)\nNote that pcr() reports the root mean squared error; in order to obtain\nthe usual MSE, we must square this quantity. For instance, a root mean\nsquared error of 352.8 corresponds to an MSE of 352.82 = 124,468.\nOne can also plot the cross-validation scores using the validationplot()\nvalidationplot()\nfunction. Using val.type = \"MSEP\" will cause the cross-validation MSE to\nbe plotted.\n> validationplot(pcr.fit , val.type = \"MSEP\")\nWe see that the smallest cross-validation error occurs when M = 18 components\nare used. This is barely fewer than M = 19, which amounts to\nsimply performing least squares, because when all of the components are\nused in PCR no dimension reduction occurs. However, from the plot we\nalso see that the cross-validation error is roughly the same when only one\ncomponent is included in the model. This suggests that a model that uses\njust a small number of components might suffice.\nThe summary() function also provides the percentage of variance explained\nin the predictors and in the response using different numbers of components.\nThis concept is discussed in greater detail in Chapter 12. Briefly,\nwe can think of this as the amount of information about the predictors or\nthe response that is captured using M principal components. For", "doc_id": "9d832c29-abd2-46d8-8da9-b5dd8286f820", "embedding": null, "doc_hash": "fd6e39917ab484aba3228ad953cd79719905ef86166dfacf29eb464a1e32627e", "extra_info": null, "node_info": {"start": 662545, "end": 665766, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "2b4782fa-0412-40b1-97ca-d7ffd3255c8c", "3": "c46cec8d-4b18-4203-a747-6b28921794d1"}}, "__type__": "1"}, "c46cec8d-4b18-4203-a747-6b28921794d1": {"__data__": {"text": "predictors or\nthe response that is captured using M principal components. For example,\nsetting M = 1 only captures 38.31% of all the variance, or information, in\nthe predictors. In contrast, using M = 5 increases the value to 84.29 %. If\nwe were to use all M = p = 19 components, this would increase to 100 %.\nWe now perform PCR on the training data and evaluate its test set\nperformance.\n> set.seed (1)\n> pcr.fit <- pcr(Salary \u223c ., data = Hitters , subset = train ,\nscale = TRUE , validation = \"CV\")\n> validationplot(pcr.fit , val.type = \"MSEP\")\nNow we find that the lowest cross-validation error occurs when M = 5\ncomponents are used. We compute the test MSE as follows.\n> pcr.pred <- predict(pcr.fit , x[test , ], ncomp = 5)\n> mean (( pcr.pred - y.test)^2)\n6.5 Lab: Linear Models and Regularization Methods 281\n[1] 142812\nThis test set MSE is competitive with the results obtained using ridge regression\nand the lasso. However, as a result of the way PCR is implemented,\nthe final model is more difficult to interpret because it does not perform\nany kind of variable selection or even directly produce coefficient estimates.\nFinally, we fit PCR on the full data set, using M = 5, the number of\ncomponents identified by cross-validation.\n> pcr.fit <- pcr(y \u223c x, scale = TRUE , ncomp = 5)\n> summary(pcr.fit)\nData: X dimension: 263 19\nY dimension: 263 1\nFit method: svdpc\nNumber of components considered: 5\nTRAINING: % variance explained\n1 comps 2 comps 3 comps 4 comps 5 comps\nX 38.31 60.16 70.84 79.03 84.29\ny 40.63 41.58 42.17 43.22 44.90\nPartial Least Squares\nWe implement partial least squares (PLS) using the plsr() function, also\nplsr()\nin the pls library. The syntax is just like that of the pcr() function.\n> set.seed (1)\n> pls.fit <- plsr(Salary \u223c ., data = Hitters , subset = train ,\nscale = TRUE , validation = \"CV\")\n> summary(pls.fit)\nData: X dimension: 131 19\nY dimension: 131 1\nFit method: kernelpls\nNumber of components considered: 19\nVALIDATION: RMSEP\nCross -validated using 10 random segments.\n(Intercept) 1 comps 2 comps 3 comps 4 comps\nCV 428.3 325.5 329.9 328.8 339.0\nadjCV 428.3 325.0 328.2 327.2 336.6\n...\nTRAINING: % variance explained\n1 comps 2 comps 3 comps 4 comps 5 comps\nX 39.13 48.80 60.09 75.07 78.58\nSalary 46.36 50.72 52.23 53.03 54.07\n...\n> validationplot(pls.fit , val.type = \"MSEP\")\nThe lowest cross-validation error occurs when only M = 1 partial least\nsquares directions are used. We now evaluate the corresponding test set\nMSE.\n> pls.pred <- predict(pls.fit , x[test , ], ncomp = 1)\n282 6. Linear Model Selection and Regularization\n> mean (( pls.pred - y.test)^2)\n[1] 151995\nThe test MSE is comparable to, but slightly higher than, the test MSE\nobtained using ridge regression, the lasso, and PCR.\nFinally, we perform PLS using the full data set, using M = 1, the number\nof components identified by cross-validation.\n> pls.fit <- plsr(Salary \u223c ., data = Hitters , scale = TRUE ,\nncomp = 1)\n> summary(pls.fit)\nData: X dimension: 263 19\nY dimension: 263 1\nFit method:", "doc_id": "c46cec8d-4b18-4203-a747-6b28921794d1", "embedding": null, "doc_hash": "abfcd0bd4eaaa2fcfbd8a69565a3fd87a6f145562e806457a74634b452d50845", "extra_info": null, "node_info": {"start": 665734, "end": 668738, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "9d832c29-abd2-46d8-8da9-b5dd8286f820", "3": "fc46fc03-c8b5-4ea5-a581-e160d813ee4e"}}, "__type__": "1"}, "fc46fc03-c8b5-4ea5-a581-e160d813ee4e": {"__data__": {"text": "X dimension: 263 19\nY dimension: 263 1\nFit method: kernelpls\nNumber of components considered: 1\nTRAINING: % variance explained\n1 comps\nX 38.08\nSalary 43.05\nNotice that the percentage of variance in Salary that the one-component\nPLS fit explains, 43.05 %, is almost as much as that explained using the final\nfive-component model PCR fit, 44.90 %. This is because PCR only attempts\nto maximize the amount of variance explained in the predictors, while PLS\nsearches for directions that explain variance in both the predictors and the\nresponse.\n6.6 Exercises\nConceptual\n1. We perform best subset, forward stepwise, and backward stepwise\nselection on a single data set. For each approach, we obtain p + 1\nmodels, containing 0, 1, 2, . . . ,p predictors. Explain your answers:\n(a) Which of the three models with k predictors has the smallest\ntraining RSS?\n(b) Which of the three models with k predictors has the smallest\ntest RSS?\n(c) True or False:\ni. The predictors in the k-variable model identified by forward\nstepwise are a subset of the predictors in the (k+1)-variable\nmodel identified by forward stepwise selection.\nii. The predictors in the k-variable model identified by backward\nstepwise are a subset of the predictors in the (k + 1)-\nvariable model identified by backward stepwise selection.\n6.6 Exercises 283\niii. The predictors in the k-variable model identified by backward\nstepwise are a subset of the predictors in the (k + 1)-\nvariable model identified by forward stepwise selection.\niv. The predictors in the k-variable model identified by forward\nstepwise are a subset of the predictors in the (k+1)-variable\nmodel identified by backward stepwise selection.\nv. The predictors in the k-variable model identified by best\nsubset are a subset of the predictors in the (k + 1)-variable\nmodel identified by best subset selection.\n2. For parts (a) through (c), indicate which of i. through iv. is correct.\nJustify your answer.\n(a) The lasso, relative to least squares, is:\ni. More flexible and hence will give improved prediction accuracy\nwhen its increase in bias is less than its decrease in\nvariance.\nii. More flexible and hence will give improved prediction accuracy\nwhen its increase in variance is less than its decrease\nin bias.\niii. Less flexible and hence will give improved prediction accuracy\nwhen its increase in bias is less than its decrease in\nvariance.\niv. Less flexible and hence will give improved prediction accuracy\nwhen its increase in variance is less than its decrease\nin bias.\n(b) Repeat (a) for ridge regression relative to least squares.\n(c) Repeat (a) for non-linear methods relative to least squares.\n3. Suppose we estimate the regression coefficients in a linear regression\nmodel by minimizing\n0n\ni=1\n\u239b\n\u239dyi \u2212 \u03b20 \u2212\n0p\nj=1\n\u03b2jxij\n\u239e\n\u23a0\n2\nsubject to\n0p\nj=1\n|\u03b2j| \u2264 s\nfor a particular value of s. For parts (a) through (e), indicate which\nof i. through v. is correct. Justify your answer.\n(a) As we increase s from 0, the training RSS will:\ni. Increase initially, and then eventually start decreasing in an\ninverted U shape.\nii. Decrease initially, and then eventually start increasing in a\nU shape.\n284 6. Linear Model Selection and Regularization\niii. Steadily increase.\niv. Steadily decrease.\nv. Remain constant.\n(b) Repeat (a) for test RSS.\n(c) Repeat (a) for variance.\n(d) Repeat (a) for (squared) bias.\n(e) Repeat", "doc_id": "fc46fc03-c8b5-4ea5-a581-e160d813ee4e", "embedding": null, "doc_hash": "5a11f9301016a14d4cf5aed3437b757e9290477e56be022b84336d49cd3dfd6b", "extra_info": null, "node_info": {"start": 668763, "end": 672110, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "c46cec8d-4b18-4203-a747-6b28921794d1", "3": "81111b16-ea16-46d9-95ee-6c58fb31d87d"}}, "__type__": "1"}, "81111b16-ea16-46d9-95ee-6c58fb31d87d": {"__data__": {"text": "Repeat (a) for (squared) bias.\n(e) Repeat (a) for the irreducible error.\n4. Suppose we estimate the regression coefficients in a linear regression\nmodel by minimizing\n0n\ni=1\n\u239b\n\u239dyi \u2212 \u03b20 \u2212\n0p\nj=1\n\u03b2jxij\n\u239e\n\u23a0\n2\n+ \u03bb\n0p\nj=1\n\u03b22\nj\nfor a particular value of \u03bb. For parts (a) through (e), indicate which\nof i. through v. is correct. Justify your answer.\n(a) As we increase \u03bb from 0, the training RSS will:\ni. Increase initially, and then eventually start decreasing in an\ninverted U shape.\nii. Decrease initially, and then eventually start increasing in a\nU shape.\niii. Steadily increase.\niv. Steadily decrease.\nv. Remain constant.\n(b) Repeat (a) for test RSS.\n(c) Repeat (a) for variance.\n(d) Repeat (a) for (squared) bias.\n(e) Repeat (a) for the irreducible error.\n5. It is well-known that ridge regression tends to give similar coefficient\nvalues to correlated variables, whereas the lasso may give quite different\ncoefficient values to correlated variables. We will now explore\nthis property in a very simple setting.\nSuppose that n = 2, p = 2, x11 = x12, x21 = x22. Furthermore,\nsuppose that y1+y2 = 0 and x11+x21 = 0 and x12+x22 = 0, so that\nthe estimate for the intercept in a least squares, ridge regression, or\nlasso model is zero: \u02c6 \u03b20 = 0.\n(a) Write out the ridge regression optimization problem in this setting.\n6.6 Exercises 285\n(b) Argue that in this setting, the ridge coefficient estimates satisfy\n\u02c6 \u03b21 = \u02c6 \u03b22.\n(c) Write out the lasso optimization problem in this setting.\n(d) Argue that in this setting, the lasso coefficients \u02c6 \u03b21 and \u02c6 \u03b22 are\nnot unique\u2014in other words, there are many possible solutions\nto the optimization problem in (c). Describe these solutions.\n6. We will now explore (6.12) and (6.13) further.\n(a) Consider (6.12) with p = 1. For some choice of y1 and \u03bb > 0,\nplot (6.12) as a function of \u03b21. Your plot should confirm that\n(6.12) is solved by (6.14).\n(b) Consider (6.13) with p = 1. For some choice of y1 and \u03bb > 0,\nplot (6.13) as a function of \u03b21. Your plot should confirm that\n(6.13) is solved by (6.15).\n7. We will now derive the Bayesian connection to the lasso and ridge\nregression discussed in Section 6.2.2.\n(a) Suppose that yi = \u03b20+\n)p\nj=1 xij\u03b2j+\u03f5i where \u03f51, . . . , \u03f5n are independent\nand identically distributed from a N(0,\u03c32) distribution.\nWrite out the likelihood for the data.\n(b) Assume the following prior for \u03b2: \u03b21, . . . ,\u03b2p are independent\nand identically distributed according to a double-exponential\ndistribution with mean 0 and common scale parameter b: i.e.\np(\u03b2) = 1\n2b exp(\u2212|\u03b2|/b). Write out the posterior for \u03b2 in this\nsetting.\n(c) Argue that the lasso estimate is the mode for \u03b2 under this posterior\ndistribution.\n(d) Now assume the following prior for \u03b2: \u03b21, . . . ,\u03b2p are independent\nand identically distributed according to a normal distribution\nwith mean zero and variance c. Write out the posterior for \u03b2 in\nthis setting.\n(e) Argue that the ridge regression estimate is both the mode and\nthe mean for \u03b2 under this posterior distribution.\nApplied\n8. In", "doc_id": "81111b16-ea16-46d9-95ee-6c58fb31d87d", "embedding": null, "doc_hash": "707ef9f19fa88ec582c8a4e146d6f573c980b7682fea54b77003bd26e6fba100", "extra_info": null, "node_info": {"start": 672118, "end": 675128, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "fc46fc03-c8b5-4ea5-a581-e160d813ee4e", "3": "aa507997-3a52-4a68-8d43-756cfdae3136"}}, "__type__": "1"}, "aa507997-3a52-4a68-8d43-756cfdae3136": {"__data__": {"text": "mean for \u03b2 under this posterior distribution.\nApplied\n8. In this exercise, we will generate simulated data, and will then use\nthis data to perform best subset selection.\n(a) Use the rnorm() function to generate a predictor X of length\nn = 100, as well as a noise vector \u03f5 of length n = 100.\n286 6. Linear Model Selection and Regularization\n(b) Generate a response vector Y of length n = 100 according to\nthe model\nY = \u03b20 + \u03b21X + \u03b22X2 + \u03b23X3 + \u03f5,\nwhere \u03b20, \u03b21, \u03b22, and \u03b23 are constants of your choice.\n(c) Use the regsubsets() function to perform best subset selection\nin order to choose the best model containing the predictors\nX,X2, . . . ,X10. What is the best model obtained according to\nCp, BIC, and adjusted R2? Show some plots to provide evidence\nfor your answer, and report the coefficients of the best model obtained.\nNote you will need to use the data.frame() function to\ncreate a single data set containing both X and Y .\n(d) Repeat (c), using forward stepwise selection and also using backwards\nstepwise selection. How does your answer compare to the\nresults in (c)?\n(e) Now fit a lasso model to the simulated data, again using X,X2,\n. . . , X10 as predictors. Use cross-validation to select the optimal\nvalue of \u03bb. Create plots of the cross-validation error as a function\nof \u03bb. Report the resulting coefficient estimates, and discuss the\nresults obtained.\n(f) Now generate a response vector Y according to the model\nY = \u03b20 + \u03b27X7 + \u03f5,\nand perform best subset selection and the lasso. Discuss the\nresults obtained.\n9. In this exercise, we will predict the number of applications received\nusing the other variables in the College data set.\n(a) Split the data set into a training set and a test set.\n(b) Fit a linear model using least squares on the training set, and\nreport the test error obtained.\n(c) Fit a ridge regression model on the training set, with \u03bb chosen\nby cross-validation. Report the test error obtained.\n(d) Fit a lasso model on the training set, with \u03bb chosen by crossvalidation.\nReport the test error obtained, along with the number\nof non-zero coefficient estimates.\n(e) Fit a PCR model on the training set, with M chosen by crossvalidation.\nReport the test error obtained, along with the value\nof M selected by cross-validation.\n(f) Fit a PLS model on the training set, with M chosen by crossvalidation.\nReport the test error obtained, along with the value\nof M selected by cross-validation.\n6.6 Exercises 287\n(g) Comment on the results obtained. How accurately can we predict\nthe number of college applications received? Is there much\ndifference among the test errors resulting from these five approaches?\n10. We have seen that as the number of features used in a model increases,\nthe training error will necessarily decrease, but the test error may not.\nWe will now explore this in a simulated data set.\n(a) Generate a data set with p = 20 features, n = 1,000 observations,\nand an associated quantitative response vector generated\naccording to the model\nY = X\u03b2 + \u03f5,\nwhere \u03b2 has some elements that are exactly equal to zero.\n(b) Split your data set into a training set containing 100 observations\nand a test set containing 900 observations.\n(c) Perform best subset selection on the training set, and plot the\ntraining set MSE associated with the best model of each size.\n(d) Plot the test set MSE associated with the best model of each\nsize.\n(e) For which model size does the test set MSE take on its minimum\nvalue? Comment on your results. If it takes on its minimum value\nfor a model containing only an intercept or a model containing\nall of the features, then play around with the way that you are\ngenerating the data in (a) until you come up with a scenario in\nwhich the test", "doc_id": "aa507997-3a52-4a68-8d43-756cfdae3136", "embedding": null, "doc_hash": "ab44693d166b01b0f1a0058d7543123a5a8269b88454cd211d5f82ec20afe06a", "extra_info": null, "node_info": {"start": 675113, "end": 678823, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "81111b16-ea16-46d9-95ee-6c58fb31d87d", "3": "07583cca-8eba-46d0-91ea-605ede74dc22"}}, "__type__": "1"}, "07583cca-8eba-46d0-91ea-605ede74dc22": {"__data__": {"text": "the data in (a) until you come up with a scenario in\nwhich the test set MSE is minimized for an intermediate model\nsize.\n(f) How does the model at which the test set MSE is minimized\ncompare to the true model used to generate the data? Comment\non the coefficient values.\n(g) Create a plot displaying\nG)p\nj=1(\u03b2j \u2212 \u02c6 \u03b2r\nj )2 for a range of values\nof r, where \u02c6 \u03b2r\nj is the jth coefficient estimate for the best model\ncontaining r coefficients. Comment on what you observe. How\ndoes this compare to the test MSE plot from (d)?\n11. We will now try to predict per capita crime rate in the Boston data\nset.\n(a) Try out some of the regression methods explored in this chapter,\nsuch as best subset selection, the lasso, ridge regression, and\nPCR. Present and discuss results for the approaches that you\nconsider.\n288 6. Linear Model Selection and Regularization\n(b) Propose a model (or set of models) that seem to perform well on\nthis data set, and justify your answer. Make sure that you are\nevaluating model performance using validation set error, crossvalidation,\nor some other reasonable alternative, as opposed to\nusing training error.\n(c) Does your chosen model involve all of the features in the data\nset? Why or why not?\n7\nMoving Beyond Linearity\nSo far in this book, we have mostly focused on linear models. Linear models\nare relatively simple to describe and implement, and have advantages over\nother approaches in terms of interpretation and inference. However, standard\nlinear regression can have significant limitations in terms of predictive\npower. This is because the linearity assumption is almost always an\napproximation, and sometimes a poor one. In Chapter 6 we see that we can\nimprove upon least squares using ridge regression, the lasso, principal components\nregression, and other techniques. In that setting, the improvement\nis obtained by reducing the complexity of the linear model, and hence the\nvariance of the estimates. But we are still using a linear model, which can\nonly be improved so far! In this chapter we relax the linearity assumption\nwhile still attempting to maintain as much interpretability as possible. We\ndo this by examining very simple extensions of linear models like polynomial\nregression and step functions, as well as more sophisticated approaches\nsuch as splines, local regression, and generalized additive models.\n\u2022 Polynomial regression extends the linear model by adding extra predictors,\nobtained by raising each of the original predictors to a power.\nFor example, a cubic regression uses three variables, X, X2, and X3,\nas predictors. This approach provides a simple way to provide a nonlinear\nfit to data.\n\u2022 Step functions cut the range of a variable into K distinct regions in\norder to produce a qualitative variable. This has the effect of fitting\na piecewise constant function.\n\u00a9 Springer Science+Business Media, LLC, part of Springer Nature 2021\nG. James et al., An Introduction to Statistical Learning, Springer Texts in Statistics,\nhttps://doi.org/10.1007/978-1-0716-1418-1_7\n289\n290 7. Moving Beyond Linearity\n\u2022 Regression splines are more flexible than polynomials and step functions,\nand in fact are an extension of the two. They involve dividing\nthe range of X into K distinct regions. Within each region, a polynomial\nfunction is fit to the data. However, these polynomials are\nconstrained so that they join smoothly at the region boundaries, or\nknots. Provided that the interval is divided into enough regions, this\ncan produce an extremely flexible fit.\n\u2022 Smoothing splines are similar to regression splines, but arise in a\nslightly different situation. Smoothing splines result from minimizing\na residual sum of squares criterion subject to a smoothness penalty.\n\u2022 Local regression is similar to splines, but differs in an important way.\nThe regions are allowed to", "doc_id": "07583cca-8eba-46d0-91ea-605ede74dc22", "embedding": null, "doc_hash": "3f917d2f6f2a158021719f9cdbe0c20702f1784bc55b923bf230cfccd4552c4f", "extra_info": null, "node_info": {"start": 678822, "end": 682648, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "aa507997-3a52-4a68-8d43-756cfdae3136", "3": "cbd1f69f-5c10-4508-8501-24f8291c2b05"}}, "__type__": "1"}, "cbd1f69f-5c10-4508-8501-24f8291c2b05": {"__data__": {"text": "similar to splines, but differs in an important way.\nThe regions are allowed to overlap, and indeed they do so in a very\nsmooth way.\n\u2022 Generalized additive models allow us to extend the methods above to\ndeal with multiple predictors.\nIn Sections 7.1\u20137.6, we present a number of approaches for modeling the\nrelationship between a response Y and a single predictor X in a flexible\nway. In Section 7.7, we show that these approaches can be seamlessly integrated\nin order to model a response Y as a function of several predictors\nX1, . . . ,Xp.\n7.1 Polynomial Regression\nHistorically, the standard way to extend linear regression to settings in\nwhich the relationship between the predictors and the response is nonlinear\nhas been to replace the standard linear model\nyi = \u03b20 + \u03b21xi + \u03f5i\nwith a polynomial function\nyi = \u03b20 + \u03b21xi + \u03b22x2i+ \u03b23x3i\n+ \u00b7 \u00b7 \u00b7 + \u03b2dxdi\n+ \u03f5i, (7.1)\nwhere \u03f5i is the error term. This approach is known as polynomial regression,\npolynomial\nand in fact we saw an example of this method in Section 3.3.2. For large regression\nenough degree d, a polynomial regression allows us to produce an extremely\nnon-linear curve. Notice that the coefficients in (7.1) can be easily estimated\nusing least squares linear regression because this is just a standard linear\nmodel with predictors xi, x2i\n, x3i\n, . . . ,xdi\n. Generally speaking, it is unusual\nto use d greater than 3 or 4 because for large values of d, the polynomial\ncurve can become overly flexible and can take on some very strange shapes.\nThis is especially true near the boundary of the X variable.\n7.1 Polynomial Regression 291\n20 30 40 50 60 70 80\n50 100 150 200 250 300\nAge\nWage\nDegree\u22124 Polynomial\n20 30 40 50 60 70 80\n0.00 0.05 0.10 0.15 0.20\nAge\n| | | | || ||| | | | | |\n| || | |\n|\n| |\n|\n|\n| || | | | || | | | |\n|\n|| |\n|\n| | | | | | | | | | | | |\n| |\n|\n|| || | || | |||| | |\n| || || |\n|| |\n|\n|\n| | | || | || || | || ||| |||| || | || || | | ||| || ||| || |||| | || ||| |\n|| |\n|\n| | || || | |\n| | ||||||| |||||| || ||| || |||||| ||| |||| ||||||| ||| |||| ||| ||| || ||| ||| ||\n| || |\n| |\n|\n| | | | | |\n|\n|\n|| || |||| || || || |\n|\n| | | || | |||| | || || || | |||| |\n|\n| | || |\n| || |\n| || | ||| |\n|\n|| |\n| || | | | || | ||| | || || || |||| || || |\n|\n|\n|\n|\n| ||| | || ||| |||| | | ||| || | |\n|\n| |\n|\n|\n|| |||| || |\n||| | | | | || |||||| |||||| ||| ||||||| | ||| |||| | || | |\n|| ||| |\n|\n| ||| || |||| || || |\n||| || || ||| || ||| || |\n| |||| |\n|\n| |\n|\n|| ||| || |||| ||| ||| || ||| ||| || |\n|\n|| |\n|\n| | |\n| |\n|\n|| || || |||||| || | | || |\n||| |||||| ||| |||||| |||||| ||| |\n| ||| ||| || |||| |||| |\n||| || || || | ||| ||| |||| |\n||| ||| ||| ||\n|\n|\n||| ||| |||||| ||||||||| |||||| |\n||| | ||| |||| |\n|\n||| |||| || ||| ||| | |\n| || ||| |\n| || || |||| ||||| | ||| |\n|\n|\n||", "doc_id": "cbd1f69f-5c10-4508-8501-24f8291c2b05", "embedding": null, "doc_hash": "e8e3fe633136a863150f6850c4604745f98956522d39f1cf0766089792d4bb24", "extra_info": null, "node_info": {"start": 682636, "end": 685378, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "07583cca-8eba-46d0-91ea-605ede74dc22", "3": "10b301a8-7223-492f-887e-f759a8a1cc2c"}}, "__type__": "1"}, "10b301a8-7223-492f-887e-f759a8a1cc2c": {"__data__": {"text": "||| |\n| || || |||| ||||| | ||| |\n|\n|\n|| |||||| || || |\n| | ||\n| || | |||| |||| |||||||||||||| |\n|\n|\n| || |||||| ||||||||| ||| ||||||| |||||||| |\n|\n|| |||||| | || ||||| || |\n||||| || |\n| | |\n| ||\n|| || ||| || Pr(Wage>250 | Age)\nFIGURE 7.1. The Wage data. Left: The solid blue curve is a degree-4 polynomial\nof wage (in thousands of dollars) as a function of age, fit by least squares. The\ndashed curves indicate an estimated 95% confidence interval. Right: We model the\nbinary event wage>250 using logistic regression, again with a degree-4 polynomial.\nThe fitted posterior probability of wage exceeding $250,000 is shown in blue, along\nwith an estimated 95% confidence interval.\nThe left-hand panel in Figure 7.1 is a plot of wage against age for the\nWage data set, which contains income and demographic information for\nmales who reside in the central Atlantic region of the United States. We\nsee the results of fitting a degree-4 polynomial using least squares (solid\nblue curve). Even though this is a linear regression model like any other,\nthe individual coefficients are not of particular interest. Instead, we look at\nthe entire fitted function across a grid of 63 values for age from 18 to 80 in\norder to understand the relationship between age and wage.\nIn Figure 7.1, a pair of dashed curves accompanies the fit; these are (2\u00d7)\nstandard error curves. Let\u2019s see how these arise. Suppose we have computed\nthe fit at a particular value of age, x0:\n\u02c6 f(x0) = \u02c6 \u03b20 + \u02c6 \u03b21x0 + \u02c6 \u03b22x20\n+ \u02c6 \u03b23x30\n+ \u02c6 \u03b24x40\n. (7.2)\nWhat is the variance of the fit, i.e. Var \u02c6 f(x0)? Least squares returns variance\nestimates for each of the fitted coefficients \u02c6 \u03b2j , as well as the covariances\nbetween pairs of coefficient estimates. We can use these to compute the\nestimated variance of \u02c6 f(x0).1 The estimated pointwise standard error of\n1If \u02c6C is the 5 \u00d7 5 covariance matrix of the \u02c6\u03b2j , and if \u2113T0\n= (1, x0, x20\n, x30\n, x40\n), then\nVar[ \u02c6 f(x0)] = \u2113T0\n\u02c6C\n\u21130.\n292 7. Moving Beyond Linearity\n\u02c6 f(x0) is the square-root of this variance. This computation is repeated\nat each reference point x0, and we plot the fitted curve, as well as twice\nthe standard error on either side of the fitted curve. We plot twice the\nstandard error because, for normally distributed error terms, this quantity\ncorresponds to an approximate 95% confidence interval.\nIt seems like the wages in Figure 7.1 are from two distinct populations:\nthere appears to be a high earners group earning more than $250,000 per\nannum, as well as a low earners group. We can treat wage as a binary\nvariable by splitting it into these two groups. Logistic regression can then\nbe used to predict this binary response, using polynomial functions of age\nas predictors. In other words, we fit the model\nPr(yi > 250|xi) =\nexp(\u03b20 + \u03b21xi + \u03b22x2i\n+ \u00b7 \u00b7 \u00b7 + \u03b2dxdi\n)\n1 + exp(\u03b20 + \u03b21xi + \u03b22x2i\n+ \u00b7 \u00b7 \u00b7 + \u03b2dxdi\n)\n. (7.3)\nThe result is shown in the right-hand panel of Figure 7.1. The gray marks\non the top and bottom of the panel indicate the ages of the high earners\nand the low earners. The solid blue curve indicates the fitted probabilities\nof being a high earner, as a function of age. The estimated 95% confidence\ninterval is shown as well. We", "doc_id": "10b301a8-7223-492f-887e-f759a8a1cc2c", "embedding": null, "doc_hash": "f1bb2784972bab316f4bae44aeddcd9d067f99067ff34048cb5d9823d09c5c33", "extra_info": null, "node_info": {"start": 685415, "end": 688598, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "cbd1f69f-5c10-4508-8501-24f8291c2b05", "3": "041234c7-1600-4b73-a5d4-e867956ebf0c"}}, "__type__": "1"}, "041234c7-1600-4b73-a5d4-e867956ebf0c": {"__data__": {"text": "a function of age. The estimated 95% confidence\ninterval is shown as well. We see that here the confidence intervals are fairly\nwide, especially on the right-hand side. Although the sample size for this\ndata set is substantial (n = 3,000), there are only 79 high earners, which\nresults in a high variance in the estimated coefficients and consequently\nwide confidence intervals.\n7.2 Step Functions\nUsing polynomial functions of the features as predictors in a linear model\nimposes a global structure on the non-linear function of X. We can instead\nuse step functions in order to avoid imposing such a global structure. Here\nstep\nwe break the range of X into bins, and fit a different constant in each bin. function\nThis amounts to converting a continuous variable into an ordered categorical\nvariable.\nordered\ncategorical\nvariable\nIn greater detail, we create cutpoints c1, c2, . . . , cK in the range of X,\nand then construct K + 1 new variables\nC0(X) = I(X <c1),\nC1(X) = I(c1 \u2264X <c2),\nC2(X) = I(c2 \u2264X <c3),\n...\nCK\u22121(X) = I(cK\u22121 \u2264X <cK),\nCK(X) = I(cK \u2264 X),\n(7.4)\nwhere I(\u00b7) is an indicator function that returns a 1 if the condition is true,\nindicator\nfunction\n7.2 Step Functions 293\n20 30 40 50 60 70 80\n50 100 150 200 250 300\nAge\nWage\nPiecewise Constant\n20 30 40 50 60 70 80\n0.00 0.05 0.10 0.15 0.20\nAge\n| | | | | | || | | | | | | || || |\n|\n| |\n|\n|\n| | | | | || | |\n| || | |\n|\n| |\n|\n| | | | | | | |\n| |\n| |\n|\n| |\n|\n| || || || | | | || || || |\n|\n|| |\n|\n|\n||| | | ||||| || || ||| |||| || || || ||| ||| || || || ||| ||| | || || |\n|\n|\n|| | | || || | | ||\n| ||||||| ||| | || | | ||| ||| ||| ||| |||||||| |\n|||||| ||| | || ||| || || |\n|| | |\n|\n|\n| | | || || |\n|\n|\n| || | || ||| || ||| |||| || |\n|| |\n|\n| |\n|\n| ||| | || ||| |\n|\n||| | |\n| |\n|| |\n|| || | | |\n|\n|\n| | || ||||| |||| || |||| || ||| | | | |\n|\n| || | ||| || | |\n|| | | || |\n|\n|\n| ||| | |||||| | | |||| | |||| ||| ||| ||| || ||| |\n| |\n| || |\n|\n|\n||| | ||||| ||| | |\n|\n| || |||||| ||||| ||| || ||\n|\n|||| | |\n|\n| |\n||| || ||| ||||||| ||||| ||| ||||| ||| ||||| |\n|\n||| | | |\n|\n|\n| |\n|| || | || || ||| |||| |||||| |||| |||| || || || |||| ||| | |\n|||||| |||||||||| | |\n|| || |||| ||| |\n| | | ||| |\n|| |||| || |||||| ||| |\n| || ||| | ||||| | || |\n| || |||| || || |||| |\n|||| ||||||||||| ||| ||||| |||| |\n|||| ||| | |||| ||| |\n| |\n|| |\n| || || | || || |\n| || || ||\n| ||||||| |||| |\n| |\n|\n| |||||| |||||||||||| |||||||| ||||||||||||| |||||||||||| ||| |\n|| |||| ||| || || || | || || |\n|\n|||| | | |\n|| Pr(Wage>250 | Age)\nFIGURE 7.2. The Wage data. Left: The solid curve displays the fitted value from\na least squares regression of wage (in thousands of dollars) using step", "doc_id": "041234c7-1600-4b73-a5d4-e867956ebf0c", "embedding": null, "doc_hash": "5302ad95d4043c9237100f1f57933aa0a8d3e3d74c9f602d45a2d711950f5dae", "extra_info": null, "node_info": {"start": 688565, "end": 691182, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "10b301a8-7223-492f-887e-f759a8a1cc2c", "3": "3380cc2e-3df7-42ac-833a-e6bf296728eb"}}, "__type__": "1"}, "3380cc2e-3df7-42ac-833a-e6bf296728eb": {"__data__": {"text": "least squares regression of wage (in thousands of dollars) using step functions\nof age. The dashed curves indicate an estimated 95% confidence interval. Right:\nWe model the binary event wage>250 using logistic regression, again using step\nfunctions of age. The fitted posterior probability of wage exceeding $250,000 is\nshown, along with an estimated 95% confidence interval.\nand returns a 0 otherwise. For example, I(cK \u2264 X) equals 1 if cK \u2264 X, and\nequals 0 otherwise. These are sometimes called dummy variables. Notice\nthat for any value of X, C0(X)+C1(X)+\u00b7 \u00b7 \u00b7+CK(X) = 1, since X must\nbe in exactly one of the K + 1 intervals. We then use least squares to fit a\nlinear model using C1(X), C2(X), . . . ,CK(X) as predictors2:\nyi = \u03b20 + \u03b21C1(xi) + \u03b22C2(xi) + \u00b7 \u00b7 \u00b7 + \u03b2KCK(xi) + \u03f5i. (7.5)\nFor a given value of X, at most one of C1, C2, . . . ,CK can be non-zero.\nNote that when X < c1\n, all of the predictors in (7.5) are zero, so \u03b20 can\nbe interpreted as the mean value of Y for X < c1\n. By comparison, (7.5)\npredicts a response of \u03b20+\u03b2j for cj \u2264X <cj +1, so \u03b2j represents the average\nincrease in the response for X in cj \u2264X <cj+1 relative to X <c1.\nAn example of fitting step functions to the Wage data from Figure 7.1 is\nshown in the left-hand panel of Figure 7.2.We also fit the logistic regression\nmodel\n2We exclude C0(X) as a predictor in (7.5) because it is redundant with the intercept.\nThis is similar to the fact that we need only two dummy variables to code a qualitative\nvariable with three levels, provided that the model will contain an intercept. The decision\nto exclude C0(X) instead of some other Ck(X) in (7.5) is arbitrary. Alternatively, we\ncould include C0(X), C1(X), . . . , CK(X), and exclude the intercept.\n294 7. Moving Beyond Linearity\nPr(yi > 250|xi) =\nexp(\u03b20 + \u03b21C1(xi) + \u00b7 \u00b7 \u00b7 + \u03b2KCK(xi))\n1 + exp(\u03b20 + \u03b21C1(xi) + \u00b7 \u00b7 \u00b7 + \u03b2KCK(xi))\n(7.6)\nin order to predict the probability that an individual is a high earner on the\nbasis of age. The right-hand panel of Figure 7.2 displays the fitted posterior\nprobabilities obtained using this approach.\nUnfortunately, unless there are natural breakpoints in the predictors,\npiecewise-constant functions can miss the action. For example, in the lefthand\npanel of Figure 7.2, the first bin clearly misses the increasing trend\nof wage with age. Nevertheless, step function approaches are very popular\nin biostatistics and epidemiology, among other disciplines. For example,\n5-year age groups are often used to define the bins.\n7.3 Basis Functions\nPolynomial and piecewise-constant regression models are in fact special\ncases of a basis function approach. The idea is to have at hand a fambasis\nily of functions or transformations that can be applied to a variable X: function\nb1(X), b2(X), . . . , bK(X). Instead of fitting a linear model in X, we fit the\nmodel\nyi = \u03b20 + \u03b21b1(xi) + \u03b22b2(xi) + \u03b23b3(xi) + \u00b7 \u00b7 \u00b7 + \u03b2KbK(xi) + \u03f5i. (7.7)\nNote that the basis functions b1(\u00b7), b2(\u00b7), . . . , bK(\u00b7) are fixed and known.\n(In other words, we choose the functions", "doc_id": "3380cc2e-3df7-42ac-833a-e6bf296728eb", "embedding": null, "doc_hash": "65da04da4b1c43351faa73241a92dd0e3421bf87e5c8ce6f7e0bd39489b1dbb6", "extra_info": null, "node_info": {"start": 691189, "end": 694203, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "041234c7-1600-4b73-a5d4-e867956ebf0c", "3": "02d76795-eaba-4ed1-8bf2-659f7aa6326a"}}, "__type__": "1"}, "02d76795-eaba-4ed1-8bf2-659f7aa6326a": {"__data__": {"text": "are fixed and known.\n(In other words, we choose the functions ahead of time.) For polynomial\nregression, the basis functions are bj(xi) = xj\ni , and for piecewise constant\nfunctions they are bj(xi) = I(cj \u2264 xi < cj+1). We can think of (7.7) as\na standard linear model with predictors b1(xi), b2(xi), . . . , bK(xi). Hence,\nwe can use least squares to estimate the unknown regression coefficients\nin (7.7). Importantly, this means that all of the inference tools for linear\nmodels that are discussed in Chapter 3, such as standard errors for the\ncoefficient estimates and F-statistics for the model\u2019s overall significance,\nare available in this setting.\nThus far we have considered the use of polynomial functions and piecewise\nconstant functions for our basis functions; however, many alternatives\nare possible. For instance, we can use wavelets or Fourier series to construct\nbasis functions. In the next section, we investigate a very common choice\nfor a basis function: regression splines.\nregression\nspline\n7.4 Regression Splines 295\n7.4 Regression Splines\nNow we discuss a flexible class of basis functions that extends upon the\npolynomial regression and piecewise constant regression approaches that\nwe have just seen.\n7.4.1 Piecewise Polynomials\nInstead of fitting a high-degree polynomial over the entire range of X, piecewise\npolynomial regression involves fitting separate low-degree polynomials\npiecewise\npolynomial\nregression\nover different regions of X. For example, a piecewise cubic polynomial works\nby fitting a cubic regression model of the form\nyi = \u03b20 + \u03b21xi + \u03b22x2i\n+ \u03b23x3i\n+ \u03f5i, (7.8)\nwhere the coefficients \u03b20, \u03b21, \u03b22, and \u03b23 differ in different parts of the range\nof X. The points where the coefficients change are called knots.\nknot\nFor example, a piecewise cubic with no knots is just a standard cubic\npolynomial, as in (7.1) with d = 3. A piecewise cubic polynomial with a\nsingle knot at a point c takes the form\nyi =\n=\n\u03b201 + \u03b211xi + \u03b221x2i\n+ \u03b231x3i\n+ \u03f5i if xi < c\n\u03b202 + \u03b212xi + \u03b222x2i\n+ \u03b232x3i\n+ \u03f5i if xi \u2265 c.\nIn other words, we fit two different polynomial functions to the data, one\non the subset of the observations with xi < c, and one on the subset of\nthe observations with xi \u2265 c. The first polynomial function has coefficients\n\u03b201,\u03b211,\u03b221, and \u03b231, and the second has coefficients \u03b202,\u03b212,\u03b222, and \u03b232.\nEach of these polynomial functions can be fit using least squares applied\nto simple functions of the original predictor.\nUsing more knots leads to a more flexible piecewise polynomial. In general,\nif we place K different knots throughout the range of X, then we\nwill end up fitting K + 1 different cubic polynomials. Note that we do not\nneed to use a cubic polynomial. For example, we can instead fit piecewise\nlinear functions. In fact, our piecewise constant functions of Section 7.2 are\npiecewise polynomials of degree 0!\nThe top left panel of Figure 7.3 shows a piecewise cubic polynomial fit to\na subset of the Wage data, with a single knot at age=50. We immediately see\na problem: the function is discontinuous and looks ridiculous! Since each\npolynomial has four parameters, we are using a total of eight degrees of\nfreedom in fitting this piecewise polynomial model.\ndegrees of\nfreedom\n7.4.2 Constraints and Splines\nThe top left panel of Figure 7.3 looks wrong because the fitted curve is just\ntoo", "doc_id": "02d76795-eaba-4ed1-8bf2-659f7aa6326a", "embedding": null, "doc_hash": "4fb828d6e17635d1ffd2a7958445b17c99e8d02faea47de46ef7d68b79c0409e", "extra_info": null, "node_info": {"start": 694211, "end": 697553, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "3380cc2e-3df7-42ac-833a-e6bf296728eb", "3": "e5c6a075-379f-4d9d-9775-8f84a43b7ea5"}}, "__type__": "1"}, "e5c6a075-379f-4d9d-9775-8f84a43b7ea5": {"__data__": {"text": "top left panel of Figure 7.3 looks wrong because the fitted curve is just\ntoo flexible. To remedy this problem, we can fit a piecewise polynomial\n296 7. Moving Beyond Linearity\n20 30 40 50 60 70\n50 100 150 200 250\nAge\nWage\nPiecewise Cubic\n20 30 40 50 60 70\n50 100 150 200 250\nAge\nWage\nContinuous Piecewise Cubic\n20 30 40 50 60 70\n50 100 150 200 250\nAge\nWage\nCubic Spline\n20 30 40 50 60 70\n50 100 150 200 250\nAge\nWage\nLinear Spline\nFIGURE 7.3. Various piecewise polynomials are fit to a subset of the Wage\ndata, with a knot at age=50. Top Left: The cubic polynomials are unconstrained.\nTop Right: The cubic polynomials are constrained to be continuous at age=50.\nBottom Left: The cubic polynomials are constrained to be continuous, and to\nhave continuous first and second derivatives. Bottom Right: A linear spline is\nshown, which is constrained to be continuous.\nunder the constraint that the fitted curve must be continuous. In other\nwords, there cannot be a jump when age=50. The top right plot in Figure 7.3\nshows the resulting fit. This looks better than the top left plot, but the Vshaped\njoin looks unnatural.\nIn the lower left plot, we have added two additional constraints: now both\nthe first and second derivatives of the piecewise polynomials are continuous\nderivative\nat age=50. In other words, we are requiring that the piecewise polynomial\nbe not only continuous when age=50, but also very smooth. Each constraint\nthat we impose on the piecewise cubic polynomials effectively frees up one\ndegree of freedom, by reducing the complexity of the resulting piecewise\npolynomial fit. So in the top left plot, we are using eight degrees of freedom,\nbut in the bottom left plot we imposed three constraints (continuity,\ncontinuity of the first derivative, and continuity of the second derivative)\n7.4 Regression Splines 297\nand so are left with five degrees of freedom. The curve in the bottom left\nplot is called a cubic spline.3 In general, a cubic spline with K knots uses\ncubic spline\na total of 4 + K degrees of freedom.\nIn Figure 7.3, the lower right plot is a linear spline, which is continuous\nlinear spline\nat age=50. The general definition of a degree-d spline is that it is a piecewise\ndegree-d polynomial, with continuity in derivatives up to degree d \u2212 1 at\neach knot. Therefore, a linear spline is obtained by fitting a line in each\nregion of the predictor space defined by the knots, requiring continuity at\neach knot.\nIn Figure 7.3, there is a single knot at age=50. Of course, we could add\nmore knots, and impose continuity at each.\n7.4.3 The Spline Basis Representation\nThe regression splines that we just saw in the previous section may have\nseemed somewhat complex: how can we fit a piecewise degree-d polynomial\nunder the constraint that it (and possibly its first d \u2212 1 derivatives) be\ncontinuous? It turns out that we can use the basis model (7.7) to represent\na regression spline. A cubic spline with K knots can be modeled as\nyi = \u03b20 + \u03b21b1(xi) + \u03b22b2(xi) + \u00b7 \u00b7 \u00b7 + \u03b2K+3bK+3(xi) + \u03f5i, (7.9)\nfor an appropriate choice of basis functions b1, b2, . . . , bK+3. The model\n(7.9) can then be fit using least squares.\nJust as there were several ways to represent polynomials, there are also\nmany equivalent ways to represent cubic splines using different choices of\nbasis functions in (7.9). The most direct way to represent a cubic spline\nusing (7.9) is to start off", "doc_id": "e5c6a075-379f-4d9d-9775-8f84a43b7ea5", "embedding": null, "doc_hash": "77a23ed423967d704d6ef04f25464d27a314b20b6a5e234f97935bb7e1749b86", "extra_info": null, "node_info": {"start": 697542, "end": 700932, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "02d76795-eaba-4ed1-8bf2-659f7aa6326a", "3": "74dadc59-b66e-4757-89f8-686ec1c3708d"}}, "__type__": "1"}, "74dadc59-b66e-4757-89f8-686ec1c3708d": {"__data__": {"text": "way to represent a cubic spline\nusing (7.9) is to start off with a basis for a cubic polynomial\u2014namely,\nx, x2, and x3\u2014and then add one truncated power basis function per knot.\ntruncated\nA truncated power basis function is defined as power basis\nh(x, \u03be) = (x \u2212 \u03be)3\n+ =\nK\n(x \u2212 \u03be)3 if x > \u03be\n0 otherwise,\n(7.10)\nwhere \u03be is the knot. One can show that adding a term of the form \u03b24h(x, \u03be)\nto the model (7.8) for a cubic polynomial will lead to a discontinuity in\nonly the third derivative at \u03be; the function will remain continuous, with\ncontinuous first and second derivatives, at each of the knots.\nIn other words, in order to fit a cubic spline to a data set with K knots, we\nperform least squares regression with an intercept and 3+K predictors, of\nthe form X,X2,X3, h(X, \u03be1), h(X, \u03be2), . . . ,h(X, \u03beK), where \u03be1, . . . , \u03beK are\nthe knots. This amounts to estimating a total of K + 4 regression coefficients;\nfor this reason, fitting a cubic spline with K knots uses K+4 degrees\nof freedom.\n3Cubic splines are popular because most human eyes cannot detect the discontinuity\nat the knots.\n298 7. Moving Beyond Linearity\n20 30 40 50 60 70\n50 100 150 200 250\nAge\nWage\nNatural Cubic Spline\nCubic Spline\nFIGURE 7.4. A cubic spline and a natural cubic spline, with three knots, fit to\na subset of the Wage data. The dashed lines denote the knot locations.\nUnfortunately, splines can have high variance at the outer range of the\npredictors\u2014that is, when X takes on either a very small or very large\nvalue. Figure 7.4 shows a fit to the Wage data with three knots. We see that\nthe confidence bands in the boundary region appear fairly wild. A natural\nspline is a regression spline with additional boundary constraints: the\nnatural\nfunction is required to be linear at the boundary (in the region where X is spline\nsmaller than the smallest knot, or larger than the largest knot). This additional\nconstraint means that natural splines generally produce more stable\nestimates at the boundaries. In Figure 7.4, a natural cubic spline is also\ndisplayed as a red line. Note that the corresponding confidence intervals\nare narrower.\n7.4.4 Choosing the Number and Locations of the Knots\nWhen we fit a spline, where should we place the knots? The regression\nspline is most flexible in regions that contain a lot of knots, because in\nthose regions the polynomial coefficients can change rapidly. Hence, one\noption is to place more knots in places where we feel the function might\nvary most rapidly, and to place fewer knots where it seems more stable.\nWhile this option can work well, in practice it is common to place knots in\na uniform fashion. One way to do this is to specify the desired degrees of\nfreedom, and then have the software automatically place the corresponding\nnumber of knots at uniform quantiles of the data.\nFigure 7.5 shows an example on the Wage data. As in Figure 7.4, we\nhave fit a natural cubic spline with three knots, except this time the knot\nlocations were chosen automatically as the 25th, 50th, and 75th percentiles\nof age. This was specified by requesting four degrees of freedom. The ar7.4\nRegression Splines 299\n20 30 40 50 60 70 80\n50 100 150 200 250 300\nAge\nWage\nNatural Cubic Spline\n20 30 40 50 60 70 80\n0.00 0.05 0.10 0.15", "doc_id": "74dadc59-b66e-4757-89f8-686ec1c3708d", "embedding": null, "doc_hash": "3fb81218b52d1a1c813d3657a7a5882b344ff28246cb610c5452ca2934410a44", "extra_info": null, "node_info": {"start": 700948, "end": 704187, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "e5c6a075-379f-4d9d-9775-8f84a43b7ea5", "3": "35b781d6-2922-439a-b102-34fff1377e4d"}}, "__type__": "1"}, "35b781d6-2922-439a-b102-34fff1377e4d": {"__data__": {"text": "30 40 50 60 70 80\n0.00 0.05 0.10 0.15 0.20\nAge\n|\n| | ||| | || | | | | |\n|\n|| || | |\n|| |\n|\n|\n| | | | | | | | || |\n| | |\n|\n|\n|\n| | | | | | | | | | | | |\n| | |\n|\n|\n|\n|\n|| || | | || |\n|\n|\n|\n|\n| ||||| || || || | ||||| ||| | ||| || ||| || |||| || | ||| || ||| ||| ||| | || || |\n|\n|\n|\n| | | || || || | | ||\n|\n|||||| | ||| ||| || || || || || || ||| |||| || ||||||| || |||| || ||| || || | |\n|\n| | | |\n|\n| ||| | | ||| ||| |\n|||| ||| ||| || |\n||| |\n|\n| | |\n| || | |||| || |\n||| |\n| |\n| || |\n||| || |\n|\n| || |\n| || | | |||| ||| || |\n| || | |\n| || || | | ||| | |\n|| | | | | | |\n|| ||||| |\n||| ||| | |\n|\n| |||| |||| |||| || ||||||||||| |||| ||| || ||| |\n|\n|\n| || ||||||| |||| || | |\n|\n||| ||\n||| |\n| |\n|\n| |\n|| || |||||||| || ||| |||| ||| |||| || |\n|| | |\n|\n| | |\n|| || || |||| |||| || | |||| || || || || ||| |\n||| |||||| ||||||||||||| ||||| |||| |\n|\n|| || |\n| || ||| || | |\n|\n| |||| |||| ||||||| ||| |\n| ||| | ||| || |||| || || | | || |\n|\n| || || | || ||| |||||| ||| |||| || |\n| | |\n|\n|\n|| |||| |||||||| |\n|\n|| |||| |||| ||| ||| ||| |\n|\n|| || | | | | | |\n|||| |||| | || |\n||| ||| ||||||| |||| |||||| |\n| |||||| |||| |||| |\n|| || | |\n| ||||| |\n|\n| ||| || Pr(Wage>250 | Age)\nFIGURE 7.5. A natural cubic spline function with four degrees of freedom is\nfit to the Wage data. Left: A spline is fit to wage (in thousands of dollars) as\na function of age. Right: Logistic regression is used to model the binary event\nwage>250 as a function of age. The fitted posterior probability of wage exceeding\n$250,000 is shown. The dashed lines denote the knot locations.\ngument by which four degrees of freedom leads to three interior knots is\nsomewhat technical.4\nHow many knots should we use, or equivalently how many degrees of\nfreedom should our spline contain? One option is to try out different numbers\nof knots and see which produces the best looking curve. A somewhat\nmore objective approach is to use cross-validation, as discussed in Chapters\n5 and 6. With this method, we remove a portion of the data (say 10 %),\nfit a spline with a certain number of knots to the remaining data, and then\nuse the spline to make predictions for the held-out portion. We repeat this\nprocess multiple times until each observation has been left out once, and\nthen compute the overall cross-validated RSS. This procedure can be repeated\nfor different numbers of knots K. Then the value of K giving the\nsmallest RSS is chosen.\nFigure 7.6 shows ten-fold cross-validated mean squared errors for splines\nwith various degrees of freedom fit to the Wage data. The left-hand panel\n4There are actually five knots, including the two boundary knots. A cubic spline with\nfive knots has nine degrees of freedom. But natural cubic splines have two additional\nnatural constraints at each boundary to enforce linearity, resulting in 9 \u2212 4 = 5 degrees\nof freedom. Since this includes a", "doc_id": "35b781d6-2922-439a-b102-34fff1377e4d", "embedding": null, "doc_hash": "163cebdb6115f019bf6849c1776e8bb029a2447d7438db78ced834ac7f62d831", "extra_info": null, "node_info": {"start": 704208, "end": 707039, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "74dadc59-b66e-4757-89f8-686ec1c3708d", "3": "a4fcc676-0028-458e-9b6f-7220d5062a60"}}, "__type__": "1"}, "a4fcc676-0028-458e-9b6f-7220d5062a60": {"__data__": {"text": "resulting in 9 \u2212 4 = 5 degrees\nof freedom. Since this includes a constant, which is absorbed in the intercept, we count\nit as four degrees of freedom.\n300 7. Moving Beyond Linearity\n2 4 6 8 10\n1600 1620 1640 1660 1680\nDegrees of Freedom of Natural Spline\nMean Squared Error\n2 4 6 8 10\n1600 1620 1640 1660 1680\nDegrees of Freedom of Cubic Spline\nMean Squared Error\nFIGURE 7.6. Ten-fold cross-validated mean squared errors for selecting the\ndegrees of freedom when fitting splines to the Wage data. The response is wage\nand the predictor age. Left: A natural cubic spline. Right: A cubic spline.\ncorresponds to a natural cubic spline and the right-hand panel to a cubic\nspline. The two methods produce almost identical results, with clear\nevidence that a one-degree fit (a linear regression) is not adequate. Both\ncurves flatten out quickly, and it seems that three degrees of freedom for\nthe natural spline and four degrees of freedom for the cubic spline are quite\nadequate.\nIn Section 7.7 we fit additive spline models simultaneously on several\nvariables at a time. This could potentially require the selection of degrees\nof freedom for each variable. In cases like this we typically adopt a more\npragmatic approach and set the degrees of freedom to a fixed number, say\nfour, for all terms.\n7.4.5 Comparison to Polynomial Regression\nFigure 7.7 compares a natural cubic spline with 15 degrees of freedom to a\ndegree-15 polynomial on the Wage data set. The extra flexibility in the polynomial\nproduces undesirable results at the boundaries, while the natural\ncubic spline still provides a reasonable fit to the data. Regression splines\noften give superior results to polynomial regression. This is because unlike\npolynomials, which must use a high degree (exponent in the highest monomial\nterm, e.g. X15) to produce flexible fits, splines introduce flexibility\nby increasing the number of knots but keeping the degree fixed. Generally,\nthis approach produces more stable estimates. Splines also allow us to place\nmore knots, and hence flexibility, over regions where the function f seems\nto be changing rapidly, and fewer knots where f appears more stable.\n7.5 Smoothing Splines 301\n20 30 40 50 60 70 80\n50 100 150 200 250 300\nAge\nWage\nNatural Cubic Spline\nPolynomial\nFIGURE 7.7. On the Wage data set, a natural cubic spline with 15 degrees\nof freedom is compared to a degree-15 polynomial. Polynomials can show wild\nbehavior, especially near the tails.\n7.5 Smoothing Splines\nIn the last section we discussed regression splines, which we create by specifying\na set of knots, producing a sequence of basis functions, and then\nusing least squares to estimate the spline coefficients. We now introduce a\nsomewhat different approach that also produces a spline.\n7.5.1 An Overview of Smoothing Splines\nIn fitting a smooth curve to a set of data, what we really want to do is\nfind some function, say g(x), that fits the observed data well: that is, we\nwant RSS =\n)n\ni=1(yi \u2212 g(xi))2 to be small. However, there is a problem\nwith this approach. If we don\u2019t put any constraints on g(xi), then we can\nalways make RSS zero simply by choosing g such that it interpolates all\nof the yi. Such a function would woefully overfit the data\u2014it would be far\ntoo flexible. What we really want is a function g that makes RSS small,\nbut that is also smooth.\nHow might we ensure that g is smooth? There are a number of ways to\ndo this. A natural approach is to find the function g that minimizes\n0n\ni=1\n(yi \u2212 g(xi))2 + \u03bb\nL\ng\u2032\u2032(t)2dt (7.11)\nwhere", "doc_id": "a4fcc676-0028-458e-9b6f-7220d5062a60", "embedding": null, "doc_hash": "16e932f70aa764f2998311d1d44cad0092f94a8b361a6b85500cd6eb3a20f0c0", "extra_info": null, "node_info": {"start": 707017, "end": 710538, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "35b781d6-2922-439a-b102-34fff1377e4d", "3": "cdf87a20-a1eb-41b6-b552-2f7ceba552d3"}}, "__type__": "1"}, "cdf87a20-a1eb-41b6-b552-2f7ceba552d3": {"__data__": {"text": "+ \u03bb\nL\ng\u2032\u2032(t)2dt (7.11)\nwhere \u03bb is a nonnegative tuning parameter. The function g that minimizes\n(7.11) is known as a smoothing spline.\nsmoothing\nWhat does (7.11) mean? Equation 7.11 takes the \u201cLoss+Penalty\u201d for- spline\nmulation that we encounter in the context of ridge regression and the lasso\n302 7. Moving Beyond Linearity\nin Chapter 6. The term\n)n\ni=1(yi \u2212 g(xi))2 is a loss function that encourloss\nfunction\nages g to fit the data well, and the term \u03bb\nM\ng\u2032\u2032(t)2dt is a penalty term\nthat penalizes the variability in g. The notation g\u2032\u2032(t) indicates the second\nderivative of the function g. The first derivative g\u2032(t) measures the slope\nof a function at t, and the second derivative corresponds to the amount by\nwhich the slope is changing. Hence, broadly speaking, the second derivative\nof a function is a measure of its roughness: it is large in absolute value if\ng(t) is very wiggly near t, and it is close to zero otherwise. (The second\nderivative of a straight line is zero; note that a line is perfectly smooth.)\nThe\nM\nnotation is an integral , which we can think of as a summation over\nthe range of t. In other words,\nM\ng\u2032\u2032(t)2dt is simply a measure of the total\nchange in the function g\u2032(t), over its entire range. If g is very smooth, then\ng\u2032(t) will be close to constant and\nM\ng\u2032\u2032(t)2dt will take on a small value.\nConversely, M if g is jumpy and variable then g\u2032(t) will vary significantly and\ng\u2032\u2032(t)2dt will take on a large value. Therefore, in (7.11), \u03bb\nM\ng\u2032\u2032(t)2dt encourages\ng to be smooth. The larger the value of \u03bb, the smoother g will be.\nWhen \u03bb = 0, then the penalty term in (7.11) has no effect, and so the\nfunction g will be very jumpy and will exactly interpolate the training\nobservations. When \u03bb \u2192 \u221e, g will be perfectly smooth\u2014it will just be\na straight line that passes as closely as possible to the training points.\nIn fact, in this case, g will be the linear least squares line, since the loss\nfunction in (7.11) amounts to minimizing the residual sum of squares. For\nan intermediate value of \u03bb, g will approximate the training observations\nbut will be somewhat smooth. We see that \u03bb controls the bias-variance\ntrade-off of the smoothing spline.\nThe function g(x) that minimizes (7.11) can be shown to have some special\nproperties: it is a piecewise cubic polynomial with knots at the unique\nvalues of x1, . . . ,xn, and continuous first and second derivatives at each\nknot. Furthermore, it is linear in the region outside of the extreme knots.\nIn other words, the function g(x) that minimizes (7.11) is a natural cubic\nspline with knots at x1, . . . ,xn! However, it is not the same natural cubic\nspline that one would get if one applied the basis function approach described\nin Section 7.4.3 with knots at x1, . . . ,xn\u2014rather, it is a shrunken\nversion of such a natural cubic spline, where the value of the tuning parameter\n\u03bb in (7.11) controls the level of shrinkage.\n7.5.2 Choosing the Smoothing Parameter \u03bb\nWe have seen that a smoothing spline is simply a natural cubic spline\nwith knots at every unique value of xi. It might seem that a smoothing\nspline will have far too many degrees of freedom, since a knot at each data\npoint allows a great deal of flexibility. But the tuning parameter \u03bb", "doc_id": "cdf87a20-a1eb-41b6-b552-2f7ceba552d3", "embedding": null, "doc_hash": "e91858bdc48242b642437b2c49e5cf52896ac8ebbd365f30633e231e52ba9810", "extra_info": null, "node_info": {"start": 710565, "end": 713795, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "a4fcc676-0028-458e-9b6f-7220d5062a60", "3": "be32b414-a3a0-4d5e-8dcb-55a866f60059"}}, "__type__": "1"}, "be32b414-a3a0-4d5e-8dcb-55a866f60059": {"__data__": {"text": "at each data\npoint allows a great deal of flexibility. But the tuning parameter \u03bb controls\nthe roughness of the smoothing spline, and hence the effective degrees of\nfreedom. It is possible to show that as \u03bb increases from 0 to \u221e, the effective\neffective\ndegrees of\nfreedom\ndegrees of freedom, which we write df\u03bb, decrease from n to 2.\n7.5 Smoothing Splines 303\nIn the context of smoothing splines, why do we discuss effective degrees\nof freedom instead of degrees of freedom? Usually degrees of freedom refer\nto the number of free parameters, such as the number of coefficients fit in a\npolynomial or cubic spline. Although a smoothing spline has n parameters\nand hence n nominal degrees of freedom, these n parameters are heavily\nconstrained or shrunk down. Hence df\u03bb is a measure of the flexibility of the\nsmoothing spline\u2014the higher it is, the more flexible (and the lower-bias but\nhigher-variance) the smoothing spline. The definition of effective degrees of\nfreedom is somewhat technical. We can write\n\u02c6g\u03bb = S\u03bby, (7.12)\nwhere \u02c6g\u03bb is the solution to (7.11) for a particular choice of \u03bb\u2014that is, it\nis an n-vector containing the fitted values of the smoothing spline at the\ntraining points x1, . . . ,xn. Equation 7.12 indicates that the vector of fitted\nvalues when applying a smoothing spline to the data can be written as a\nn \u00d7 n matrix S\u03bb (for which there is a formula) times the response vector\ny. Then the effective degrees of freedom is defined to be\ndf\u03bb =\n0n\ni=1\n{S\u03bb}ii, (7.13)\nthe sum of the diagonal elements of the matrix S\u03bb.\nIn fitting a smoothing spline, we do not need to select the number or\nlocation of the knots\u2014there will be a knot at each training observation,\nx1, . . . ,xn. Instead, we have another problem: we need to choose the value\nof \u03bb. It should come as no surprise that one possible solution to this problem\nis cross-validation. In other words, we can find the value of \u03bb that makes\nthe cross-validated RSS as small as possible. It turns out that the leaveone-\nout cross-validation error (LOOCV) can be computed very efficiently\nfor smoothing splines, with essentially the same cost as computing a single\nfit, using the following formula:\nRSScv(\u03bb) =\n0n\ni=1\n(yi \u2212 \u02c6g(\u2212i)\n\u03bb (xi))2 =\n0n\ni=1\n3\nyi \u2212 \u02c6g\u03bb(xi)\n1\u2212{S\u03bb}ii\n42\n.\nThe notation \u02c6g(\u2212i)\n\u03bb (xi) indicates the fitted value for this smoothing spline\nevaluated at xi, where the fit uses all of the training observations except\nfor the ith observation (xi, yi). In contrast, \u02c6g\u03bb(xi) indicates the smoothing\nspline function fit to all of the training observations and evaluated at xi.\nThis remarkable formula says that we can compute each of these leaveone-\nout fits using only \u02c6g\u03bb, the original fit to all of the data!5 We have\n5The exact formulas for computing \u02c6g(xi) and S\u03bb are very technical; however, efficient\nalgorithms are available for computing these quantities.\n304 7. Moving Beyond Linearity\n20 30 40 50 60 70 80\n0 50 100 200 300\nAge\nWage\nSmoothing Spline\n16 Degrees of Freedom\n6.8 Degrees of Freedom (LOOCV)\nFIGURE 7.8. Smoothing spline fits to the Wage data. The red curve results\nfrom specifying 16 effective degrees of freedom. For the blue curve, \u03bb was found\nautomatically by leave-one-out cross-validation, which resulted in 6.8 effective\ndegrees of freedom.\na very similar formula (5.2) on page 202 in Chapter 5 for least squares\nlinear", "doc_id": "be32b414-a3a0-4d5e-8dcb-55a866f60059", "embedding": null, "doc_hash": "5139e78eb6a7e2202655b62529187c6c1b9da6a883cf1fb94ac5e1ae1b935edf", "extra_info": null, "node_info": {"start": 713754, "end": 717084, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "cdf87a20-a1eb-41b6-b552-2f7ceba552d3", "3": "34e4a08c-4117-4939-8dfc-111168e33bf6"}}, "__type__": "1"}, "34e4a08c-4117-4939-8dfc-111168e33bf6": {"__data__": {"text": "formula (5.2) on page 202 in Chapter 5 for least squares\nlinear regression. Using (5.2), we can very quickly perform LOOCV for\nthe regression splines discussed earlier in this chapter, as well as for least\nsquares regression using arbitrary basis functions.\nFigure 7.8 shows the results from fitting a smoothing spline to the Wage\ndata. The red curve indicates the fit obtained from pre-specifying that we\nwould like a smoothing spline with 16 effective degrees of freedom. The blue\ncurve is the smoothing spline obtained when \u03bb is chosen using LOOCV; in\nthis case, the value of \u03bb chosen results in 6.8 effective degrees of freedom\n(computed using (7.13)). For this data, there is little discernible difference\nbetween the two smoothing splines, beyond the fact that the one with 16\ndegrees of freedom seems slightly wigglier. Since there is little difference\nbetween the two fits, the smoothing spline fit with 6.8 degrees of freedom\nis preferable, since in general simpler models are better unless the data\nprovides evidence in support of a more complex model.\n7.6 Local Regression\nLocal regression is a different approach for fitting flexible non-linear funclocal\ntions, which involves computing the fit at a target point x0 using only the regression\nnearby training observations. Figure 7.9 illustrates the idea on some simulated\ndata, with one target point near 0.4, and another near the boundary\n7.6 Local Regression 305\n0.0 0.2 0.4 0.6 0.8 1.0\n\u22121.0 \u22120.5 0.0 0.5 1.0 1.5\nO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nOOO\nO\nO\nO\nO\nO\nO\nO\nO\nOO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nOO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nOO\nO\nO\nO\nO\nO\nOO\nO\nO\nO\nO\nOO\nO\nO\nOO\nO\nO\nO\nOO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nOO\nO\nO\nO\nO\nOO\nO\nO\nO\nO\nO\nO\n0.0 0.2 0.4 0.6 0.8 1.0\n\u22121.0 \u22120.5 0.0 0.5 1.0 1.5\nO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nOOO\nO\nO\nO\nO\nO\nO\nO\nO\nOO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nOO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nOO\nO\nO\nO\nO\nO\nOO\nO\nO\nO\nO\nOO\nO\nO\nOO\nO\nO\nO\nOO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nO\nOO\nO\nO\nO\nO\nOO\nO\nO\nO\nO\nO\nO\nLocal Regression\nFIGURE 7.9. Local regression illustrated on some simulated data, where the\nblue curve represents f(x) from which the data were generated, and the light\norange curve corresponds to the local regression estimate \u02c6 f(x). The orange colored\npoints are local to the target point x0, represented by the orange vertical line.\nThe yellow bell-shape superimposed on the plot indicates weights assigned to each\npoint, decreasing to zero with distance from the target point. The fit \u02c6 f(x0) at x0 is\nobtained by fitting a weighted linear regression (orange line segment), and using\nthe fitted value at x0 (orange solid dot) as the estimate \u02c6 f(x0).\nat 0.05. In this figure the blue line represents the function f(x) from which\nthe data were generated, and the light orange line corresponds to the", "doc_id": "34e4a08c-4117-4939-8dfc-111168e33bf6", "embedding": null, "doc_hash": "80074abbdca188b6cb12eecf88b307dad4ed08bb10619b90d7d6ac1b31918de8", "extra_info": null, "node_info": {"start": 717100, "end": 719799, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "be32b414-a3a0-4d5e-8dcb-55a866f60059", "3": "435a0a43-2c54-4ce1-8da1-20f39b410155"}}, "__type__": "1"}, "435a0a43-2c54-4ce1-8da1-20f39b410155": {"__data__": {"text": "from which\nthe data were generated, and the light orange line corresponds to the local\nregression estimate \u02c6 f(x). Local regression is described in Algorithm 7.1.\nNote that in Step 3 of Algorithm 7.1, the weights Ki0 will differ for each\nvalue of x0. In other words, in order to obtain the local regression fit at a\nnew point, we need to fit a new weighted least squares regression model by\nminimizing (7.14) for a new set of weights. Local regression is sometimes\nreferred to as a memory-based procedure, because like nearest-neighbors, we\nneed all the training data each time we wish to compute a prediction. We\nwill avoid getting into the technical details of local regression here\u2014there\nare books written on the topic.\nIn order to perform local regression, there are a number of choices to\nbe made, such as how to define the weighting function K, and whether\nto fit a linear, constant, or quadratic regression in Step 3. (Equation 7.14\ncorresponds to a linear regression.) While all of these choices make some\ndifference, the most important choice is the span s, which is the proportion\nof points used to compute the local regression at x0, as defined in Step 1\nabove. The span plays a role like that of the tuning parameter \u03bb in smoothing\nsplines: it controls the flexibility of the non-linear fit. The smaller the\nvalue of s, the more local and wiggly will be our fit; alternatively, a very\nlarge value of s will lead to a global fit to the data using all of the training\nobservations. We can again use cross-validation to choose s, or we can\n306 7. Moving Beyond Linearity\nAlgorithm 7.1 Local Regression At X = x0\n1. Gather the fraction s = k/n of training points whose xi are closest\nto x0.\n2. Assign a weight Ki0 = K(xi, x0) to each point in this neighborhood,\nso that the point furthest from x0 has weight zero, and the closest\nhas the highest weight. All but these k nearest neighbors get weight\nzero.\n3. Fit a weighted least squares regression of the yi on the xi using the\naforementioned weights, by finding \u02c6 \u03b20 and \u02c6 \u03b21 that minimize\n0n\ni=1\nKi0(yi \u2212 \u03b20 \u2212 \u03b21xi)2. (7.14)\n4. The fitted value at x0 is given by \u02c6 f(x0) = \u02c6 \u03b20 + \u02c6 \u03b21x0.\nspecify it directly. Figure 7.10 displays local linear regression fits on the\nWage data, using two values of s: 0.7 and 0.2. As expected, the fit obtained\nusing s = 0.7 is smoother than that obtained using s = 0.2.\nThe idea of local regression can be generalized in many different ways.\nIn a setting with multiple features X1,X2, . . . ,Xp, one very useful generalization\ninvolves fitting a multiple linear regression model that is global in\nsome variables, but local in another, such as time. Such varying coefficient\nmodels are a useful way of adapting a model to the most recently gathered\nvarying\ncoefficient\nmodel\ndata. Local regression also generalizes very naturally when we want to fit\nmodels that are local in a pair of variables X1 and X2, rather than one.\nWe can simply use two-dimensional neighborhoods, and fit bivariate linear\nregression models using the observations that are near each target point\nin two-dimensional space. Theoretically the same approach can be implemented\nin higher dimensions, using linear regressions fit to p-dimensional\nneighborhoods. However, local regression can perform poorly if p is much\nlarger than about 3 or 4 because there will generally be very few training\nobservations close to x0. Nearest-neighbors regression, discussed in Chapter\n3, suffers from a similar problem in high dimensions.\n7.7 Generalized Additive Models\nIn Sections 7.1\u20137.6, we present a number of approaches for flexibly predicting\na", "doc_id": "435a0a43-2c54-4ce1-8da1-20f39b410155", "embedding": null, "doc_hash": "2f29b5a22e2436332892ff830cd196d9dca20669ebdc6ce722d6258ed756a59e", "extra_info": null, "node_info": {"start": 719785, "end": 723383, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "34e4a08c-4117-4939-8dfc-111168e33bf6", "3": "38ccf581-9aa9-41f6-b4bf-703151dcd81b"}}, "__type__": "1"}, "38ccf581-9aa9-41f6-b4bf-703151dcd81b": {"__data__": {"text": "we present a number of approaches for flexibly predicting\na response Y on the basis of a single predictor X. These approaches can\nbe seen as extensions of simple linear regression. Here we explore the prob7.7\nGeneralized Additive Models 307\n20 30 40 50 60 70 80\n0 50 100 200 300\nAge\nWage\nLocal Linear Regression\nSpan is 0.2 (16.4 Degrees of Freedom)\nSpan is 0.7 (5.3 Degrees of Freedom)\nFIGURE 7.10. Local linear fits to the Wage data. The span specifies the fraction\nof the data used to compute the fit at each target point.\nlem of flexibly predicting Y on the basis of several predictors, X1, . . . ,Xp.\nThis amounts to an extension of multiple linear regression.\nGeneralized additive models (GAMs) provide a general framework for\ngeneralized\nadditive\nmodel\nextending a standard linear model by allowing non-linear functions of each\nof the variables, while maintaining additivity. Just like linear models, GAMs\ncan be applied with both quantitative and qualitative responses. We first additivity\nexamine GAMs for a quantitative response in Section 7.7.1, and then for a\nqualitative response in Section 7.7.2.\n7.7.1 GAMs for Regression Problems\nA natural way to extend the multiple linear regression model\nyi = \u03b20 + \u03b21xi1 + \u03b22xi2 + \u00b7 \u00b7 \u00b7 + \u03b2pxip + \u03f5i\nin order to allow for non-linear relationships between each feature and the\nresponse is to replace each linear component \u03b2jxij with a (smooth) nonlinear\nfunction fj(xij ). We would then write the model as\nyi = \u03b20 +\n0p\nj=1\nfj(xij) + \u03f5i\n= \u03b20 + f1(xi1) + f2(xi2) + \u00b7 \u00b7 \u00b7 + fp(xip) + \u03f5i. (7.15)\nThis is an example of a GAM. It is called an additive model because we\ncalculate a separate fj for each Xj , and then add together all of their\ncontributions.\n308 7. Moving Beyond Linearity\n2003 2005 2007 2009\n\u221230 \u221220 \u221210 0 10 20 30\n20 30 40 50 60 70 80\n\u221250 \u221240 \u221230 \u221220 \u221210 0 10 20\n\u221230 \u221220 \u221210 0 10 20 30 40\n<HS HS <Coll Coll >Coll\nf1(year)\nf2(age)\nf3(education)\nyear age\neducation\nFIGURE 7.11. For the Wage data, plots of the relationship between each feature\nand the response, wage, in the fitted model (7.16). Each plot displays the fitted\nfunction and pointwise standard errors. The first two functions are natural splines\nin year and age, with four and five degrees of freedom, respectively. The third\nfunction is a step function, fit to the qualitative variable education.\nIn Sections 7.1\u20137.6, we discuss many methods for fitting functions to a\nsingle variable. The beauty of GAMs is that we can use these methods\nas building blocks for fitting an additive model. In fact, for most of the\nmethods that we have seen so far in this chapter, this can be done fairly\ntrivially. Take, for example, natural splines, and consider the task of fitting\nthe model\nwage = \u03b20 + f1(year) + f2(age) + f3(education) + \u03f5 (7.16)\non the Wage data. Here year and age are quantitative variables, and education\nis a qualitative variable with five levels: <HS, HS, <Coll, Coll, >Coll, referring\nto the amount of high school or college education that an individual\nhas completed. We fit the first two functions using natural splines. We fit\nthe third function using a separate constant for each level, via the usual\ndummy variable approach of Section 3.3.1.\nFigure 7.11 shows the results of fitting the model (7.16) using least\nsquares. This is easy to do, since as discussed in Section 7.4, natural splines\ncan be constructed using an appropriately chosen set of basis", "doc_id": "38ccf581-9aa9-41f6-b4bf-703151dcd81b", "embedding": null, "doc_hash": "d8d96c0248827e8111b1fe88f4869a9d3a048d5eb2a9c26bae2048167e95962e", "extra_info": null, "node_info": {"start": 723401, "end": 726795, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "435a0a43-2c54-4ce1-8da1-20f39b410155", "3": "99233656-309f-4cd2-bafe-c7ef630e8b40"}}, "__type__": "1"}, "99233656-309f-4cd2-bafe-c7ef630e8b40": {"__data__": {"text": "natural splines\ncan be constructed using an appropriately chosen set of basis functions.\nHence the entire model is just a big regression onto spline basis variables\nand dummy variables, all packed into one big regression matrix.\nFigure 7.11 can be easily interpreted. The left-hand panel indicates that\nholding age and education fixed, wage tends to increase slightly with year;\nthis may be due to inflation. The center panel indicates that holding education\nand year fixed, wage tends to be highest for intermediate values of age, and\nlowest for the very young and very old. The right-hand panel indicates\nthat holding year and age fixed, wage tends to increase with education: the\nmore educated a person is, the higher their salary, on average. All of these\nfindings are intuitive.\n7.7 Generalized Additive Models 309\n2003 2005 2007 2009\n\u221230 \u221220 \u221210 0 10 20 30\n20 30 40 50 60 70 80\n\u221250 \u221240 \u221230 \u221220 \u221210 0 10 20\n\u221230 \u221220 \u221210 0 10 20 30 40\n<HS HS <Coll Coll >Coll\nf1(year)\nf2(age)\nf3(education)\nyear age\neducation\nFIGURE 7.12. Details are as in Figure 7.11, but now f1 and f2 are smoothing\nsplines with four and five degrees of freedom, respectively.\nFigure 7.12 shows a similar triple of plots, but this time f1 and f2 are\nsmoothing splines with four and five degrees of freedom, respectively. Fitting\na GAM with a smoothing spline is not quite as simple as fitting a GAM\nwith a natural spline, since in the case of smoothing splines, least squares\ncannot be used. However, standard software such as the gam() function in R\ncan be used to fit GAMs using smoothing splines, via an approach known\nas backfitting. This method fits a model involving multiple predictors by\nbackfitting\nrepeatedly updating the fit for each predictor in turn, holding the others\nfixed. The beauty of this approach is that each time we update a function,\nwe simply apply the fitting method for that variable to a partial residual.6\nThe fitted functions in Figures 7.11 and 7.12 look rather similar. In most\nsituations, the differences in the GAMs obtained using smoothing splines\nversus natural splines are small.\nWe do not have to use splines as the building blocks for GAMs: we can\njust as well use local regression, polynomial regression, or any combination\nof the approaches seen earlier in this chapter in order to create a GAM.\nGAMs are investigated in further detail in the lab at the end of this chapter.\nPros and Cons of GAMs\nBefore we move on, let us summarize the advantages and limitations of a\nGAM.\n\u25b2 GAMs allow us to fit a non-linear fj to each Xj , so that we can\nautomatically model non-linear relationships that standard linear regression\nwill miss. This means that we do not need to manually try\nout many different transformations on each variable individually.\n6A partial residual for X3, for example, has the form ri = yi \u2212 f1(xi1) \u2212 f2(xi2).\nIf we know f1 and f2, then we can fit f3 by treating this residual as a response in a\nnon-linear regression on X3.\n310 7. Moving Beyond Linearity\n\u25b2 The non-linear fits can potentially make more accurate predictions\nfor the response Y .\n\u25b2 Because the model is additive, we can examine the effect of each Xj\non Y individually while holding all of the other variables fixed.\n\u25b2 The smoothness of the function fj for the variable Xj can be summarized\nvia degrees of freedom.\n\u25c6 The main limitation of GAMs is that the model is restricted to be\nadditive. With many variables, important interactions can be missed.\nHowever, as with linear regression, we can manually add interaction\nterms to the GAM model by including additional predictors of the\nform Xj \u00d7 Xk. In addition we can add low-dimensional interaction\nfunctions of the form", "doc_id": "99233656-309f-4cd2-bafe-c7ef630e8b40", "embedding": null, "doc_hash": "3f2a90e453a5c1ed9aebc47270d3d54d4866a2b4883aea10c2214525d0aeb7a2", "extra_info": null, "node_info": {"start": 726780, "end": 730444, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "38ccf581-9aa9-41f6-b4bf-703151dcd81b", "3": "2607745b-1b5f-45d2-b723-325b9926861c"}}, "__type__": "1"}, "2607745b-1b5f-45d2-b723-325b9926861c": {"__data__": {"text": "Xk. In addition we can add low-dimensional interaction\nfunctions of the form fjk(Xj,Xk) into the model; such terms can\nbe fit using two-dimensional smoothers such as local regression, or\ntwo-dimensional splines (not covered here).\nFor fully general models, we have to look for even more flexible approaches\nsuch as random forests and boosting, described in Chapter 8. GAMs provide\na useful compromise between linear and fully nonparametric models.\n7.7.2 GAMs for Classification Problems\nGAMs can also be used in situations where Y is qualitative. For simplicity,\nhere we will assume Y takes on values zero or one, and let p(X) = Pr(Y =\n1|X) be the conditional probability (given the predictors) that the response\nequals one. Recall the logistic regression model (4.6):\nlog\n*\np(X)\n1 \u2212 p(X)\n+\n= \u03b20 + \u03b21X1 + \u03b22X2 + \u00b7 \u00b7 \u00b7 + \u03b2pXp. (7.17)\nThe left-hand side is the log of the odds of P(Y = 1|X) versus P(Y = 0|X),\nwhich (7.17) represents as a linear function of the predictors. A natural way\nto extend (7.17) to allow for non-linear relationships is to use the model\nlog\n*\np(X)\n1 \u2212 p(X)\n+\n= \u03b20 + f1(X1) + f2(X2) + \u00b7 \u00b7 \u00b7 + fp(Xp). (7.18)\nEquation 7.18 is a logistic regression GAM. It has all the same pros and\ncons as discussed in the previous section for quantitative responses.\nWe fit a GAM to the Wage data in order to predict the probability that\nan individual\u2019s income exceeds $250,000 per year. The GAM that we fit\ntakes the form\nlog\n*\np(X)\n1 \u2212 p(X)\n+\n= \u03b20 + \u03b21 \u00d7 year + f2(age) + f3(education), (7.19)\nwhere\np(X) = Pr(wage > 250|year, age, education).\n7.8 Lab: Non-linear Modeling 311\n2003 2005 2007 2009\n\u22124 \u22122 0 2 4\n20 30 40 50 60 70 80\n\u22128 \u22126 \u22124 \u22122 0 2\n\u2212400 \u2212200 0 200 400\n<HS HS <Coll Coll >Coll\nf1(year)\nf2(age)\nf3(education)\nyear age\neducation\nFIGURE 7.13. For the Wage data, the logistic regression GAM given in (7.19)\nis fit to the binary response I(wage>250). Each plot displays the fitted function\nand pointwise standard errors. The first function is linear in year, the second\nfunction a smoothing spline with five degrees of freedom in age, and the third a\nstep function for education. There are very wide standard errors for the first\nlevel <HS of education.\nOnce again f2 is fit using a smoothing spline with five degrees of freedom,\nand f3 is fit as a step function, by creating dummy variables for each of the\nlevels of education. The resulting fit is shown in Figure 7.13. The last panel\nlooks suspicious, with very wide confidence intervals for level <HS. In fact,\nno response values equal one for that category: no individuals with less than\na high school education make more than $250,000 per year. Hence we refit\nthe GAM, excluding the individuals with less than a high school education.\nThe resulting model is shown in Figure 7.14. As in Figures 7.11 and 7.12,\nall three panels have similar vertical scales. This allows us to visually assess\nthe relative contributions of each of the variables. We observe that age and\neducation have a much larger effect than year on the probability of being\na high earner.\n7.8 Lab: Non-linear Modeling\nIn this lab, we re-analyze the Wage data considered in the examples throughout\nthis chapter, in order to illustrate the fact that many of the complex\nnon-linear fitting procedures discussed can be", "doc_id": "2607745b-1b5f-45d2-b723-325b9926861c", "embedding": null, "doc_hash": "d8eb5ba1df563b99bb85c6b7c0a48dbd3394389499510fb40c620e51170f1185", "extra_info": null, "node_info": {"start": 730446, "end": 733700, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "99233656-309f-4cd2-bafe-c7ef630e8b40", "3": "a1865110-e92f-4490-a66c-41a5986d2898"}}, "__type__": "1"}, "a1865110-e92f-4490-a66c-41a5986d2898": {"__data__": {"text": "the fact that many of the complex\nnon-linear fitting procedures discussed can be easily implemented in R. We\nbegin by loading the ISLR2 library, which contains the data.\n> library(ISLR2)\n> attach(Wage)\n312 7. Moving Beyond Linearity\n2003 2005 2007 2009\n\u22124 \u22122 0 2 4\n20 30 40 50 60 70 80\n\u22128 \u22126 \u22124 \u22122 0 2\n\u22124 \u22122 0 2 4\nHS <Coll Coll >Coll\nf1(year)\nf2(age)\nf3(education)\nyear age\neducation\nFIGURE 7.14. The same model is fit as in Figure 7.13, this time excluding the\nobservations for which education is <HS. Now we see that increased education\ntends to be associated with higher salaries.\n7.8.1 Polynomial Regression and Step Functions\nWe now examine how Figure 7.1 was produced. We first fit the model using\nthe following command:\n> fit <- lm(wage \u223c poly(age , 4), data = Wage)\n> coef(summary(fit))\nEstimate Std. Error t value Pr(>|t|)\n(Intercept) 111.704 0.729 153.28 <2e-16\npoly(age , 4)1 447.068 39.915 11.20 <2e-16\npoly(age , 4)2 -478.316 39.915 -11.98 <2e-16\npoly(age , 4)3 125.522 39.915 3.14 0.0017\npoly(age , 4)4 -77.911 39.915 -1.95 0.0510\nThis syntax fits a linear model, using the lm() function, in order to predict\nwage using a fourth-degree polynomial in age: poly(age, 4). The poly()\ncommand allows us to avoid having to write out a long formula with powers\nof age. The function returns a matrix whose columns are a basis of\northogonal polynomials, which essentially means that each column is a linorthogonal\near combination of the variables age, age^2, age^3 and age^4. polynomial\nHowever, we can also use poly() to obtain age, age^2, age^3 and age^4\ndirectly, if we prefer. We can do this by using the raw = TRUE argument to\nthe poly() function. Later we see that this does not affect the model in a\nmeaningful way\u2014though the choice of basis clearly affects the coefficient\nestimates, it does not affect the fitted values obtained.\n> fit2 <- lm(wage \u223c poly(age , 4, raw = T), data = Wage)\n> coef(summary(fit2))\nEstimate Std. Error t value Pr(>|t|)\n(Intercept) -1.84e+02 6.00e+01 -3.07 0.002180\npoly(age , 4, raw = T)1 2.12e+01 5.89e+00 3.61 0.000312\npoly(age , 4, raw = T)2 -5.64e-01 2.06e-01 -2.74 0.006261\npoly(age , 4, raw = T)3 6.81e-03 3.07e-03 2.22 0.026398\npoly(age , 4, raw = T)4 -3.20e-05 1.64e-05 -1.95 0.051039\n7.8 Lab: Non-linear Modeling 313\nThere are several other equivalent ways of fitting this model, which showcase\nthe flexibility of the formula language in R. For example\n> fit2a <- lm(wage \u223c age + I(age^2) + I(age^3) + I(age^4),\ndata = Wage)\n> coef(fit2a)\n(Intercept) age I(age^2) I(age^3) I(age^4)\n-1.84e+02 2.12e+01 -5.64e-01 6.81e-03 -3.20e-05\nThis simply creates the polynomial basis functions on the fly, taking care\nto protect terms like age^2 via the wrapper function I() (the ^ symbol has wrapper\na special meaning in formulas).\n>", "doc_id": "a1865110-e92f-4490-a66c-41a5986d2898", "embedding": null, "doc_hash": "64dc447296dd3a8074cf813b52796a19a33ddf6bc4b93afdaa9ad3011603b5af", "extra_info": null, "node_info": {"start": 733698, "end": 736469, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "2607745b-1b5f-45d2-b723-325b9926861c", "3": "1fca6e8d-3298-4c5a-b651-df9b9fcae83f"}}, "__type__": "1"}, "1fca6e8d-3298-4c5a-b651-df9b9fcae83f": {"__data__": {"text": "function I() (the ^ symbol has wrapper\na special meaning in formulas).\n> fit2b <- lm(wage \u223c cbind(age , age^2, age^3, age^4),\ndata = Wage)\nThis does the same more compactly, using the cbind() function for building\na matrix from a collection of vectors; any function call such as cbind() inside\na formula also serves as a wrapper.\nWe now create a grid of values for age at which we want predictions, and\nthen call the generic predict() function, specifying that we want standard\nerrors as well.\n> agelims <- range(age)\n> age.grid <- seq(from = agelims[1], to = agelims [2])\n> preds <- predict(fit , newdata = list(age = age.grid),\nse = TRUE)\n> se.bands <- cbind(preds$fit + 2 * preds$se.fit ,\npreds$fit - 2 * preds$se.fit)\nFinally, we plot the data and add the fit from the degree-4 polynomial.\n> par(mfrow = c(1, 2), mar = c(4.5 , 4.5, 1, 1),\noma = c(0, 0, 4, 0))\n> plot(age , wage , xlim = agelims , cex = .5, col = \"darkgrey\")\n> title(\"Degree -4 Polynomial\", outer = T)\n> lines(age.grid, preds$fit , lwd = 2, col = \"blue\")\n> matlines(age.grid , se.bands, lwd = 1, col = \"blue\", lty = 3)\nHere the mar and oma arguments to par() allow us to control the margins\nof the plot, and the title() function creates a figure title that spans both\ntitle()\nsubplots.\nWe mentioned earlier that whether or not an orthogonal set of basis functions\nis produced in the poly() function will not affect the model obtained\nin a meaningful way. What do we mean by this? The fitted values obtained\nin either case are identical:\n> preds2 <- predict(fit2 , newdata = list(age = age.grid),\nse = TRUE)\n> max(abs(preds$fit - preds2$fit))\n[1] 7.82e-11\nIn performing a polynomial regression we must decide on the degree of\nthe polynomial to use. One way to do this is by using hypothesis tests. We\n314 7. Moving Beyond Linearity\nnow fit models ranging from linear to a degree-5 polynomial and seek to\ndetermine the simplest model which is sufficient to explain the relationship\nbetween wage and age. We use the anova() function, which performs an\nanova()\nanalysis of variance (ANOVA, using an F-test) in order to test the null\nanalysis of\nhypothesis that a model M1 is sufficient to explain the data against the variance\nalternative hypothesis that a more complex modelM2 is required. In order\nto use the anova() function, M1 and M2 must be nested models: the\npredictors in M1 must be a subset of the predictors in M2. In this case,\nwe fit five different models and sequentially compare the simpler model to\nthe more complex model.\n> fit.1 <- lm(wage \u223c age , data = Wage)\n> fit.2 <- lm(wage \u223c poly(age , 2), data = Wage)\n> fit.3 <- lm(wage \u223c poly(age , 3), data = Wage)\n> fit.4 <- lm(wage \u223c poly(age , 4), data = Wage)\n> fit.5 <- lm(wage \u223c poly(age , 5), data = Wage)\n> anova(fit.1, fit.2, fit.3, fit.4, fit.5)\nAnalysis of Variance Table\nModel 1: wage \u223c age\nModel 2: wage \u223c poly(age , 2)\nModel 3: wage \u223c poly(age , 3)\nModel 4: wage \u223c poly(age , 4)\nModel 5: wage \u223c poly(age , 5)\nRes.Df RSS Df Sum of Sq F", "doc_id": "1fca6e8d-3298-4c5a-b651-df9b9fcae83f", "embedding": null, "doc_hash": "005e892081f28d6f1292c810be3ae38fda3a608111a234e4aba87e3458b12720", "extra_info": null, "node_info": {"start": 736477, "end": 739452, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "a1865110-e92f-4490-a66c-41a5986d2898", "3": "e5254c1f-3c1c-4538-84b4-76ca69262ea5"}}, "__type__": "1"}, "e5254c1f-3c1c-4538-84b4-76ca69262ea5": {"__data__": {"text": "poly(age , 5)\nRes.Df RSS Df Sum of Sq F Pr(>F)\n1 2998 5022216\n2 2997 4793430 1 228786 143.59 <2e-16 ***\n3 2996 4777674 1 15756 9.89 0.0017 **\n4 2995 4771604 1 6070 3.81 0.0510 .\n5 2994 4770322 1 1283 0.80 0.3697\n---\nSignif. codes: 0 \u2018***\u2019 0.001 \u2018**\u2019 0.01 \u2018*\u2019 0.05 \u2018.\u2019 0.1 \u2018 \u2019 1\nThe p-value comparing the linear Model 1 to the quadratic Model 2 is\nessentially zero (<10\u221215), indicating that a linear fit is not sufficient. Similarly\nthe p-value comparing the quadratic Model 2 to the cubic Model 3\nis very low (0.0017), so the quadratic fit is also insufficient. The p-value\ncomparing the cubic and degree-4 polynomials, Model 3 and Model 4, is approximately\n5% while the degree-5 polynomial Model 5 seems unnecessary\nbecause its p-value is 0.37. Hence, either a cubic or a quartic polynomial\nappear to provide a reasonable fit to the data, but lower- or higher-order\nmodels are not justified.\nIn this case, instead of using the anova() function, we could have obtained\nthese p-values more succinctly by exploiting the fact that poly() creates\northogonal polynomials.\n> coef(summary(fit.5))\nEstimate Std. Error t value Pr(>|t|)\n(Intercept) 111.70 0.7288 153.2780 0.000e+00\npoly(age , 5)1 447.07 39.9161 11.2002 1.491e-28\n7.8 Lab: Non-linear Modeling 315\npoly(age , 5)2 -478.32 39.9161 -11.9830 2.368e-32\npoly(age , 5)3 125.52 39.9161 3.1446 1.679e-03\npoly(age , 5)4 -77.91 39.9161 -1.9519 5.105e-02\npoly(age , 5)5 -35.81 39.9161 -0.8972 3.697e-01\nNotice that the p-values are the same, and in fact the square of the\nt-statistics are equal to the F-statistics from the anova() function; for\nexample:\n> (-11.983)^2\n[1] 143.6\nHowever, the ANOVA method works whether or not we used orthogonal\npolynomials; it also works when we have other terms in the model as well.\nFor example, we can use anova() to compare these three models:\n> fit.1 <- lm(wage \u223c education + age , data = Wage)\n> fit.2 <- lm(wage \u223c education + poly(age , 2), data = Wage)\n> fit.3 <- lm(wage \u223c education + poly(age , 3), data = Wage)\n> anova(fit.1, fit.2, fit.3)\nAs an alternative to using hypothesis tests and ANOVA, we could choose\nthe polynomial degree using cross-validation, as discussed in Chapter 5.\nNext we consider the task of predicting whether an individual earns more\nthan $250,000 per year. We proceed much as before, except that first we\ncreate the appropriate response vector, and then apply the glm() function\nusing family = \"binomial\" in order to fit a polynomial logistic regression\nmodel.\n> fit <- glm(I(wage > 250) \u223c poly(age , 4), data = Wage ,\nfamily = binomial)\nNote that we again use the wrapper I() to create this binary response\nvariable on the fly. The expression wage > 250 evaluates to a logical variable\ncontaining TRUEs and FALSEs, which glm() coerces to binary by setting the\nTRUEs to 1 and the FALSEs to 0.\nOnce again, we make predictions using the predict() function.\n> preds <- predict(fit , newdata = list(age = age.grid), se = T)\nHowever,", "doc_id": "e5254c1f-3c1c-4538-84b4-76ca69262ea5", "embedding": null, "doc_hash": "880cef35f5bd65829f1a05976ed6cefaed95c36590be97345969733ce9e5e611", "extra_info": null, "node_info": {"start": 739484, "end": 742424, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "1fca6e8d-3298-4c5a-b651-df9b9fcae83f", "3": "b3483f2a-ff89-438e-997c-40309420a7b2"}}, "__type__": "1"}, "b3483f2a-ff89-438e-997c-40309420a7b2": {"__data__": {"text": ", newdata = list(age = age.grid), se = T)\nHowever, calculating the confidence intervals is slightly more involved than\nin the linear regression case. The default prediction type for a glm() model\nis type = \"link\", which is what we use here. This means we get predictions\nfor the logit, or log-odds: that is, we have fit a model of the form\nlog\n*\nPr(Y = 1|X)\n1 \u2212 Pr(Y = 1|X)\n+\n= X\u03b2,\nand the predictions given are of the form X \u02c6 \u03b2. The standard errors given\nare also for X \u02c6 \u03b2. In order to obtain confidence intervals for Pr(Y = 1|X),\nwe use the transformation\nPr(Y = 1|X) =\nexp(X\u03b2)\n1 + exp(X\u03b2)\n.\n316 7. Moving Beyond Linearity\n> pfit <- exp(preds$fit) / (1 + exp(preds$fit))\n> se.bands.logit <- cbind(preds$fit + 2 * preds$se.fit ,\npreds$fit - 2 * preds$se.fit)\n> se.bands <- exp(se.bands.logit) / (1 + exp(se.bands.logit))\nNote that we could have directly computed the probabilities by selecting\nthe type = \"response\" option in the predict() function.\n> preds <- predict(fit , newdata = list(age = age.grid),\ntype = \"response\", se = T)\nHowever, the corresponding confidence intervals would not have been sensible\nbecause we would end up with negative probabilities!\nFinally, the right-hand plot from Figure 7.1 was made as follows:\n> plot(age , I(wage > 250), xlim = agelims , type = \"n\",\nylim = c(0, .2))\n> points(jitter(age), I(( wage > 250) / 5), cex = .5, pch = \"|\",\ncol = \"darkgrey\")\n> lines(age.grid, pfit , lwd = 2, col = \"blue\")\n> matlines(age.grid , se.bands , lwd = 1, col = \"blue\", lty = 3)\nWe have drawn the age values corresponding to the observations with wage\nvalues above 250 as gray marks on the top of the plot, and those with wage\nvalues below 250 are shown as gray marks on the bottom of the plot. We\nused the jitter() function to jitter the age values a bit so that observations\njitter()\nwith the same age value do not cover each other up. This is often called a\nrug plot.\nrug plot\nIn order to fit a step function, as discussed in Section 7.2, we use the\ncut() function.\ncut()\n> table(cut(age , 4))\n(17.9 ,33.5] (33.5 ,49] (49 ,64.5] (64.5 ,80.1]\n750 1399 779 72\n> fit <- lm(wage \u223c cut(age , 4), data = Wage)\n> coef(summary(fit))\nEstimate Std. Error t value Pr(>|t|)\n(Intercept) 94.16 1.48 63.79 0.00e+00\ncut(age , 4) (33.5 ,49] 24.05 1.83 13.15 1.98e-38\ncut(age , 4) (49 ,64.5] 23.66 2.07 11.44 1.04e-29\ncut(age , 4) (64.5 ,80.1] 7.64 4.99 1.53 1.26e-01\nHere cut() automatically picked the cutpoints at 33.5, 49, and 64.5 years\nof age. We could also have specified our own cutpoints directly using the\nbreaks option. The function cut() returns an ordered categorical variable;\nthe lm() function then creates a set of dummy variables for use in the regression.\nThe age < 33.5 category is left out, so the intercept coefficient of\n$94,160 can be interpreted as the average salary for those under 33.5 years\nof age, and the other coefficients can be interpreted as the average additional\nsalary for those in the other age groups. We", "doc_id": "b3483f2a-ff89-438e-997c-40309420a7b2", "embedding": null, "doc_hash": "98697c55a0028f7b37d1e0bc46de126db8687f54d1154195c4316d2eca5ae998", "extra_info": null, "node_info": {"start": 742414, "end": 745366, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "e5254c1f-3c1c-4538-84b4-76ca69262ea5", "3": "90f14eae-babe-4be2-b2d0-215aab0df56f"}}, "__type__": "1"}, "90f14eae-babe-4be2-b2d0-215aab0df56f": {"__data__": {"text": "be interpreted as the average additional\nsalary for those in the other age groups. We can produce predictions\nand plots just as we did in the case of the polynomial fit.\n7.8 Lab: Non-linear Modeling 317\n7.8.2 Splines\nIn order to fit regression splines in R, we use the splines library. In Section\n7.4, we saw that regression splines can be fit by constructing an appropriate\nmatrix of basis functions. The bs() function generates the entire matrix of\nbs()\nbasis functions for splines with the specified set of knots. By default, cubic\nsplines are produced. Fitting wage to age using a regression spline is simple:\n> library(splines)\n> fit <- lm(wage \u223c bs(age , knots = c(25, 40, 60)), data = Wage)\n> pred <- predict(fit , newdata = list(age = age.grid), se = T)\n> plot(age , wage , col = \"gray\")\n> lines(age.grid, pred$fit , lwd = 2)\n> lines(age.grid , pred$fit + 2 * pred$se, lty = \"dashed\")\n> lines(age.grid , pred$fit - 2 * pred$se, lty = \"dashed\")\nHere we have prespecified knots at ages 25, 40, and 60. This produces a\nspline with six basis functions. (Recall that a cubic spline with three knots\nhas seven degrees of freedom; these degrees of freedom are used up by an\nintercept, plus six basis functions.) We could also use the df option to\nproduce a spline with knots at uniform quantiles of the data.\n> dim(bs(age , knots = c(25, 40, 60)))\n[1] 3000 6\n> dim(bs(age , df = 6))\n[1] 3000 6\n> attr(bs(age , df = 6), \"knots\")\n25% 50% 75%\n33.8 42.0 51.0\nIn this case R chooses knots at ages 33.8, 42.0, and 51.0, which correspond\nto the 25th, 50th, and 75th percentiles of age. The function bs() also has\na degree argument, so we can fit splines of any degree, rather than the\ndefault degree of 3 (which yields a cubic spline).\nIn order to instead fit a natural spline, we use the ns() function. Here\nns()\nwe fit a natural spline with four degrees of freedom.\n> fit2 <- lm(wage \u223c ns(age , df = 4), data = Wage)\n> pred2 <- predict(fit2 , newdata = list(age = age.grid),\nse = T)\n> lines(age.grid , pred2$fit , col = \"red\", lwd = 2)\nAs with the bs() function, we could instead specify the knots directly using\nthe knots option.\nIn order to fit a smoothing spline, we use the smooth.spline() function.\nsmooth.\nFigure 7.8 was produced with the following code: spline()\n> plot(age , wage , xlim = agelims , cex = .5, col = \"darkgrey\")\n> title(\"Smoothing Spline\")\n> fit <- smooth.spline(age , wage , df = 16)\n> fit2 <- smooth.spline(age , wage , cv = TRUE)\n> fit2$df\n318 7. Moving Beyond Linearity\n[1] 6.8\n> lines(fit , col = \"red\", lwd = 2)\n> lines(fit2 , col = \"blue\", lwd = 2)\n> legend(\"topright\", legend = c(\"16 DF\", \"6.8 DF\"),\ncol = c(\"red\", \"blue\"), lty = 1, lwd = 2, cex = .8)\nNotice that in the first call to smooth.spline(), we specified df = 16. The\nfunction then determines which value of \u03bb leads to 16 degrees of freedom. In\nthe second call to smooth.spline(), we select the smoothness level by crossvalidation;\nthis results in a value of \u03bb that yields 6.8", "doc_id": "90f14eae-babe-4be2-b2d0-215aab0df56f", "embedding": null, "doc_hash": "20489de8a7122b9844202290a513045322609560c7d68eda4c24e99db3fbe7de", "extra_info": null, "node_info": {"start": 745337, "end": 748300, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "b3483f2a-ff89-438e-997c-40309420a7b2", "3": "a04f63cf-9288-41f4-8ce3-8a092591324a"}}, "__type__": "1"}, "a04f63cf-9288-41f4-8ce3-8a092591324a": {"__data__": {"text": "by crossvalidation;\nthis results in a value of \u03bb that yields 6.8 degrees of freedom.\nIn order to perform local regression, we use the loess() function.\nloess()\n> plot(age , wage , xlim = agelims , cex = .5, col = \"darkgrey\")\n> title(\"Local Regression\")\n> fit <- loess(wage \u223c age , span = .2, data = Wage)\n> fit2 <- loess(wage \u223c age , span = .5, data = Wage)\n> lines(age.grid, predict(fit , data.frame(age = age.grid)),\ncol = \"red\", lwd = 2)\n> lines(age.grid, predict(fit2 , data.frame(age = age.grid)),\ncol = \"blue\", lwd = 2)\n> legend(\"topright\", legend = c(\"Span = 0.2\", \"Span = 0.5\"),\ncol = c(\"red\", \"blue\"), lty = 1, lwd = 2, cex = .8)\nHere we have performed local linear regression using spans of 0.2 and 0.5:\nthat is, each neighborhood consists of 20% or 50% of the observations. The\nlarger the span, the smoother the fit. The locfit library can also be used\nfor fitting local regression models in R.\n7.8.3 GAMs\nWe now fit a GAM to predict wage using natural spline functions of year\nand age, treating education as a qualitative predictor, as in (7.16). Since\nthis is just a big linear regression model using an appropriate choice of\nbasis functions, we can simply do this using the lm() function.\n> gam1 <- lm(wage \u223c ns(year , 4) + ns(age , 5) + education ,\ndata = Wage)\nWe now fit the model (7.16) using smoothing splines rather than natural\nsplines. In order to fit more general sorts of GAMs, using smoothing splines\nor other components that cannot be expressed in terms of basis functions\nand then fit using least squares regression, we will need to use the gam\nlibrary in R.\nThe s() function, which is part of the gam library, is used to indicate that\ns()\nwe would like to use a smoothing spline. We specify that the function of\nyear should have 4 degrees of freedom, and that the function of age will\nhave 5 degrees of freedom. Since education is qualitative, we leave it as is,\nand it is converted into four dummy variables. We use the gam() function in\ngam()\norder to fit a GAM using these components. All of the terms in (7.16) are\nfit simultaneously, taking each other into account to explain the response.\n7.8 Lab: Non-linear Modeling 319\n> library(gam)\n> gam.m3 <- gam(wage \u223c s(year , 4) + s(age , 5) + education ,\ndata = Wage)\nIn order to produce Figure 7.12, we simply call the plot() function:\n> par(mfrow = c(1, 3))\n> plot(gam.m3, se = TRUE , col = \"blue\")\nThe generic plot() function recognizes that gam.m3 is an object of class Gam,\nand invokes the appropriate plot.Gam() method. Conveniently, even though\nplot.Gam()\ngam1 is not of class Gam but rather of class lm, we can still use plot.Gam()\non it. Figure 7.11 was produced using the following expression:\n> plot.Gam(gam1 , se = TRUE , col = \"red\")\nNotice here we had to use plot.Gam() rather than the generic plot()\nfunction.\nIn these plots, the function of year looks rather linear. We can perform a\nseries of ANOVA tests in order to determine which of these three models is\nbest: a GAM that excludes year (M1), a GAM that uses a linear function\nof year (M2), or a GAM that uses a spline function of year (M3).\n> gam.m1 <- gam(wage \u223c s(age , 5) + education , data = Wage)\n> gam.m2 <- gam(wage", "doc_id": "a04f63cf-9288-41f4-8ce3-8a092591324a", "embedding": null, "doc_hash": "7d058d5d09c407b2277c7502cd4fa0dd3809a6021611858a640f05e27ffb5dfd", "extra_info": null, "node_info": {"start": 748319, "end": 751489, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "90f14eae-babe-4be2-b2d0-215aab0df56f", "3": "ceeb34e3-8a46-4760-9118-85ed595600b6"}}, "__type__": "1"}, "ceeb34e3-8a46-4760-9118-85ed595600b6": {"__data__": {"text": "+ education , data = Wage)\n> gam.m2 <- gam(wage \u223c year + s(age , 5) + education ,\ndata = Wage)\n> anova(gam.m1, gam.m2, gam.m3, test = \"F\")\nAnalysis of Deviance Table\nModel 1: wage \u223c s(age , 5) + education\nModel 2: wage \u223c year + s(age , 5) + education\nModel 3: wage \u223c s(year , 4) + s(age , 5) + education\nResid. Df Resid. Dev Df Deviance F Pr(>F)\n1 2990 3711730\n2 2989 3693841 1 17889 14.5 0.00014 ***\n3 2986 3689770 3 4071 1.1 0.34857\n---\nSignif.codes: 0 \u2018***\u2019 0.001 \u2018**\u2019 0.01 \u2018*\u2019 0.05 \u2018.\u2019 0.1 \u2018 \u2019 1\nWe find that there is compelling evidence that a GAM with a linear function\nof year is better than a GAM that does not include year at all\n(p-value=0.00014). However, there is no evidence that a non-linear function\nof year is needed (p-value=0.349). In other words, based on the results\nof this ANOVA, M2 is preferred.\nThe summary() function produces a summary of the gam fit.\n> summary(gam.m3)\nCall: gam(formula = wage \u223c s(year , 4) + s(age , 5) + education ,\ndata = Wage)\nDeviance Residuals:\nMin 1Q Median 3Q Max\n-119.43 -19.70 -3.33 14.17 213.48\n320 7. Moving Beyond Linearity\n(Dispersion Parameter for gaussian family taken to be 1236)\nNull Deviance: 5222086 on 2999 degrees of freedom\nResidual Deviance: 3689770 on 2986 degrees of freedom\nAIC: 29888\nNumber of Local Scoring Iterations: 2\nAnova for Parametric Effects\nDf Sum Sq Mean Sq F value Pr(>F)\ns(year , 4) 1 27162 27162 22 2.9e-06 ***\ns(age , 5) 1 195338 195338 158 < 2e-16 ***\neducation 4 1069726 267432 216 < 2e-16 ***\nResiduals 2986 3689770 1236\n---\nSignif. codes: 0 \u2018***\u2019 0.001 \u2018**\u2019 0.01 \u2018*\u2019 0.05 \u2018.\u2019 0.1 \u2018 \u2019 1\nAnova for Nonparametric Effects\nNpar Df Npar F Pr(F)\n(Intercept)\ns(year , 4) 3 1.1 0.35\ns(age , 5) 4 32.4 <2e-16 ***\neducation\n---\nSignif. codes: 0 \u2018***\u2019 0.001 \u2018**\u2019 0.01 \u2018*\u2019 0.05 \u2018.\u2019 0.1 \u2018 \u2019 1\nThe \u201cAnova for Parametric Effects\u201d p-values clearly demonstrate that year,\nage, and education are all highly statistically significant, even when only\nassuming a linear relationship. Alternatively, the \u201cAnova for Nonparametric\nEffects\u201d p-values for year and age correspond to a null hypothesis of a\nlinear relationship versus the alternative of a non-linear relationship. The\nlarge p-value for year reinforces our conclusion from the ANOVA test that\na linear function is adequate for this term. However, there is very clear\nevidence that a non-linear term is required for age.\nWe can make predictions using the predict() method for the class Gam.\nHere we make predictions on the training set.\n> preds <- predict(gam.m2, newdata = Wage)\nWe can also use local regression fits as building blocks in a GAM, using\nthe lo() function.\nlo()\n> gam.lo <- gam(\nwage \u223c s(year , df = 4) + lo(age , span = 0.7) + education ,\ndata = Wage\n)\n> plot.Gam(gam.lo, se = TRUE , col = \"green\")\nHere we have used local regression for the age term, with a span of", "doc_id": "ceeb34e3-8a46-4760-9118-85ed595600b6", "embedding": null, "doc_hash": "55e4ba61a77482a97a685dc77454eab68ef4c068b8d0ebe67f0f0702e3137768", "extra_info": null, "node_info": {"start": 751505, "end": 754312, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "a04f63cf-9288-41f4-8ce3-8a092591324a", "3": "ed270ae0-a880-405a-a730-219188cbca54"}}, "__type__": "1"}, "ed270ae0-a880-405a-a730-219188cbca54": {"__data__": {"text": "\"green\")\nHere we have used local regression for the age term, with a span of 0.7.\nWe can also use the lo() function to create interactions before calling the\ngam() function. For example,\n7.9 Exercises 321\n> gam.lo.i <- gam(wage \u223c lo(year , age , span = 0.5) + education ,\ndata = Wage)\nfits a two-term model, in which the first term is an interaction between\nyear and age, fit by a local regression surface. We can plot the resulting\ntwo-dimensional surface if we first install the akima package.\n> library(akima)\n> plot(gam.lo.i)\nIn order to fit a logistic regression GAM, we once again use the I() function\nin constructing the binary response variable, and set family=binomial.\n> gam.lr <- gam(\nI(wage > 250) \u223c year + s(age , df = 5) + education ,\nfamily = binomial , data = Wage\n)\n> par(mfrow = c(1, 3))\n> plot(gam.lr, se = T, col = \"green\")\nIt is easy to see that there are no high earners in the < HS category:\n> table(education , I(wage > 250))\neducation FALSE TRUE\n1. < HS Grad 268 0\n2. HS Grad 966 5\n3. Some College 643 7\n4. College Grad 663 22\n5. Advanced Degree 381 45\nHence, we fit a logistic regression GAM using all but this category. This\nprovides more sensible results.\n> gam.lr.s <- gam(\nI(wage > 250) \u223c year + s(age , df = 5) + education ,\nfamily = binomial , data = Wage ,\nsubset = (education != \"1. < HS Grad\")\n)\n> plot(gam.lr.s, se = T, col = \"green\")\n7.9 Exercises\nConceptual\n1. It was mentioned in the chapter that a cubic regression spline with\none knot at \u03be can be obtained using a basis of the form x, x2, x3,\n(x \u2212 \u03be)3\n+, where (x \u2212 \u03be)3\n+ = (x \u2212 \u03be)3 if x > \u03be and equals 0 otherwise.\nWe will now show that a function of the form\nf(x) = \u03b20 + \u03b21x + \u03b22x2 + \u03b23x3 + \u03b24(x \u2212 \u03be)3\n+\n322 7. Moving Beyond Linearity\nis indeed a cubic regression spline, regardless of the values of \u03b20,\u03b21,\u03b22,\n\u03b23,\u03b24.\n(a) Find a cubic polynomial\nf1(x) = a1 + b1x + c1x2 + d1x3\nsuch that f(x) = f1(x) for all x \u2264 \u03be. Express a1, b1, c1, d1 in\nterms of \u03b20,\u03b21,\u03b22,\u03b23,\u03b24.\n(b) Find a cubic polynomial\nf2(x) = a2 + b2x + c2x2 + d2x3\nsuch that f(x) = f2(x) for all x > \u03be. Express a2, b2, c2, d2 in\nterms of \u03b20,\u03b21,\u03b22,\u03b23,\u03b24. We have now established that f(x) is\na piecewise polynomial.\n(c) Show that f1(\u03be) = f2(\u03be). That is, f(x) is continuous at \u03be.\n(d) Show that f\u20321 (\u03be) = f\u20322(\u03be). That is, f\u2032(x) is continuous at \u03be.\n(e) Show that f\u2032\u2032 1 (\u03be) = f\u2032\u2032 2 (\u03be). That is, f\u2032\u2032(x) is continuous at \u03be.\nTherefore, f(x) is indeed a cubic spline.\nHint: Parts (d) and (e) of this problem require knowledge of singlevariable\ncalculus. As a reminder, given a cubic polynomial\nf1(x) = a1 + b1x + c1x2 + d1x3,\nthe first derivative", "doc_id": "ed270ae0-a880-405a-a730-219188cbca54", "embedding": null, "doc_hash": "6abae6d643190cfa421ee384d7cf50372028dfcd4a2d6c6355166c2f11017409", "extra_info": null, "node_info": {"start": 754289, "end": 756879, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "ceeb34e3-8a46-4760-9118-85ed595600b6", "3": "d5543c12-2d1e-463d-88ed-36e6af8b561d"}}, "__type__": "1"}, "d5543c12-2d1e-463d-88ed-36e6af8b561d": {"__data__": {"text": "b1x + c1x2 + d1x3,\nthe first derivative takes the form\nf\u20321(x) = b1 + 2c1x + 3d1x2\nand the second derivative takes the form\nf\u2032\u2032 1 (x) = 2c1 + 6d1x.\n2. Suppose that a curve \u02c6g is computed to smoothly fit a set of n points\nusing the following formula:\n\u02c6g = arg min\ng\n>\n0n\ni=1\n(yi \u2212 g(xi))2 + \u03bb\nL 7\ng(m)(x)\n82\ndx\n?\n,\nwhere g(m) represents the mth derivative of g (and g(0) = g). Provide\nexample sketches of \u02c6g in each of the following scenarios.\n(a) \u03bb = \u221e,m = 0.\n(b) \u03bb = \u221e,m = 1.\n7.9 Exercises 323\n(c) \u03bb = \u221e,m = 2.\n(d) \u03bb = \u221e,m = 3.\n(e) \u03bb = 0,m = 3.\n3. Suppose we fit a curve with basis functions b1(X) = X, b2(X) =\n(X \u2212 1)2I(X \u2265 1). (Note that I(X \u2265 1) equals 1 for X \u2265 1 and 0\notherwise.) We fit the linear regression model\nY = \u03b20 + \u03b21b1(X) + \u03b22b2(X) + \u03f5,\nand obtain coefficient estimates \u02c6 \u03b20 = 1, \u02c6 \u03b21 = 1, \u02c6 \u03b22 = \u22122. Sketch the\nestimated curve between X = \u22122 and X = 2. Note the intercepts,\nslopes, and other relevant information.\n4. Suppose we fit a curve with basis functions b1(X) = I(0 \u2264 X \u2264 2) \u2212 (X \u22121)I(1 \u2264 X \u2264 2), b2(X) = (X \u22123)I(3 \u2264 X \u2264 4)+I(4 < X \u2264 5).\nWe fit the linear regression model\nY = \u03b20 + \u03b21b1(X) + \u03b22b2(X) + \u03f5,\nand obtain coefficient estimates \u02c6 \u03b20 = 1, \u02c6 \u03b21 = 1, \u02c6 \u03b22 = 3. Sketch the\nestimated curve between X = \u22122 and X = 6. Note the intercepts,\nslopes, and other relevant information.\n5. Consider two curves, \u02c6g1 and \u02c6g2, defined by\n\u02c6g1 = arg min\ng\n>\n0n\ni=1\n(yi \u2212 g(xi))2 + \u03bb\nL 7\ng(3)(x)\n82\ndx\n?\n,\n\u02c6g2 = arg min\ng\n>\n0n\ni=1\n(yi \u2212 g(xi))2 + \u03bb\nL 7\ng(4)(x)\n82\ndx\n?\n,\nwhere g(m) represents the mth derivative of g.\n(a) As \u03bb\u2192\u221e, will \u02c6g1 or \u02c6g2 have the smaller training RSS?\n(b) As \u03bb\u2192\u221e, will \u02c6g1 or \u02c6g2 have the smaller test RSS?\n(c) For \u03bb = 0, will \u02c6g1 or \u02c6g2 have the smaller training and test RSS?\nApplied\n6. In this exercise, you will further analyze the Wage data set considered\nthroughout this chapter.\n(a) Perform polynomial regression to predict wage using age. Use\ncross-validation to select the optimal degree d for the polynomial.\nWhat degree was chosen, and how does this compare to\nthe results of hypothesis testing using ANOVA? Make a plot of\nthe resulting polynomial fit to the data.\n324 7. Moving Beyond Linearity\n(b) Fit a step function to predict wage using age, and perform crossvalidation\nto choose the optimal number of cuts. Make a plot of\nthe fit obtained.\n7. The Wage data set contains a number of other features not explored\nin this chapter, such as marital status (maritl), job class", "doc_id": "d5543c12-2d1e-463d-88ed-36e6af8b561d", "embedding": null, "doc_hash": "d712b82e32194c748579443a195c33f33d0fb84f3bb771fddaf1c583c47e7491", "extra_info": null, "node_info": {"start": 756910, "end": 759334, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "ed270ae0-a880-405a-a730-219188cbca54", "3": "19a8eec9-d533-4f3b-bffc-f47beb61826b"}}, "__type__": "1"}, "19a8eec9-d533-4f3b-bffc-f47beb61826b": {"__data__": {"text": "not explored\nin this chapter, such as marital status (maritl), job class (jobclass),\nand others. Explore the relationships between some of these other\npredictors and wage, and use non-linear fitting techniques in order to\nfit flexible models to the data. Create plots of the results obtained,\nand write a summary of your findings.\n8. Fit some of the non-linear models investigated in this chapter to the\nAuto data set. Is there evidence for non-linear relationships in this\ndata set? Create some informative plots to justify your answer.\n9. This question uses the variables dis (the weighted mean of distances\nto five Boston employment centers) and nox (nitrogen oxides concentration\nin parts per 10 million) from the Boston data. We will treat\ndis as the predictor and nox as the response.\n(a) Use the poly() function to fit a cubic polynomial regression to\npredict nox using dis. Report the regression output, and plot\nthe resulting data and polynomial fits.\n(b) Plot the polynomial fits for a range of different polynomial\ndegrees (say, from 1 to 10), and report the associated residual\nsum of squares.\n(c) Perform cross-validation or another approach to select the optimal\ndegree for the polynomial, and explain your results.\n(d) Use the bs() function to fit a regression spline to predict nox\nusing dis. Report the output for the fit using four degrees of\nfreedom. How did you choose the knots? Plot the resulting fit.\n(e) Now fit a regression spline for a range of degrees of freedom, and\nplot the resulting fits and report the resulting RSS. Describe the\nresults obtained.\n(f) Perform cross-validation or another approach in order to select\nthe best degrees of freedom for a regression spline on this data.\nDescribe your results.\n10. This question relates to the College data set.\n(a) Split the data into a training set and a test set. Using out-of-state\ntuition as the response and the other variables as the predictors,\nperform forward stepwise selection on the training set in order\nto identify a satisfactory model that uses just a subset of the\npredictors.\n7.9 Exercises 325\n(b) Fit a GAM on the training data, using out-of-state tuition as\nthe response and the features selected in the previous step as\nthe predictors. Plot the results, and explain your findings.\n(c) Evaluate the model obtained on the test set, and explain the\nresults obtained.\n(d) For which variables, if any, is there evidence of a non-linear\nrelationship with the response?\n11. In Section 7.7, it was mentioned that GAMs are generally fit using\na backfitting approach. The idea behind backfitting is actually quite\nsimple. We will now explore backfitting in the context of multiple\nlinear regression.\nSuppose that we would like to perform multiple linear regression, but\nwe do not have software to do so. Instead, we only have software\nto perform simple linear regression. Therefore, we take the following\niterative approach: we repeatedly hold all but one coefficient estimate\nfixed at its current value, and update only that coefficient\nestimate using a simple linear regression. The process is continued until\nconvergence\u2014that is, until the coefficient estimates stop changing.\nWe now try this out on a toy example.\n(a) Generate a response Y and two predictors X1 and X2, with\nn = 100.\n(b) Initialize \u02c6 \u03b21 to take on a value of your choice. It does not matter\nwhat value you choose.\n(c) Keeping \u02c6 \u03b21 fixed, fit the model\nY \u2212 \u02c6 \u03b21X1 = \u03b20 + \u03b22X2 + \u03f5.\nYou can do this as follows:\n> a <- y - beta1 * x1\n> beta2 <- lm(a \u223c x2)$coef [2]\n(d) Keeping \u02c6 \u03b22 fixed, fit the model\nY \u2212 \u02c6 \u03b22X2 = \u03b20 + \u03b21X1 + \u03f5.\nYou can do this as follows:\n> a <- y -", "doc_id": "19a8eec9-d533-4f3b-bffc-f47beb61826b", "embedding": null, "doc_hash": "c32cee9885151196c72fb59af200db1a6145b53f5364c783e27db7048e964db2", "extra_info": null, "node_info": {"start": 759306, "end": 762928, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "d5543c12-2d1e-463d-88ed-36e6af8b561d", "3": "09899ee6-ddbb-4bcd-aa31-a0b53b2f273a"}}, "__type__": "1"}, "09899ee6-ddbb-4bcd-aa31-a0b53b2f273a": {"__data__": {"text": "+ \u03f5.\nYou can do this as follows:\n> a <- y - beta2 * x2\n> beta1 <- lm(a \u223c x1)$coef [2]\n(e) Write a for loop to repeat (c) and (d) 1,000 times. Report the\nestimates of \u02c6 \u03b20, \u02c6 \u03b21, and \u02c6 \u03b22 at each iteration of the for loop.\nCreate a plot in which each of these values is displayed, with \u02c6 \u03b20,\n\u02c6 \u03b21, and \u02c6 \u03b22 each shown in a different color.\n326 7. Moving Beyond Linearity\n(f) Compare your answer in (e) to the results of simply performing\nmultiple linear regression to predict Y using X1 and X2. Use\nthe abline() function to overlay those multiple linear regression\ncoefficient estimates on the plot obtained in (e).\n(g) On this data set, how many backfitting iterations were required\nin order to obtain a \u201cgood\u201d approximation to the multiple regression\ncoefficient estimates?\n12. This problem is a continuation of the previous exercise. In a toy\nexample with p = 100, show that one can approximate the multiple\nlinear regression coefficient estimates by repeatedly performing simple\nlinear regression in a backfitting procedure. How many backfitting\niterations are required in order to obtain a \u201cgood\u201d approximation to\nthe multiple regression coefficient estimates? Create a plot to justify\nyour answer.\n8\nTree-Based Methods\nIn this chapter, we describe tree-based methods for regression and classification.\nThese involve stratifying or segmenting the predictor space into\na number of simple regions. In order to make a prediction for a given observation,\nwe typically use the mean or the mode response value for the\ntraining observations in the region to which it belongs. Since the set of\nsplitting rules used to segment the predictor space can be summarized in\na tree, these types of approaches are known as decision tree methods.\ndecision tree\nTree-based methods are simple and useful for interpretation. However,\nthey typically are not competitive with the best supervised learning approaches,\nsuch as those seen in Chapters 6 and 7, in terms of prediction\naccuracy. Hence in this chapter we also introduce bagging, random forests,\nboosting, and Bayesian additive regression trees. Each of these approaches\ninvolves producing multiple trees which are then combined to yield a single\nconsensus prediction. We will see that combining a large number of trees\ncan often result in dramatic improvements in prediction accuracy, at the\nexpense of some loss in interpretation.\n8.1 The Basics of Decision Trees\nDecision trees can be applied to both regression and classification problems.\nWe first consider regression problems, and then move on to classification.\n\u00a9 Springer Science+Business Media, LLC, part of Springer Nature 2021\nG. James et al., An Introduction to Statistical Learning, Springer Texts in Statistics,\nhttps://doi.org/10.1007/978-1-0716-1418-1_8\n327\n328 8. Tree-Based Methods\n|\nYears < 4.5\nHits < 117.5\n5.11\n6.00 6.74\nFIGURE 8.1. For the Hitters data, a regression tree for predicting the log\nsalary of a baseball player, based on the number of years that he has played in\nthe major leagues and the number of hits that he made in the previous year. At a\ngiven internal node, the label (of the form Xj < tk) indicates the left-hand branch\nemanating from that split, and the right-hand branch corresponds to Xj \u2265 tk.\nFor instance, the split at the top of the tree results in two large branches. The\nleft-hand branch corresponds to Years<4.5, and the right-hand branch corresponds\nto Years>=4.5. The tree has two internal nodes and three terminal nodes, or\nleaves. The number in each leaf is the mean of the response for the observations\nthat fall there.\n8.1.1 Regression Trees\nIn order to motivate regression trees,", "doc_id": "09899ee6-ddbb-4bcd-aa31-a0b53b2f273a", "embedding": null, "doc_hash": "3f17349b8335f3ab9e0500c4e494e22aa4ff72524f557283293eef529b32460b", "extra_info": null, "node_info": {"start": 762958, "end": 766585, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "19a8eec9-d533-4f3b-bffc-f47beb61826b", "3": "f151602c-c8b5-4949-abfe-b1a67a978a85"}}, "__type__": "1"}, "f151602c-c8b5-4949-abfe-b1a67a978a85": {"__data__": {"text": "Regression Trees\nIn order to motivate regression trees, we begin with a simple example.\nregression\ntree\nPredicting Baseball Players\u2019 Salaries Using Regression Trees\nWe use the Hitters data set to predict a baseball player\u2019s Salary based on\nYears (the number of years that he has played in the major leagues) and\nHits (the number of hits that he made in the previous year).We first remove\nobservations that are missing Salary values, and log-transform Salary so\nthat its distribution has more of a typical bell-shape. (Recall that Salary\nis measured in thousands of dollars.)\nFigure 8.1 shows a regression tree fit to this data. It consists of a series\nof splitting rules, starting at the top of the tree. The top split assigns\nobservations having Years<4.5 to the left branch.1 The predicted salary\nfor these players is given by the mean response value for the players in\nthe data set with Years<4.5. For such players, the mean log salary is 5.107,\nand so we make a prediction of e5.107 thousands of dollars, i.e. $165,174, for\n1Both Years and Hits are integers in these data; the tree() function in R labels\nthe splits at the midpoint between two adjacent values.\n8.1 The Basics of Decision Trees 329\nYears\nHits\n1\n117.5\n238\n1 4.5 24\nR1\nR3\nR2\nFIGURE 8.2. The three-region partition for the Hitters data set from the regression\ntree illustrated in Figure 8.1.\nthese players. Players with Years>=4.5 are assigned to the right branch, and\nthen that group is further subdivided by Hits. Overall, the tree stratifies\nor segments the players into three regions of predictor space: players who\nhave played for four or fewer years, players who have played for five or more\nyears and who made fewer than 118 hits last year, and players who have\nplayed for five or more years and who made at least 118 hits last year. These\nthree regions can be written as R1 ={X | Years<4.5}, R2 ={X | Years>=4.5,\nHits<117.5}, and R3 ={X | Years>=4.5, Hits>=117.5}. Figure 8.2 illustrates\nthe regions as a function of Years and Hits. The predicted salaries for these\nthree groups are $1,000\u00d7e5.107 =$165,174, $1,000\u00d7e5.999 =$402,834, and\n$1,000\u00d7e6.740 =$845,346 respectively.\nIn keeping with the tree analogy, the regions R1, R2, and R3 are known\nas terminal nodes or leaves of the tree. As is the case for Figure 8.1, decision\nterminal\nnode\nleaf\ntrees are typically drawn upside down, in the sense that the leaves are at\nthe bottom of the tree. The points along the tree where the predictor space\nis split are referred to as internal nodes. In Figure 8.1, the two internal\ninternal\nnodes are indicated by the text Years<4.5 and Hits<117.5. We refer to the node\nsegments of the trees that connect the nodes as branches.\nbranch\nWe might interpret the regression tree displayed in Figure 8.1 as follows:\nYears is the most important factor in determining Salary, and players with\nless experience earn lower salaries than more experienced players. Given\nthat a player is less experienced, the number of hits that he made in the\nprevious year seems to play little role in his salary. But among players who\nhave been in the major leagues for five or more years, the number of hits\nmade in the previous year does affect salary, and players who made more\nhits last year tend to have higher salaries. The regression tree shown in\n330 8. Tree-Based Methods\nFigure 8.1 is likely an over-simplification of the true relationship between\nHits, Years, and Salary. However, it has advantages over other types of\nregression models (such as those seen in Chapters 3", "doc_id": "f151602c-c8b5-4949-abfe-b1a67a978a85", "embedding": null, "doc_hash": "3e62bcaa9700d5050886acacca787bc8b4488f6ec3ae4415f981ce8a69d21885", "extra_info": null, "node_info": {"start": 766570, "end": 770091, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "09899ee6-ddbb-4bcd-aa31-a0b53b2f273a", "3": "5062b202-8316-440a-a29b-c4abfa743f10"}}, "__type__": "1"}, "5062b202-8316-440a-a29b-c4abfa743f10": {"__data__": {"text": "has advantages over other types of\nregression models (such as those seen in Chapters 3 and 6): it is easier to\ninterpret, and has a nice graphical representation.\nPrediction via Stratification of the Feature Space\nWe now discuss the process of building a regression tree. Roughly speaking,\nthere are two steps.\n1. We divide the predictor space \u2014 that is, the set of possible values\nfor X1,X2, . . . ,Xp \u2014 into J distinct and non-overlapping regions,\nR1,R2, . . . ,RJ .\n2. For every observation that falls into the region Rj , we make the same\nprediction, which is simply the mean of the response values for the\ntraining observations in Rj .\nFor instance, suppose that in Step 1 we obtain two regions, R1 and R2,\nand that the response mean of the training observations in the first region\nis 10, while the response mean of the training observations in the second\nregion is 20. Then for a given observation X = x, if x \u2208 R1 we will predict\na value of 10, and if x \u2208 R2 we will predict a value of 20.\nWe now elaborate on Step 1 above. How do we construct the regions\nR1, . . . ,RJ? In theory, the regions could have any shape. However, we\nchoose to divide the predictor space into high-dimensional rectangles, or\nboxes, for simplicity and for ease of interpretation of the resulting predictive\nmodel. The goal is to find boxes R1, . . . ,RJ that minimize the RSS,\ngiven by\n0J\nj=1\n0\ni\u2208Rj\n(yi \u2212 \u02c6yRj )2, (8.1)\nwhere \u02c6yRj is the mean response for the training observations within the\njth box. Unfortunately, it is computationally infeasible to consider every\npossible partition of the feature space into J boxes. For this reason, we take\na top-down, greedy approach that is known as recursive binary splitting. The\nrecursive\nbinary\nsplitting\napproach is top-down because it begins at the top of the tree (at which point\nall observations belong to a single region) and then successively splits the\npredictor space; each split is indicated via two new branches further down\non the tree. It is greedy because at each step of the tree-building process,\nthe best split is made at that particular step, rather than looking ahead\nand picking a split that will lead to a better tree in some future step.\nIn order to perform recursive binary splitting, we first select the predictor\nXj and the cutpoint s such that splitting the predictor space into\nthe regions {X|Xj < s} and {X|Xj \u2265 s} leads to the greatest possible\nreduction in RSS. (The notation {X|Xj < s} means the region of predictor\n8.1 The Basics of Decision Trees 331\nspace in which Xj takes on a value less than s.) That is, we consider all\npredictors X1, . . . ,Xp, and all possible values of the cutpoint s for each of\nthe predictors, and then choose the predictor and cutpoint such that the\nresulting tree has the lowest RSS. In greater detail, for any j and s, we\ndefine the pair of half-planes\nR1(j, s) = {X|Xj < s} and R2(j, s) = {X|Xj \u2265 s}, (8.2)\nand we seek the value of j and s that minimize the equation\n0\ni: xi\u2208R1(j,s)\n(yi \u2212 \u02c6yR1 )2 +\n0\ni: xi\u2208R2(j,s)\n(yi \u2212 \u02c6yR2 )2, (8.3)\nwhere \u02c6yR1 is the mean response for the training observations in R1(j, s),\nand \u02c6yR2 is the mean response for the training observations in R2(j, s).\nFinding the values of j and s that minimize (8.3) can be done quite", "doc_id": "5062b202-8316-440a-a29b-c4abfa743f10", "embedding": null, "doc_hash": "199536a61ba3e351d8ce73edb25293e031a67c2cc0da0f15979aee42ea2821df", "extra_info": null, "node_info": {"start": 770068, "end": 773313, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "f151602c-c8b5-4949-abfe-b1a67a978a85", "3": "89d1c93c-42c3-4ad5-9495-82074de0cb15"}}, "__type__": "1"}, "89d1c93c-42c3-4ad5-9495-82074de0cb15": {"__data__": {"text": "the values of j and s that minimize (8.3) can be done quite quickly,\nespecially when the number of features p is not too large.\nNext, we repeat the process, looking for the best predictor and best\ncutpoint in order to split the data further so as to minimize the RSS within\neach of the resulting regions. However, this time, instead of splitting the\nentire predictor space, we split one of the two previously identified regions.\nWe now have three regions. Again, we look to split one of these three regions\nfurther, so as to minimize the RSS. The process continues until a stopping\ncriterion is reached; for instance, we may continue until no region contains\nmore than five observations.\nOnce the regions R1, . . . ,RJ have been created, we predict the response\nfor a given test observation using the mean of the training observations in\nthe region to which that test observation belongs.\nA five-region example of this approach is shown in Figure 8.3.\nTree Pruning\nThe process described above may produce good predictions on the training\nset, but is likely to overfit the data, leading to poor test set performance.\nThis is because the resulting tree might be too complex. A smaller tree\nwith fewer splits (that is, fewer regions R1, . . . ,RJ ) might lead to lower\nvariance and better interpretation at the cost of a little bias. One possible\nalternative to the process described above is to build the tree only so long\nas the decrease in the RSS due to each split exceeds some (high) threshold.\nThis strategy will result in smaller trees, but is too short-sighted since a\nseemingly worthless split early on in the tree might be followed by a very\ngood split\u2014that is, a split that leads to a large reduction in RSS later on.\nTherefore, a better strategy is to grow a very large tree T0, and then\nprune it back in order to obtain a subtree. How do we determine the best prune\nway to prune the tree? Intuitively, our goal is to select a subtree that subtree\nleads to the lowest test error rate. Given a subtree, we can estimate its\n332 8. Tree-Based Methods\n|\nt1\nt2\nt3\nt4\nR1\nR1\nR2\nR2\nR3\nR3\nR4\nR4\nR5\nR5\nX1\nX1 X1\nX2\nX2\nX2\nX1 \u2264 t1\nX2 \u2264 t2 X1 \u2264 t3\nX2 \u2264 t4\nFIGURE 8.3. Top Left: A partition of two-dimensional feature space that could\nnot result from recursive binary splitting. Top Right: The output of recursive\nbinary splitting on a two-dimensional example. Bottom Left: A tree corresponding\nto the partition in the top right panel. Bottom Right: A perspective plot of the\nprediction surface corresponding to that tree.\ntest error using cross-validation or the validation set approach. However,\nestimating the cross-validation error for every possible subtree would be too\ncumbersome, since there is an extremely large number of possible subtrees.\nInstead, we need a way to select a small set of subtrees for consideration.\nCost complexity pruning\u2014also known as weakest link pruning\u2014gives us\ncost\ncomplexity\npruning\nweakest link\npruning\na way to do just this. Rather than considering every possible subtree, we\nconsider a sequence of trees indexed by a nonnegative tuning parameter \u03b1.\nFor each value of \u03b1 there corresponds a subtree T \u2282 T0 such that\n0|T|\nm=1\n0\ni: xi\u2208Rm\n(yi \u2212 \u02c6yRm)2 + \u03b1|T| (8.4)\n8.1 The Basics of Decision Trees 333\nAlgorithm 8.1 Building a Regression Tree\n1. Use recursive binary splitting to grow a large tree on the training\ndata, stopping only when each terminal node has fewer than some\nminimum number of observations.\n2. Apply cost complexity pruning to the large tree in order to obtain a\nsequence of best", "doc_id": "89d1c93c-42c3-4ad5-9495-82074de0cb15", "embedding": null, "doc_hash": "d0a9de001b7d58c7433694819dd89233321fad6c52716e9b8df3194b06098e7c", "extra_info": null, "node_info": {"start": 773340, "end": 776866, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "5062b202-8316-440a-a29b-c4abfa743f10", "3": "266c220d-5bfc-4fc1-ba02-e69b6c11407f"}}, "__type__": "1"}, "266c220d-5bfc-4fc1-ba02-e69b6c11407f": {"__data__": {"text": "Apply cost complexity pruning to the large tree in order to obtain a\nsequence of best subtrees, as a function of \u03b1.\n3. Use K-fold cross-validation to choose \u03b1. That is, divide the training\nobservations into K folds. For each k = 1, . . . ,K:\n(a) Repeat Steps 1 and 2 on all but the kth fold of the training data.\n(b) Evaluate the mean squared prediction error on the data in the\nleft-out kth fold, as a function of \u03b1.\nAverage the results for each value of \u03b1, and pick \u03b1 to minimize the\naverage error.\n4. Return the subtree from Step 2 that corresponds to the chosen value\nof \u03b1.\nis as small as possible. Here |T| indicates the number of terminal nodes\nof the tree T, Rm is the rectangle (i.e. the subset of predictor space) corresponding\nto the mth terminal node, and \u02c6yRm is the predicted response\nassociated with Rm\u2014that is, the mean of the training observations in Rm.\nThe tuning parameter \u03b1 controls a trade-off between the subtree\u2019s complexity\nand its fit to the training data. When \u03b1 = 0, then the subtree T\nwill simply equal T0, because then (8.4) just measures the training error.\nHowever, as \u03b1 increases, there is a price to pay for having a tree with\nmany terminal nodes, and so the quantity (8.4) will tend to be minimized\nfor a smaller subtree. Equation 8.4 is reminiscent of the lasso (6.7) from\nChapter 6, in which a similar formulation was used in order to control the\ncomplexity of a linear model.\nIt turns out that as we increase \u03b1 from zero in (8.4), branches get pruned\nfrom the tree in a nested and predictable fashion, so obtaining the whole\nsequence of subtrees as a function of \u03b1 is easy. We can select a value of\n\u03b1 using a validation set or using cross-validation. We then return to the\nfull data set and obtain the subtree corresponding to \u03b1. This process is\nsummarized in Algorithm 8.1.\nFigures 8.4 and 8.5 display the results of fitting and pruning a regression\ntree on the Hitters data, using nine of the features. First, we randomly\ndivided the data set in half, yielding 132 observations in the training set\nand 131 observations in the test set. We then built a large regression tree\non the training data and varied \u03b1 in (8.4) in order to create subtrees with\ndifferent numbers of terminal nodes. Finally, we performed six-fold cross334\n8. Tree-Based Methods\n|\nYears < 4.5\nRBI < 60.5\nPutouts < 82\nYears < 3.5\nYears < 3.5\nHits < 117.5\nWalks < 43.5\nRuns < 47.5\nWalks < 52.5\nRBI < 80.5\nYears < 6.5\n5.487\n4.622 5.183\n5.394 6.189\n6.015 5.571\n6.407 6.549\n6.459 7.007\n7.289\nFIGURE 8.4. Regression tree analysis for the Hitters data. The unpruned tree\nthat results from top-down greedy splitting on the training data is shown.\nvalidation in order to estimate the cross-validated MSE of the trees as\na function of \u03b1. (We chose to perform six-fold cross-validation because\n132 is an exact multiple of six.) The unpruned regression tree is shown\nin Figure 8.4. The green curve in Figure 8.5 shows the CV error as a\nfunction of the number of leaves,2 while the orange curve indicates the\ntest error. Also shown are standard error bars around the estimated errors.\nFor reference, the training error curve is shown in black. The CV error\nis a reasonable approximation of the test error: the CV error takes on its\nminimum for a three-node tree, while the test error also dips down at the\nthree-node tree (though it takes on its lowest value at the ten-node tree).\nThe pruned tree containing three terminal", "doc_id": "266c220d-5bfc-4fc1-ba02-e69b6c11407f", "embedding": null, "doc_hash": "b500f551025b839feff4393d35a1b51e61598cd8a11d7f2756bc51b47193e78f", "extra_info": null, "node_info": {"start": 776843, "end": 780262, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "89d1c93c-42c3-4ad5-9495-82074de0cb15", "3": "bc6c6470-df6e-4cfa-bab0-da0083584302"}}, "__type__": "1"}, "bc6c6470-df6e-4cfa-bab0-da0083584302": {"__data__": {"text": "its lowest value at the ten-node tree).\nThe pruned tree containing three terminal nodes is shown in Figure 8.1.\n2Although CV error is computed as a function of \u03b1, it is convenient to display the\nresult as a function of |T|, the number of leaves; this is based on the relationship between\n\u03b1 and |T| in the original tree grown to all the training data.\n8.1 The Basics of Decision Trees 335\n2 4 6 8 10\n0.0 0.2 0.4 0.6 0.8 1.0\nTree Size\nMean Squared Error\nTraining\nCross\u2212Validation\nTest\nFIGURE 8.5. Regression tree analysis for the Hitters data. The training,\ncross-validation, and test MSE are shown as a function of the number of terminal\nnodes in the pruned tree. Standard error bands are displayed. The minimum\ncross-validation error occurs at a tree size of three.\n8.1.2 Classification Trees\nA classification tree is very similar to a regression tree, except that it is\nclassification\nused to predict a qualitative response rather than a quantitative one. Re- tree\ncall that for a regression tree, the predicted response for an observation is\ngiven by the mean response of the training observations that belong to the\nsame terminal node. In contrast, for a classification tree, we predict that\neach observation belongs to the most commonly occurring class of training\nobservations in the region to which it belongs. In interpreting the results of\na classification tree, we are often interested not only in the class prediction\ncorresponding to a particular terminal node region, but also in the class\nproportions among the training observations that fall into that region.\nThe task of growing a classification tree is quite similar to the task of\ngrowing a regression tree. Just as in the regression setting, we use recursive\nbinary splitting to grow a classification tree. However, in the classification\nsetting, RSS cannot be used as a criterion for making the binary splits.\nA natural alternative to RSS is the classification error rate. Since we plan\nclassification\nto assign an observation in a given region to the most commonly occurring error rate\nclass of training observations in that region, the classification error rate is\nsimply the fraction of the training observations in that region that do not\nbelong to the most common class:\nE = 1\u2212 max\nk\n(\u02c6pmk). (8.5)\n336 8. Tree-Based Methods\nHere \u02c6pmk represents the proportion of training observations in the mth\nregion that are from the kth class. However, it turns out that classification\nerror is not sufficiently sensitive for tree-growing, and in practice two other\nmeasures are preferable.\nThe Gini index is defined by\nGini index\nG =\n0K\nk=1\n\u02c6pmk(1 \u2212 \u02c6pmk), (8.6)\na measure of total variance across the K classes. It is not hard to see\nthat the Gini index takes on a small value if all of the \u02c6pmk\u2019s are close to\nzero or one. For this reason the Gini index is referred to as a measure of\nnode purity\u2014a small value indicates that a node contains predominantly\nobservations from a single class.\nAn alternative to the Gini index is entropy, given by\nentropy\nD = \u2212\n0K\nk=1\n\u02c6pmk log \u02c6pmk. (8.7)\nSince 0 \u2264 \u02c6pmk \u2264 1, it follows that 0 \u2264 \u2212\u02c6pmk log \u02c6pmk. One can show that\nthe entropy will take on a value near zero if the \u02c6pmk\u2019s are all near zero or\nnear one. Therefore, like the Gini index, the entropy will take on a small\nvalue if the mth node is pure. In fact, it turns out that the Gini index and\nthe entropy are quite similar numerically.\nWhen building a classification tree, either the Gini index or the entropy\nare typically used to evaluate the quality of a particular split, since these\ntwo approaches are more sensitive to node purity than is the classification\nerror rate. Any of these three approaches might be used when pruning", "doc_id": "bc6c6470-df6e-4cfa-bab0-da0083584302", "embedding": null, "doc_hash": "54dc03a0e65d9071084cf3f52b86f8f812a2eceafc15151a9dce1beaa7cb660a", "extra_info": null, "node_info": {"start": 780264, "end": 783958, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "266c220d-5bfc-4fc1-ba02-e69b6c11407f", "3": "240cb13e-531d-4556-a481-50d5f4388db2"}}, "__type__": "1"}, "240cb13e-531d-4556-a481-50d5f4388db2": {"__data__": {"text": "is the classification\nerror rate. Any of these three approaches might be used when pruning the\ntree, but the classification error rate is preferable if prediction accuracy of\nthe final pruned tree is the goal.\nFigure 8.6 shows an example on the Heart data set. These data contain\na binary outcome HD for 303 patients who presented with chest pain.\nAn outcome value of Yes indicates the presence of heart disease based on\nan angiographic test, while No means no heart disease. There are 13 predictors\nincluding Age, Sex, Chol (a cholesterol measurement), and other heart\nand lung function measurements. Cross-validation results in a tree with six\nterminal nodes.\nIn our discussion thus far, we have assumed that the predictor variables\ntake on continuous values. However, decision trees can be constructed\neven in the presence of qualitative predictor variables. For instance, in the\nHeart data, some of the predictors, such as Sex, Thal (Thallium stress test),\nand ChestPain, are qualitative. Therefore, a split on one of these variables\namounts to assigning some of the qualitative values to one branch and\nassigning the remaining to the other branch. In Figure 8.6, some of the internal\nnodes correspond to splitting qualitative variables. For instance, the\n8.1 The Basics of Decision Trees 337\n|\nThal:a\nCa < 0.5\nMaxHR < 161.5\nRestBP < 157\nChol < 244\nMaxHR < 156\nMaxHR < 145.5\nChestPain:bc\nChol < 244 Sex < 0.5\nCa < 0.5\nSlope < 1.5\nAge < 52 Thal:b\nChestPain:a\nOldpeak < 1.1\nRestECG < 1\nNo Yes\nNo\nNo\nYes\nNo\nNo No No Yes\nYes No No\nNo Yes\nYes Yes\nYes\n5 10 15\n0.0 0.1 0.2 0.3 0.4 0.5 0.6\nTree Size\nError\nTraining\nCross\u2212Validation\nTest\n|\nThal:a\nCa < 0.5\nMaxHR < 161.5 ChestPain:bc\nCa < 0.5\nNo No\nNo Yes\nYes Yes\nFIGURE 8.6. Heart data. Top: The unpruned tree. Bottom Left: Cross-validation\nerror, training, and test error, for different sizes of the pruned tree. Bottom\nRight: The pruned tree corresponding to the minimal cross-validation error.\ntop internal node corresponds to splitting Thal. The text Thal:a indicates\nthat the left-hand branch coming out of that node consists of observations\nwith the first value of the Thal variable (normal), and the right-hand node\nconsists of the remaining observations (fixed or reversible defects). The text\nChestPain:bc two splits down the tree on the left indicates that the left-hand\nbranch coming out of that node consists of observations with the second\nand third values of the ChestPain variable, where the possible values are\ntypical angina, atypical angina, non-anginal pain, and asymptomatic.\nFigure 8.6 has a surprising characteristic: some of the splits yield two\nterminal nodes that have the same predicted value. For instance, consider\nthe split RestECG<1 near the bottom right of the unpruned tree. Regardless\n338 8. Tree-Based Methods\nof the value of RestECG, a response value of Yes is predicted for those observations.\nWhy, then, is the split performed at all? The split is performed\nbecause it leads to increased node purity. That is, all 9 of the observations\ncorresponding to the right-hand leaf have a response value of Yes, whereas\n7/11 of those corresponding to the left-hand leaf have a response value of\nYes. Why is node purity important? Suppose that we have a test observation\nthat belongs to the region given by that right-hand leaf. Then we\ncan be pretty certain that its response value is Yes. In contrast, if a test\nobservation belongs to the region given by the left-hand leaf, then its response\nvalue is probably Yes, but we are much less certain. Even", "doc_id": "240cb13e-531d-4556-a481-50d5f4388db2", "embedding": null, "doc_hash": "c4538d70c0ddbb220b460f1230a52422e70f9f4c02967fc3b5f38ce744f394a5", "extra_info": null, "node_info": {"start": 783952, "end": 787476, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "bc6c6470-df6e-4cfa-bab0-da0083584302", "3": "061ce2ad-d8cd-4ad1-9879-bab439d81063"}}, "__type__": "1"}, "061ce2ad-d8cd-4ad1-9879-bab439d81063": {"__data__": {"text": "leaf, then its response\nvalue is probably Yes, but we are much less certain. Even though\nthe split RestECG<1 does not reduce the classification error, it improves the\nGini index and the entropy, which are more sensitive to node purity.\n8.1.3 Trees Versus Linear Models\nRegression and classification trees have a very different flavor from the more\nclassical approaches for regression and classification presented in Chapters 3\nand 4. In particular, linear regression assumes a model of the form\nf(X) = \u03b20 +\n0p\nj=1\nXj\u03b2j , (8.8)\nwhereas regression trees assume a model of the form\nf(X) =\nM0\nm=1\ncm \u00b7 1(X\u2208Rm) (8.9)\nwhere R1, . . . ,RM represent a partition of feature space, as in Figure 8.3.\nWhich model is better? It depends on the problem at hand. If the relationship\nbetween the features and the response is well approximated by\na linear model as in (8.8), then an approach such as linear regression will\nlikely work well, and will outperform a method such as a regression tree\nthat does not exploit this linear structure. If instead there is a highly nonlinear\nand complex relationship between the features and the response as\nindicated by model (8.9), then decision trees may outperform classical approaches.\nAn illustrative example is displayed in Figure 8.7. The relative\nperformances of tree-based and classical approaches can be assessed by estimating\nthe test error, using either cross-validation or the validation set\napproach (Chapter 5).\nOf course, other considerations beyond simply test error may come into\nplay in selecting a statistical learning method; for instance, in certain settings,\nprediction using a tree may be preferred for the sake of interpretability\nand visualization.\n8.1 The Basics of Decision Trees 339\n\u22122 \u22121 0 1 2\n\u22122 \u22121 0 1 2\nX1\nX2\n\u22122 \u22121 0 1 2\n\u22122 \u22121 0 1 2\nX1\nX2\n\u22122 \u22121 0 1 2\n\u22122 \u22121 0 1 2\nX1\nX2\n\u22122 \u22121 0 1 2\n\u22122 \u22121 0 1 2\nX1\nX2\nFIGURE 8.7. Top Row: A two-dimensional classification example in which the\ntrue decision boundary is linear, and is indicated by the shaded regions. A classical\napproach that assumes a linear boundary (left) will outperform a decision tree\nthat performs splits parallel to the axes (right). Bottom Row: Here the true decision\nboundary is non-linear. Here a linear model is unable to capture the true\ndecision boundary (left), whereas a decision tree is successful (right).\n8.1.4 Advantages and Disadvantages of Trees\nDecision trees for regression and classification have a number of advantages\nover the more classical approaches seen in Chapters 3 and 4:\n\u25b2 Trees are very easy to explain to people. In fact, they are even easier\nto explain than linear regression!\n\u25b2 Some people believe that decision trees more closely mirror human\ndecision-making than do the regression and classification approaches\nseen in previous chapters.\n\u25b2 Trees can be displayed graphically, and are easily interpreted even by\na non-expert (especially if they are small).\n\u25b2 Trees can easily handle qualitative predictors without the need to\ncreate dummy variables.\n340 8. Tree-Based Methods\n\u25bc Unfortunately, trees generally do not have the same level of predictive\naccuracy as some of the other regression and classification approaches\nseen in this book.\n\u25bc Additionally, trees can be very non-robust. In other words, a small\nchange in the data can cause a large change in the final estimated\ntree.\nHowever, by aggregating many decision trees, using methods like bagging,\nrandom forests, and boosting, the predictive performance of trees can be\nsubstantially improved. We introduce these concepts in the next section.\n8.2 Bagging, Random Forests,", "doc_id": "061ce2ad-d8cd-4ad1-9879-bab439d81063", "embedding": null, "doc_hash": "aeeb6c200115bad2d119358d057427b4fa5f2dab3f77caebff46993bd8dd24a8", "extra_info": null, "node_info": {"start": 787486, "end": 791059, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "240cb13e-531d-4556-a481-50d5f4388db2", "3": "f45d38b7-9cad-49b8-8f66-ac61a426e089"}}, "__type__": "1"}, "f45d38b7-9cad-49b8-8f66-ac61a426e089": {"__data__": {"text": "these concepts in the next section.\n8.2 Bagging, Random Forests, Boosting, and\nBayesian Additive Regression Trees\nAn ensemble method is an approach that combines many simple \u201cbuilding\nensemble\nblock\u201d models in order to obtain a single and potentially very powerful\nmodel. These simple building block models are sometimes known as weak\nlearners, since they may lead to mediocre predictions on their own.\nweak\nWe will now discuss bagging, random forests, boosting, and Bayesian learners\nadditive regression trees. These are ensemble methods for which the simple\nbuilding block is a regression or a classification tree.\n8.2.1 Bagging\nThe bootstrap, introduced in Chapter 5, is an extremely powerful idea. It is\nused in many situations in which it is hard or even impossible to directly\ncompute the standard deviation of a quantity of interest. We see here that\nthe bootstrap can be used in a completely different context, in order to\nimprove statistical learning methods such as decision trees.\nThe decision trees discussed in Section 8.1 suffer from high variance.\nThis means that if we split the training data into two parts at random,\nand fit a decision tree to both halves, the results that we get could be\nquite different. In contrast, a procedure with low variance will yield similar\nresults if applied repeatedly to distinct data sets; linear regression tends\nto have low variance, if the ratio of n to p is moderately large. Bootstrap\naggregation, or bagging, is a general-purpose procedure for reducing the\nbagging\nvariance of a statistical learning method; we introduce it here because it is\nparticularly useful and frequently used in the context of decision trees.\nRecall that given a set of n independent observations Z1, . . . ,Zn, each\nwith variance \u03c32, the variance of the mean \u00af Z of the observations is given\nby \u03c32/n. In other words, averaging a set of observations reduces variance.\nHence a natural way to reduce the variance and increase the test set accuracy\nof a statistical learning method is to take many training sets from\n8.2 Bagging, Random Forests, Boosting, and Bayesian Additive Regression Trees 341\nthe population, build a separate prediction model using each training set,\nand average the resulting predictions. In other words, we could calculate\n\u02c6 f1(x), \u02c6 f2(x), . . . , \u02c6 fB(x) using B separate training sets, and average them\nin order to obtain a single low-variance statistical learning model, given by\n\u02c6 favg(x) =\n1\nB\n0B\nb=1\n\u02c6 fb(x).\nOf course, this is not practical because we generally do not have access\nto multiple training sets. Instead, we can bootstrap, by taking repeated\nsamples from the (single) training data set. In this approach we generate\nB different bootstrapped training data sets. We then train our method on\nthe bth bootstrapped training set in order to get \u02c6 f\u2217b(x), and finally average\nall the predictions, to obtain\n\u02c6 fbag(x) =\n1\nB\n0B\nb=1\n\u02c6 f\u2217b(x).\nThis is called bagging.\nWhile bagging can improve predictions for many regression methods,\nit is particularly useful for decision trees. To apply bagging to regression\ntrees, we simply construct B regression trees using B bootstrapped training\nsets, and average the resulting predictions. These trees are grown deep,\nand are not pruned. Hence each individual tree has high variance, but\nlow bias. Averaging these B trees reduces the variance. Bagging has been\ndemonstrated to give impressive improvements in accuracy by combining\ntogether hundreds or even thousands of trees into a single procedure.\nThus far, we have described the bagging procedure in the regression\ncontext, to predict a quantitative outcome Y . How can bagging be extended\nto a classification problem where Y is qualitative? In that situation, there\nare a few possible approaches, but the simplest is", "doc_id": "f45d38b7-9cad-49b8-8f66-ac61a426e089", "embedding": null, "doc_hash": "95020ac5b2aefb028fdd9ae1bed2302441b349afa623ec9a0a82f76646157433", "extra_info": null, "node_info": {"start": 791072, "end": 794847, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "061ce2ad-d8cd-4ad1-9879-bab439d81063", "3": "d6bf58e6-7ec4-4f9e-9e53-0bb53d80f9f1"}}, "__type__": "1"}, "d6bf58e6-7ec4-4f9e-9e53-0bb53d80f9f1": {"__data__": {"text": "that situation, there\nare a few possible approaches, but the simplest is as follows. For a given test\nobservation, we can record the class predicted by each of the B trees, and\ntake a majority vote: the overall prediction is the most commonly occurring\nmajority\nclass among the B predictions. vote\nFigure 8.8 shows the results from bagging trees on the Heart data. The\ntest error rate is shown as a function of B, the number of trees constructed\nusing bootstrapped training data sets. We see that the bagging test error\nrate is slightly lower in this case than the test error rate obtained from a\nsingle tree. The number of trees B is not a critical parameter with bagging;\nusing a very large value of B will not lead to overfitting. In practice we\nuse a value of B sufficiently large that the error has settled down. Using\nB = 100 is sufficient to achieve good performance in this example.\n342 8. Tree-Based Methods\n0 50 100 150 200 250 300\n0.10 0.15 0.20 0.25 0.30\nNumber of Trees\nError\nTest: Bagging\nTest: RandomForest\nOOB: Bagging\nOOB: RandomForest\nFIGURE 8.8. Bagging and random forest results for the Heart data. The test\nerror (black and orange) is shown as a function of B, the number of bootstrapped\ntraining sets used. Random forests were applied with m = \u221ap. The dashed line\nindicates the test error resulting from a single classification tree. The green and\nblue traces show the OOB error, which in this case is \u2014 by chance \u2014 considerably\nlower.\nOut-of-Bag Error Estimation\nIt turns out that there is a very straightforward way to estimate the test\nerror of a bagged model, without the need to perform cross-validation or\nthe validation set approach. Recall that the key to bagging is that trees are\nrepeatedly fit to bootstrapped subsets of the observations. One can show\nthat on average, each bagged tree makes use of around two-thirds of the\nobservations.3 The remaining one-third of the observations not used to fit a\ngiven bagged tree are referred to as the out-of-bag (OOB) observations. We\nout-of-bag\ncan predict the response for the ith observation using each of the trees in\nwhich that observation was OOB. This will yield around B/3 predictions\nfor the ith observation. In order to obtain a single prediction for the ith\nobservation, we can average these predicted responses (if regression is the\ngoal) or can take a majority vote (if classification is the goal). This leads\nto a single OOB prediction for the ith observation. An OOB prediction\ncan be obtained in this way for each of the n observations, from which the\n3This relates to Exercise 2 of Chapter 5.\n8.2 Bagging, Random Forests, Boosting, and Bayesian Additive Regression Trees 343\noverall OOB MSE (for a regression problem) or classification error (for a\nclassification problem) can be computed. The resulting OOB error is a valid\nestimate of the test error for the bagged model, since the response for each\nobservation is predicted using only the trees that were not fit using that\nobservation. Figure 8.8 displays the OOB error on the Heart data. It can\nbe shown that with B sufficiently large, OOB error is virtually equivalent\nto leave-one-out cross-validation error. The OOB approach for estimating\nthe test error is particularly convenient when performing bagging on large\ndata sets for which cross-validation would be computationally onerous.\nVariable Importance Measures\nAs we have discussed, bagging typically results in improved accuracy over\nprediction using a single tree. Unfortunately, however, it can be difficult to\ninterpret the resulting model. Recall that one of the advantages of decision\ntrees is the attractive and easily interpreted diagram that results, such as\nthe one displayed in Figure 8.1. However, when we bag a large number of\ntrees, it is no longer possible to represent the resulting statistical learning\nprocedure using a single tree, and it is no longer clear", "doc_id": "d6bf58e6-7ec4-4f9e-9e53-0bb53d80f9f1", "embedding": null, "doc_hash": "7b2f293a15deaba7dcd03f06b50a9b3388fe90f40886e36542e1b4047485b9cd", "extra_info": null, "node_info": {"start": 794842, "end": 798721, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "f45d38b7-9cad-49b8-8f66-ac61a426e089", "3": "e78df40e-b437-40f5-ac1d-b3d5bb686836"}}, "__type__": "1"}, "e78df40e-b437-40f5-ac1d-b3d5bb686836": {"__data__": {"text": "statistical learning\nprocedure using a single tree, and it is no longer clear which variables\nare most important to the procedure. Thus, bagging improves prediction\naccuracy at the expense of interpretability.\nAlthough the collection of bagged trees is much more difficult to interpret\nthan a single tree, one can obtain an overall summary of the importance of\neach predictor using the RSS (for bagging regression trees) or the Gini index\n(for bagging classification trees). In the case of bagging regression trees, we\ncan record the total amount that the RSS (8.1) is decreased due to splits\nover a given predictor, averaged over all B trees. A large value indicates\nan important predictor. Similarly, in the context of bagging classification\ntrees, we can add up the total amount that the Gini index (8.6) is decreased\nby splits over a given predictor, averaged over all B trees.\nA graphical representation of the variable importances in the Heart data\nvariable\nis shown in Figure 8.9.We see the mean decrease in Gini index for each vari- importance\nable, relative to the largest. The variables with the largest mean decrease\nin Gini index are Thal, Ca, and ChestPain.\n8.2.2 Random Forests\nRandom forests provide an improvement over bagged trees by way of a\nrandom\nsmall tweak that decorrelates the trees. As in bagging, we build a number forest\nof decision trees on bootstrapped training samples. But when building these\ndecision trees, each time a split in a tree is considered, a random sample of\nm predictors is chosen as split candidates from the full set of p predictors.\nThe split is allowed to use only one of those m predictors. A fresh sample of\nm predictors is taken at each split, and typically we choose m \u2248 \u221ap\u2014that\nis, the number of predictors considered at each split is approximately equal\n344 8. Tree-Based Methods\nThal\nCa\nChestPain\nOldpeak\nMaxHR\nRestBP\nAge\nChol\nSlope\nSex\nExAng\nRestECG\nFbs\n0 20 40 60 80 100\nVariable Importance\nFIGURE 8.9. A variable importance plot for the Heart data. Variable importance\nis computed using the mean decrease in Gini index, and expressed relative\nto the maximum.\nto the square root of the total number of predictors (4 out of the 13 for the\nHeart data).\nIn other words, in building a random forest, at each split in the tree,\nthe algorithm is not even allowed to consider a majority of the available\npredictors. This may sound crazy, but it has a clever rationale. Suppose\nthat there is one very strong predictor in the data set, along with a number\nof other moderately strong predictors. Then in the collection of bagged\ntrees, most or all of the trees will use this strong predictor in the top split.\nConsequently, all of the bagged trees will look quite similar to each other.\nHence the predictions from the bagged trees will be highly correlated. Unfortunately,\naveraging many highly correlated quantities does not lead to\nas large of a reduction in variance as averaging many uncorrelated quantities.\nIn particular, this means that bagging will not lead to a substantial\nreduction in variance over a single tree in this setting.\nRandom forests overcome this problem by forcing each split to consider\nonly a subset of the predictors. Therefore, on average (p \u2212 m)/p of the\nsplits will not even consider the strong predictor, and so other predictors\nwill have more of a chance. We can think of this process as decorrelating\nthe trees, thereby making the average of the resulting trees less variable\nand hence more reliable.\n8.2 Bagging, Random Forests, Boosting, and Bayesian Additive Regression Trees 345\nThe main difference between bagging and random forests is the choice\nof predictor subset size m. For instance, if a random forest is built using\nm = p, then this amounts simply to bagging. On the Heart data, random\nforests using m = \u221ap leads to", "doc_id": "e78df40e-b437-40f5-ac1d-b3d5bb686836", "embedding": null, "doc_hash": "d411a09c45216b3549e7188ad9973fc52aeac2fe3edd6c06c67ab456dcd1c7db", "extra_info": null, "node_info": {"start": 798718, "end": 802525, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "d6bf58e6-7ec4-4f9e-9e53-0bb53d80f9f1", "3": "12766e2d-8679-4d0d-8ba3-87b81b03e9c1"}}, "__type__": "1"}, "12766e2d-8679-4d0d-8ba3-87b81b03e9c1": {"__data__": {"text": "On the Heart data, random\nforests using m = \u221ap leads to a reduction in both test error and OOB error\nover bagging (Figure 8.8).\nUsing a small value of m in building a random forest will typically be\nhelpful when we have a large number of correlated predictors. We applied\nrandom forests to a high-dimensional biological data set consisting of expression\nmeasurements of 4,718 genes measured on tissue samples from 349\npatients. There are around 20,000 genes in humans, and individual genes\nhave different levels of activity, or expression, in particular cells, tissues,\nand biological conditions. In this data set, each of the patient samples has\na qualitative label with 15 different levels: either normal or 1 of 14 different\ntypes of cancer. Our goal was to use random forests to predict cancer type\nbased on the 500 genes that have the largest variance in the training set.\nWe randomly divided the observations into a training and a test set, and\napplied random forests to the training set for three different values of the\nnumber of splitting variables m. The results are shown in Figure 8.10. The\nerror rate of a single tree is 45.7 %, and the null rate is 75.4 %.4 We see that\nusing 400 trees is sufficient to give good performance, and that the choice\nm = \u221ap gave a small improvement in test error over bagging (m = p) in\nthis example. As with bagging, random forests will not overfit if we increase\nB, so in practice we use a value of B sufficiently large for the error rate to\nhave settled down.\n8.2.3 Boosting\nWe now discuss boosting, yet another approach for improving the predicboosting\ntions resulting from a decision tree. Like bagging, boosting is a general\napproach that can be applied to many statistical learning methods for regression\nor classification. Here we restrict our discussion of boosting to the\ncontext of decision trees.\nRecall that bagging involves creating multiple copies of the original training\ndata set using the bootstrap, fitting a separate decision tree to each\ncopy, and then combining all of the trees in order to create a single predictive\nmodel. Notably, each tree is built on a bootstrap data set, independent\nof the other trees. Boosting works in a similar way, except that the trees are\ngrown sequentially : each tree is grown using information from previously\ngrown trees. Boosting does not involve bootstrap sampling; instead each\ntree is fit on a modified version of the original data set.\n4The null rate results from simply classifying each observation to the dominant class\noverall, which is in this case the normal class.\n346 8. Tree-Based Methods\n0 100 200 300 400 500\n0.2 0.3 0.4 0.5\nNumber of Trees\nTest Classification Error\nm=p\nm=p/2\nm= p\nFIGURE 8.10. Results from random forests for the 15-class gene expression\ndata set with p = 500 predictors. The test error is displayed as a function of\nthe number of trees. Each colored line corresponds to a different value of m, the\nnumber of predictors available for splitting at each interior tree node. Random\nforests (m < p) lead to a slight improvement over bagging (m = p). A single\nclassification tree has an error rate of 45.7 %.\nConsider first the regression setting. Like bagging, boosting involves combining\na large number of decision trees, \u02c6 f1, . . . , \u02c6 fB. Boosting is described\nin Algorithm 8.2.\nWhat is the idea behind this procedure? Unlike fitting a single large decision\ntree to the data, which amounts to fitting the data hard and potentially\noverfitting, the boosting approach instead learns slowly. Given the current\nmodel, we fit a decision tree to the residuals from the model. That is, we\nfit a tree using the current residuals, rather than the outcome Y , as the response.\nWe then add this new decision tree into the fitted function in order\nto update the residuals. Each of these trees can be rather small, with just\na few terminal nodes, determined by the parameter d in the", "doc_id": "12766e2d-8679-4d0d-8ba3-87b81b03e9c1", "embedding": null, "doc_hash": "94550d2d41893ffc5ade845faad0a960cb24de087755256604356fb66f888e20", "extra_info": null, "node_info": {"start": 802547, "end": 806449, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "e78df40e-b437-40f5-ac1d-b3d5bb686836", "3": "6c91912b-c304-4570-9039-90bb8c4af655"}}, "__type__": "1"}, "6c91912b-c304-4570-9039-90bb8c4af655": {"__data__": {"text": "with just\na few terminal nodes, determined by the parameter d in the algorithm. By\nfitting small trees to the residuals, we slowly improve \u02c6 f in areas where it\ndoes not perform well. The shrinkage parameter \u03bb slows the process down\neven further, allowing more and different shaped trees to attack the residuals.\nIn general, statistical learning approaches that learn slowly tend to\nperform well. Note that in boosting, unlike in bagging, the construction of\neach tree depends strongly on the trees that have already been grown.\nWe have just described the process of boosting regression trees. Boosting\nclassification trees proceeds in a similar but slightly more complex way, and\nthe details are omitted here.\nBoosting has three tuning parameters:\n8.2 Bagging, Random Forests, Boosting, and Bayesian Additive Regression Trees 347\nAlgorithm 8.2 Boosting for Regression Trees\n1. Set \u02c6 f(x) = 0 and ri = yi for all i in the training set.\n2. For b = 1, 2, . . . ,B, repeat:\n(a) Fit a tree \u02c6 fb with d splits (d+1 terminal nodes) to the training\ndata (X, r).\n(b) Update \u02c6 f by adding in a shrunken version of the new tree:\n\u02c6 f(x) \u2190 \u02c6 f(x) + \u03bb \u02c6 fb(x). (8.10)\n(c) Update the residuals,\nri \u2190 ri \u2212 \u03bb \u02c6 fb(xi). (8.11)\n3. Output the boosted model,\n\u02c6 f(x) =\n0B\nb=1\n\u03bb \u02c6 fb(x). (8.12)\n1. The number of trees B. Unlike bagging and random forests, boosting\ncan overfit if B is too large, although this overfitting tends to occur\nslowly if at all. We use cross-validation to select B.\n2. The shrinkage parameter \u03bb, a small positive number. This controls the\nrate at which boosting learns. Typical values are 0.01 or 0.001, and\nthe right choice can depend on the problem. Very small \u03bb can require\nusing a very large value of B in order to achieve good performance.\n3. The number d of splits in each tree, which controls the complexity\nof the boosted ensemble. Often d = 1 works well, in which case each\ntree is a stump, consisting of a single split. In this case, the boosted\nstump\nensemble is fitting an additive model, since each term involves only a\nsingle variable. More generally d is the interaction depth, and controls\ninteraction\nthe interaction order of the boosted model, since d splits can involve depth\nat most d variables.\nIn Figure 8.11, we applied boosting to the 15-class cancer gene expression\ndata set, in order to develop a classifier that can distinguish the normal\nclass from the 14 cancer classes. We display the test error as a function of\nthe total number of trees and the interaction depth d. We see that simple\nstumps with an interaction depth of one perform well if enough of them\nare included. This model outperforms the depth-two model, and both outperform\na random forest. This highlights one difference between boosting\n348 8. Tree-Based Methods\n0 1000 2000 3000 4000 5000\n0.05 0.10 0.15 0.20 0.25\nNumber of Trees\nTest Classification Error\nBoosting: depth=1\nBoosting: depth=2\nRandomForest: m= p\nFIGURE 8.11. Results from performing boosting and random forests on the\n15-class gene expression data set in order to predict cancer versus normal. The\ntest error is displayed as a function of the number of trees. For the two boosted\nmodels, \u03bb = 0.01. Depth-1 trees slightly outperform depth-2 trees, and both outperform\nthe random forest, although the standard errors are around 0.02, making\nnone of these differences significant. The test error rate for a single tree is 24 %.\nand random forests: in boosting, because the growth of a particular tree\ntakes into account the other trees that have already been grown,", "doc_id": "6c91912b-c304-4570-9039-90bb8c4af655", "embedding": null, "doc_hash": "7ef5cb631002840e69709682795c2126568cbf1cd71beb9d86d8560bf29f6299", "extra_info": null, "node_info": {"start": 806438, "end": 809964, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "12766e2d-8679-4d0d-8ba3-87b81b03e9c1", "3": "24df013c-53c9-4e76-835a-e247653e0040"}}, "__type__": "1"}, "24df013c-53c9-4e76-835a-e247653e0040": {"__data__": {"text": "a particular tree\ntakes into account the other trees that have already been grown, smaller\ntrees are typically sufficient. Using smaller trees can aid in interpretability\nas well; for instance, using stumps leads to an additive model.\n8.2.4 Bayesian Additive Regression Trees\nFinally, we discuss Bayesian additive regression trees (BART), another en-\nBayesian\nadditive\nregression\ntrees\nsemble method that uses decision trees as its building blocks. For simplicity,\nwe present BART for regression (as opposed to classification).\nRecall that bagging and random forests make predictions from an average\nof regression trees, each of which is built using a random sample of data\nand/or predictors. Each tree is built separately from the others. By contrast,\nboosting uses a weighted sum of trees, each of which is constructed\nby fitting a tree to the residual of the current fit. Thus, each new tree attempts\nto capture signal that is not yet accounted for by the current set\nof trees. BART is related to both approaches: each tree is constructed in\na random manner as in bagging and random forests, and each tree tries to\ncapture signal not yet accounted for by the current model, as in boosting.\nThe main novelty in BART is the way in which new trees are generated.\nBefore we introduce the BART algorithm, we define some notation. We\nlet K denote the number of regression trees, and B the number of iterations\nfor which the BART algorithm will be run. The notation \u02c6 fb\nk(x) represents\n8.2 Bagging, Random Forests, Boosting, and Bayesian Additive Regression Trees 349\n(a): \u02c6 fb\u22121\nk (X) (b): Possibility #1 for \u02c6 fb\nk(X)\nX < 1|69.17\nX < 114.305\nX < 140.35\n\u22120.5031\n0.2667 \u22120.2470\n0.4079\nX < 1|69.17\nX < 114.305\nX < 140.35\n\u22120.5110\n0.2693 \u22120.2649\n0.4221\n(c): Possibility #2 for \u02c6 fb\nk(X) (d): Possibility #3 for \u02c6 fb\nk(X)\nX < 1|69.17\n\u22120.1218 0.4079\nX < 1|69.17\nX < 114.305\nX < 106.755 X < 140.35\n\u22120.05089 \u22121.03100\n0.26670 \u22120.24700\n0.40790\nFIGURE 8.12. A schematic of perturbed trees from the BART algorithm. (a):\nThe kth tree at the (b\u22121)st iteration, \u02c6 fb\u22121\nk (X), is displayed. Panels (b)\u2013(d) display\nthree of many possibilities for \u02c6 fb\nk(X), given the form of \u02c6 fb\u22121\nk (X). (b): One\npossibility is that \u02c6 fb\nk(X) has the same structure as \u02c6 fb\u22121\nk (X), but with different\npredictions at the terminal nodes. (c): Another possibility is that \u02c6 fb\nk(X) results\nfrom pruning \u02c6 fb\u22121\nk (X). (d): Alternatively, \u02c6 fb\nk(X) may have more terminal nodes\nthan \u02c6 fb\u22121\nk (X).\nthe prediction at x for the kth regression tree used in the bth iteration. At\nthe end of each iteration, the K trees from that iteration will be summed,\ni.e. \u02c6 fb(x) =\n)K\nk=1\n\u02c6 fb\nk(x) for b = 1, . . . ,B.\nIn the first iteration of the BART algorithm, all trees are initialized to\nhave a single root node, with \u02c6 f1\nk (x) = 1\nnK\n)n\ni=1 yi, the mean of the response\nvalues divided by the total number of trees. Thus, \u02c6 f1(x) =\n)K\nk=1\n\u02c6 f1\nk (x) =\n1n\n)n\ni=1", "doc_id": "24df013c-53c9-4e76-835a-e247653e0040", "embedding": null, "doc_hash": "f8809a40921a156c6581c7afbe319d400da4dc6cf2bafe7fbeaeff978050b9f2", "extra_info": null, "node_info": {"start": 809952, "end": 812867, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "6c91912b-c304-4570-9039-90bb8c4af655", "3": "fbcf3197-ec43-49df-bdb9-da8bd4f0b84e"}}, "__type__": "1"}, "fbcf3197-ec43-49df-bdb9-da8bd4f0b84e": {"__data__": {"text": "f1\nk (x) =\n1n\n)n\ni=1 yi.\nIn subsequent iterations, BART updates each of the K trees, one at a\ntime. In the bth iteration, to update the kth tree, we subtract from each\nresponse value the predictions from all but the kth tree, in order to obtain\na partial residual\nri = yi \u2212\n0\nk\u2032<k\n\u02c6 fb\nk\u2032 (xi) \u2212\n0\nk\u2032>k\n\u02c6 fb\u22121\nk\u2032 (xi)\nfor the ith observation, i = 1, . . . ,n. Rather than fitting a fresh tree to this\npartial residual, BART randomly chooses a perturbation to the tree from\nthe previous iteration ( \u02c6 fb\u22121\nk ) from a set of possible perturbations, favoring\nones that improve the fit to the partial residual. There are two components\nto this perturbation:\n350 8. Tree-Based Methods\n1. We may change the structure of the tree by adding or pruning branches.\n2. We may change the prediction in each terminal node of the tree.\nFigure 8.12 illustrates examples of possible perturbations to a tree.\nThe output of BART is a collection of prediction models,\n\u02c6 fb(x) =\n0K\nk=1\n\u02c6 fb\nk(x), for b = 1, 2, . . . ,B.\nWe typically throw away the first few of these prediction models, since\nmodels obtained in the earlier iterations \u2014 known as the burn-in period\nburn-in\n\u2014 tend not to provide very good results. We can let L denote the number\nof burn-in iterations; for instance, we might take L = 200. Then, to\nobtain a single prediction, we simply take the average after the burn-in\niterations, \u02c6 f(x) = 1\nB\u2212L\n)B\nb=L+1\n\u02c6 fb(x). However, it is also possible to compute\nquantities other than the average: for instance, the percentiles of\n\u02c6 fL+1(x), . . . , \u02c6 fB(x) provide a measure of uncertainty in the final prediction.\nThe overall BART procedure is summarized in Algorithm 8.3.\nA key element of the BART approach is that in Step 3(a)ii., we do not fit\na fresh tree to the current partial residual: instead, we try to improve the fit\nto the current partial residual by slightly modifying the tree obtained in the\nprevious iteration (see Figure 8.12). Roughly speaking, this guards against\noverfitting since it limits how \u201chard\u201d we fit the data in each iteration.\nFurthermore, the individual trees are typically quite small. We limit the\ntree size in order to avoid overfitting the data, which would be more likely\nto occur if we grew very large trees.\nFigure 8.13 shows the result of applying BART to the Heart data, using\nK = 200 trees, as the number of iterations is increased to 10, 000. During\nthe initial iterations, the test and training errors jump around a bit. After\nthis initial burn-in period, the error rates settle down. We note that there\nis only a small difference between the training error and the test error,\nindicating that the tree perturbation process largely avoids overfitting.\nThe training and test errors for boosting are also displayed in Figure 8.13.\nWe see that the test error for boosting approaches that of BART, but then\nbegins to increase as the number of iterations increases. Furthermore, the\ntraining error for boosting decreases as the number of iterations increases,\nindicating that boosting has overfit the data.\nThough the details are outside of the scope of this book, it turns out\nthat the BART method can be viewed as a Bayesian approach to fitting an\nensemble of trees: each time we randomly perturb a tree in order to fit the\nresiduals, we are in fact drawing a new tree from a posterior distribution.\n(Of course, this Bayesian connection is the motivation for BART\u2019s name.)\nFurthermore, Algorithm 8.3 can be viewed as a Markov chain Monte", "doc_id": "fbcf3197-ec43-49df-bdb9-da8bd4f0b84e", "embedding": null, "doc_hash": "c08630f3b0ac73b8947d2b814dada304bd25e592b9f42b198428a0513b5ffe8c", "extra_info": null, "node_info": {"start": 812920, "end": 816387, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "24df013c-53c9-4e76-835a-e247653e0040", "3": "f8d051eb-a52e-4301-9610-273fff258116"}}, "__type__": "1"}, "f8d051eb-a52e-4301-9610-273fff258116": {"__data__": {"text": "Algorithm 8.3 can be viewed as a Markov chain Monte Carlo\nMarkov\nchain Monte\nCarlo\nalgorithm for fitting the BART model.\n8.2 Bagging, Random Forests, Boosting, and Bayesian Additive Regression Trees 351\nAlgorithm 8.3 Bayesian Additive Regression Trees\n1. Let \u02c6 f1\n1 (x) = \u02c6 f1\n2 (x) = \u00b7 \u00b7 \u00b7 = \u02c6 f1K\n(x) = 1\nnK\n)n\ni=1 yi.\n2. Compute \u02c6 f1(x) =\n)K\nk=1\n\u02c6 f1\nk (x) = 1n\n)n\ni=1 yi.\n3. For b = 2, . . . ,B:\n(a) For k = 1, 2, . . . ,K:\ni. For i = 1, . . . ,n, compute the current partial residual\nri = yi \u2212\n0\nk\u2032<k\n\u02c6 fb\nk\u2032 (xi) \u2212\n0\nk\u2032>k\n\u02c6 fb\u22121\nk\u2032 (xi).\nii. Fit a new tree, \u02c6 fb\nk(x), to ri, by randomly perturbing the\nkth tree from the previous iteration, \u02c6 fb\u22121\nk (x). Perturbations\nthat improve the fit are favored.\n(b) Compute \u02c6 fb(x) =\n)K\nk=1\n\u02c6 fb\nk(x).\n4. Compute the mean after L burn-in samples,\n\u02c6 f(x) =\n1\nB \u2212 L\n0B\nb=L+1\n\u02c6 fb(x).\nWhen we apply BART, we must select the number of trees K, the number\nof iterations B, and the number of burn-in iterations L.We typically choose\nlarge values for B and K, and a moderate value for L: for instance, K = 200,\nB = 1,000, and L = 100 is a reasonable choice. BART has been shown to\nhave very impressive out-of-box performance \u2014 that is, it performs well\nwith minimal tuning.\n8.2.5 Summary of Tree Ensemble Methods\nTrees are an attractive choice of weak learner for an ensemble method\nfor a number of reasons, including their flexibility and ability to handle\npredictors of mixed types (i.e. qualitative as well as quantitative). We have\nnow seen four approaches for fitting an ensemble of trees: bagging, random\nforests, boosting, and BART.\n\u2022 In bagging, the trees are grown independently on random samples of\nthe observations. Consequently, the trees tend to be quite similar to\neach other. Thus, bagging can get caught in local optima and can fail\nto thoroughly explore the model space.\n352 8. Tree-Based Methods\n5 10 50 100 500 5000\n0.0 0.1 0.2 0.3 0.4 0.5\nNumber of Iterations\nError\nBART Training Error\nBART Test Error\nBoosting Training Error\nBoosting Test Error\nFIGURE 8.13. BART and boosting results for the Heart data. Both training\nand test errors are displayed. After a burn-in period of 100 iterations (shown in\ngray), the error rates for BART settle down. Boosting begins to overfit after a\nfew hundred iterations.\n\u2022 In random forests, the trees are once again grown independently on\nrandom samples of the observations. However, each split on each tree\nis performed using a random subset of the features, thereby decorrelating\nthe trees, and leading to a more thorough exploration of model\nspace relative to bagging.\n\u2022 In boosting, we only use the original data, and do not draw any random\nsamples. The trees are grown successively, using a \u201cslow\u201d learning\napproach: each new tree is fit to the signal that is left over from\nthe earlier trees, and shrunken down before it is used.\n\u2022 In BART, we once again only make use of the original data, and we\ngrow the trees successively. However, each tree is perturbed in order\nto avoid local minima and achieve a more thorough exploration of\nthe model space.\n8.3 Lab: Decision Trees", "doc_id": "f8d051eb-a52e-4301-9610-273fff258116", "embedding": null, "doc_hash": "fdac458904716064ec5b01684f132a13b58ce36aa5a0959d313ede6a0e184646", "extra_info": null, "node_info": {"start": 816364, "end": 819438, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "fbcf3197-ec43-49df-bdb9-da8bd4f0b84e", "3": "e42c8f67-6977-4b71-adb3-63f6109bdcee"}}, "__type__": "1"}, "e42c8f67-6977-4b71-adb3-63f6109bdcee": {"__data__": {"text": "thorough exploration of\nthe model space.\n8.3 Lab: Decision Trees 353\n8.3 Lab: Decision Trees\n8.3.1 Fitting Classification Trees\nThe tree library is used to construct classification and regression trees.\n> library(tree)\nWe first use classification trees to analyze the Carseats data set. In these\ndata, Sales is a continuous variable, and so we begin by recoding it as a\nbinary variable. We use the ifelse() function to create a variable, called\nifelse()\nHigh, which takes on a value of Yes if the Sales variable exceeds 8, and\ntakes on a value of No otherwise.\n> library(ISLR2)\n> attach(Carseats)\n> High <- factor(ifelse(Sales <= 8, \"No\", \"Yes\"))\nFinally, we use the data.frame() function to merge High with the rest of\nthe Carseats data.\n> Carseats <- data.frame(Carseats , High)\nWe now use the tree() function to fit a classification tree in order to predict\ntree()\nHigh using all variables but Sales. The syntax of the tree() function is quite\nsimilar to that of the lm() function.\n> tree.carseats <- tree(High \u223c . - Sales, Carseats)\nThe summary() function lists the variables that are used as internal nodes\nin the tree, the number of terminal nodes, and the (training) error rate.\n> summary(tree.carseats)\nClassification tree:\ntree(formula = High \u223c . - Sales, data = Carseats)\nVariables actually used in tree construction:\n[1] \"ShelveLoc\" \"Price\" \"Income\" \"CompPrice\"\n[5] \"Population\" \"Advertising\" \"Age\" \"US\"\nNumber of terminal nodes: 27\nResidual mean deviance: 0.4575 = 170.7 / 373\nMisclassification error rate: 0.09 = 36 / 400\nWe see that the training error rate is 9 %. For classification trees, the deviance\nreported in the output of summary() is given by\n\u22122\n0\nm\n0\nk\nnmk log \u02c6pmk,\nwhere nmk is the number of observations in the mth terminal node that\nbelong to the kth class. This is closely related to the entropy, defined in\n(8.7). A small deviance indicates a tree that provides a good fit to the\n(training) data. The residual mean deviance reported is simply the deviance\ndivided by n\u2212|T0|, which in this case is 400 \u2212 27 = 373.\n354 8. Tree-Based Methods\nOne of the most attractive properties of trees is that they can be\ngraphically displayed. We use the plot() function to display the tree structure,\nand the text() function to display the node labels. The argument\npretty = 0 instructs R to include the category names for any qualitative\npredictors, rather than simply displaying a letter for each category.\n> plot(tree.carseats)\n> text(tree.carseats , pretty = 0)\nThe most important indicator of Sales appears to be shelving location,\nsince the first branch differentiates Good locations from Bad and Medium\nlocations.\nIf we just type the name of the tree object, R prints output corresponding\nto each branch of the tree. R displays the split criterion (e.g. Price < 92.5),\nthe number of observations in that branch, the deviance, the overall prediction\nfor the branch (Yes or No), and the fraction of observations in that\nbranch that take on values of Yes and No. Branches that lead to terminal\nnodes are indicated using asterisks.\n> tree.carseats\nnode), split , n, deviance , yval , (yprob)\n* denotes terminal node\n1) root 400 541.5 No ( 0.590 0.410 )\n2) ShelveLoc: Bad ,Medium 315 390.6 No ( 0.689 0.311 )\n4) Price < 92.5 46 56.53 Yes ( 0.304 0.696 )\n8) Income < 57 10 12.22 No ( 0.700 0.300 )\nIn order to properly evaluate the performance of a classification tree", "doc_id": "e42c8f67-6977-4b71-adb3-63f6109bdcee", "embedding": null, "doc_hash": "eced25e49268e5c24a53e6c1bfd4309d25d9be3945313ac77ddfcda3ebe097d0", "extra_info": null, "node_info": {"start": 819424, "end": 822809, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "f8d051eb-a52e-4301-9610-273fff258116", "3": "539997ac-9c57-4cf3-87ab-74294fb67884"}}, "__type__": "1"}, "539997ac-9c57-4cf3-87ab-74294fb67884": {"__data__": {"text": "0.300 )\nIn order to properly evaluate the performance of a classification tree on\nthese data, we must estimate the test error rather than simply computing\nthe training error. We split the observations into a training set and a test\nset, build the tree using the training set, and evaluate its performance on the\ntest data. The predict() function can be used for this purpose. In the case\nof a classification tree, the argument type = \"class\" instructs R to return\nthe actual class prediction. This approach leads to correct predictions for\naround 77% of the locations in the test data set.\n> set.seed (2)\n> train <- sample (1: nrow(Carseats), 200)\n> Carseats.test <- Carseats[-train, ]\n> High.test <- High[-train]\n> tree.carseats <- tree(High \u223c . - Sales, Carseats,\nsubset = train)\n> tree.pred <- predict(tree.carseats , Carseats.test ,\ntype = \"class\")\n> table(tree.pred , High.test)\nHigh.test\ntree.pred No Yes\nNo 104 33\nYes 13 50\n> (104 + 50) / 200\n[1] 0.77\n8.3 Lab: Decision Trees 355\n(If you re-run the predict() function then you might get slightly different\nresults, due to \u201cties\u201d: for instance, this can happen when the training observations\ncorresponding to a terminal node are evenly split between Yes\nand No response values.)\nNext, we consider whether pruning the tree might lead to improved\nresults. The function cv.tree() performs cross-validation in order to\ncv.tree()\ndetermine the optimal level of tree complexity; cost complexity pruning\nis used in order to select a sequence of trees for consideration. We use\nthe argument FUN = prune.misclass in order to indicate that we want the\nclassification error rate to guide the cross-validation and pruning process,\nrather than the default for the cv.tree() function, which is deviance. The\ncv.tree() function reports the number of terminal nodes of each tree considered\n(size) as well as the corresponding error rate and the value of the\ncost-complexity parameter used (k, which corresponds to \u03b1 in (8.4)).\n> set.seed (7)\n> cv.carseats <- cv.tree(tree.carseats , FUN = prune.misclass)\n> names(cv.carseats)\n[1] \"size\" \"dev\" \"k\" \"method\"\n> cv.carseats\n$size\n[1] 21 19 14 9 8 5 3 2 1\n$dev\n[1] 75 75 75 74 82 83 83 85 82\n$k\n[1] -Inf 0.0 1.0 1.4 2.0 3.0 4.0 9.0 18.0\n$method\n[1] \"misclass\"\nattr(,\"class \")\n[1] \"prune\" \"tree.sequence\"\nDespite its name, dev corresponds to the number of cross-validation errors.\nThe tree with 9 terminal nodes results in only 74 cross-validation errors.\nWe plot the error rate as a function of both size and k.\n> par(mfrow = c(1, 2))\n> plot(cv.carseats$size , cv.carseats$dev, type = \"b\")\n> plot(cv.carseats$k, cv.carseats$dev, type = \"b\")\nWe now apply the prune.misclass() function in order to prune the tree to\nobtain the nine-node tree.\n> prune.carseats <- prune.misclass(tree.carseats , best = 9)\n> plot(prune.carseats)\n> text(prune.carseats , pretty = 0)\nHow well does this pruned tree perform on the test data set? Once again,\nwe apply the predict() function.\n> tree.pred <- predict(prune.carseats , Carseats.test ,\ntype = \"class\")\n> table(tree.pred , High.test)\nHigh.test\nprune.misclass()\n356 8. Tree-Based Methods\ntree.pred No Yes\nNo 97", "doc_id": "539997ac-9c57-4cf3-87ab-74294fb67884", "embedding": null, "doc_hash": "058641a5c8e54a4c1320d4288196676e88ae3ef65280f97089e37a7e021f86f1", "extra_info": null, "node_info": {"start": 822800, "end": 825930, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "e42c8f67-6977-4b71-adb3-63f6109bdcee", "3": "185c1d10-b04f-4d71-88c6-7408f190ebed"}}, "__type__": "1"}, "185c1d10-b04f-4d71-88c6-7408f190ebed": {"__data__": {"text": "8. Tree-Based Methods\ntree.pred No Yes\nNo 97 25\nYes 20 58\n> (97 + 58) / 200\n[1] 0.775\nNow 77.5% of the test observations are correctly classified, so not only has\nthe pruning process produced a more interpretable tree, but it has also\nslightly improved the classification accuracy.\nIf we increase the value of best, we obtain a larger pruned tree with lower\nclassification accuracy:\n> prune.carseats <- prune.misclass(tree.carseats , best = 14)\n> plot(prune.carseats)\n> text(prune.carseats , pretty = 0)\n> tree.pred <- predict(prune.carseats , Carseats.test ,\ntype = \"class\")\n> table(tree.pred , High.test)\nHigh.test\ntree.pred No Yes\nNo 102 31\nYes 15 52\n> (102 + 52) / 200\n[1] 0.77\n8.3.2 Fitting Regression Trees\nHere we fit a regression tree to the Boston data set. First, we create a\ntraining set, and fit the tree to the training data.\n> set.seed (1)\n> train <- sample (1: nrow(Boston), nrow(Boston) / 2)\n> tree.boston <- tree(medv \u223c ., Boston , subset = train)\n> summary(tree.boston)\nRegression tree:\ntree(formula = medv \u223c ., data = Boston , subset = train)\nVariables actually used in tree construction:\n[1] \"rm\" \"lstat\" \"crim\" \"age\"\nNumber of terminal nodes: 7\nResidual mean deviance: 10.4 = 2550 / 246\nDistribution of residuals:\nMin. 1st Qu. Median Mean 3rd Qu. Max.\n-10.200 -1.780 -0.177 0.000 1.920 16.600\nNotice that the output of summary() indicates that only four of the variables\nhave been used in constructing the tree. In the context of a regression tree,\nthe deviance is simply the sum of squared errors for the tree. We now plot\nthe tree.\n> plot(tree.boston)\n> text(tree.boston , pretty = 0)\n8.3 Lab: Decision Trees 357\nThe variable lstat measures the percentage of individuals with lower\nsocioeconomic status, while the variable rm corresponds to the average number\nof rooms. The tree indicates that larger values of rm, or lower values of\nlstat, correspond to more expensive houses. For example, the tree predicts\na median house price of $45,400 for homes in census tracts in which rm >=\n7.553.\nIt is worth noting that we could have fit a much bigger tree, by passing\ncontrol = tree.control(nobs = length(train), mindev = 0) into the\ntree() function.\nNow we use the cv.tree() function to see whether pruning the tree will\nimprove performance.\n> cv.boston <- cv.tree(tree.boston)\n> plot(cv.boston$size , cv.boston$dev, type = \"b\")\nIn this case, the most complex tree under consideration is selected by crossvalidation.\nHowever, if we wish to prune the tree, we could do so as follows,\nusing the prune.tree() function:\nprune.tree()\n> prune.boston <- prune.tree(tree.boston , best = 5)\n> plot(prune.boston)\n> text(prune.boston , pretty = 0)\nIn keeping with the cross-validation results, we use the unpruned tree to\nmake predictions on the test set.\n> yhat <- predict(tree.boston , newdata = Boston[-train , ])\n> boston.test <- Boston[-train, \"medv\"]\n> plot(yhat , boston.test)\n> abline (0, 1)\n> mean (( yhat - boston.test)^2)\n[1] 35.29\nIn other words, the test set MSE associated with the regression tree is 35.29.\nThe square root of the MSE is therefore around 5.941, indicating that", "doc_id": "185c1d10-b04f-4d71-88c6-7408f190ebed", "embedding": null, "doc_hash": "67e9c5ded8c61fa033534310523213303e0fb38032ac78fc90edb5f7e395c9ee", "extra_info": null, "node_info": {"start": 825959, "end": 829058, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "539997ac-9c57-4cf3-87ab-74294fb67884", "3": "41de17aa-b73a-428e-8755-2efe6c2c2524"}}, "__type__": "1"}, "41de17aa-b73a-428e-8755-2efe6c2c2524": {"__data__": {"text": "square root of the MSE is therefore around 5.941, indicating that this\nmodel leads to test predictions that are (on average) within approximately\n$5,941 of the true median home value for the census tract.\n8.3.3 Bagging and Random Forests\nHere we apply bagging and random forests to the Boston data, using the\nrandomForest package in R. The exact results obtained in this section may\ndepend on the version of R and the version of the randomForest package\ninstalled on your computer. Recall that bagging is simply a special case of\na random forest with m = p. Therefore, the randomForest() function can\nrandomForest()\nbe used to perform both random forests and bagging. We perform bagging\nas follows:\n> library(randomForest)\n> set.seed (1)\n> bag.boston <- randomForest(medv \u223c ., data = Boston ,\n358 8. Tree-Based Methods\nsubset = train , mtry = 12, importance = TRUE)\n> bag.boston\nCall:\nrandomForest(formula = medv \u223c ., data = Boston , mtry = 12,\nimportance = TRUE , subset = train)\nType of random forest: regression\nNumber of trees: 500\nNo. of variables tried at each split: 12\nMean of squared residuals: 11.40\n% Var explained: 85.17\nThe argument mtry = 12 indicates that all 12 predictors should be considered\nfor each split of the tree\u2014in other words, that bagging should be done.\nHow well does this bagged model perform on the test set?\n> yhat.bag <- predict(bag.boston , newdata = Boston[-train , ])\n> plot(yhat.bag , boston.test)\n> abline (0, 1)\n> mean (( yhat.bag - boston.test)^2)\n[1] 23.42\nThe test set MSE associated with the bagged regression tree is 23.42, about\ntwo-thirds of that obtained using an optimally-pruned single tree.We could\nchange the number of trees grown by randomForest() using the ntree argument:\n> bag.boston <- randomForest(medv \u223c ., data = Boston ,\nsubset = train , mtry = 12, ntree = 25)\n> yhat.bag <- predict(bag.boston , newdata = Boston[-train , ])\n> mean (( yhat.bag - boston.test)^2)\n[1] 25.75\nGrowing a random forest proceeds in exactly the same way, except that\nwe use a smaller value of the mtry argument. By default, randomForest()\nuses p/3 variables when building a random forest of regression trees, and\n\u221ap variables when building a random forest of classification trees. Here we\nuse mtry = 6.\n> set.seed (1)\n> rf.boston <- randomForest(medv \u223c ., data = Boston ,\nsubset = train , mtry = 6, importance = TRUE)\n> yhat.rf <- predict(rf.boston, newdata = Boston[-train , ])\n> mean (( yhat.rf - boston.test)^2)\n[1] 20.07\nThe test set MSE is 20.07; this indicates that random forests yielded an\nimprovement over bagging in this case.\nUsing the importance() function, we can view the importance of each\nimportance()\nvariable.\n> importance(rf.boston)\n%IncMSE IncNodePurity\ncrim 19.436 1070.42\n8.3 Lab: Decision Trees 359\nzn 3.092 82.19\nindus 6.141 590.10\nchas 1.370 36.70\nnox 13.263 859.97\nrm 35.095 8270.34\nage 15.145 634.31\ndis 9.164 684.88\nrad 4.794 83.19\ntax 4.411 292.21\nptratio 8.613 902.20\nlstat 28.725 5813.05\nTwo measures of variable importance are reported. The first is based upon\nthe mean decrease of accuracy in predictions on the out of bag samples when\na given variable is permuted. The second is a measure of the total", "doc_id": "41de17aa-b73a-428e-8755-2efe6c2c2524", "embedding": null, "doc_hash": "5ceaefb7ae2943e380b5903e579abdeac80b94fbad5cd9173d0bd8585587efa7", "extra_info": null, "node_info": {"start": 829043, "end": 832212, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "185c1d10-b04f-4d71-88c6-7408f190ebed", "3": "34124fcf-ca8e-4bb2-984e-f6e5fb7ced8b"}}, "__type__": "1"}, "34124fcf-ca8e-4bb2-984e-f6e5fb7ced8b": {"__data__": {"text": "samples when\na given variable is permuted. The second is a measure of the total decrease\nin node impurity that results from splits over that variable, averaged over\nall trees (this was plotted in Figure 8.9). In the case of regression trees,\nthe node impurity is measured by the training RSS, and for classification\ntrees by the deviance. Plots of these importance measures can be produced\nusing the varImpPlot() function.\nvarImpPlot()\n> varImpPlot(rf.boston)\nThe results indicate that across all of the trees considered in the random\nforest, the wealth of the community (lstat) and the house size (rm) are by\nfar the two most important variables.\n8.3.4 Boosting\nHere we use the gbm package, and within it the gbm() function, to fit boosted\ngbm()\nregression trees to the Boston data set. We run gbm() with the option\ndistribution = \"gaussian\" since this is a regression problem; if it were\na binary classification problem, we would use distribution = \"bernoulli\".\nThe argument n.trees = 5000 indicates that we want 5000 trees, and the\noption interaction.depth = 4 limits the depth of each tree.\n> library(gbm)\n> set.seed (1)\n> boost.boston <- gbm(medv \u223c ., data = Boston[train , ],\ndistribution = \"gaussian\", n.trees = 5000,\ninteraction.depth = 4)\nThe summary() function produces a relative influence plot and also outputs\nthe relative influence statistics.\n> summary(boost.boston)\nvar rel.inf\nrm rm 44.482\nlstat lstat 32.703\ncrim crim 4.851\ndis dis 4.487\nnox nox 3.752\n360 8. Tree-Based Methods\nage age 3.198\nptratio ptratio 2.814\ntax tax 1.544\nindus indus 1.034\nrad rad 0.876\nzn zn 0.162\nchas chas 0.097\nWe see that lstat and rm are by far the most important variables. We can\nalso produce partial dependence plots for these two variables. These plots\npartial\ndependence\nplot\nillustrate the marginal effect of the selected variables on the response after\nintegrating out the other variables. In this case, as we might expect, median\nhouse prices are increasing with rm and decreasing with lstat.\n> plot(boost.boston , i = \"rm\")\n> plot(boost.boston , i = \"lstat\")\nWe now use the boosted model to predict medv on the test set:\n> yhat.boost <- predict(boost.boston ,\nnewdata = Boston[-train , ], n.trees = 5000)\n> mean (( yhat.boost - boston.test)^2)\n[1] 18.39\nThe test MSE obtained is 18.39: this is superior to the test MSE of random\nforests and bagging. If we want to, we can perform boosting with a different\nvalue of the shrinkage parameter \u03bb in (8.10). The default value is 0.001,\nbut this is easily modified. Here we take \u03bb = 0.2.\n> boost.boston <- gbm(medv \u223c ., data = Boston[train , ],\ndistribution = \"gaussian\", n.trees = 5000,\ninteraction.depth = 4, shrinkage = 0.2, verbose = F)\n> yhat.boost <- predict(boost.boston ,\nnewdata = Boston[-train , ], n.trees = 5000)\n> mean (( yhat.boost - boston.test)^2)\n[1] 16.55\nIn this case, using \u03bb = 0.2 leads to a lower test MSE than \u03bb = 0.001.\n8.3.5 Bayesian Additive Regression Trees\nIn this section we use the BART package, and within it the gbart() function,\ngbart()\nto fit a Bayesian additive regression tree model to the Boston housing data\nset. The gbart() function is designed for quantitative outcome variables.\nFor binary outcomes, lbart() and pbart() are available.\nlbart()\npbart()\nTo run the gbart()", "doc_id": "34124fcf-ca8e-4bb2-984e-f6e5fb7ced8b", "embedding": null, "doc_hash": "9c7fd1706f7229223f9571107aaa558054c3a7252c1f4b05139dd40b750bb463", "extra_info": null, "node_info": {"start": 832202, "end": 835461, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "41de17aa-b73a-428e-8755-2efe6c2c2524", "3": "10287aef-2f93-481d-8d5a-a45274a24250"}}, "__type__": "1"}, "10287aef-2f93-481d-8d5a-a45274a24250": {"__data__": {"text": "are available.\nlbart()\npbart()\nTo run the gbart() function, we must first create matrices of predictors\nfor the training and test data. We run BART with default settings.\n> library(BART)\n> x <- Boston[, 1:12]\n> y <- Boston[, \"medv\"]\n> xtrain <- x[train, ]\n> ytrain <- y[train]\n8.4 Exercises 361\n> xtest <- x[-train, ]\n> ytest <- y[-train]\n> set.seed (1)\n> bartfit <- gbart(xtrain , ytrain , x.test = xtest)\nNext we compute the test error.\n> yhat.bart <- bartfit$yhat.test.mean\n> mean (( ytest - yhat.bart)^2)\n[1] 15.95\nOn this data set, the test error of BART is lower than the test error of\nrandom forests and boosting.\nNow we can check how many times each variable appeared in the collection\nof trees.\n> ord <- order(bartfit$varcount.mean , decreasing = T)\n> bartfit$varcount.mean[ord]\nnox lstat tax rad rm indus chas ptratio\n22.95 21.33 21.25 20.78 19.89 19.82 19.05 18.98\nage zn dis crim\n18.27 15.95 14.46 11.01\n8.4 Exercises\nConceptual\n1. Draw an example (of your own invention) of a partition of twodimensional\nfeature space that could result from recursive binary\nsplitting. Your example should contain at least six regions. Draw a\ndecision tree corresponding to this partition. Be sure to label all aspects\nof your figures, including the regions R1,R2, . . ., the cutpoints\nt1, t2, . . ., and so forth.\nHint: Your result should look something like Figures 8.1 and 8.2.\n2. It is mentioned in Section 8.2.3 that boosting using depth-one trees\n(or stumps) leads to an additive model: that is, a model of the form\nf(X) =\n0p\nj=1\nfj(Xj).\nExplain why this is the case. You can begin with (8.12) in\nAlgorithm 8.2.\n3. Consider the Gini index, classification error, and entropy in a simple\nclassification setting with two classes. Create a single plot that displays\neach of these quantities as a function of \u02c6pm1. The x-axis should\n362 8. Tree-Based Methods\n|\nX2 < 1\nX1 < 1\nX1 < 0\nX2 < 2\n-1.80\n-1.06 0.21\n0.63\n2.49\n5\n15\n10\n0\n3\n0 1\nX2\nX1\n0\n1\nFIGURE 8.14. Left: A partition of the predictor space corresponding to Exercise\n4a. Right: A tree corresponding to Exercise 4b.\ndisplay \u02c6pm1, ranging from 0 to 1, and the y-axis should display the\nvalue of the Gini index, classification error, and entropy.\nHint: In a setting with two classes, \u02c6pm1 = 1 \u2212 \u02c6pm2. You could make\nthis plot by hand, but it will be much easier to make in R.\n4. This question relates to the plots in Figure 8.14.\n(a) Sketch the tree corresponding to the partition of the predictor\nspace illustrated in the left-hand panel of Figure 8.14. The numbers\ninside the boxes indicate the mean of Y within each region.\n(b) Create a diagram similar to the left-hand panel of Figure 8.14,\nusing the tree illustrated in the right-hand panel of the same\nfigure. You should divide up the predictor space into the correct\nregions, and indicate the mean for each region.\n5. Suppose we produce ten bootstrapped samples from a data set\ncontaining red and green classes. We then apply a classification tree\nto each bootstrapped sample and, for a specific value of X, produce\n10 estimates of P(Class is", "doc_id": "10287aef-2f93-481d-8d5a-a45274a24250", "embedding": null, "doc_hash": "b694e5742fa83b26a5d921850457d639a3d278a98e349898fb326889a0f1d6c6", "extra_info": null, "node_info": {"start": 835483, "end": 838531, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "34124fcf-ca8e-4bb2-984e-f6e5fb7ced8b", "3": "396640b7-5f35-48ac-8531-5a49f1ebbcc1"}}, "__type__": "1"}, "396640b7-5f35-48ac-8531-5a49f1ebbcc1": {"__data__": {"text": "and, for a specific value of X, produce\n10 estimates of P(Class is Red|X):\n0.1, 0.15, 0.2, 0.2, 0.55, 0.6, 0.6, 0.65, 0.7, and 0.75.\nThere are two common ways to combine these results together into a\nsingle class prediction. One is the majority vote approach discussed in\nthis chapter. The second approach is to classify based on the average\nprobability. In this example, what is the final classification under each\nof these two approaches?\n6. Provide a detailed explanation of the algorithm that is used to fit a\nregression tree.\n8.4 Exercises 363\nApplied\n7. In the lab, we applied random forests to the Boston data using mtry =\n6 and using ntree = 25 and ntree = 500. Create a plot displaying the\ntest error resulting from random forests on this data set for a more\ncomprehensive range of values for mtry and ntree. You can model\nyour plot after Figure 8.10. Describe the results obtained.\n8. In the lab, a classification tree was applied to the Carseats data set after\nconverting Sales into a qualitative response variable. Now we will\nseek to predict Sales using regression trees and related approaches,\ntreating the response as a quantitative variable.\n(a) Split the data set into a training set and a test set.\n(b) Fit a regression tree to the training set. Plot the tree, and interpret\nthe results. What test MSE do you obtain?\n(c) Use cross-validation in order to determine the optimal level of\ntree complexity. Does pruning the tree improve the test MSE?\n(d) Use the bagging approach in order to analyze this data. What\ntest MSE do you obtain? Use the importance() function to determine\nwhich variables are most important.\n(e) Use random forests to analyze this data. What test MSE do you\nobtain? Use the importance() function to determine which variables\nare most important. Describe the effect of m, the number of\nvariables considered at each split, on the error rate\nobtained.\n(f) Now analyze the data using BART, and report your results.\n9. This problem involves the OJ data set which is part of the ISLR2\npackage.\n(a) Create a training set containing a random sample of 800 observations,\nand a test set containing the remaining observations.\n(b) Fit a tree to the training data, with Purchase as the response\nand the other variables as predictors. Use the summary() function\nto produce summary statistics about the tree, and describe the\nresults obtained. What is the training error rate? How many\nterminal nodes does the tree have?\n(c) Type in the name of the tree object in order to get a detailed\ntext output. Pick one of the terminal nodes, and interpret the\ninformation displayed.\n(d) Create a plot of the tree, and interpret the results.\n(e) Predict the response on the test data, and produce a confusion\nmatrix comparing the test labels to the predicted test labels.\nWhat is the test error rate?\n364 8. Tree-Based Methods\n(f) Apply the cv.tree() function to the training set in order to\ndetermine the optimal tree size.\n(g) Produce a plot with tree size on the x-axis and cross-validated\nclassification error rate on the y-axis.\n(h) Which tree size corresponds to the lowest cross-validated classification\nerror rate?\n(i) Produce a pruned tree corresponding to the optimal tree size\nobtained using cross-validation. If cross-validation does not lead\nto selection of a pruned tree, then create a pruned tree with five\nterminal nodes.\n(j) Compare the training error rates between the pruned and unpruned\ntrees. Which is higher?\n(k) Compare the test error rates between the pruned and unpruned\ntrees. Which is higher?\n10. We now use boosting to predict Salary in the Hitters data set.\n(a) Remove the observations for whom the salary information is\nunknown, and then log-transform the", "doc_id": "396640b7-5f35-48ac-8531-5a49f1ebbcc1", "embedding": null, "doc_hash": "50eb2ebab1edc146b1b420cbac0d9c8a5a8832221ccff675af26ce4b3c9e7d6a", "extra_info": null, "node_info": {"start": 838522, "end": 842223, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "10287aef-2f93-481d-8d5a-a45274a24250", "3": "091bbe47-8f5b-45cf-acac-a10c6a12bb7b"}}, "__type__": "1"}, "091bbe47-8f5b-45cf-acac-a10c6a12bb7b": {"__data__": {"text": "observations for whom the salary information is\nunknown, and then log-transform the salaries.\n(b) Create a training set consisting of the first 200 observations, and\na test set consisting of the remaining observations.\n(c) Perform boosting on the training set with 1,000 trees for a range\nof values of the shrinkage parameter \u03bb. Produce a plot with\ndifferent shrinkage values on the x-axis and the corresponding\ntraining set MSE on the y-axis.\n(d) Produce a plot with different shrinkage values on the x-axis and\nthe corresponding test set MSE on the y-axis.\n(e) Compare the test MSE of boosting to the test MSE that results\nfrom applying two of the regression approaches seen in\nChapters 3 and 6.\n(f) Which variables appear to be the most important predictors in\nthe boosted model?\n(g) Now apply bagging to the training set. What is the test set MSE\nfor this approach?\n11. This question uses the Caravan data set.\n(a) Create a training set consisting of the first 1,000 observations,\nand a test set consisting of the remaining observations.\n(b) Fit a boosting model to the training set with Purchase as the\nresponse and the other variables as predictors. Use 1,000 trees,\nand a shrinkage value of 0.01. Which predictors appear to be\nthe most important?\n8.4 Exercises 365\n(c) Use the boosting model to predict the response on the test data.\nPredict that a person will make a purchase if the estimated probability\nof purchase is greater than 20 %. Form a confusion matrix.\nWhat fraction of the people predicted to make a purchase\ndo in fact make one? How does this compare with the results\nobtained from applying KNN or logistic regression to this data\nset?\n12. Apply boosting, bagging, random forests, and BART to a data set\nof your choice. Be sure to fit the models on a training set and to\nevaluate their performance on a test set. How accurate are the results\ncompared to simple methods like linear or logistic regression? Which\nof these approaches yields the best performance?\n9\nSupport Vector Machines\nIn this chapter, we discuss the support vector machine (SVM), an approach\nfor classification that was developed in the computer science community in\nthe 1990s and that has grown in popularity since then. SVMs have been\nshown to perform well in a variety of settings, and are often considered one\nof the best \u201cout of the box\u201d classifiers.\nThe support vector machine is a generalization of a simple and intuitive\nclassifier called the maximal margin classifier , which we introduce in\nSection 9.1. Though it is elegant and simple, we will see that this classifier\nunfortunately cannot be applied to most data sets, since it requires that\nthe classes be separable by a linear boundary. In Section 9.2, we introduce\nthe support vector classifier , an extension of the maximal margin classifier\nthat can be applied in a broader range of cases. Section 9.3 introduces the\nsupport vector machine, which is a further extension of the support vector\nclassifier in order to accommodate non-linear class boundaries. Support\nvector machines are intended for the binary classification setting in which\nthere are two classes; in Section 9.4 we discuss extensions of support vector\nmachines to the case of more than two classes. In Section 9.5 we discuss\nthe close connections between support vector machines and other statistical\nmethods such as logistic regression.\nPeople often loosely refer to the maximal margin classifier, the support\nvector classifier, and the support vector machine as \u201csupport vector\nmachines\u201d. To avoid confusion, we will carefully distinguish between these\nthree notions in this chapter.\n\u00a9 Springer Science+Business Media, LLC, part of Springer Nature 2021\nG. James et al., An Introduction to Statistical Learning, Springer Texts in Statistics,\nhttps://doi.org/10.1007/978-1-0716-1418-1_9\n367\n368 9. Support Vector Machines\n9.1 Maximal Margin", "doc_id": "091bbe47-8f5b-45cf-acac-a10c6a12bb7b", "embedding": null, "doc_hash": "b04d3c6ac77de0ec64c9bf6685017b9c0d89779997c76a5fd505875e3adc9eca", "extra_info": null, "node_info": {"start": 842206, "end": 846068, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "396640b7-5f35-48ac-8531-5a49f1ebbcc1", "3": "d552c078-f6fd-4294-b114-4b86eccd9e6d"}}, "__type__": "1"}, "d552c078-f6fd-4294-b114-4b86eccd9e6d": {"__data__": {"text": "9. Support Vector Machines\n9.1 Maximal Margin Classifier\nIn this section, we define a hyperplane and introduce the concept of an\noptimal separating hyperplane.\n9.1.1 What Is a Hyperplane?\nIn a p-dimensional space, a hyperplane is a flat affine subspace of\nhyperplane\ndimension p \u2212 1.1 For instance, in two dimensions, a hyperplane is a flat\none-dimensional subspace\u2014in other words, a line. In three dimensions, a\nhyperplane is a flat two-dimensional subspace\u2014that is, a plane. In p > 3\ndimensions, it can be hard to visualize a hyperplane, but the notion of a\n(p \u2212 1)-dimensional flat subspace still applies.\nThe mathematical definition of a hyperplane is quite simple. In two dimensions,\na hyperplane is defined by the equation\n\u03b20 + \u03b21X1 + \u03b22X2 = 0 (9.1)\nfor parameters \u03b20,\u03b21, and \u03b22. When we say that (9.1) \u201cdefines\u201d the hyperplane,\nwe mean that any X = (X1,X2)T for which (9.1) holds is a point\non the hyperplane. Note that (9.1) is simply the equation of a line, since\nindeed in two dimensions a hyperplane is a line.\nEquation 9.1 can be easily extended to the p-dimensional setting:\n\u03b20 + \u03b21X1 + \u03b22X2 + \u00b7 \u00b7 \u00b7 + \u03b2pXp = 0 (9.2)\ndefines a p-dimensional hyperplane, again in the sense that if a point X =\n(X1,X2, . . . ,Xp)T in p-dimensional space (i.e. a vector of length p) satisfies\n(9.2), then X lies on the hyperplane.\nNow, suppose that X does not satisfy (9.2); rather,\n\u03b20 + \u03b21X1 + \u03b22X2 + \u00b7 \u00b7 \u00b7 + \u03b2pXp > 0. (9.3)\nThen this tells us that X lies to one side of the hyperplane. On the other\nhand, if\n\u03b20 + \u03b21X1 + \u03b22X2 + \u00b7 \u00b7 \u00b7 + \u03b2pXp < 0, (9.4)\nthen X lies on the other side of the hyperplane. So we can think of the\nhyperplane as dividing p-dimensional space into two halves. One can easily\ndetermine on which side of the hyperplane a point lies by simply calculating\nthe sign of the left hand side of (9.2). A hyperplane in two-dimensional\nspace is shown in Figure 9.1.\n1The word affine indicates that the subspace need not pass through the origin.\n9.1 Maximal Margin Classifier 369\n\u22121.5 \u22121.0 \u22120.5 0.0 0.5 1.0 1.5\n\u22121.5 \u22121.0 \u22120.5 0.0 0.5 1.0 1.5\nX1\nX2\nFIGURE 9.1. The hyperplane 1 + 2X1 + 3X2 = 0 is shown. The blue region is\nthe set of points for which 1+2X1 +3X2 > 0, and the purple region is the set of\npoints for which 1 + 2X1 + 3X2 < 0.\n9.1.2 Classification Using a Separating Hyperplane\nNow suppose that we have a n\u00d7p data matrix X that consists of n training\nobservations in p-dimensional space,\nx1 =\n\u239b\n\u239c\u239d\nx11\n...\nx1p\n\u239e\n\u239f\u23a0\n, . . . ,xn =\n\u239b\n\u239c\u239d\nxn1\n...\nxnp\n\u239e\n\u239f\u23a0\n, (9.5)\nand that these observations fall into two classes\u2014that is, y1, . . . , yn \u2208\n{\u22121, 1} where \u22121 represents one class and 1 the other class. We also have a\ntest observation, a p-vector of observed features x\u2217 =\n'\nx\u22171 . . . x\u2217p\n(T\n. Our\ngoal is to develop a classifier based on the training data that will correctly\nclassify the", "doc_id": "d552c078-f6fd-4294-b114-4b86eccd9e6d", "embedding": null, "doc_hash": "53f72a7369decb5d9c603b770a6219237cd0dc43f536645286df634ac6ad82dc", "extra_info": null, "node_info": {"start": 846102, "end": 848901, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "091bbe47-8f5b-45cf-acac-a10c6a12bb7b", "3": "9d15e4be-2e23-486b-8e44-136e91a97119"}}, "__type__": "1"}, "9d15e4be-2e23-486b-8e44-136e91a97119": {"__data__": {"text": "is to develop a classifier based on the training data that will correctly\nclassify the test observation using its feature measurements. We have seen\na number of approaches for this task, such as linear discriminant analysis\nand logistic regression in Chapter 4, and classification trees, bagging, and\nboosting in Chapter 8. We will now see a new approach that is based upon\nthe concept of a separating hyperplane.\nseparating\nSuppose that it is possible to construct a hyperplane that separates the hyperplane\ntraining observations perfectly according to their class labels. Examples\nof three such separating hyperplanes are shown in the left-hand panel of\nFigure 9.2. We can label the observations from the blue class as yi = 1 and\nthose from the purple class as yi = \u22121. Then a separating hyperplane has\nthe property that\n\u03b20 + \u03b21xi1 + \u03b22xi2 + \u00b7 \u00b7 \u00b7 + \u03b2pxip > 0 if yi = 1, (9.6)\n370 9. Support Vector Machines\n\u22121 0 1 2 3\n\u22121 0 1 2 3\n\u22121 0 1 2 3\n\u22121 0 1 2 3\nX1 X1\nX2\nX2\nFIGURE 9.2. Left: There are two classes of observations, shown in blue and\nin purple, each of which has measurements on two variables. Three separating\nhyperplanes, out of many possible, are shown in black. Right: A separating hyperplane\nis shown in black. The blue and purple grid indicates the decision rule\nmade by a classifier based on this separating hyperplane: a test observation that\nfalls in the blue portion of the grid will be assigned to the blue class, and a test\nobservation that falls into the purple portion of the grid will be assigned to the\npurple class.\nand\n\u03b20 + \u03b21xi1 + \u03b22xi2 + \u00b7 \u00b7 \u00b7 + \u03b2pxip < 0 if yi = \u22121. (9.7)\nEquivalently, a separating hyperplane has the property that\nyi(\u03b20 + \u03b21xi1 + \u03b22xi2 + \u00b7 \u00b7 \u00b7 + \u03b2pxip) > 0 (9.8)\nfor all i = 1, . . . ,n.\nIf a separating hyperplane exists, we can use it to construct a very natural\nclassifier: a test observation is assigned a class depending on which side of\nthe hyperplane it is located. The right-hand panel of Figure 9.2 shows\nan example of such a classifier. That is, we classify the test observation x\u2217\nbased on the sign of f(x\u2217) = \u03b20+\u03b21x\u22171 +\u03b22x\u22172+\u00b7 \u00b7 \u00b7+\u03b2px\u2217p. If f(x\u2217) is positive,\nthen we assign the test observation to class 1, and if f(x\u2217) is negative, then\nwe assign it to class \u22121. We can also make use of the magnitude of f(x\u2217). If\nf(x\u2217) is far from zero, then this means that x\u2217 lies far from the hyperplane,\nand so we can be confident about our class assignment for x\u2217. On the other\nhand, if f(x\u2217) is close to zero, then x\u2217 is located near the hyperplane, and so\nwe are less certain about the class assignment for x\u2217. Not surprisingly, and\nas we see in Figure 9.2, a classifier that is based on a separating hyperplane\nleads to a linear decision boundary.\n9.1 Maximal Margin Classifier 371\n9.1.3 The Maximal Margin Classifier\nIn general, if our data can be perfectly separated using a hyperplane, then\nthere will in fact exist an infinite number of such hyperplanes. This is\nbecause a given separating hyperplane can usually be shifted a tiny bit up or\ndown, or rotated, without coming into contact with any of the observations.\nThree possible separating hyperplanes are shown in the left-hand panel\nof Figure 9.2. In order to construct a classifier based upon a separating\nhyperplane, we must have a reasonable way to decide which of the infinite\npossible separating hyperplanes to use.\nA natural choice is the maximal margin hyperplane (also known as the\nmaximal\nmargin\nhyperplane\noptimal separating", "doc_id": "9d15e4be-2e23-486b-8e44-136e91a97119", "embedding": null, "doc_hash": "fa6952e0145e080524b21000f27cbe15a89f1148ee20133756d34563dcaa7b1e", "extra_info": null, "node_info": {"start": 848869, "end": 852315, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "d552c078-f6fd-4294-b114-4b86eccd9e6d", "3": "6dac1576-1ecc-4ea4-a1c3-9065d0c10895"}}, "__type__": "1"}, "6dac1576-1ecc-4ea4-a1c3-9065d0c10895": {"__data__": {"text": "hyperplane (also known as the\nmaximal\nmargin\nhyperplane\noptimal separating hyperplane), which is the separating hyperplane that\noptimal\nseparating\nhyperplane\nis farthest from the training observations. That is, we can compute the\n(perpendicular) distance from each training observation to a given separating\nhyperplane; the smallest such distance is the minimal distance from the\nobservations to the hyperplane, and is known as the margin. The maximal\nmargin hyperplane is the separating hyperplane for which the margin is margin\nlargest\u2014that is, it is the hyperplane that has the farthest minimum distance\nto the training observations. We can then classify a test observation\nbased on which side of the maximal margin hyperplane it lies. This is known\nas the maximal margin classifier. We hope that a classifier that has a large\nmaximal\nmargin\nclassifier\nmargin on the training data will also have a large margin on the test data,\nand hence will classify the test observations correctly. Although the maximal\nmargin classifier is often successful, it can also lead to overfitting when\np is large.\nIf \u03b20,\u03b21, . . . ,\u03b2p are the coefficients of the maximal margin hyperplane,\nthen the maximal margin classifier classifies the test observation x\u2217 based\non the sign of f(x\u2217) = \u03b20 + \u03b21x\u22171 + \u03b22x\u22172 + \u00b7 \u00b7 \u00b7 + \u03b2px\u2217p.\nFigure 9.3 shows the maximal margin hyperplane on the data set of\nFigure 9.2. Comparing the right-hand panel of Figure 9.2 to Figure 9.3,\nwe see that the maximal margin hyperplane shown in Figure 9.3 does indeed\nresult in a greater minimal distance between the observations and the\nseparating hyperplane\u2014that is, a larger margin. In a sense, the maximal\nmargin hyperplane represents the mid-line of the widest \u201cslab\u201d that we can\ninsert between the two classes.\nExamining Figure 9.3, we see that three training observations are equidistant\nfrom the maximal margin hyperplane and lie along the dashed lines\nindicating the width of the margin. These three observations are known as\nsupport vectors, since they are vectors in p-dimensional space (in Figure 9.3,\nsupport\np = 2) and they \u201csupport\u201d the maximal margin hyperplane in the sense vector\nthat if these points were moved slightly then the maximal margin hyperplane\nwould move as well. Interestingly, the maximal margin hyperplane\ndepends directly on the support vectors, but not on the other observations:\na movement to any of the other observations would not affect the separating\nhyperplane, provided that the observation\u2019s movement does not cause it to\n372 9. Support Vector Machines\n\u22121 0 1 2 3\n\u22121 0 1 2 3\nX1\nX2\nFIGURE 9.3. There are two classes of observations, shown in blue and in purple.\nThe maximal margin hyperplane is shown as a solid line. The margin is the\ndistance from the solid line to either of the dashed lines. The two blue points and\nthe purple point that lie on the dashed lines are the support vectors, and the distance\nfrom those points to the hyperplane is indicated by arrows. The purple and\nblue grid indicates the decision rule made by a classifier based on this separating\nhyperplane.\ncross the boundary set by the margin. The fact that the maximal margin\nhyperplane depends directly on only a small subset of the observations is\nan important property that will arise later in this chapter when we discuss\nthe support vector classifier and support vector machines.\n9.1.4 Construction of the Maximal Margin Classifier\nWe now consider the task of constructing the maximal margin hyperplane\nbased on a set of n training observations x1, . . . ,xn \u2208 Rp and associated\nclass labels y1, . . . , yn \u2208 {\u22121, 1}. Briefly, the maximal margin hyperplane\nis the solution to the optimization problem\nmaximize\n\u03b20,\u03b21,...,\u03b2p,M\nM (9.9)\nsubject to\n0p\nj=1\n\u03b22\nj = 1,", "doc_id": "6dac1576-1ecc-4ea4-a1c3-9065d0c10895", "embedding": null, "doc_hash": "8cd98b01b0bde7f920b44cbe297e5faf0dd4ead50ee4e2ae43b1467c0258f879", "extra_info": null, "node_info": {"start": 852320, "end": 856053, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "9d15e4be-2e23-486b-8e44-136e91a97119", "3": "6a64407e-9e4b-4ca9-89f2-faf9e39247e7"}}, "__type__": "1"}, "6a64407e-9e4b-4ca9-89f2-faf9e39247e7": {"__data__": {"text": "to\n0p\nj=1\n\u03b22\nj = 1, (9.10)\nyi(\u03b20 + \u03b21xi1 + \u03b22xi2 + \u00b7 \u00b7 \u00b7 + \u03b2pxip) \u2265 M 3 i = 1, . . . , n. (9.11)\nThis optimization problem (9.9)\u2013(9.11) is actually simpler than it looks.\nFirst of all, the constraint in (9.11) that\nyi(\u03b20 + \u03b21xi1 + \u03b22xi2 + \u00b7 \u00b7 \u00b7 + \u03b2pxip) \u2265 M 3 i = 1, . . . ,n\n9.2 Support Vector Classifiers 373\nguarantees that each observation will be on the correct side of the hyperplane,\nprovided that M is positive. (Actually, for each observation to be on\nthe correct side of the hyperplane we would simply need yi(\u03b20 + \u03b21xi1 +\n\u03b22xi2+\u00b7 \u00b7 \u00b7+\u03b2pxip) > 0, so the constraint in (9.11) in fact requires that each\nobservation be on the correct side of the hyperplane, with some cushion,\nprovided that M is positive.)\nSecond, note that (9.10) is not really a constraint on the hyperplane, since\nif \u03b20 + \u03b21xi1 + \u03b22xi2 + \u00b7 \u00b7 \u00b7 + \u03b2pxip = 0 defines a hyperplane, then so does\nk(\u03b20 +\u03b21xi1 +\u03b22xi2 +\u00b7 \u00b7 \u00b7+\u03b2pxip) = 0 for any k \u0338= 0. However, (9.10) adds\nmeaning to (9.11); one can show that with this constraint the perpendicular\ndistance from the ith observation to the hyperplane is given by\nyi(\u03b20 + \u03b21xi1 + \u03b22xi2 + \u00b7 \u00b7 \u00b7 + \u03b2pxip).\nTherefore, the constraints (9.10) and (9.11) ensure that each observation\nis on the correct side of the hyperplane and at least a distance M from the\nhyperplane. Hence, M represents the margin of our hyperplane, and the\noptimization problem chooses \u03b20,\u03b21, . . . ,\u03b2p to maximize M. This is exactly\nthe definition of the maximal margin hyperplane! The problem (9.9)\u2013(9.11)\ncan be solved efficiently, but details of this optimization are outside of the\nscope of this book.\n9.1.5 The Non-separable Case\nThe maximal margin classifier is a very natural way to perform classification,\nif a separating hyperplane exists. However, as we have hinted, in\nmany cases no separating hyperplane exists, and so there is no maximal\nmargin classifier. In this case, the optimization problem (9.9)\u2013(9.11) has no\nsolution with M >0. An example is shown in Figure 9.4. In this case, we\ncannot exactly separate the two classes. However, as we will see in the next\nsection, we can extend the concept of a separating hyperplane in order to\ndevelop a hyperplane that almost separates the classes, using a so-called\nsoft margin. The generalization of the maximal margin classifier to the\nnon-separable case is known as the support vector classifier.\n9.2 Support Vector Classifiers\n9.2.1 Overview of the Support Vector Classifier\nIn Figure 9.4, we see that observations that belong to two classes are not\nnecessarily separable by a hyperplane. In fact, even if a separating hyperplane\ndoes exist, then there are instances in which a classifier based on\na separating hyperplane might not be desirable. A classifier based on a\nseparating hyperplane will necessarily perfectly classify all of the training\n374 9. Support Vector Machines\n0 1 2 3\n\u22121.0 \u22120.5 0.0 0.5 1.0 1.5 2.0\nX1\nX2\nFIGURE 9.4. There are two classes of observations, shown in blue and in purple.\nIn this case, the two classes are not separable by a hyperplane, and so the\nmaximal margin classifier cannot be used.\nobservations; this can lead to sensitivity to individual observations. An example\nis shown in Figure 9.5. The addition of a single observation in", "doc_id": "6a64407e-9e4b-4ca9-89f2-faf9e39247e7", "embedding": null, "doc_hash": "192a46fe7754b5d132d143c4fb16fbde1b00ba99ebed10686bdfb839157a7f08", "extra_info": null, "node_info": {"start": 856106, "end": 859323, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "6dac1576-1ecc-4ea4-a1c3-9065d0c10895", "3": "caaeb8c4-c002-4c5c-a41b-7a8e847eb4f4"}}, "__type__": "1"}, "caaeb8c4-c002-4c5c-a41b-7a8e847eb4f4": {"__data__": {"text": "example\nis shown in Figure 9.5. The addition of a single observation in the\nright-hand panel of Figure 9.5 leads to a dramatic change in the maximal\nmargin hyperplane. The resulting maximal margin hyperplane is not\nsatisfactory\u2014for one thing, it has only a tiny margin. This is problematic\nbecause as discussed previously, the distance of an observation from the\nhyperplane can be seen as a measure of our confidence that the observation\nwas correctly classified. Moreover, the fact that the maximal margin\nhyperplane is extremely sensitive to a change in a single observation\nsuggests that it may have overfit the training data.\nIn this case, we might be willing to consider a classifier based on a hyperplane\nthat does not perfectly separate the two classes, in the interest of\n\u2022 Greater robustness to individual observations, and\n\u2022 Better classification of most of the training observations.\nThat is, it could be worthwhile to misclassify a few training observations\nin order to do a better job in classifying the remaining observations.\nThe support vector classifier, sometimes called a soft margin classifier,\nsupport\nvector\nclassifier\nsoft margin\nclassifier\ndoes exactly this. Rather than seeking the largest possible margin so that\nevery observation is not only on the correct side of the hyperplane but\nalso on the correct side of the margin, we instead allow some observations\nto be on the incorrect side of the margin, or even the incorrect side of\nthe hyperplane. (The margin is soft because it can be violated by some\nof the training observations.) An example is shown in the left-hand panel\n9.2 Support Vector Classifiers 375\n\u22121 0 1 2 3\n\u22121 0 1 2 3\n\u22121 0 1 2 3\n\u22121 0 1 2 3\nX1 X1\nX2\nX2\nFIGURE 9.5. Left: Two classes of observations are shown in blue and in\npurple, along with the maximal margin hyperplane. Right: An additional blue\nobservation has been added, leading to a dramatic shift in the maximal margin\nhyperplane shown as a solid line. The dashed line indicates the maximal margin\nhyperplane that was obtained in the absence of this additional point.\nof Figure 9.6. Most of the observations are on the correct side of the margin.\nHowever, a small subset of the observations are on the wrong side of the\nmargin.\nAn observation can be not only on the wrong side of the margin, but also\non the wrong side of the hyperplane. In fact, when there is no separating\nhyperplane, such a situation is inevitable. Observations on the wrong side of\nthe hyperplane correspond to training observations that are misclassified by\nthe support vector classifier. The right-hand panel of Figure 9.6 illustrates\nsuch a scenario.\n9.2.2 Details of the Support Vector Classifier\nThe support vector classifier classifies a test observation depending on\nwhich side of a hyperplane it lies. The hyperplane is chosen to correctly\nseparate most of the training observations into the two classes, but may\nmisclassify a few observations. It is the solution to the optimization problem\nmaximize\n\u03b20,\u03b21,...,\u03b2p,\u03f51,...,\u03f5n,M\nM (9.12)\nsubject to\n0p\nj=1\n\u03b22\nj = 1, (9.13)\nyi(\u03b20 + \u03b21xi1 + \u03b22xi2 + \u00b7 \u00b7 \u00b7 + \u03b2pxip) \u2265 M(1 \u2212 \u03f5i), (9.14)\n\u03f5i \u2265 0,\n0n\ni=1\n\u03f5i \u2264 C, (9.15)\n376 9. Support Vector Machines\n\u22120.5 0.0 0.5 1.0 1.5 2.0 2.5\n\u22121 0 1 2 3 4\n1\n2\n3\n4 5\n6\n7\n8\n9\n10\n\u22120.5 0.0 0.5 1.0 1.5 2.0 2.5\n\u22121 0 1 2 3 4\n1\n2\n3\n4 5\n6\n7\n8\n9\n10\n11\n12\nX1 X1\nX2\nX2\nFIGURE 9.6. Left: A support vector classifier was fit to", "doc_id": "caaeb8c4-c002-4c5c-a41b-7a8e847eb4f4", "embedding": null, "doc_hash": "10b1809e00e41683e2cb93f2b88471dfd4633e16f9cefc6686b6c6b52e9135e2", "extra_info": null, "node_info": {"start": 859281, "end": 862651, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "6a64407e-9e4b-4ca9-89f2-faf9e39247e7", "3": "bcf99c2a-821c-48ec-81b0-283134061b35"}}, "__type__": "1"}, "bcf99c2a-821c-48ec-81b0-283134061b35": {"__data__": {"text": "9.6. Left: A support vector classifier was fit to a small data set. The\nhyperplane is shown as a solid line and the margins are shown as dashed lines.\nPurple observations: Observations 3, 4, 5, and 6 are on the correct side of the\nmargin, observation 2 is on the margin, and observation 1 is on the wrong side of\nthe margin. Blue observations: Observations 7 and 10 are on the correct side of\nthe margin, observation 9 is on the margin, and observation 8 is on the wrong side\nof the margin. No observations are on the wrong side of the hyperplane. Right:\nSame as left panel with two additional points, 11 and 12. These two observations\nare on the wrong side of the hyperplane and the wrong side of the margin.\nwhere C is a nonnegative tuning parameter. As in (9.11), M is the width\nof the margin; we seek to make this quantity as large as possible. In (9.14),\n\u03f51, . . . , \u03f5n are slack variables that allow individual observations to be on\nslack\nthe wrong side of the margin or the hyperplane; we will explain them in variable\ngreater detail momentarily. Once we have solved (9.12)\u2013(9.15), we classify\na test observation x\u2217 as before, by simply determining on which side of the\nhyperplane it lies. That is, we classify the test observation based on the\nsign of f(x\u2217) = \u03b20 + \u03b21x\u22171 + \u00b7 \u00b7 \u00b7 + \u03b2px\u2217p.\nThe problem (9.12)\u2013(9.15) seems complex, but insight into its behavior\ncan be made through a series of simple observations presented below. First\nof all, the slack variable \u03f5i tells us where the ith observation is located,\nrelative to the hyperplane and relative to the margin. If \u03f5i = 0 then the ith\nobservation is on the correct side of the margin, as we saw in Section 9.1.4.\nIf \u03f5i > 0 then the ith observation is on the wrong side of the margin, and\nwe say that the ith observation has violated the margin. If \u03f5i > 1 then it\nis on the wrong side of the hyperplane.\nWe now consider the role of the tuning parameter C. In (9.15), C bounds\nthe sum of the \u03f5i\u2019s, and so it determines the number and severity of the violations\nto the margin (and to the hyperplane) that we will tolerate. We can\nthink of C as a budget for the amount that the margin can be violated\nby the n observations. If C = 0 then there is no budget for violations to\nthe margin, and it must be the case that \u03f51 = \u00b7 \u00b7 \u00b7 = \u03f5n = 0, in which case\n(9.12)\u2013(9.15) simply amounts to the maximal margin hyperplane optimiza9.2\nSupport Vector Classifiers 377\ntion problem (9.9)\u2013(9.11). (Of course, a maximal margin hyperplane exists\nonly if the two classes are separable.) For C > 0 no more than C observations\ncan be on the wrong side of the hyperplane, because if an observation\nis on the wrong side of the hyperplane then \u03f5i > 1, and (9.15) requires\nthat\n)n\ni=1 \u03f5i \u2264 C. As the budget C increases, we become more tolerant of\nviolations to the margin, and so the margin will widen. Conversely, as C\ndecreases, we become less tolerant of violations to the margin and so the\nmargin narrows. An example is shown in Figure 9.7.\nIn practice, C is treated as a tuning parameter that is generally chosen via\ncross-validation. As with the tuning parameters that we have seen throughout\nthis book, C controls the bias-variance trade-off of the statistical learning\ntechnique. When C is small, we seek narrow margins that are rarely\nviolated; this amounts to a classifier that is highly fit to the data, which\nmay have low bias but high variance. On the other hand, when C is larger,\nthe margin", "doc_id": "bcf99c2a-821c-48ec-81b0-283134061b35", "embedding": null, "doc_hash": "82072b03c7b6d5f3680cd153d3dbb22285ca24f47e5b164c15d31a838769ce30", "extra_info": null, "node_info": {"start": 862671, "end": 866111, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "caaeb8c4-c002-4c5c-a41b-7a8e847eb4f4", "3": "bef06ef2-33b1-40f9-9df1-538af5ab966c"}}, "__type__": "1"}, "bef06ef2-33b1-40f9-9df1-538af5ab966c": {"__data__": {"text": "but high variance. On the other hand, when C is larger,\nthe margin is wider and we allow more violations to it; this amounts to\nfitting the data less hard and obtaining a classifier that is potentially more\nbiased but may have lower variance.\nThe optimization problem (9.12)\u2013(9.15) has a very interesting property:\nit turns out that only observations that either lie on the margin or that\nviolate the margin will affect the hyperplane, and hence the classifier obtained.\nIn other words, an observation that lies strictly on the correct side\nof the margin does not affect the support vector classifier! Changing the\nposition of that observation would not change the classifier at all, provided\nthat its position remains on the correct side of the margin. Observations\nthat lie directly on the margin, or on the wrong side of the margin for\ntheir class, are known as support vectors. These observations do affect the\nsupport vector classifier.\nThe fact that only support vectors affect the classifier is in line with our\nprevious assertion that C controls the bias-variance trade-off of the support\nvector classifier. When the tuning parameter C is large, then the margin is\nwide, many observations violate the margin, and so there are many support\nvectors. In this case, many observations are involved in determining the\nhyperplane. The top left panel in Figure 9.7 illustrates this setting: this\nclassifier has low variance (since many observations are support vectors)\nbut potentially high bias. In contrast, if C is small, then there will be fewer\nsupport vectors and hence the resulting classifier will have low bias but\nhigh variance. The bottom right panel in Figure 9.7 illustrates this setting,\nwith only eight support vectors.\nThe fact that the support vector classifier\u2019s decision rule is based only\non a potentially small subset of the training observations (the support vectors)\nmeans that it is quite robust to the behavior of observations that\nare far away from the hyperplane. This property is distinct from some of\nthe other classification methods that we have seen in preceding chapters,\nsuch as linear discriminant analysis. Recall that the LDA classification rule\ndepends on the mean of all of the observations within each class, as well as\n378 9. Support Vector Machines\n\u22121 0 1 2\n\u22123 \u22122 \u22121 0 1 2 3\n\u22121 0 1 2\n\u22123 \u22122 \u22121 0 1 2 3\n\u22121 0 1 2\n\u22123 \u22122 \u22121 0 1 2 3\n\u22121 0 1 2\n\u22123 \u22122 \u22121 0 1 2 3\nX1 X1\nX1 X1\nX2\nX2\nX2\nX2\nFIGURE 9.7. A support vector classifier was fit using four different values of the\ntuning parameter C in (9.12)\u2013(9.15). The largest value of C was used in the top\nleft panel, and smaller values were used in the top right, bottom left, and bottom\nright panels. When C is large, then there is a high tolerance for observations being\non the wrong side of the margin, and so the margin will be large. As C decreases,\nthe tolerance for observations being on the wrong side of the margin decreases,\nand the margin narrows.\nthe within-class covariance matrix computed using all of the observations.\nIn contrast, logistic regression, unlike LDA, has very low sensitivity to observations\nfar from the decision boundary. In fact we will see in Section 9.5\nthat the support vector classifier and logistic regression are closely related.\n9.3 Support Vector Machines 379\n\u22124 \u22122 0 2 4\n\u22124 \u22122 0 2 4\n\u22124 \u22122 0 2 4\n\u22124 \u22122 0 2 4\nX1 X1\nX2\nX2\nFIGURE 9.8. Left: The observations fall into two classes, with a non-linear\nboundary between them. Right: The support vector classifier seeks a linear boundary,\nand consequently performs very poorly.\n9.3 Support Vector Machines\nWe first discuss a general mechanism for converting a linear classifier into\none that produces non-linear decision", "doc_id": "bef06ef2-33b1-40f9-9df1-538af5ab966c", "embedding": null, "doc_hash": "05f2abf6784a43ca20c50f1f515490a43b6b8d25ddd6511bcacc766f52068871", "extra_info": null, "node_info": {"start": 866098, "end": 869776, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "bcf99c2a-821c-48ec-81b0-283134061b35", "3": "db4b78bc-f3c3-4780-ab9e-61ab3bf79244"}}, "__type__": "1"}, "db4b78bc-f3c3-4780-ab9e-61ab3bf79244": {"__data__": {"text": "for converting a linear classifier into\none that produces non-linear decision boundaries. We then introduce the\nsupport vector machine, which does this in an automatic way.\n9.3.1 Classification with Non-Linear Decision Boundaries\nThe support vector classifier is a natural approach for classification in the\ntwo-class setting, if the boundary between the two classes is linear. However,\nin practice we are sometimes faced with non-linear class boundaries.\nFor instance, consider the data in the left-hand panel of Figure 9.8. It is\nclear that a support vector classifier or any linear classifier will perform\npoorly here. Indeed, the support vector classifier shown in the right-hand\npanel of Figure 9.8 is useless here.\nIn Chapter 7, we are faced with an analogous situation. We see there\nthat the performance of linear regression can suffer when there is a nonlinear\nrelationship between the predictors and the outcome. In that case,\nwe consider enlarging the feature space using functions of the predictors,\nsuch as quadratic and cubic terms, in order to address this non-linearity.\nIn the case of the support vector classifier, we could address the problem\nof possibly non-linear boundaries between classes in a similar way, by\nenlarging the feature space using quadratic, cubic, and even higher-order\npolynomial functions of the predictors. For instance, rather than fitting a\nsupport vector classifier using p features\nX1,X2, . . . ,Xp,\n380 9. Support Vector Machines\nwe could instead fit a support vector classifier using 2p features\nX1,X2\n1,X2,X2\n2 , . . . ,Xp,X2\np .\nThen (9.12)\u2013(9.15) would become\nmaximize\n\u03b20,\u03b211,\u03b212,...,\u03b2p1,\u03b2p2,\u03f51,...,\u03f5n,M\nM (9.16)\nsubject to yi\n\u239b\n\u239d\u03b20 +\n0p\nj=1\n\u03b2j1xij +\n0p\nj=1\n\u03b2j2x2\nij\n\u239e\n\u23a0 \u2265 M(1 \u2212 \u03f5i),\n0n\ni=1\n\u03f5i \u2264 C, \u03f5i \u2265 0,\n0p\nj=1\n02\nk=1\n\u03b22\njk = 1.\nWhy does this lead to a non-linear decision boundary? In the enlarged\nfeature space, the decision boundary that results from (9.16) is in fact linear.\nBut in the original feature space, the decision boundary is of the form\nq(x) = 0, where q is a quadratic polynomial, and its solutions are generally\nnon-linear. One might additionally want to enlarge the feature space\nwith higher-order polynomial terms, or with interaction terms of the form\nXjXj\u2032 for j \u0338= j\u2032. Alternatively, other functions of the predictors could\nbe considered rather than polynomials. It is not hard to see that there\nare many possible ways to enlarge the feature space, and that unless we\nare careful, we could end up with a huge number of features. Then computations\nwould become unmanageable. The support vector machine, which\nwe present next, allows us to enlarge the feature space used by the support\nvector classifier in a way that leads to efficient computations.\n9.3.2 The Support Vector Machine\nThe support vector machine (SVM) is an extension of the support vector\nsupport\nvector\nmachine\nclassifier that results from enlarging the feature space in a specific way,\nusing kernels. We will now discuss this extension, the details of which are\nsomewhat complex and beyond the scope of this book. However, the main kernel\nidea is described in Section 9.3.1: we may want to enlarge our feature space\nin order to accommodate a non-linear boundary between the classes. The\nkernel approach that we describe here is simply an efficient computational\napproach for enacting this idea.\nWe have not discussed exactly how the support vector classifier is computed\nbecause the details become somewhat technical. However, it turns\nout that the solution to the support vector classifier problem", "doc_id": "db4b78bc-f3c3-4780-ab9e-61ab3bf79244", "embedding": null, "doc_hash": "0083d4d50f71f655fe2cdc38eb95896f576c34255d6367d318fc15777563f17d", "extra_info": null, "node_info": {"start": 869764, "end": 873301, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "bef06ef2-33b1-40f9-9df1-538af5ab966c", "3": "d689753f-fbc6-4ab1-8c57-b37788e2df6e"}}, "__type__": "1"}, "d689753f-fbc6-4ab1-8c57-b37788e2df6e": {"__data__": {"text": "technical. However, it turns\nout that the solution to the support vector classifier problem (9.12)\u2013(9.15)\ninvolves only the inner products of the observations (as opposed to the\nobservations themselves). The inner product of two r-vectors a and b is\ndefined as \u27e8a, b\u27e9 =\n)r\ni=1 aibi. Thus the inner product of two observations\n9.3 Support Vector Machines 381\nxi, xi\u2032 is given by\n\u27e8xi, xi\u2032 \u27e9 =\n0p\nj=1\nxijxi\u2032j . (9.17)\nIt can be shown that\n\u2022 The linear support vector classifier can be represented as\nf(x) = \u03b20 +\n0n\ni=1\n\u03b1i\u27e8x, xi\u27e9, (9.18)\nwhere there are n parameters \u03b1i, i = 1, . . . ,n, one per training\nobservation.\n\u2022 'To estimate the parameters \u03b11, . . . , \u03b1n and \u03b20, all we need are the n\n2\n(\ninner products \u27e8xi, xi\u2032 \u27e9 between all pairs of training observations.\n(The notation\n'n\n2\n(\nmeans n(n \u2212 1)/2, and gives the number of pairs\namong a set of n items.)\nNotice that in (9.18), in order to evaluate the function f(x), we need to\ncompute the inner product between the new point x and each of the training\npoints xi. However, it turns out that \u03b1i is nonzero only for the support\nvectors in the solution\u2014that is, if a training observation is not a support\nvector, then its \u03b1i equals zero. So if S is the collection of indices of these\nsupport points, we can rewrite any solution function of the form (9.18) as\nf(x) = \u03b20 +\n0\ni\u2208S\n\u03b1i\u27e8x, xi\u27e9, (9.19)\nwhich typically involves far fewer terms than in (9.18).2\nTo summarize, in representing the linear classifier f(x), and in computing\nits coefficients, all we need are inner products.\nNow suppose that every time the inner product (9.17) appears in the\nrepresentation (9.18), or in a calculation of the solution for the support\nvector classifier, we replace it with a generalization of the inner product of\nthe form\nK(xi, xi\u2032 ), (9.20)\nwhere K is some function that we will refer to as a kernel. A kernel is a\nkernel\nfunction that quantifies the similarity of two observations. For instance, we\ncould simply take\nK(xi, xi\u2032) =\n0p\nj=1\nxijxi\u2032j , (9.21)\n2By expanding each of the inner products in (9.19), it is easy to see that f(x) is\na linear function of the coordinates of x. Doing so also establishes the correspondence\nbetween the \u03b1i and the original parameters \u03b2j .\n382 9. Support Vector Machines\nwhich would just give us back the support vector classifier. Equation 9.21\nis known as a linear kernel because the support vector classifier is linear\nin the features; the linear kernel essentially quantifies the similarity of a\npair of observations using Pearson (standard) correlation. But one could\ninstead choose another form for (9.20). For instance, one could replace\nevery instance of\n)p\nj=1 xijxi\u2032j with the quantity\nK(xi, xi\u2032 ) = (1 +\n0p\nj=1\nxijxi\u2032j)d. (9.22)\nThis is known as a polynomial kernel of degree d, where d is a positive\npolynomial\ninteger. Using such a kernel with d > 1, instead of the standard linear kernel\nkernel (9.21), in the support vector classifier algorithm leads to a much more\nflexible decision boundary. It essentially amounts to fitting a support vector\nclassifier in a higher-dimensional space involving polynomials of degree d,\nrather than in the original feature space. When the support vector classifier\nis combined with a non-linear kernel such as (9.22), the resulting classifier is\nknown as a support", "doc_id": "d689753f-fbc6-4ab1-8c57-b37788e2df6e", "embedding": null, "doc_hash": "8bc5bdf84fab10a28e525ab157198a6624f02a915e200bb8d6b9c6d5cdcc9ced", "extra_info": null, "node_info": {"start": 873291, "end": 876576, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "db4b78bc-f3c3-4780-ab9e-61ab3bf79244", "3": "085adcb2-f37e-48e8-96b0-6bfb2c583dad"}}, "__type__": "1"}, "085adcb2-f37e-48e8-96b0-6bfb2c583dad": {"__data__": {"text": "kernel such as (9.22), the resulting classifier is\nknown as a support vector machine. Note that in this case the (non-linear)\nfunction has the form\nf(x) = \u03b20 +\n0\ni\u2208S\n\u03b1iK(x, xi). (9.23)\nThe left-hand panel of Figure 9.9 shows an example of an SVM with a\npolynomial kernel applied to the non-linear data from Figure 9.8. The fit is\na substantial improvement over the linear support vector classifier. When\nd = 1, then the SVM reduces to the support vector classifier seen earlier in\nthis chapter.\nThe polynomial kernel shown in (9.22) is one example of a possible\nnon-linear kernel, but alternatives abound. Another popular choice is the\nradial kernel, which takes the form\nradial kernel\nK(xi, xi\u2032 ) = exp(\u2212\u03b3\n0p\nj=1\n(xij \u2212 xi\u2032j)2). (9.24)\nIn (9.24), \u03b3 is a positive constant. The right-hand panel of Figure 9.9 shows\nan example of an SVM with a radial kernel on this non-linear data; it also\ndoes a good job in separating the two classes.\nHow does the radial kernel (9.24) actually work? If a given test observation\nx\u2217 = (x\u22171, . . . ,x\u2217p)T is far from a training observation xi in terms of\nEuclidean distance, then\n)p\nj=1(x\u2217j \u2212xij)2 will be large, and so K(x\u2217, xi) =\nexp(\u2212\u03b3\n)p\nj=1(x\u2217j \u2212 xij)2) will be tiny. This means that in (9.23), xi will\nplay virtually no role in f(x\u2217). Recall that the predicted class label for the\ntest observation x\u2217 is based on the sign of f(x\u2217). In other words, training\nobservations that are far from x\u2217 will play essentially no role in the predicted\nclass label for x\u2217. This means that the radial kernel has very local\n9.3 Support Vector Machines 383\n\u22124 \u22122 0 2 4\n\u22124 \u22122 0 2 4\n\u22124 \u22122 0 2 4\n\u22124 \u22122 0 2 4\nX1 X1\nX2\nX2\nFIGURE 9.9. Left: An SVM with a polynomial kernel of degree 3 is applied to\nthe non-linear data from Figure 9.8, resulting in a far more appropriate decision\nrule. Right: An SVM with a radial kernel is applied. In this example, either kernel\nis capable of capturing the decision boundary.\nbehavior, in the sense that only nearby training observations have an effect\non the class label of a test observation.\nWhat is the advantage of using a kernel rather than simply enlarging\nthe feature space using functions of the original features, as in (9.16)? One\nadvantage is computational, and it amounts to the fact that using kernels,\none need only compute K(xi, x\u2032i) for all\n'n\n2\n(\ndistinct pairs i, i\u2032. This can be\ndone without explicitly working in the enlarged feature space. This is important\nbecause in many applications of SVMs, the enlarged feature space\nis so large that computations are intractable. For some kernels, such as the\nradial kernel (9.24), the feature space is implicit and infinite-dimensional,\nso we could never do the computations there anyway!\n9.3.3 An Application to the Heart Disease Data\nIn Chapter 8 we apply decision trees and related methods to the Heart data.\nThe aim is to use 13 predictors such as Age, Sex, and Chol in order to predict\nwhether an individual has heart disease. We now investigate how an SVM\ncompares to LDA on this data. After removing 6 missing observations, the\ndata consist of 297 subjects, which we randomly split into 207 training and\n90 test observations.\nWe first fit LDA and the support vector classifier to the training data.\nNote that the support vector classifier is equivalent to a SVM using a", "doc_id": "085adcb2-f37e-48e8-96b0-6bfb2c583dad", "embedding": null, "doc_hash": "602a064042fb22c145872a06a6f8277451b3cf03fdbdb4e48460a780b9882443", "extra_info": null, "node_info": {"start": 876597, "end": 879887, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "d689753f-fbc6-4ab1-8c57-b37788e2df6e", "3": "334a12ca-9753-4128-9b57-8cccf66151ca"}}, "__type__": "1"}, "334a12ca-9753-4128-9b57-8cccf66151ca": {"__data__": {"text": "training data.\nNote that the support vector classifier is equivalent to a SVM using a polynomial\nkernel of degree d = 1. The left-hand panel of Figure 9.10 displays\nROC curves (described in Section 4.4.2) for the training set predictions for\nboth LDA and the support vector classifier. Both classifiers compute scores\nof the form \u02c6 f(X) = \u02c6 \u03b20 + \u02c6 \u03b21X1 + \u02c6 \u03b22X2 + \u00b7 \u00b7 \u00b7 + \u02c6 \u03b2pXp for each observation.\n384 9. Support Vector Machines\nFalse positive rate\nTrue positive rate\n0.0 0.2 0.4 0.6 0.8 1.0\n0.0 0.2 0.4 0.6 0.8 1.0\nSupport Vector Classifier\nLDA\nFalse positive rate\nTrue positive rate\n0.0 0.2 0.4 0.6 0.8 1.0\n0.0 0.2 0.4 0.6 0.8 1.0\nSupport Vector Classifier\nSVM: \u03b3=10\u22123\nSVM: \u03b3=10\u22122\nSVM: \u03b3=10\u22121\nFIGURE 9.10. ROC curves for the Heart data training set. Left: The support\nvector classifier and LDA are compared. Right: The support vector classifier is\ncompared to an SVM using a radial basis kernel with \u03b3 = 10\u22123, 10\u22122, and 10\u22121.\nFor any given cutoff t, we classify observations into the heart disease or\nno heart disease categories depending on whether \u02c6 f(X) < t or \u02c6 f(X) \u2265 t.\nThe ROC curve is obtained by forming these predictions and computing\nthe false positive and true positive rates for a range of values of t. An optimal\nclassifier will hug the top left corner of the ROC plot. In this instance\nLDA and the support vector classifier both perform well, though there is a\nsuggestion that the support vector classifier may be slightly superior.\nThe right-hand panel of Figure 9.10 displays ROC curves for SVMs using\na radial kernel, with various values of \u03b3. As \u03b3 increases and the fit becomes\nmore non-linear, the ROC curves improve. Using \u03b3 = 10\u22121 appears to give\nan almost perfect ROC curve. However, these curves represent training\nerror rates, which can be misleading in terms of performance on new test\ndata. Figure 9.11 displays ROC curves computed on the 90 test observations.\nWe observe some differences from the training ROC curves. In the\nleft-hand panel of Figure 9.11, the support vector classifier appears to have\na small advantage over LDA (although these differences are not statistically\nsignificant). In the right-hand panel, the SVM using \u03b3 = 10\u22121, which\nshowed the best results on the training data, produces the worst estimates\non the test data. This is once again evidence that while a more flexible\nmethod will often produce lower training error rates, this does not necessarily\nlead to improved performance on test data. The SVMs with \u03b3 = 10\u22122\nand \u03b3 = 10\u22123 perform comparably to the support vector classifier, and all\nthree outperform the SVM with \u03b3 = 10\u22121.\n9.4 SVMs with More than Two Classes 385\nFalse positive rate\nTrue positive rate\n0.0 0.2 0.4 0.6 0.8 1.0\n0.0 0.2 0.4 0.6 0.8 1.0\nSupport Vector Classifier\nLDA\nFalse positive rate\nTrue positive rate\n0.0 0.2 0.4 0.6 0.8 1.0\n0.0 0.2 0.4 0.6 0.8 1.0\nSupport Vector Classifier\nSVM: \u03b3=10\u22123\nSVM: \u03b3=10\u22122\nSVM: \u03b3=10\u22121\nFIGURE 9.11. ROC curves for the test set of the Heart data. Left: The support\nvector classifier and LDA are compared. Right: The support vector classifier is\ncompared to an SVM using a radial basis kernel with \u03b3 = 10\u22123, 10\u22122, and 10\u22121.\n9.4 SVMs with More than Two Classes\nSo far, our discussion", "doc_id": "334a12ca-9753-4128-9b57-8cccf66151ca", "embedding": null, "doc_hash": "a13ff38fa7646db3e0ea15bd5703bff2a5e1f60a6ca5e1f59c5bb9c5328d369c", "extra_info": null, "node_info": {"start": 879875, "end": 883065, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "085adcb2-f37e-48e8-96b0-6bfb2c583dad", "3": "5b233062-a8b0-4c9b-ad55-a676c80f7a5c"}}, "__type__": "1"}, "5b233062-a8b0-4c9b-ad55-a676c80f7a5c": {"__data__": {"text": "SVMs with More than Two Classes\nSo far, our discussion has been limited to the case of binary classification:\nthat is, classification in the two-class setting. How can we extend SVMs\nto the more general case where we have some arbitrary number of classes?\nIt turns out that the concept of separating hyperplanes upon which SVMs\nare based does not lend itself naturally to more than two classes. Though\na number of proposals for extending SVMs to the K-class case have been\nmade, the two most popular are the one-versus-one and one-versus-all\napproaches. We briefly discuss those two approaches here.\n9.4.1 One-Versus-One Classification\nSuppose that we would like to perform classification using SVMs, and there\nare K > 2 classes. A one-versus-one or all-pairs approach constructs\n'K\n2\n(\none-versus-\nSVMs, each of which compares a pair of classes. For example, one such one\nSVM might compare the kth class, coded as +1, to the k\u2032th class, coded\nas \u22121. We classify a test observation using each of the\n'K\n2\n(\nclassifiers, and\nwe tally the number of times that the test observation is assigned to each\nof the K classes. The final classification is performed by assigning the test\n'observation to the class to which it was most frequently assigned in these K\n2\n(\npairwise classifications.\n9.4.2 One-Versus-All Classification\nThe one-versus-all approach is an alternative procedure for applying SVMs one-versusin\nthe case of K > 2 classes. We fit K SVMs, each time comparing one of all\n386 9. Support Vector Machines\nthe K classes to the remaining K \u2212 1 classes. Let \u03b20k,\u03b21k, . . . ,\u03b2pk denote\nthe parameters that result from fitting an SVM comparing the kth class\n(coded as +1) to the others (coded as \u22121). Let x\u2217 denote a test observation.\nWe assign the observation to the class for which \u03b20k+\u03b21kx\u22171 +\u03b22kx\u22172 +\u00b7 \u00b7 \u00b7+\n\u03b2pkx\u2217p is largest, as this amounts to a high level of confidence that the test\nobservation belongs to the kth class rather than to any of the other classes.\n9.5 Relationship to Logistic Regression\nWhen SVMs were first introduced in the mid-1990s, they made quite a\nsplash in the statistical and machine learning communities. This was due\nin part to their good performance, good marketing, and also to the fact\nthat the underlying approach seemed both novel and mysterious. The idea\nof finding a hyperplane that separates the data as well as possible, while allowing\nsome violations to this separation, seemed distinctly different from\nclassical approaches for classification, such as logistic regression and linear\ndiscriminant analysis. Moreover, the idea of using a kernel to expand\nthe feature space in order to accommodate non-linear class boundaries appeared\nto be a unique and valuable characteristic.\nHowever, since that time, deep connections between SVMs and other\nmore classical statistical methods have emerged. It turns out that one can\nrewrite the criterion (9.12)\u2013(9.15) for fitting the support vector classifier\nf(X) = \u03b20 + \u03b21X1 + \u00b7 \u00b7 \u00b7 + \u03b2pXp as\nminimize\n\u03b20,\u03b21,...,\u03b2p\n\u23a7\u23a8\n\u23a9\n0n\ni=1\nmax [0, 1 \u2212 yif(xi)] + \u03bb\n0p\nj=1\n\u03b22\nj\n\u23ab\u23ac\n\u23ad, (9.25)\nwhere \u03bb is a nonnegative tuning parameter. When \u03bb is large then \u03b21, . . . ,\u03b2p\nare small, more violations to the margin are tolerated, and a low-variance\nbut high-bias classifier will result. When \u03bb is small then few violations\nto the margin will occur; this amounts to a", "doc_id": "5b233062-a8b0-4c9b-ad55-a676c80f7a5c", "embedding": null, "doc_hash": "c15a39ed8e44396af88ec419f6351e8869340003c8f6a7e36669069c0de32c78", "extra_info": null, "node_info": {"start": 883092, "end": 886421, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "334a12ca-9753-4128-9b57-8cccf66151ca", "3": "2a48d728-a618-4aa9-9959-0f78dbb2236d"}}, "__type__": "1"}, "2a48d728-a618-4aa9-9959-0f78dbb2236d": {"__data__": {"text": "\u03bb is small then few violations\nto the margin will occur; this amounts to a high-variance but low-bias\nclassifier. Thus, a small value of \u03bb in (9.25) amounts to a small value of C\nin (9.15). Note that the \u03bb\n)p\nj=1 \u03b22\nj term in (9.25) is the ridge penalty term\nfrom Section 6.2.1, and plays a similar role in controlling the bias-variance\ntrade-off for the support vector classifier.\nNow (9.25) takes the \u201cLoss + Penalty\u201d form that we have seen repeatedly\nthroughout this book:\nminimize\n\u03b20,\u03b21,...,\u03b2p {L(X, y,\u03b2) + \u03bbP(\u03b2)} . (9.26)\nIn (9.26), L(X, y,\u03b2) is some loss function quantifying the extent to which\nthe model, parametrized by \u03b2, fits the data (X, y), and P(\u03b2) is a penalty\n9.5 Relationship to Logistic Regression 387\nfunction on the parameter vector \u03b2 whose effect is controlled by a nonnegative\ntuning parameter \u03bb. For instance, ridge regression and the lasso both\ntake this form with\nL(X, y,\u03b2) =\n0n\ni=1\n\u239b\n\u239dyi \u2212 \u03b20 \u2212\n0p\nj=1\nxij\u03b2j\n\u239e\n\u23a0\n2\nand with P(\u03b2) =\n)p\nj=1 \u03b22\nj for ridge regression and P(\u03b2) =\n)p\nj=1 |\u03b2j | for\nthe lasso. In the case of (9.25) the loss function instead takes the form\nL(X, y,\u03b2) =\n0n\ni=1\nmax [0, 1 \u2212 yi(\u03b20 + \u03b21xi1 + \u00b7 \u00b7 \u00b7 + \u03b2pxip)] .\nThis is known as hinge loss, and is depicted in Figure 9.12. However, it\nhinge loss\nturns out that the hinge loss function is closely related to the loss function\nused in logistic regression, also shown in Figure 9.12.\nAn interesting characteristic of the support vector classifier is that only\nsupport vectors play a role in the classifier obtained; observations on the\ncorrect side of the margin do not affect it. This is due to the fact that the\nloss function shown in Figure 9.12 is exactly zero for observations for which\nyi(\u03b20 + \u03b21xi1 + \u00b7 \u00b7 \u00b7 + \u03b2pxip) \u2265 1; these correspond to observations that are\non the correct side of the margin.3 In contrast, the loss function for logistic\nregression shown in Figure 9.12 is not exactly zero anywhere. But it is very\nsmall for observations that are far from the decision boundary. Due to the\nsimilarities between their loss functions, logistic regression and the support\nvector classifier often give very similar results. When the classes are well\nseparated, SVMs tend to behave better than logistic regression; in more\noverlapping regimes, logistic regression is often preferred.\nWhen the support vector classifier and SVM were first introduced, it was\nthought that the tuning parameter C in (9.15) was an unimportant \u201cnuisance\u201d\nparameter that could be set to some default value, like 1. However,\nthe \u201cLoss + Penalty\u201d formulation (9.25) for the support vector classifier\nindicates that this is not the case. The choice of tuning parameter is very\nimportant and determines the extent to which the model underfits or overfits\nthe data, as illustrated, for example, in Figure 9.7.\nWe have established that the support vector classifier is closely related\nto logistic regression and other preexisting statistical methods. Is the SVM\nunique in its use of kernels to enlarge the feature space to accommodate\nnon-linear class boundaries? The answer to this question is \u201cno\u201d. We could\njust as well perform logistic regression or many of the other classification\nmethods seen in this book using non-linear kernels; this is closely related to\n3With this hinge-loss + penalty representation, the margin corresponds to the value\none, and the width", "doc_id": "2a48d728-a618-4aa9-9959-0f78dbb2236d", "embedding": null, "doc_hash": "bc15793cefa5823bbb583264d0a0a991326a90e24f25b89164e0b07f64953c5f", "extra_info": null, "node_info": {"start": 886407, "end": 889744, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "5b233062-a8b0-4c9b-ad55-a676c80f7a5c", "3": "134108e7-cdd1-4af1-b202-286245d077f0"}}, "__type__": "1"}, "134108e7-cdd1-4af1-b202-286245d077f0": {"__data__": {"text": "+ penalty representation, the margin corresponds to the value\none, and the width of the margin is determined by\n!\n\u03b22\nj .\n388 9. Support Vector Machines\n\u22126 \u22124 \u22122 0 2\n0 2 4 6 8\nLoss\nSVM Loss\nLogistic Regression Loss\nyi(\u03b20 + \u03b21xi1 + . . . + \u03b2pxip)\nFIGURE 9.12. The SVM and logistic regression loss functions are compared,\nas a function of yi(\u03b20 +\u03b21xi1 +\u00b7 \u00b7 \u00b7+\u03b2pxip). When yi(\u03b20 +\u03b21xi1 +\u00b7 \u00b7 \u00b7+\u03b2pxip) is\ngreater than 1, then the SVM loss is zero, since this corresponds to an observation\nthat is on the correct side of the margin. Overall, the two loss functions have quite\nsimilar behavior.\nsome of the non-linear approaches seen in Chapter 7. However, for historical\nreasons, the use of non-linear kernels is much more widespread in the\ncontext of SVMs than in the context of logistic regression or other methods.\nThough we have not addressed it here, there is in fact an extension\nof the SVM for regression (i.e. for a quantitative rather than a qualitative\nresponse), called support vector regression. In Chapter 3, we saw that\nsupport\nvector\nregression\nleast squares regression seeks coefficients \u03b20,\u03b21, . . . ,\u03b2p such that the sum\nof squared residuals is as small as possible. (Recall from Chapter 3 that\nresiduals are defined as yi \u2212 \u03b20 \u2212 \u03b21xi1 \u2212 \u00b7 \u00b7 \u00b7 \u2212 \u03b2pxip.) Support vector\nregression instead seeks coefficients that minimize a different type of loss,\nwhere only residuals larger in absolute value than some positive constant\ncontribute to the loss function. This is an extension of the margin used in\nsupport vector classifiers to the regression setting.\n9.6 Lab: Support Vector Machines\nWe use the e1071 library in R to demonstrate the support vector classifier\nand the SVM. Another option is the LiblineaR library, which is useful for\nvery large linear problems.\n9.6 Lab: Support Vector Machines 389\n9.6.1 Support Vector Classifier\nThe e1071 library contains implementations for a number of statistical\nlearning methods. In particular, the svm() function can be used to fit a\nsvm()\nsupport vector classifier when the argument kernel = \"linear\" is used.\nThis function uses a slightly different formulation from (9.14) and (9.25)\nfor the support vector classifier. A cost argument allows us to specify the\ncost of a violation to the margin. When the cost argument is small, then\nthe margins will be wide and many support vectors will be on the margin\nor will violate the margin. When the cost argument is large, then the margins\nwill be narrow and there will be few support vectors on the margin or\nviolating the margin.\nWe now use the svm() function to fit the support vector classifier for a\ngiven value of the cost parameter. Here we demonstrate the use of this\nfunction on a two-dimensional example so that we can plot the resulting\ndecision boundary. We begin by generating the observations, which belong\nto two classes, and checking whether the classes are linearly separable.\n> set.seed (1)\n> x <- matrix(rnorm (20 * 2), ncol = 2)\n> y <- c(rep(-1, 10), rep(1, 10))\n> x[y == 1, ] <- x[y == 1, ] + 1\n> plot(x, col = (3 - y))\nThey are not. Next, we fit the support vector classifier. Note that in order\nfor the svm() function to perform classification (as opposed to SVM-based\nregression), we must encode the response as a factor variable. We now\ncreate a data frame with the response coded as a factor.\n> dat <- data.frame(x = x, y = as.factor(y))\n> library(e1071)\n> svmfit <- svm(y \u223c ., data = dat , kernel = \"linear\",\ncost = 10, scale = FALSE)\nThe argument scale = FALSE tells the", "doc_id": "134108e7-cdd1-4af1-b202-286245d077f0", "embedding": null, "doc_hash": "d1751e1bbd619229107f39035af3080631c3d87cad810371d06ff475d5295381", "extra_info": null, "node_info": {"start": 889737, "end": 893231, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "2a48d728-a618-4aa9-9959-0f78dbb2236d", "3": "fe625d73-7564-41c2-9bbc-b6e914111614"}}, "__type__": "1"}, "fe625d73-7564-41c2-9bbc-b6e914111614": {"__data__": {"text": "= 10, scale = FALSE)\nThe argument scale = FALSE tells the svm() function not to scale each\nfeature to have mean zero or standard deviation one; depending on the\napplication, one might prefer to use scale = TRUE.\nWe can now plot the support vector classifier obtained:\n> plot(svmfit , dat)\nNote that the two arguments to the SVM plot() function are the output\nof the call to svm(), as well as the data used in the call to svm(). The region\nof feature space that will be assigned to the \u22121 class is shown in light\nyellow, and the region that will be assigned to the +1 class is shown in\nred. The decision boundary between the two classes is linear (because we\nused the argument kernel = \"linear\"), though due to the way in which the\nplotting function is implemented in this library the decision boundary looks\nsomewhat jagged in the plot. (Note that here the second feature is plotted\non the x-axis and the first feature is plotted on the y-axis, in contrast to\n390 9. Support Vector Machines\nthe behavior of the usual plot() function in R.) The support vectors are\nplotted as crosses and the remaining observations are plotted as circles;\nwe see here that there are seven support vectors. We can determine their\nidentities as follows:\n> svmfit$index\n[1] 1 2 5 7 14 16 17\nWe can obtain some basic information about the support vector classifier\nfit using the summary() command:\n> summary(svmfit)\nCall:\nsvm(formula = y \u223c ., data = dat , kernel = \"linear\", cost = 10,\nscale = FALSE)\nParameters:\nSVM -Type: C- classification\nSVM -Kernel: linear\ncost: 10\nNumber of Support Vectors: 7\n( 4 3 )\nNumber of Classes: 2\nLevels:\n-1 1\nThis tells us, for instance, that a linear kernel was used with cost = 10,\nand that there were seven support vectors, four in one class and three in\nthe other.\nWhat if we instead used a smaller value of the cost parameter?\n> svmfit <- svm(y \u223c ., data = dat , kernel = \"linear\",\ncost = 0.1, scale = FALSE)\n> plot(svmfit , dat)\n> svmfit$index\n[1] 1 2 3 4 5 7 9 10 12 13 14 15 16 17 18 20\nNow that a smaller value of the cost parameter is being used, we obtain a\nlarger number of support vectors, because the margin is now wider. Unfortunately,\nthe svm() function does not explicitly output the coefficients of\nthe linear decision boundary obtained when the support vector classifier is\nfit, nor does it output the width of the margin.\nThe e1071 library includes a built-in function, tune(), to perform crosstune()\nvalidation. By default, tune() performs ten-fold cross-validation on a set\nof models of interest. In order to use this function, we pass in relevant\ninformation about the set of models that are under consideration. The\nfollowing command indicates that we want to compare SVMs with a linear\nkernel, using a range of values of the cost parameter.\n> set.seed (1)\n> tune.out <- tune(svm , y \u223c ., data = dat , kernel = \"linear\",\nranges = list(cost = c(0.001 , 0.01, 0.1, 1, 5, 10, 100)))\n9.6 Lab: Support Vector Machines 391\nWe can easily access the cross-validation errors for each of these models\nusing the summary() command:\n> summary(tune.out)\nParameter tuning of \u2018svm \u2019:\n- sampling method: 10-fold cross validation\n- best parameters:\ncost\n0.1\n- best performance: 0.05\n- Detailed performance results:\ncost error dispersion\n1 1e-03 0.55 0.438\n2 1e-02 0.55 0.438\n3 1e-01 0.05 0.158\n4 1e+00 0.15 0.242\n5 5e+00 0.15 0.242\n6 1e+01 0.15 0.242\n7 1e+02 0.15", "doc_id": "fe625d73-7564-41c2-9bbc-b6e914111614", "embedding": null, "doc_hash": "8736e506cb084a1387f738926c000b4ab5ac6ce9b8bd55e61324c096030c77f2", "extra_info": null, "node_info": {"start": 893254, "end": 896634, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "134108e7-cdd1-4af1-b202-286245d077f0", "3": "4d94470b-04a1-4a72-b061-02d6558ddfb7"}}, "__type__": "1"}, "4d94470b-04a1-4a72-b061-02d6558ddfb7": {"__data__": {"text": "1e+01 0.15 0.242\n7 1e+02 0.15 0.242\nWe see that cost = 0.1 results in the lowest cross-validation error rate. The\ntune() function stores the best model obtained, which can be accessed as\nfollows:\n> bestmod <- tune.out$best.model\n> summary(bestmod)\nThe predict() function can be used to predict the class label on a set of\ntest observations, at any given value of the cost parameter. We begin by\ngenerating a test data set.\n> xtest <- matrix(rnorm (20 * 2), ncol = 2)\n> ytest <- sample(c(-1, 1), 20, rep = TRUE)\n> xtest[ytest == 1, ] <- xtest[ytest == 1, ] + 1\n> testdat <- data.frame(x = xtest , y = as.factor(ytest))\nNow we predict the class labels of these test observations. Here we use the\nbest model obtained through cross-validation in order to make predictions.\n> ypred <- predict(bestmod , testdat)\n> table(predict = ypred , truth = testdat$y)\ntruth\npredict -1 1\n-1 9 1\n1 2 8\nThus, with this value of cost, 17 of the test observations are correctly\nclassified. What if we had instead used cost = 0.01?\n> svmfit <- svm(y \u223c ., data = dat , kernel = \"linear\",\ncost = .01, scale = FALSE)\n> ypred <- predict(svmfit , testdat)\n> table(predict = ypred , truth = testdat$y)\ntruth\npredict -1 1\n392 9. Support Vector Machines\n-1 11 6\n1 0 3\nIn this case three additional observations are misclassified.\nNow consider a situation in which the two classes are linearly separable.\nThen we can find a separating hyperplane using the svm() function. We\nfirst further separate the two classes in our simulated data so that they are\nlinearly separable:\n> x[y == 1, ] <- x[y == 1, ] + 0.5\n> plot(x, col = (y + 5) / 2, pch = 19)\nNow the observations are just barely linearly separable. We fit the support\nvector classifier and plot the resulting hyperplane, using a very large value\nof cost so that no observations are misclassified.\n> dat <- data.frame(x = x, y = as.factor(y))\n> svmfit <- svm(y \u223c ., data = dat , kernel = \"linear\",\ncost = 1e5)\n> summary(svmfit)\nCall:\nsvm(formula = y \u223c ., data = dat , kernel = \"linear\", cost =\n1e+05)\nParameters:\nSVM -Type: C- classification\nSVM -Kernel: linear\ncost: 1e+05\nNumber of Support Vectors: 3\n( 1 2 )\nNumber of Classes: 2\nLevels:\n-1 1\n> plot(svmfit , dat)\nNo training errors were made and only three support vectors were used.\nHowever, we can see from the figure that the margin is very narrow (because\nthe observations that are not support vectors, indicated as circles, are very\nclose to the decision boundary). It seems likely that this model will perform\npoorly on test data. We now try a smaller value of cost:\n> svmfit <- svm(y \u223c ., data = dat , kernel = \"linear\", cost = 1)\n> summary(svmfit)\n> plot(svmfit , dat)\nUsing cost = 1, we misclassify a training observation, but we also obtain a\nmuch wider margin and make use of seven support vectors. It seems likely\nthat this model will perform better on test data than the model with\ncost = 1e5.\n9.6.2 Support Vector Machine\nIn order to fit an SVM using a non-linear kernel, we once again use the svm()\nfunction. However, now we use a different value of the parameter kernel.\n9.6 Lab: Support Vector Machines 393\nTo fit an SVM with a", "doc_id": "4d94470b-04a1-4a72-b061-02d6558ddfb7", "embedding": null, "doc_hash": "5bde58b81bc0d983e1e8b62ad772d14a1a2319afe7d4fe07693b038e35a59f61", "extra_info": null, "node_info": {"start": 896657, "end": 899777, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "fe625d73-7564-41c2-9bbc-b6e914111614", "3": "9f4c3767-0be7-43da-b55f-541289d4fb6c"}}, "__type__": "1"}, "9f4c3767-0be7-43da-b55f-541289d4fb6c": {"__data__": {"text": "Lab: Support Vector Machines 393\nTo fit an SVM with a polynomial kernel we use kernel = \"polynomial\",\nand to fit an SVM with a radial kernel we use kernel = \"radial\". In the\nformer case we also use the degree argument to specify a degree for the\npolynomial kernel (this is d in (9.22)), and in the latter case we use gamma\nto specify a value of \u03b3 for the radial basis kernel (9.24).\nWe first generate some data with a non-linear class boundary, as follows:\n> set.seed (1)\n> x <- matrix(rnorm (200 * 2), ncol = 2)\n> x[1:100, ] <- x[1:100, ] + 2\n> x[101:150, ] <- x[101:150, ] - 2\n> y <- c(rep(1, 150) , rep(2, 50))\n> dat <- data.frame(x = x, y = as.factor(y))\nPlotting the data makes it clear that the class boundary is indeed nonlinear:\n> plot(x, col = y)\nThe data is randomly split into training and testing groups. We then fit\nthe training data using the svm() function with a radial kernel and \u03b3 = 1:\n> train <- sample (200 , 100)\n> svmfit <- svm(y \u223c ., data = dat[train , ], kernel = \"radial\",\ngamma = 1, cost = 1)\n> plot(svmfit , dat[train , ])\nThe plot shows that the resulting SVM has a decidedly non-linear\nboundary. The summary() function can be used to obtain some\ninformation about the SVM fit:\n> summary(svmfit)\nCall:\nsvm(formula = y \u223c ., data = dat[train , ], kernel = \"radial\",\ngamma = 1, cost = 1)\nParameters:\nSVM -Type: C-classification\nSVM -Kernel: radial\ncost: 1\nNumber of Support Vectors: 31\n( 16 15 )\nNumber of Classes: 2\nLevels:\n1 2\nWe can see from the figure that there are a fair number of training errors\nin this SVM fit. If we increase the value of cost, we can reduce the number\nof training errors. However, this comes at the price of a more irregular\ndecision boundary that seems to be at risk of overfitting the data.\n> svmfit <- svm(y \u223c ., data = dat[train , ], kernel = \"radial\",\ngamma = 1, cost = 1e5)\n> plot(svmfit , dat[train , ])\n394 9. Support Vector Machines\nWe can perform cross-validation using tune() to select the best choice of\n\u03b3 and cost for an SVM with a radial kernel:\n> set.seed (1)\n> tune.out <- tune(svm , y \u223c ., data = dat[train , ],\nkernel = \"radial\",\nranges = list(\ncost = c(0.1 , 1, 10, 100, 1000) ,\ngamma = c(0.5, 1, 2, 3, 4)\n)\n)\n> summary(tune.out)\nParameter tuning of \u2018svm \u2019:\n- sampling method: 10-fold cross validation\n- best parameters:\ncost gamma\n1 0.5\n- best performance: 0.07\n- Detailed performance results:\ncost gamma error dispersion\n1 1e-01 0.5 0.26 0.158\n2 1e+00 0.5 0.07 0.082\n3 1e+01 0.5 0.07 0.082\n4 1e+02 0.5 0.14 0.151\n5 1e+03 0.5 0.11 0.074\n6 1e-01 1.0 0.22 0.162\n7 1e+00 1.0 0.07 0.082\n. . .\nTherefore, the best choice of parameters involves cost = 1 and gamma =\n0.5. We can view the test set predictions for this model by applying the\npredict() function to the data. Notice that to do this we subset the dataframe\ndat using -train as an index set.\n> table(\ntrue = dat[-train ,", "doc_id": "9f4c3767-0be7-43da-b55f-541289d4fb6c", "embedding": null, "doc_hash": "aa7874028056755965898d3a9b289c72d705d2957445fbe1fd531d27fa03e4ab", "extra_info": null, "node_info": {"start": 899759, "end": 902606, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "4d94470b-04a1-4a72-b061-02d6558ddfb7", "3": "fa53c742-95cf-4549-8f19-11201e2fbbaa"}}, "__type__": "1"}, "fa53c742-95cf-4549-8f19-11201e2fbbaa": {"__data__": {"text": "using -train as an index set.\n> table(\ntrue = dat[-train , \"y\"],\npred = predict(\ntune.out$best.model , newdata = dat[-train , ]\n)\n)\n12% of test observations are misclassified by this SVM.\n9.6.3 ROC Curves\nThe ROCR package can be used to produce ROC curves such as those in\nFigures 9.10 and 9.11. We first write a short function to plot an ROC curve\ngiven a vector containing a numerical score for each observation, pred, and\na vector containing the class label for each observation, truth.\n> library(ROCR)\n> rocplot <- function(pred , truth , ...) {\n+ predob <- prediction(pred , truth)\n9.6 Lab: Support Vector Machines 395\n+ perf <- performance(predob , \"tpr\", \"fpr\")\n+ plot(perf , ...)\n+ }\nSVMs and support vector classifiers output class labels for each observation.\nHowever, it is also possible to obtain fitted values for each observation,\nwhich are the numerical scores used to obtain the class labels. For instance,\nin the case of a support vector classifier, the fitted value for an observation\nX = (X1,X2, . . . ,Xp)T takes the form \u02c6 \u03b20 + \u02c6 \u03b21X1 + \u02c6 \u03b22X2 + \u00b7 \u00b7 \u00b7 + \u02c6 \u03b2pXp.\nFor an SVM with a non-linear kernel, the equation that yields the fitted\nvalue is given in (9.23). In essence, the sign of the fitted value determines\non which side of the decision boundary the observation lies. Therefore, the\nrelationship between the fitted value and the class prediction for a given\nobservation is simple: if the fitted value exceeds zero then the observation\nis assigned to one class, and if it is less than zero then it is assigned to the\nother. In order to obtain the fitted values for a given SVM model fit, we use\ndecision.values = TRUE when fitting svm(). Then the predict() function\nwill output the fitted values.\n> svmfit.opt <- svm(y \u223c ., data = dat[train , ],\nkernel = \"radial\", gamma = 2, cost = 1,\ndecision.values = T)\n> fitted <- attributes(\npredict(svmfit.opt , dat[train , ], decision.values = TRUE)\n)$decision.values\nNow we can produce the ROC plot. Note we use the negative of the fitted\nvalues so that negative values correspond to class 1 and positive values to\nclass 2.\n> par(mfrow = c(1, 2))\n> rocplot(-fitted, dat[train , \"y\"], main = \"Training Data\")\nSVM appears to be producing accurate predictions. By increasing \u03b3 we can\nproduce a more flexible fit and generate further improvements in accuracy.\n> svmfit.flex <- svm(y \u223c ., data = dat[train , ],\nkernel = \"radial\", gamma = 50, cost = 1,\ndecision.values = T)\n> fitted <- attributes(\npredict(svmfit.flex , dat[train , ], decision.values = T)\n)$decision.values\n> rocplot(-fitted , dat[train , \"y\"], add = T, col = \"red\")\nHowever, these ROC curves are all on the training data. We are really\nmore interested in the level of prediction accuracy on the test data. When\nwe compute the ROC curves on the test data, the model with \u03b3 = 2 appears\nto provide the most accurate results.\n> fitted <- attributes(\npredict(svmfit.opt , dat[-train , ], decision.values = T)\n)$decision.values\n396 9. Support Vector Machines\n> rocplot(-fitted , dat[-train , \"y\"], main = \"Test Data\")\n> fitted <- attributes(\npredict(svmfit.flex , dat[-train , ], decision.values = T)\n)$decision.values\n> rocplot(-fitted , dat[-train , \"y\"], add = T, col =", "doc_id": "fa53c742-95cf-4549-8f19-11201e2fbbaa", "embedding": null, "doc_hash": "3a3341c98246a050df8a5732ab7ae95131ba1ea73a2927552f07133ab8a41975", "extra_info": null, "node_info": {"start": 902602, "end": 905798, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "9f4c3767-0be7-43da-b55f-541289d4fb6c", "3": "dab9955d-687d-4514-ac65-6c91ad86ea79"}}, "__type__": "1"}, "dab9955d-687d-4514-ac65-6c91ad86ea79": {"__data__": {"text": "rocplot(-fitted , dat[-train , \"y\"], add = T, col = \"red\")\n9.6.4 SVM with Multiple Classes\nIf the response is a factor containing more than two levels, then the svm()\nfunction will perform multi-class classification using the one-versus-one approach.\nWe explore that setting here by generating a third class of observations.\n> set.seed (1)\n> x <- rbind(x, matrix(rnorm (50 * 2), ncol = 2))\n> y <- c(y, rep(0, 50))\n> x[y == 0, 2] <- x[y == 0, 2] + 2\n> dat <- data.frame(x = x, y = as.factor(y))\n> par(mfrow = c(1, 1))\n> plot(x, col = (y + 1))\nWe now fit an SVM to the data:\n> svmfit <- svm(y \u223c ., data = dat , kernel = \"radial\",\ncost = 10, gamma = 1)\n> plot(svmfit , dat)\nThe e1071 library can also be used to perform support vector regression,\nif the response vector that is passed in to svm() is numerical rather than a\nfactor.\n9.6.5 Application to Gene Expression Data\nWe now examine the Khan data set, which consists of a number of tissue\nsamples corresponding to four distinct types of small round blue cell tumors.\nFor each tissue sample, gene expression measurements are available.\nThe data set consists of training data, xtrain and ytrain, and testing data,\nxtest and ytest.\nWe examine the dimension of the data:\n> library(ISLR2)\n> names(Khan)\n[1] \"xtrain\" \"xtest\" \"ytrain\" \"ytest\"\n> dim(Khan$xtrain)\n[1] 63 2308\n> dim(Khan$xtest)\n[1] 20 2308\n> length(Khan$ytrain)\n[1] 63\n> length(Khan$ytest)\n[1] 20\n9.6 Lab: Support Vector Machines 397\nThis data set consists of expression measurements for 2,308 genes.\nThe training and test sets consist of 63 and 20 observations respectively.\n> table(Khan$ytrain)\n1 2 3 4\n8 23 12 20\n> table(Khan$ytest)\n1 2 3 4\n3 6 6 5\nWe will use a support vector approach to predict cancer subtype using gene\nexpression measurements. In this data set, there are a very large number\nof features relative to the number of observations. This suggests that we\nshould use a linear kernel, because the additional flexibility that will result\nfrom using a polynomial or radial kernel is unnecessary.\n> dat <- data.frame(\nx = Khan$xtrain,\ny = as.factor(Khan$ytrain)\n)\n> out <- svm(y \u223c ., data = dat , kernel = \"linear\",\ncost = 10)\n> summary(out)\nCall:\nsvm(formula = y \u223c ., data = dat , kernel = \"linear\",\ncost = 10)\nParameters:\nSVM -Type: C- classification\nSVM -Kernel: linear\ncost: 10\nNumber of Support Vectors: 58\n( 20 20 11 7 )\nNumber of Classes: 4\nLevels:\n1 2 3 4\n> table(out$fitted, dat$y)\n1 2 3 4\n1 8 0 0 0\n2 0 23 0 0\n3 0 0 12 0\n4 0 0 0 20\nWe see that there are no training errors. In fact, this is not surprising,\nbecause the large number of variables relative to the number of observations\nimplies that it is easy to find hyperplanes that fully separate the classes.We\nare most interested not in the support vector classifier\u2019s performance on the\ntraining observations, but rather its performance on the test observations.\n> dat.te <- data.frame(\nx = Khan$xtest,\ny = as.factor(Khan$ytest))\n> pred.te <- predict(out , newdata = dat.te)\n> table(pred.te,", "doc_id": "dab9955d-687d-4514-ac65-6c91ad86ea79", "embedding": null, "doc_hash": "bf41afdcf94f48f2f147c04f4ffd291bc9a74b8e0a7a9309402f9e7702ac8edd", "extra_info": null, "node_info": {"start": 905806, "end": 908785, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "fa53c742-95cf-4549-8f19-11201e2fbbaa", "3": "7c66f775-1ee4-4327-ba02-da2e48218d8e"}}, "__type__": "1"}, "7c66f775-1ee4-4327-ba02-da2e48218d8e": {"__data__": {"text": "predict(out , newdata = dat.te)\n> table(pred.te, dat.te$y)\npred.te 1 2 3 4\n1 3 0 0 0\n398 9. Support Vector Machines\n2 0 6 2 0\n3 0 0 4 0\n4 0 0 0 5\nWe see that using cost = 10 yields two test set errors on this data.\n9.7 Exercises\nConceptual\n1. This problem involves hyperplanes in two dimensions.\n(a) Sketch the hyperplane 1 + 3X1 \u2212 X2 = 0. Indicate the set of\npoints for which 1 + 3X1 \u2212 X2 > 0, as well as the set of points\nfor which 1 + 3X1 \u2212 X2 < 0.\n(b) On the same plot, sketch the hyperplane \u22122 + X1 + 2X2 = 0.\nIndicate the set of points for which \u22122+X1 +2X2 > 0, as well\nas the set of points for which \u22122 + X1 + 2X2 < 0.\n2. We have seen that in p = 2 dimensions, a linear decision boundary\ntakes the form \u03b20+\u03b21X1+\u03b22X2 = 0.We now investigate a non-linear\ndecision boundary.\n(a) Sketch the curve\n(1 + X1)2 + (2 \u2212 X2)2 = 4.\n(b) On your sketch, indicate the set of points for which\n(1 + X1)2 + (2 \u2212 X2)2 > 4,\nas well as the set of points for which\n(1 + X1)2 + (2 \u2212 X2)2 \u2264 4.\n(c) Suppose that a classifier assigns an observation to the blue class\nif\n(1 + X1)2 + (2 \u2212 X2)2 > 4,\nand to the red class otherwise. To what class is the observation\n(0, 0) classified? (\u22121, 1)? (2, 2)? (3, 8)?\n(d) Argue that while the decision boundary in (c) is not linear in\nterms of X1 and X2, it is linear in terms of X1, X2\n1 , X2, and\nX2\n2 .\n3. Here we explore the maximal margin classifier on a toy data set.\n9.7 Exercises 399\n(a) We are given n = 7 observations in p = 2 dimensions. For each\nobservation, there is an associated class label.\nObs. X1 X2 Y\n1 3 4 Red\n2 2 2 Red\n3 4 4 Red\n4 1 4 Red\n5 2 1 Blue\n6 4 3 Blue\n7 4 1 Blue\nSketch the observations.\n(b) Sketch the optimal separating hyperplane, and provide the equation\nfor this hyperplane (of the form (9.1)).\n(c) Describe the classification rule for the maximal margin classifier.\nIt should be something along the lines of \u201cClassify to Red if\n\u03b20 +\u03b21X1 +\u03b22X2 > 0, and classify to Blue otherwise.\u201d Provide\nthe values for \u03b20, \u03b21, and \u03b22.\n(d) On your sketch, indicate the margin for the maximal margin\nhyperplane.\n(e) Indicate the support vectors for the maximal margin classifier.\n(f) Argue that a slight movement of the seventh observation would\nnot affect the maximal margin hyperplane.\n(g) Sketch a hyperplane that is not the optimal separating hyperplane,\nand provide the equation for this hyperplane.\n(h) Draw an additional observation on the plot so that the two\nclasses are no longer separable by a hyperplane.\nApplied\n4. Generate a simulated two-class data set with 100 observations and\ntwo features in which there is a visible but non-linear separation between\nthe two classes. Show that in this setting, a support vector\nmachine with a polynomial kernel (with degree greater than 1) or a\nradial kernel will outperform a support vector classifier on the training\ndata. Which technique performs best on the test data? Make\nplots and report training and test error rates in order to back up\nyour assertions.\n5. We have seen that we can fit an SVM", "doc_id": "7c66f775-1ee4-4327-ba02-da2e48218d8e", "embedding": null, "doc_hash": "0be488e4a5adfa0b76f6b08c0308b75a59c4512e126e5d8b03bd8e9205589559", "extra_info": null, "node_info": {"start": 908785, "end": 911774, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "dab9955d-687d-4514-ac65-6c91ad86ea79", "3": "eb202163-0c21-41fb-8e30-94dbcbc831d8"}}, "__type__": "1"}, "eb202163-0c21-41fb-8e30-94dbcbc831d8": {"__data__": {"text": "back up\nyour assertions.\n5. We have seen that we can fit an SVM with a non-linear kernel in order\nto perform classification using a non-linear decision boundary.We will\nnow see that we can also obtain a non-linear decision boundary by\nperforming logistic regression using non-linear transformations of the\nfeatures.\n400 9. Support Vector Machines\n(a) Generate a data set with n = 500 and p = 2, such that the observations\nbelong to two classes with a quadratic decision boundary\nbetween them. For instance, you can do this as follows:\n> x1 <- runif (500) - 0.5\n> x2 <- runif (500) - 0.5\n> y <- 1 * (x1^2 - x2^2 > 0)\n(b) Plot the observations, colored according to their class labels.\nYour plot should display X1 on the x-axis, and X2 on the yaxis.\n(c) Fit a logistic regression model to the data, using X1 and X2 as\npredictors.\n(d) Apply this model to the training data in order to obtain a predicted\nclass label for each training observation. Plot the observations,\ncolored according to the predicted class labels. The\ndecision boundary should be linear.\n(e) Now fit a logistic regression model to the data using non-linear\nfunctions of X1 and X2 as predictors (e.g. X2\n1 , X1\u00d7X2, log(X2),\nand so forth).\n(f) Apply this model to the training data in order to obtain a predicted\nclass label for each training observation. Plot the observations,\ncolored according to the predicted class labels. The\ndecision boundary should be obviously non-linear. If it is not,\nthen repeat (a)-(e) until you come up with an example in which\nthe predicted class labels are obviously non-linear.\n(g) Fit a support vector classifier to the data with X1 and X2 as\npredictors. Obtain a class prediction for each training observation.\nPlot the observations, colored according to the predicted\nclass labels.\n(h) Fit a SVM using a non-linear kernel to the data. Obtain a class\nprediction for each training observation. Plot the observations,\ncolored according to the predicted class labels.\n(i) Comment on your results.\n6. At the end of Section 9.6.1, it is claimed that in the case of data that\nis just barely linearly separable, a support vector classifier with a\nsmall value of cost that misclassifies a couple of training observations\nmay perform better on test data than one with a huge value of cost\nthat does not misclassify any training observations. You will now\ninvestigate this claim.\n(a) Generate two-class data with p = 2 in such a way that the classes\nare just barely linearly separable.\n9.7 Exercises 401\n(b) Compute the cross-validation error rates for support vector\nclassifiers with a range of cost values. How many training errors\nare misclassified for each value of cost considered, and how\ndoes this relate to the cross-validation errors obtained?\n(c) Generate an appropriate test data set, and compute the test\nerrors corresponding to each of the values of cost considered.\nWhich value of cost leads to the fewest test errors, and how\ndoes this compare to the values of cost that yield the fewest\ntraining errors and the fewest cross-validation errors?\n(d) Discuss your results.\n7. In this problem, you will use support vector approaches in order to\npredict whether a given car gets high or low gas mileage based on the\nAuto data set.\n(a) Create a binary variable that takes on a 1 for cars with gas\nmileage above the median, and a 0 for cars with gas mileage\nbelow the median.\n(b) Fit a support vector classifier to the data with various values\nof cost, in order to predict whether a car gets high or low gas\nmileage. Report the cross-validation errors associated with different\nvalues of this parameter. Comment on your results. Note\nyou will need to fit the classifier without the gas mileage variable\nto produce", "doc_id": "eb202163-0c21-41fb-8e30-94dbcbc831d8", "embedding": null, "doc_hash": "b2d2d74e896a12bb3c6420361ed3e563f3821359d05a5ccf60641c3f39c8a260", "extra_info": null, "node_info": {"start": 911766, "end": 915479, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "7c66f775-1ee4-4327-ba02-da2e48218d8e", "3": "bfc18b3b-e790-429a-8f95-6635e3b25080"}}, "__type__": "1"}, "bfc18b3b-e790-429a-8f95-6635e3b25080": {"__data__": {"text": "Note\nyou will need to fit the classifier without the gas mileage variable\nto produce sensible results.\n(c) Now repeat (b), this time using SVMs with radial and polynomial\nbasis kernels, with different values of gamma and degree and\ncost. Comment on your results.\n(d) Make some plots to back up your assertions in (b) and (c).\nHint: In the lab, we used the plot() function for svm objects\nonly in cases with p = 2. When p > 2, you can use the plot()\nfunction to create plots displaying pairs of variables at a time.\nEssentially, instead of typing\n> plot(svmfit , dat)\nwhere svmfit contains your fitted model and dat is a data frame\ncontaining your data, you can type\n> plot(svmfit , dat , x1 \u223c x4)\nin order to plot just the first and fourth variables. However, you\nmust replace x1 and x4 with the correct variable names. To find\nout more, type ?plot.svm.\n8. This problem involves the OJ data set which is part of the ISLR2\npackage.\n402 9. Support Vector Machines\n(a) Create a training set containing a random sample of 800\nobservations, and a test set containing the remaining\nobservations.\n(b) Fit a support vector classifier to the training data using\ncost = 0.01, with Purchase as the response and the other variables\nas predictors. Use the summary() function to produce summary\nstatistics, and describe the results obtained.\n(c) What are the training and test error rates?\n(d) Use the tune() function to select an optimal cost. Consider values\nin the range 0.01 to 10.\n(e) Compute the training and test error rates using this new value\nfor cost.\n(f) Repeat parts (b) through (e) using a support vector machine\nwith a radial kernel. Use the default value for gamma.\n(g) Repeat parts (b) through (e) using a support vector machine\nwith a polynomial kernel. Set degree = 2.\n(h) Overall, which approach seems to give the best results on this\ndata?\n10\nDeep Learning\nThis chapter covers the important topic of deep learning. At the time of\ndeep\nwriting (2020), deep learning is a very active area of research in the machine learning\nlearning and artificial intelligence communities. The cornerstone of deep\nlearning is the neural network.\nneural\nNeural networks rose to fame in the late 1980s. There was a lot of excite- network\nment and a certain amount of hype associated with this approach, and they\nwere the impetus for the popular Neural Information Processing Systems\nmeetings (NeurIPS, formerly NIPS) held every year, typically in exotic\nplaces like ski resorts. This was followed by a synthesis stage, where the\nproperties of neural networks were analyzed by machine learners, mathematicians\nand statisticians; algorithms were improved, and the methodology\nstabilized. Then along came SVMs, boosting, and random forests,\nand neural networks fell somewhat from favor. Part of the reason was that\nneural networks required a lot of tinkering, while the new methods were\nmore automatic. Also, on many problems the new methods outperformed\npoorly-trained neural networks. This was the status quo for the first decade\nin the new millennium.\nAll the while, though, a core group of neural-network enthusiasts were\npushing their technology harder on ever-larger computing architectures and\ndata sets. Neural networks resurfaced after 2010 with the new name deep\nlearning, with new architectures, additional bells and whistles, and a string\nof success stories on some niche problems such as image and video classification,\nspeech and text modeling. Many in the field believe that the major\nreason for these successes is the availability of ever-larger training datasets,\nmade possible by the wide-scale use of digitization in science and industry.\n\u00a9 Springer Science+Business Media, LLC, part of Springer Nature 2021\nG. James et al., An Introduction to Statistical Learning, Springer Texts in", "doc_id": "bfc18b3b-e790-429a-8f95-6635e3b25080", "embedding": null, "doc_hash": "3096f588e991177b09c4f667af0981fa7ad210d22553d31eda063ec5f4ca8c31", "extra_info": null, "node_info": {"start": 915460, "end": 919247, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "eb202163-0c21-41fb-8e30-94dbcbc831d8", "3": "f7b7586f-b152-44a7-96c9-ee2cc5fdc651"}}, "__type__": "1"}, "f7b7586f-b152-44a7-96c9-ee2cc5fdc651": {"__data__": {"text": "James et al., An Introduction to Statistical Learning, Springer Texts in Statistics,\nhttps://doi.org/10.1007/978-1-0716-1418-1_10\n403\n404 10. Deep Learning\nIn this chapter we discuss the basics of neural networks and deep learning,\nand then go into some of the specializations for specific problems, such as\nconvolutional neural networks (CNNs) for image classification, and recurrent\nneural networks (RNNs) for time series and other sequences. We will\nalso demonstrate these models using the R package keras, which interfaces\nwith the tensorflow deep-learning software developed at Google.1\nThe material in this chapter is slightly more challenging than elsewhere\nin this book.\n10.1 Single Layer Neural Networks\nA neural network takes an input vector of p variables X = (X1,X2, . . . ,Xp)\nand builds a nonlinear function f(X) to predict the response Y . We have\nbuilt nonlinear prediction models in earlier chapters, using trees, boosting\nand generalized additive models. What distinguishes neural networks from\nthese methods is the particular structure of the model. Figure 10.1 shows\na simple feed-forward neural network for modeling a quantitative response\nfeed-forward\nneural\nnetwork\nusing p = 4 predictors. In the terminology of neural networks, the four features\nX1, . . . ,X4 make up the units in the input layer. The arrows indicate\nthat each of the inputs from the input layer feeds into each of the K hidden input layer\nunits (we get to pick K; here we chose 5). The neural network model has\nhidden units\nthe form\nf(X) = \u03b20 +\n)K\nk=1 \u03b2khk(X)\n= \u03b20 +\n)K\nk=1 \u03b2kg(wk0 +\n)p\nj=1 wkjXj).\n(10.1)\nIt is built up here in two steps. First the K activations Ak, k = 1, . . . ,K, in\nactivations\nthe hidden layer are computed as functions of the input features X1, . . . ,Xp,\nAk = hk(X) = g(wk0 +\n)p\nj=1 wkjXj), (10.2)\nwhere g(z) is a nonlinear activation function that is specified in advance.\nactivation\nWe can think of each Ak as a different transformation hk(X) of the original function\nfeatures, much like the basis functions of Chapter 7. These K activations\nfrom the hidden layer then feed into the output layer, resulting in\nf(X) = \u03b20 +\n0K\nk=1\n\u03b2kAk, (10.3)\na linear regression model in the K = 5 activations. All the parameters\n\u03b20, . . . ,\u03b2K and w10, . . . ,wKp need to be estimated from data. In the early\n1For more information about keras, see Chollet et al. (2015) \u201cKeras\u201d, available\nat https://keras.io. For more information about tensorflow, see Abadi et al. (2015)\n\u201cTensorFlow: Large-scale machine learning on heterogeneous distributed systems\u201d, available\nat https://www.tensorflow.org/.\n10.1 Single Layer Neural Networks 405\nX1\nX2\nX3\nX4\nA1\nA2\nA3\nA4\nA5\nf(X) Y\nHidden\nLayer\nInput\nLayer\nOutput\nLayer\nFIGURE 10.1. Neural network with a single hidden layer. The hidden layer\ncomputes activations Ak = hk(X) that are nonlinear transformations of linear\ncombinations of the inputs X1,X2, . . . , Xp. Hence these Ak are not directly observed.\nThe functions hk(\u00b7) are not fixed in advance, but are learned during the\ntraining of the network. The output layer is a linear model that uses these activations\nAk as inputs, resulting in a function f(X).\ninstances of neural networks, the sigmoid activation function was favored,\nsigmoid\ng(z) =\nez\n1 + ez =\n1\n1 + e\u2212z ,", "doc_id": "f7b7586f-b152-44a7-96c9-ee2cc5fdc651", "embedding": null, "doc_hash": "f0cb04f1729250c7ae8ead5db95b32d608fd18a4429914eff96bd12eedc8965a", "extra_info": null, "node_info": {"start": 919258, "end": 922522, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "bfc18b3b-e790-429a-8f95-6635e3b25080", "3": "1ef9a1c4-a40f-4201-be50-b5c4755e91b3"}}, "__type__": "1"}, "1ef9a1c4-a40f-4201-be50-b5c4755e91b3": {"__data__": {"text": "=\nez\n1 + ez =\n1\n1 + e\u2212z , (10.4)\nwhich is the same function used in logistic regression to convert a linear\nfunction into probabilities between zero and one (see Figure 10.2). The\npreferred choice in modern neural networks is the ReLU (rectified linear\nReLU\nunit) activation function, which takes the form\nrectified\nlinear unit\ng(z) = (z)+ =\nK\n0 if z < 0\nz otherwise.\n(10.5)\nA ReLU activation can be computed and stored more efficiently than a\nsigmoid activation. Although it thresholds at zero, because we apply it to a\nlinear function (10.2) the constant term wk0 will shift this inflection point.\nSo in words, the model depicted in Figure 10.1 derives five new features\nby computing five different linear combinations of X, and then squashes\neach through an activation function g(\u00b7) to transform it. The final model\nis linear in these derived variables.\nThe name neural network originally derived from thinking of these hidden\nunits as analogous to neurons in the brain \u2014 values of the activations\nAk = hk(X) close to one are firing, while those close to zero are silent\n(using the sigmoid activation function).\n406 10. Deep Learning\n\u22124 \u22122 0 2 4\n0.0 0.2 0.4 0.6 0.8 1.0\nz\ng(z)\nsigmoid\nReLU\nFIGURE 10.2. Activation functions. The piecewise-linear ReLU function is popular\nfor its efficiency and computability. We have scaled it down by a factor of\nfive for ease of comparison.\nThe nonlinearity in the activation function g(\u00b7) is essential, since without\nit the model f(X) in (10.1) would collapse into a simple linear model in\nX1, . . . ,Xp. Moreover, having a nonlinear activation function allows the\nmodel to capture complex nonlinearities and interaction effects. Consider\na very simple example with p = 2 input variables X = (X1,X2), and\nK = 2 hidden units h1(X) and h2(X) with g(z) = z2. We specify the other\nparameters as\n\u03b20 = 0, \u03b21 = 14\n, \u03b22 = \u221214\n,\nw10 = 0, w11 = 1, w12= 1,\nw20 = 0, w21 = 1, w22 = \u22121.\n(10.6)\nFrom (10.2), this means that\nh1(X) = (0 + X1 + X2)2,\nh2(X) = (0 + X1 \u2212 X2)2.\n(10.7)\nThen plugging (10.7) into (10.1), we get\nf(X) = 0+14\n\u00b7 (0 + X1 + X2)2 \u2212 14 \u00b7 (0 + X1 \u2212 X2)2\n= 1\n4\nN\n(X1 + X2)2 \u2212 (X1 \u2212 X2)2\nO\n= X1X2.\n(10.8)\nSo the sum of two nonlinear transformations of linear functions can give\nus an interaction! In practice we would not use a quadratic function for\ng(z), since we would always get a second-degree polynomial in the original\ncoordinates X1, . . . ,Xp. The sigmoid or ReLU activations do not have such\na limitation.\nFitting a neural network requires estimating the unknown parameters in\n(10.1). For a quantitative response, typically squared-error loss is used, so\nthat the parameters are chosen to minimize\n0n\ni=1\n(yi \u2212 f(xi))2 . (10.9)\n10.2 Multilayer Neural Networks 407\nFIGURE 10.3. Examples of handwritten digits from the MNIST corpus. Each\ngrayscale image has 28 \u00d7 28 pixels, each of which is an eight-bit number (0\u2013255)\nwhich represents how dark that pixel is. The first 3, 5, and 8 are enlarged to show\ntheir 784 individual pixel values.\nDetails about how to perform this minimization are provided in Section 10.7.\n10.2 Multilayer Neural Networks\nModern neural", "doc_id": "1ef9a1c4-a40f-4201-be50-b5c4755e91b3", "embedding": null, "doc_hash": "dca1b797a8cec668b638e8d0a852fbba199c7f478b6b66a750158e58d26b3fdd", "extra_info": null, "node_info": {"start": 922566, "end": 925674, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "f7b7586f-b152-44a7-96c9-ee2cc5fdc651", "3": "ad4a45de-d538-49d9-b300-4086bd0b251d"}}, "__type__": "1"}, "ad4a45de-d538-49d9-b300-4086bd0b251d": {"__data__": {"text": "Section 10.7.\n10.2 Multilayer Neural Networks\nModern neural networks typically have more than one hidden layer, and\noften many units per layer. In theory a single hidden layer with a large\nnumber of units has the ability to approximate most functions. However,\nthe learning task of discovering a good solution is made much easier with\nmultiple layers each of modest size.\nWe will illustrate a large dense network on the famous and publicly\navailable MNIST handwritten digit dataset.2 Figure 10.3 shows examples of\nthese digits. The idea is to build a model to classify the images into their\ncorrect digit class 0\u20139. Every image has p = 28 \u00d7 28 = 784 pixels, each\nof which is an eight-bit grayscale value between 0 and 255 representing\nthe relative amount of the written digit in that tiny square.3 These pixels\nare stored in the input vector X (in, say, column order). The output is\nthe class label, represented by a vector Y = (Y0, Y1, . . . ,Y9) of 10 dummy\nvariables, with a one in the position corresponding to the label, and zeros\nelsewhere. In the machine learning community, this is known as one-hot\nencoding. There are 60,000 training images, and 10,000 test images.\none-hot\nOn a historical note, digit recognition problems were the catalyst that encoding\naccelerated the development of neural network technology in the late 1980s\nat AT&T Bell Laboratories and elsewhere. Pattern recognition tasks of this\n2See LeCun, Cortes, and Burges (2010) \u201cThe MNIST database of handwritten digits\u201d,\navailable at http://yann.lecun.com/exdb/mnist.\n3In the analog-to-digital conversion process, only part of the written numeral may\nfall in the square representing a particular pixel.\n408 10. Deep Learning\nkind are relatively simple for humans. Our visual system occupies a large\nfraction of our brains, and good recognition is an evolutionary force for\nsurvival. These tasks are not so simple for machines, and it has taken more\nthan 30 years to refine the neural-network architectures to match human\nperformance.\nFigure 10.4 shows a multilayer network architecture that works well for\nsolving the digit-classification task. It differs from Figure 10.1 in several\nways:\n\u2022 It has two hidden layers L1 (256 units) and L2 (128 units) rather\nthan one. Later we will see a network with seven hidden layers.\n\u2022 It has ten output variables, rather than one. In this case the ten variables\nreally represent a single qualitative variable and so are quite\ndependent. (We have indexed them by the digit class 0\u20139 rather than\n1\u201310, for clarity.) More generally, in multi-task learning one can premulti-\ntask\ndict different responses simultaneously with a single network; they all learning\nhave a say in the formation of the hidden layers.\n\u2022 The loss function used for training the network is tailored for the\nmulticlass classification task.\nThe first hidden layer is as in (10.2), with\nA(1)\nk = h(1)\nk (X)\n= g(w(1)\nk0 +\n)p\nj=1 w(1)\nkj Xj)\n(10.10)\nfor k = 1, . . . ,K1. The second hidden layer treats the activations A(1)\nk of\nthe first hidden layer as inputs and computes new activations\nA(2)\n\u2113 = h(2)\n\u2113 (X)\n= g(w(2)\n\u21130 +\n)K1\nk=1 w(2)\n\u2113k A(1)\nk )\n(10.11)\nfor \u2113 = 1, . . . ,K2. Notice that each of the activations in the second layer\nA(2)\n\u2113 = h(2)\n\u2113 (X) is a function of the input vector X. This is the case because\nwhile they are explicitly a function of the activations A(1)\nk from layer L1,\nthese in turn are functions of X. This would also be the case with", "doc_id": "ad4a45de-d538-49d9-b300-4086bd0b251d", "embedding": null, "doc_hash": "a627f5c3ce6b48c7e67e417885acaf31fb4b64a6e5bbfbcc618d43957eefb5f0", "extra_info": null, "node_info": {"start": 925640, "end": 929081, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "1ef9a1c4-a40f-4201-be50-b5c4755e91b3", "3": "3a30299b-82bd-4428-8f87-6cf1ac23551d"}}, "__type__": "1"}, "3a30299b-82bd-4428-8f87-6cf1ac23551d": {"__data__": {"text": "L1,\nthese in turn are functions of X. This would also be the case with more\nhidden layers. Thus, through a chain of transformations, the network is\nable to build up fairly complex transformations of X that ultimately feed\ninto the output layer as features.\nWe have introduced additional superscript notation such as h(2)\n\u2113 (X) and\nw(2)\n\u2113j in (10.10) and (10.11) to indicate to which layer the activations and\nweights (coefficients) belong, in this case layer 2. The notation W1 in Figweights\nure 10.4 represents the entire matrix of weights that feed from the input\nlayer to the first hidden layer L1. This matrix will have 785\u00d7256 = 200,960\n10.2 Multilayer Neural Networks 409\nX1\nX2\nX3\nX4\nX5\nX6\n...\nXp\nA(1)\n1\nA(1)\n2\nA(1)\n3\nA(1)\n4\n...\nA(1)\nK1\nA(2)\n1\nA(2)\n2\nA(2)\n3\n...\nA(2)\nK2\nf0(X) Y0\nf1(X) Y1\n...\n...\nf9(X) Y9\nHidden\nlayer L2\nHidden\nlayer L1\nInput\nlayer\nOutput\nlayer\nW1\nW2\nB\nFIGURE 10.4. Neural network diagram with two hidden layers and multiple\noutputs, suitable for the MNIST handwritten-digit problem. The input layer has\np = 784 units, the two hidden layers K1 = 256 and K2 = 128 units respectively,\nand the output layer 10 units. Along with intercepts (referred to as biases in the\ndeep-learning community) this network has 235,146 parameters (referred to as\nweights).\nelements; there are 785 rather than 784 because we must account for the\nintercept or bias term.4\nbias\nEach element A(1)\nk feeds to the second hidden layer L2 via the matrix of\nweights W2 of dimension 257 \u00d7 128 = 32,896.\nWe now get to the output layer, where we now have ten responses rather\nthan one. The first step is to compute ten different linear models similar\nto our single model (10.1),\nZm = \u03b2m0 +\n)K2\n\u2113=1 \u03b2m\u2113h(2)\n\u2113 (X)\n= \u03b2m0 +\n)K2\n\u2113=1 \u03b2m\u2113A(2)\n\u2113 ,\n(10.12)\nfor m = 0, 1, . . . , 9. The matrix B stores all 129 \u00d7 10 = 1,290 of these\nweights.\n4The use of \u201cweights\u201d for coefficients and \u201cbias\u201d for the intercepts wk0 in (10.2) is\npopular in the machine learning community; this use of bias is not to be confused with\nthe \u201cbias-variance\u201d usage elsewhere in this book.\n410 10. Deep Learning\nMethod Test Error\nNeural Network + Ridge Regularization 2.3%\nNeural Network + Dropout Regularization 1.8%\nMultinomial Logistic Regression 7.2%\nLinear Discriminant Analysis 12.7%\nTABLE 10.1. Test error rate on the MNIST data, for neural networks with two\nforms of regularization, as well as multinomial logistic regression and linear discriminant\nanalysis. In this example, the extra complexity of the neural network\nleads to a marked improvement in test error.\nIf these were all separate quantitative responses, we would simply set\neach fm(X) = Zm and be done. However, we would like our estimates to\nrepresent class probabilities fm(X) = Pr(Y = m|X), just like in multinomial\nlogistic regression in Section 4.3.5. So we use the special softmax\nsoftmax\nactivation function (see (4.13) on page 141),\nfm(X) = Pr(Y = m|X) =\neZm\n)9\n\u2113=0 eZ\u2113\n, (10.13)\nfor m = 0, 1, . . . , 9. This ensures that the 10 numbers", "doc_id": "3a30299b-82bd-4428-8f87-6cf1ac23551d", "embedding": null, "doc_hash": "0bd9285aeb54d2eb32b777cd3295f9d6661e56f2ec0d6fda7a9b00330a2446e8", "extra_info": null, "node_info": {"start": 929079, "end": 932050, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "ad4a45de-d538-49d9-b300-4086bd0b251d", "3": "1895e169-d872-404c-a964-9a03051776da"}}, "__type__": "1"}, "1895e169-d872-404c-a964-9a03051776da": {"__data__": {"text": "m = 0, 1, . . . , 9. This ensures that the 10 numbers behave like probabilities\n(non-negative and sum to one). Even though the goal is to build\na classifier, our model actually estimates a probability for each of the 10\nclasses. The classifier then assigns the image to the class with the highest\nprobability.\nTo train this network, since the response is qualitative, we look for coefficient\nestimates that minimize the negative multinomial log-likelihood\n\u2212\n0n\ni=1\n09\nm=0\nyim log(fm(xi)), (10.14)\nalso known as the cross-entropy. This is a generalization of the crite- crossrion\n(4.5) for two-class logistic regression. Details on how to minimize this entropy\nobjective are given in Section 10.7. If the response were quantitative, we\nwould instead minimize squared-error loss as in (10.9).\nTable 10.1 compares the test performance of the neural network with\ntwo simple models presented in Chapter 4 that make use of linear decision\nboundaries: multinomial logistic regression and linear discriminant analysis.\nThe improvement of neural networks over both of these linear methods is\ndramatic: the network with dropout regularization achieves a test error rate\nbelow 2% on the 10,000 test images. (We describe dropout regularization in\nSection 10.7.3.) In Section 10.9.2 of the lab, we present the code for fitting\nthis model, which runs in just over two minutes on a laptop computer.\nAdding the number of coefficients in W1, W2 and B, we get 235,146 in\nall, more than 33 times the number 785 \u00d7 9 = 7,065 needed for multinomial\nlogistic regression. Recall that there are 60,000 images in the training\n10.3 Convolutional Neural Networks 411\nFIGURE 10.5. A sample of images from the CIFAR100 database: a collection of\nnatural images from everyday life, with 100 different classes represented.\nset. While this might seem like a large training set, there are almost four\ntimes as many coefficients in the neural network model as there are observations\nin the training set! To avoid overfitting, some regularization is\nneeded. In this example, we used two forms of regularization: ridge regularization,\nwhich is similar to ridge regression from Chapter 6, and dropout\ndropout\nregularization. We discuss both forms of regularization in Section 10.7.\n10.3 Convolutional Neural Networks\nNeural networks rebounded around 2010 with big successes in image classification.\nAround that time, massive databases of labeled images were being\naccumulated, with ever-increasing numbers of classes. Figure 10.5 shows\n75 images drawn from the CIFAR100 database.5 This database consists of\n60,000 images labeled according to 20 superclasses (e.g. aquatic mammals),\nwith five classes per superclass (beaver, dolphin, otter, seal, whale). Each\nimage has a resolution of 32 \u00d7 32 pixels, with three eight-bit numbers per\npixel representing red, green and blue. The numbers for each image are\norganized in a three-dimensional array called a feature map. The first two\nfeature map\naxes are spatial (both are 32-dimensional), and the third is the channel\nchannel\naxis,6 representing the three colors. There is a designated training set of\n50,000 images, and a test set of 10,000.\nA special family of convolutional neural networks (CNNs) has evolved for\nconvolutional\nneural\nnetworks\nclassifying images such as these, and has shown spectacular success on a\nwide range of problems. CNNs mimic to some degree how humans classify\nimages, by recognizing specific features or patterns anywhere in the image\n5See Chapter 3 of Krizhevsky (2009) \u201cLearning multiple layers of features\nfrom tiny images\u201d, available at https://www.cs.toronto.edu/~kriz/\nlearning-features-2009-TR.pdf.\n6The term channel is taken from the signal-processing literature. Each channel is a\ndistinct source of information.\n412 10. Deep Learning\nFIGURE 10.6. Schematic showing how a convolutional", "doc_id": "1895e169-d872-404c-a964-9a03051776da", "embedding": null, "doc_hash": "772f4c0dff5a36c6c76a5f10d61ba9650068fe1e584026589a835d16a5bef2f7", "extra_info": null, "node_info": {"start": 932069, "end": 935900, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "3a30299b-82bd-4428-8f87-6cf1ac23551d", "3": "58ec49ee-fcbe-4443-8b6d-94cfd9215cb2"}}, "__type__": "1"}, "58ec49ee-fcbe-4443-8b6d-94cfd9215cb2": {"__data__": {"text": "10. Deep Learning\nFIGURE 10.6. Schematic showing how a convolutional neural network classifies\nan image of a tiger. The network takes in the image and identifies local features.\nIt then combines the local features in order to create compound features, which in\nthis example include eyes and ears. These compound features are used to output\nthe label \u201ctiger\u201d.\nthat distinguish each particular object class. In this section we give a brief\noverview of how they work.\nFigure 10.6 illustrates the idea behind a convolutional neural network on\na cartoon image of a tiger.7\nThe network first identifies low-level features in the input image, such\nas small edges, patches of color, and the like. These low-level features are\nthen combined to form higher-level features, such as parts of ears, eyes,\nand so on. Eventually, the presence or absence of these higher-level features\ncontributes to the probability of any given output class.\nHow does a convolutional neural network build up this hierarchy? It combines\ntwo specialized types of hidden layers, called convolution layers and\npooling layers. Convolution layers search for instances of small patterns in\nthe image, whereas pooling layers downsample these to select a prominent\nsubset. In order to achieve state-of-the-art results, contemporary neuralnetwork\narchitectures make use of many convolution and pooling layers.\nWe describe convolution and pooling layers next.\n10.3.1 Convolution Layers\nA convolution layer is made up of a large number of convolution filters, each\nconvolution\nlayer\nconvolution\nfilter\nof which is a template that determines whether a particular local feature is\npresent in an image. A convolution filter relies on a very simple operation,\ncalled a convolution, which basically amounts to repeatedly multiplying\nmatrix elements and then adding the results.\n7Thanks to Elena Tuzhilina for producing the diagram and https://www.\ncartooning4kids.com/ for permission to use the cartoon tiger.\n10.3 Convolutional Neural Networks 413\nTo understand how a convolution filter works, consider a very simple\nexample of a 4 \u00d7 3 image:\nOriginal Image =\n\u23a1\n\u23a2\u23a2\u23a3\na b c\nd e f\ng h i\nj k l\n\u23a4\n\u23a5\u23a5\u23a6\n.\nNow consider a 2 \u00d7 2 filter of the form\nConvolution Filter =\n3\n\u03b1 \u03b2\n\u03b3 \u03b4\n4\n.\nWhen we convolve the image with the filter, we get the result8\nConvolved Image =\n\u23a1\n\u23a3\na\u03b1 + b\u03b2 + d\u03b3 + e\u03b4 b\u03b1 + c\u03b2 + e\u03b3 + f\u03b4\nd\u03b1 + e\u03b2 + g\u03b3 + h\u03b4 e\u03b1 + f\u03b2 + h\u03b3 + i\u03b4\ng\u03b1 + h\u03b2 + j\u03b3 + k\u03b4 h\u03b1 + i\u03b2 + k\u03b3 + l\u03b4\n\u23a4\n\u23a6 .\nFor instance, the top-left element comes from multiplying each element in\nthe 2 \u00d7 2 filter by the corresponding element in the top left 2 \u00d7 2 portion\nof the image, and adding the results. The other elements are obtained in\na similar way: the convolution filter is applied to every 2 \u00d7 2 submatrix\nof the original image in order to obtain the convolved image. If a 2 \u00d7 2\nsubmatrix of the original image resembles the convolution filter, then it will\nhave a large value in the convolved image; otherwise, it will have a small\nvalue. Thus, the convolved image highlights regions of the original image\nthat resemble the convolution filter. We have used 2 \u00d7 2 as an example;\nin general convolution filters are small \u21131 \u00d7 \u21132 arrays, with \u21131 and \u21132 small\npositive integers that are not necessarily equal.\nFigure 10.7 illustrates the application of two convolution filters to a 192\u00d7 179 image of a tiger, shown on the left-hand side.9 Each convolution filter\nis a 15 \u00d7 15 image containing mostly zeros (black), with a narrow strip\nof ones (white) oriented either vertically or horizontally", "doc_id": "58ec49ee-fcbe-4443-8b6d-94cfd9215cb2", "embedding": null, "doc_hash": "32004571858d2b59e3fdb3f6f1a4076d77f0cbb8444cae4b2ad6f4512145c364", "extra_info": null, "node_info": {"start": 935880, "end": 939386, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "1895e169-d872-404c-a964-9a03051776da", "3": "b91112f1-9f78-4fd9-8b6e-98a8fbd279dd"}}, "__type__": "1"}, "b91112f1-9f78-4fd9-8b6e-98a8fbd279dd": {"__data__": {"text": "with a narrow strip\nof ones (white) oriented either vertically or horizontally within the image.\nWhen each filter is convolved with the image of the tiger, areas of the tiger\nthat resemble the filter (i.e. that have either horizontal or vertical stripes or\nedges) are given large values, and areas of the tiger that do not resemble the\nfeature are given small values. The convolved images are displayed on the\nright-hand side. We see that the horizontal stripe filter picks out horizontal\nstripes and edges in the original image, whereas the vertical stripe filter\npicks out vertical stripes and edges in the original image.\n8The convolved image is smaller than the original image because its dimension is\ngiven by the number of 2 \u00d7 2 submatrices in the original image. Note that 2 \u00d7 2 is the\ndimension of the convolution filter. If we want the convolved image to have the same\ndimension as the original image, then padding can be applied.\n9The tiger image used in Figures 10.7\u201310.9 was obtained from the public domain\nimage resource https://www.needpix.com/.\n414 10. Deep Learning\nFIGURE 10.7. Convolution filters find local features in an image, such as edges\nand small shapes. We begin with the image of the tiger shown on the left, and\napply the two small convolution filters in the middle. The convolved images highlight\nareas in the original image where details similar to the filters are found.\nSpecifically, the top convolved image highlights the tiger\u2019s vertical stripes, whereas\nthe bottom convolved image highlights the tiger\u2019s horizontal stripes. We can think\nof the original image as the input layer in a convolutional neural network, and\nthe convolved images as the units in the first hidden layer.\nWe have used a large image and two large filters in Figure 10.7 for illustration.\nFor the CIFAR100 database there are 32\u00d732 color pixels per image,\nand we use 3 \u00d7 3 convolution filters.\nIn a convolution layer, we use a whole bank of filters to pick out a variety\nof differently-oriented edges and shapes in the image. Using predefined\nfilters in this way is standard practice in image processing. By contrast,\nwith CNNs the filters are learned for the specific classification task. We can\nthink of the filter weights as the parameters going from an input layer to a\nhidden layer, with one hidden unit for each pixel in the convolved image.\nThis is in fact the case, though the parameters are highly structured and\nconstrained (see Exercise 4 for more details). They operate on localized\npatches in the input image (so there are many structural zeros), and the\nsame weights in a given filter are reused for all possible patches in the image\n(so the weights are constrained).10\nWe now give some additional details.\n\u2022 Since the input image is in color, it has three channels represented\nby a three-dimensional feature map (array). Each channel is a twodimensional\n(32 \u00d7 32) feature map \u2014 one for red, one for green, and\none for blue. A single convolution filter will also have three channels,\none per color, each of dimension 3\u00d73, with potentially different filter\nweights. The results of the three convolutions are summed to form\n10This used to be called weight sharing in the early years of neural networks.\n10.3 Convolutional Neural Networks 415\na two-dimensional output feature map. Note that at this point the\ncolor information has been used, and is not passed on to subsequent\nlayers except through its role in the convolution.\n\u2022 If we use K different convolution filters at this first hidden layer,\nwe get K two-dimensional output feature maps, which together are\ntreated as a single three-dimensional feature map. We view each of\nthe K output feature maps as a separate channel of information, so\nnow we have K channels in contrast to the three color channels of\nthe original input feature map. The three-dimensional feature map is\njust like the activations in a hidden layer of a simple neural network,\nexcept organized and produced in a spatially structured way.\n\u2022 We typically apply the ReLU activation function (10.5) to the convolved\nimage. This step is sometimes viewed as a separate layer", "doc_id": "b91112f1-9f78-4fd9-8b6e-98a8fbd279dd", "embedding": null, "doc_hash": "7bd22808888122db87734cef29f9cf57f4a42981ccff35414c0f2d8a9a235468", "extra_info": null, "node_info": {"start": 939379, "end": 943492, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "58ec49ee-fcbe-4443-8b6d-94cfd9215cb2", "3": "b91a2124-5798-41d4-bf74-bf6074f9212f"}}, "__type__": "1"}, "b91a2124-5798-41d4-bf74-bf6074f9212f": {"__data__": {"text": "to the convolved\nimage. This step is sometimes viewed as a separate layer in\nthe convolutional neural network, in which case it is referred to as a\ndetector layer.\ndetector\nlayer\n10.3.2 Pooling Layers\nA pooling layer provides a way to condense a large image into a smaller\npooling\nsummary image. While there are a number of possible ways to perform\npooling, the max pooling operation summarizes each non-overlapping 2\u00d72\nblock of pixels in an image using the maximum value in the block. This\nreduces the size of the image by a factor of two in each direction, and it\nalso provides some location invariance: i.e. as long as there is a large value\nin one of the four pixels in the block, the whole block registers as a large\nvalue in the reduced image.\nHere is a simple example of max pooling:\nMax pool\n\u23a1\n\u23a2\u23a2\u23a3\n1 2 5 3\n3 0 1 2\n2 1 3 4\n1 1 2 0\n\u23a4\n\u23a5\u23a5\u23a6 \u2192\n3\n3 5\n2 4\n4\n.\n10.3.3 Architecture of a Convolutional Neural Network\nSo far we have defined a single convolution layer \u2014 each filter produces a\nnew two-dimensional feature map. The number of convolution filters in a\nconvolution layer is akin to the number of units at a particular hidden layer\nin a fully-connected neural network of the type we saw in Section 10.2.\nThis number also defines the number of channels in the resulting threedimensional\nfeature map. We have also described a pooling layer, which\nreduces the first two dimensions of each three-dimensional feature map.\nDeep CNNs have many such layers. Figure 10.8 shows a typical architecture\nfor a CNN for the CIFAR100 image classification task.\n416 10. Deep Learning\n32\n16\n32\n8\n16\n4\n32\n2\n500\n100\nconvolve\nconvolve\nconvolve\npool\npool\npool flatten\n8\nFIGURE 10.8. Architecture of a deep CNN for the CIFAR100 classification task.\nConvolution layers are interspersed with 2 \u00d7 2 max-pool layers, which reduce the\nsize by a factor of 2 in both dimensions.\nAt the input layer, we see the three-dimensional feature map of a color\nimage, where the channel axis represents each color by a 32 \u00d7 32 twodimensional\nfeature map of pixels. Each convolution filter produces a new\nchannel at the first hidden layer, each of which is a 32 \u00d7 32 feature map\n(after some padding at the edges). After this first round of convolutions, we\nnow have a new \u201cimage\u201d; a feature map with considerably more channels\nthan the three color input channels (six in the figure, since we used six\nconvolution filters).\nThis is followed by a max-pool layer, which reduces the size of the feature\nmap in each channel by a factor of four: two in each dimension.\nThis convolve-then-pool sequence is now repeated for the next two layers.\nSome details are as follows:\n\u2022 Each subsequent convolve layer is similar to the first. It takes as input\nthe three-dimensional feature map from the previous layer and treats\nit like a single multi-channel image. Each convolution filter learned\nhas as many channels as this feature map.\n\u2022 Since the channel feature maps are reduced in size after each pool\nlayer, we usually increase the number of filters in the next convolve\nlayer to compensate.\n\u2022 Sometimes we repeat several convolve layers before a pool layer. This\neffectively increases the dimension of the filter.\nThese operations are repeated until the pooling has reduced each channel\nfeature map down to just a few pixels in each dimension. At this point the\nthree-dimensional feature maps are flattened \u2014 the pixels are treated as\nseparate units \u2014 and fed into one or more fully-connected layers before\nreaching the output layer, which is a softmax activation for the 100 classes\n(as in (10.13)).\nThere are many tuning parameters to be selected in constructing such a\nnetwork, apart from the number, nature, and sizes of each layer. Dropout\nlearning can be used at each layer, as well as", "doc_id": "b91a2124-5798-41d4-bf74-bf6074f9212f", "embedding": null, "doc_hash": "26213119c7dd2d0bb86e216af3ec37641bb851ae23e9271fa108a873dcdbde12", "extra_info": null, "node_info": {"start": 943499, "end": 947247, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "b91112f1-9f78-4fd9-8b6e-98a8fbd279dd", "3": "87365a1c-0d72-4971-86d5-960c205dfd9d"}}, "__type__": "1"}, "87365a1c-0d72-4971-86d5-960c205dfd9d": {"__data__": {"text": "sizes of each layer. Dropout\nlearning can be used at each layer, as well as lasso or ridge regularization\n(see Section 10.7). The details of constructing a convolutional neural network\ncan seem daunting. Fortunately, terrific software is available, with\n10.3 Convolutional Neural Networks 417\nFIGURE 10.9. Data augmentation. The original image (leftmost) is distorted\nin natural ways to produce different images with the same class label. These distortions\ndo not fool humans, and act as a form of regularization when fitting the\nCNN.\nextensive examples and vignettes that provide guidance on sensible choices\nfor the parameters. For the CIFAR100 official test set, the best accuracy as\nof this writing is just above 75%, but undoubtedly this performance will\ncontinue to improve.\n10.3.4 Data Augmentation\nAn additional important trick used with image modeling is data augmentdata\naugation.\nEssentially, each training image is replicated many times, with each mentation\nreplicate randomly distorted in a natural way such that human recognition\nis unaffected. Figure 10.9 shows some examples. Typical distortions are\nzoom, horizontal and vertical shift, shear, small rotations, and in this case\nhorizontal flips. At face value this is a way of increasing the training set\nconsiderably with somewhat different examples, and thus protects against\noverfitting. In fact we can see this as a form of regularization: we build a\ncloud of images around each original image, all with the same label. This\nkind of fattening of the data is similar in spirit to ridge regularization.\nWe will see in Section 10.7.2 that the stochastic gradient descent algorithms\nfor fitting deep learning models repeatedly process randomlyselected\nbatches of, say, 128 training images at a time. This works hand-inglove\nwith augmentation, because we can distort each image in the batch\non the fly, and hence do not have to store all the new images.\n10.3.5 Results Using a Pretrained Classifier\nHere we use an industry-level pretrained classifier to predict the class of\nsome new images. The resnet50 classifier is a convolutional neural network\nthat was trained using the imagenet data set, which consists of millions of\nimages that belong to an ever-growing number of categories.11 Figure 10.10\n11For more information about resnet50, see He, Zhang, Ren, and Sun (2015) \u201cDeep\nresidual learning for image recognition\u201d, https://arxiv.org/abs/1512.03385. For details\nabout imagenet, see Russakovsky, Deng, et al. (2015) \u201cImageNet Large Scale\nVisual Recognition Challenge\u201d, in International Journal of Computer Vision.\n418 10. Deep Learning\nflamingo Cooper\u2019s hawk Cooper\u2019s hawk\nflamingo 0.83 kite 0.60 fountain 0.35\nspoonbill 0.17 great grey owl 0.09 nail 0.12\nwhite stork 0.00 robin 0.06 hook 0.07\nLhasa Apso cat Cape weaver\nTibetan terrier 0.56 Old English sheepdog 0.82 jacamar 0.28\nLhasa 0.32 Shih-Tzu 0.04 macaw 0.12\ncocker spaniel 0.03 Persian cat 0.04 robin 0.12\nFIGURE 10.10. Classification of six photographs using the resnet50 CNN\ntrained on the imagenet corpus. The table below the images displays the true\n(intended) label at the top of each panel, and the top three choices of the classifier\n(out of 100). The numbers are the estimated probabilities for each choice. (A kite\nis a raptor, but not a hawk.)\ndemonstrates the performance of resnet50 on six photographs (private collection\nof one of the authors).12 The CNN does a reasonable job classifying\nthe hawk in the second image. If we zoom out as in the third image, it\ngets confused and chooses the fountain rather than the hawk. In the final\nimage a \u201cjacamar\u201d is a tropical bird from South and Central America with\nsimilar coloring to the South African Cape Weaver. We give more details\non", "doc_id": "87365a1c-0d72-4971-86d5-960c205dfd9d", "embedding": null, "doc_hash": "8250fe75d87c5c29dbc0b3ca739fed5fc34503ed31d3a0596957f0978f3ff15a", "extra_info": null, "node_info": {"start": 947248, "end": 950972, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "b91a2124-5798-41d4-bf74-bf6074f9212f", "3": "acf92a72-dfde-4e95-9d27-bd6836eadf55"}}, "__type__": "1"}, "acf92a72-dfde-4e95-9d27-bd6836eadf55": {"__data__": {"text": "with\nsimilar coloring to the South African Cape Weaver. We give more details\non this example in Section 10.9.4.\nMuch of the work in fitting a CNN is in learning the convolution filters\nat the hidden layers; these are the coefficients of a CNN. For models fit to\nmassive corpora such as imagenet with many classes, the output of these\n12These resnet results can change with time, since the publicly-trained model gets\nupdated periodically.\n10.4 Document Classification 419\nfilters can serve as features for general natural-image classification problems.\nOne can use these pretrained hidden layers for new problems with\nmuch smaller training sets (a process referred to as weight freezing), and\nweight\njust train the last few layers of the network, which requires much less data. freezing\nThe vignettes and book13 that accompany the keras package give more\ndetails on such applications.\n10.4 Document Classification\nIn this section we introduce a new type of example that has important\napplications in industry and science: predicting attributes of documents.\nExamples of documents include articles in medical journals, Reuters news\nfeeds, emails, tweets, and so on. Our example will be IMDb (Internet Movie\nDatabase) ratings \u2014 short documents where viewers have written critiques\nof movies.14 The response in this case is the sentiment of the review, which\nwill be positive or negative.\nHere is the beginning of a rather amusing negative review:\nThis has to be one of the worst films of the 1990s. When my\nfriends & I were watching this film (being the target audience it\nwas aimed at) we just sat & watched the first half an hour with\nour jaws touching the floor at how bad it really was. The rest\nof the time, everyone else in the theater just started talking to\neach other, leaving or generally crying into their popcorn . . .\nEach review can be a different length, include slang or non-words, have\nspelling errors, etc. We need to find a way to featurize such a document.\nfeaturize\nThis is modern parlance for defining a set of predictors.\nThe simplest and most common featurization is the bag-of-words model.\nbag-of-words\nWe score each document for the presence or absence of each of the words in\na language dictionary \u2014 in this case an English dictionary. If the dictionary\ncontains M words, that means for each document we create a binary feature\nvector of length M, and score a 1 for every word present, and 0 otherwise.\nThat can be a very wide feature vector, so we limit the dictionary \u2014 in\nthis case to the 10,000 most frequently occurring words in the training\ncorpus of 25,000 reviews. Fortunately there are nice tools for doing this\nautomatically. Here is the beginning of a positive review that has been\nredacted in this way:\n\u27e8START\u27e9 this film was just brilliant casting location scenery\nstory direction everyone\u2019s really suited the part they played and\n13Deep Learning with R by F. Chollet and J.J. Allaire, 2018, Manning Publications.\n14For details, see Maas et al. (2011) \u201cLearning word vectors for sentiment analysis\u201d,\nin Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics:\nHuman Language Technologies, pages 142\u2013150.\n420 10. Deep Learning\n\u25cf\n\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\n\u25cf\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\u25cf\n\u25cf\n\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\n4 6 8 10 12\n0.6 0.7 0.8 0.9 1.0\nLasso\n\u2212", "doc_id": "acf92a72-dfde-4e95-9d27-bd6836eadf55", "embedding": null, "doc_hash": "8977187990ffe74e14c9d96bec5237d9c4065e4ffa543f30ae2725a93fb5dfed", "extra_info": null, "node_info": {"start": 950967, "end": 954304, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "87365a1c-0d72-4971-86d5-960c205dfd9d", "3": "189460e0-def7-497d-b0ca-ea6c0845d9fd"}}, "__type__": "1"}, "189460e0-def7-497d-b0ca-ea6c0845d9fd": {"__data__": {"text": "0.7 0.8 0.9 1.0\nLasso\n\u2212 log(\u03bb)\nAccuracy\n\u25cf\n\u25cf\u25cf\u25cf\n\u25cf\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\u25cf\n\u25cf\n\u25cf\u25cf\u25cf\u25cf\n\u25cf\n\u25cf\n\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\n\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\n\u25cf\u25cf\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\n\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\n\u25cf\n\u25cf\n\u25cf\ntrain\nvalidation\ntest\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf \u25cf \u25cf \u25cf \u25cf \u25cf \u25cf \u25cf \u25cf \u25cf \u25cf \u25cf \u25cf\n5 10 15 20\n0.6 0.7 0.8 0.9 1.0\nNeural Net\nEpochs\nAccuracy\n\u25cf\n\u25cf \u25cf \u25cf \u25cf \u25cf \u25cf \u25cf \u25cf\n\u25cf \u25cf \u25cf \u25cf \u25cf \u25cf \u25cf \u25cf\n\u25cf\n\u25cf \u25cf \u25cf\n\u25cf \u25cf \u25cf\n\u25cf \u25cf \u25cf \u25cf\n\u25cf \u25cf \u25cf \u25cf \u25cf \u25cf \u25cf \u25cf \u25cf \u25cf \u25cf \u25cf\nFIGURE 10.11. Accuracy of the lasso and a two-hidden-layer neural network\non the IMDb data. For the lasso, the x-axis displays \u2212log(\u03bb), while for the neural\nnetwork it displays epochs (number of times the fitting algorithm passes through\nthe training set). Both show a tendency to overfit, and achieve approximately the\nsame test accuracy.\nyou could just imagine being there robert \u27e8UNK\u27e9 is an amazing\nactor and now the same being director \u27e8UNK\u27e9 father came from\nthe same scottish island as myself so i loved . . .\nHere we can see many words have been omitted, and some unknown words\n(UNK) have been marked as such. With this reduction the binary feature\nvector has length 10,000, and consists mostly of 0\u2019s and a smattering of 1\u2019s\nin the positions corresponding to words that are present in the document.\nWe have a training set and test set, each with 25,000 examples, and each\nbalanced with regard to sentiment. The resulting training feature matrix X\nhas dimension 25,000\u00d710,000, but only 1.3% of the binary entries are nonzero.\nWe call such a matrix sparse, because most of the values are the same\n(zero in this case); it can be stored efficiently in sparse matrix format.15\nsparse\nmatrix\nformat\nThere are a variety of ways to account for the document length; here we\nonly score a word as in or out of the document, but for example one could\ninstead record the relative frequency of words. We split off a validation set\nof size 2,000 from the 25,000 training observations (for model tuning), and\nfit two model sequences:\n15Rather than store the whole matrix, we can store instead the location and values\nfor the nonzero entries. In this case, since the nonzero entries are all 1, just the locations\nare stored.\n10.5 Recurrent Neural Networks 421\n\u2022 A lasso logistic regression using the glmnet package;\n\u2022 A two-class neural network with two hidden layers, each with 16\nReLU units.\nBoth methods produce a sequence of solutions. The lasso sequence is indexed\nby the regularization parameter \u03bb. The neural-net sequence is indexed\nby the number of gradient-descent iterations used in the fitting,\nas measured by training epochs or passes through the training set (Section\n10.7). Notice that the training accuracy in Figure 10.11 (black points)\nincreases monotonically in both cases. We can use the validation error to\npick a good solution from each sequence (blue points in the plots), which\nwould then be used to make predictions on the test data set.\nNote that a two-class neural network", "doc_id": "189460e0-def7-497d-b0ca-ea6c0845d9fd", "embedding": null, "doc_hash": "9030620e3a653cc3776ba6899321ad0a3df402d5cfb3a58268182bb30fd15f9f", "extra_info": null, "node_info": {"start": 954353, "end": 957289, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "acf92a72-dfde-4e95-9d27-bd6836eadf55", "3": "418b398e-9332-42ad-b5f5-88591506a5a3"}}, "__type__": "1"}, "418b398e-9332-42ad-b5f5-88591506a5a3": {"__data__": {"text": "to make predictions on the test data set.\nNote that a two-class neural network amounts to a nonlinear logistic\nregression model. From (10.12) and (10.13) we can see that\nlog\n*\nPr(Y = 1|X)\nPr(Y = 0|X)\n+\n= Z1 \u2212 Z0 (10.15)\n= (\u03b210 \u2212 \u03b200) +\n0K2\n\u2113=1\n(\u03b21\u2113 \u2212 \u03b20\u2113)A(2)\n\u2113 .\n(This shows the redundancy in the softmax function; for K classes we\nreally only need to estimate K\u22121 sets of coefficients. See Section 4.3.5.) In\nFigure 10.11 we show accuracy (fraction correct) rather than classification accuracy\nerror (fraction incorrect), the former being more popular in the machine\nlearning community. Both models achieve a test-set accuracy of about 88%.\nThe bag-of-words model summarizes a document by the words present,\nand ignores their context. There are at least two popular ways to take the\ncontext into account:\n\u2022 The bag-of-n-grams model. For example, a bag of 2-grams records\nbag-of-nthe\nconsecutive co-occurrence of every distinct pair of words. \u201cBliss- grams\nfully long\u201d can be seen as a positive phrase in a movie review, while\n\u201cblissfully short\u201d a negative.\n\u2022 Treat the document as a sequence, taking account of all the words in\nthe context of those that preceded and those that follow.\nIn the next section we explore models for sequences of data, which have\napplications in weather forecasting, speech recognition, language translation,\nand time-series prediction, to name a few. We continue with this IMDb\nexample there.\n10.5 Recurrent Neural Networks\nMany data sources are sequential in nature, and call for special treatment\nwhen building predictive models. Examples include:\n422 10. Deep Learning\nA\u2113 = A1 A2 A3 AL-1 AL\nO\u2113\nY\nX\u2113\nO1\nX1\nO2\nX2\nO3\nX3\nOL-1\nXL-1\nOL\nY\nXL . . .\nW\nU\nB\nW\nB\nW\nB\nW\nB\nW\nB\nW\nB\nU U U U\nFIGURE 10.12. Schematic of a simple recurrent neural network. The input is a\nsequence of vectors {X\u2113}L1\n, and here the target is a single response. The network\nprocesses the input sequence X sequentially; each X\u2113 feeds into the hidden layer,\nwhich also has as input the activation vector A\u2113\u22121 from the previous element in\nthe sequence, and produces the current activation vector A\u2113. The same collections\nof weightsW, U and B are used as each element of the sequence is processed. The\noutput layer produces a sequence of predictions O\u2113 from the current activation A\u2113,\nbut typically only the last of these, OL, is of relevance. To the left of the equal\nsign is a concise representation of the network, which is unrolled into a more\nexplicit version on the right.\n\u2022 Documents such as book and movie reviews, newspaper articles, and\ntweets. The sequence and relative positions of words in a document\ncapture the narrative, theme and tone, and can be exploited in tasks\nsuch as topic classification, sentiment analysis, and language translation.\n\u2022 Time series of temperature, rainfall, wind speed, air quality, and so\non. We may want to forecast the weather several days ahead, or climate\nseveral decades ahead.\n\u2022 Financial time series, where we track market indices, trading volumes,\nstock and bond prices, and exchange rates. Here prediction is often\ndifficult, but as we will see, certain indices can be predicted with\nreasonable accuracy.\n\u2022 Recorded speech, musical recordings, and other sound recordings. We\nmay want to give a text transcription of a speech, or perhaps a language\ntranslation. We may want to assess the quality of a piece of\nmusic, or assign certain attributes.\n\u2022 Handwriting, such as doctor\u2019s notes,", "doc_id": "418b398e-9332-42ad-b5f5-88591506a5a3", "embedding": null, "doc_hash": "a8d7bca25a1cd46d7effbbfafa1637bfa89247fc5142d7e1412136f2362f076d", "extra_info": null, "node_info": {"start": 957244, "end": 960670, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "189460e0-def7-497d-b0ca-ea6c0845d9fd", "3": "10033000-44b0-48ec-a1bc-4c773ad4a084"}}, "__type__": "1"}, "10033000-44b0-48ec-a1bc-4c773ad4a084": {"__data__": {"text": "or assign certain attributes.\n\u2022 Handwriting, such as doctor\u2019s notes, and handwritten digits such as\nzip codes. Here we want to turn the handwriting into digital text, or\nread the digits (optical character recognition).\nIn a recurrent neural network (RNN), the input object X is a sequence.\nrecurrent\nneural\nnetwork\n10.5 Recurrent Neural Networks 423\nConsider a corpus of documents, such as the collection of IMDb movie reviews.\nEach document can be represented as a sequence of L words, so\nX = {X1,X2, . . . ,XL}, where each X\u2113 represents a word. The order of\nthe words, and closeness of certain words in a sentence, convey semantic\nmeaning. RNNs are designed to accommodate and take advantage of the\nsequential nature of such input objects, much like convolutional neural networks\naccommodate the spatial structure of image inputs. The output Y\ncan also be a sequence (such as in language translation), but often is a\nscalar, like the binary sentiment label of a movie review document.\nFigure 10.12 illustrates the structure of a very basic RNN with a sequence\nX = {X1,X2, . . . ,XL} as input, a simple output Y , and a hidden-layer\nsequence {A\u2113}L1\n= {A1,A2, . . . ,AL}. Each X\u2113 is a vector; in the document\nexample X\u2113 could represent a one-hot encoding for the \u2113th word based on\nthe language dictionary for the corpus (see the top panel in Figure 10.13\nfor a simple example). As the sequence is processed one vector X\u2113 at a\ntime, the network updates the activations A\u2113 in the hidden layer, taking\nas input the vector X\u2113 and the activation vector A\u2113\u22121 from the previous\nstep in the sequence. Each A\u2113 feeds into the output layer and produces a\nprediction O\u2113 for Y . OL, the last of these, is the most relevant.\nIn detail, suppose each vector X\u2113 of the input sequence has p components\nXT\n\u2113 = (X\u21131,X\u21132, . . . ,X\u2113p), and the hidden layer consists of K units AT\u2113 =\n(A\u21131,A\u21132, . . . ,A\u2113K). As in Figure 10.4, we represent the collection of K \u00d7 (p+1) shared weights wkj for the input layer by a matrixW, and similarly\nU is a K \u00d7 K matrix of the weights uks for the hidden-to-hidden layers,\nand B is a K + 1 vector of weights \u03b2k for the output layer. Then\nA\u2113k = g\n1\nwk0 +\n0p\nj=1\nwkjX\u2113j +\n0K\ns=1\nuksA\u2113\u22121,s\n2\n, (10.16)\nand the output O\u2113 is computed as\nO\u2113 = \u03b20 +\n0K\nk=1\n\u03b2kA\u2113k (10.17)\nfor a quantitative response, or with an additional sigmoid activation function\nfor a binary response, for example. Here g(\u00b7) is an activation function\nsuch as ReLU. Notice that the same weights W, U and B are used as we\nprocess each element in the sequence, i.e. they are not functions of \u2113. This\nis a form of weight sharing used by RNNs, and similar to the use of filters\nweight\nin convolutional neural networks (Section 10.3.1.) As we proceed from be- sharing\nginning to end, the activations A\u2113 accumulate a history of what has been\nseen before, so that the learned context can be used for prediction.\nFor regression problems the loss function for an observation (X, Y ) is\n(Y \u2212 OL)2, (10.18)\n424 10. Deep Learning\nwhich only references the final output OL = \u03b20+\n)K\nk=1 \u03b2kALk. Thus O1,O2,\n. . . , OL\u22121 are not used. When we fit the model, each", "doc_id": "10033000-44b0-48ec-a1bc-4c773ad4a084", "embedding": null, "doc_hash": "57ba553d9bebaa6ccf9537bef1ec4535d4c113083f30f3a64ca1fd668a2c28b2", "extra_info": null, "node_info": {"start": 960677, "end": 963795, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "418b398e-9332-42ad-b5f5-88591506a5a3", "3": "57c3c531-0ecc-4fc0-b759-cfe7226b4d1d"}}, "__type__": "1"}, "57c3c531-0ecc-4fc0-b759-cfe7226b4d1d": {"__data__": {"text": ". . , OL\u22121 are not used. When we fit the model, each element X\u2113 of the input\nsequence X contributes to OL via the chain (10.16), and hence contributes\nindirectly to learning the shared parameters W, U and B via the loss\n(10.18). With n input sequence/response pairs (xi, yi), the parameters are\nfound by minimizing the sum of squares\n0n\ni=1\n(yi\u2212oiL)2 =\n0n\ni=1\n1\nyi\u2212\n'\n\u03b20+\n0K\nk=1\n\u03b2kg\n'\nwk0+\n0p\nj=1\nwkjxiLj+\n0K\ns=1\nuksai,L\u22121,s\n((22\n.\n(10.19)\nHere we use lowercase letters for the observed yi and vector sequences\nxi = {xi1, xi2, . . . ,xiL},16 as well as the derived activations.\nSince the intermediate outputs O\u2113 are not used, one may well ask why\nthey are there at all. First of all, they come for free, since they use the same\noutput weights B needed to produce OL, and provide an evolving prediction\nfor the output. Furthermore, for some learning tasks the response is also a\nsequence, and so the output sequence {O1,O2, . . . ,OL} is explicitly needed.\nWhen used at full strength, recurrent neural networks can be quite complex.\nWe illustrate their use in two simple applications. In the first, we\ncontinue with the IMDb sentiment analysis of the previous section, where\nwe process the words in the reviews sequentially. In the second application,\nwe illustrate their use in a financial time series forecasting problem.\n10.5.1 Sequential Models for Document Classification\nHere we return to our classification task with the IMDb reviews. Our approach\nin Section 10.4 was to use the bag-of-words model. Here the plan\nis to use instead the sequence of words occurring in a document to make\npredictions about the label for the entire document.\nWe have, however, a dimensionality problem: each word in our document\nis represented by a one-hot-encoded vector (dummy variable) with 10,000\nelements (one per word in the dictionary)! An approach that has become\npopular is to represent each word in a much lower-dimensional embedding\nembedding\nspace. This means that rather than representing each word by a binary\nvector with 9,999 zeros and a single one in some position, we will represent\nit instead by a set of m real numbers, none of which are typically zero. Here\nm is the embedding dimension, and can be in the low 100s, or even less.\nThis means (in our case) that we need a matrix E of dimension m\u00d710,000,\nwhere each column is indexed by one of the 10,000 words in our dictionary,\nand the values in that column give the m coordinates for that word in the\nembedding space.\n16This is a sequence of vectors; each element xi\u2113 is a p-vector.\n10.5 Recurrent Neural Networks 425\nthis\nis\none\nof\nthe\nbest\nfilms\nactually\nthe\nbest\nI\nhave\never\nseen\nthe\nfilm\nstarts\none\nfall\nday\nEmbed One\u2212hot\nFIGURE 10.13. Depiction of a sequence of 20 words representing a single document:\none-hot encoded using a dictionary of 16 words (top panel) and embedded\nin an m-dimensional space with m = 5 (bottom panel).\nFigure 10.13 illustrates the idea (with a dictionary of 16 rather than\n10,000, and m = 5). Where does E come from? If we have a large corpus\nof labeled documents, we can have the neural network learn E as part\nof the optimization. In this case E is referred to as an embedding layer,\nembedding\nand a specialized E is learned for the task at hand. Otherwise we can layer\ninsert a precomputed matrix E in the embedding layer, a process known\nas weight freezing. Two pretrained embeddings, word2vec and GloVe, are\nweight\nfreezing\nword2vec\nGloVe\nwidely used.17 These are built from a very", "doc_id": "57c3c531-0ecc-4fc0-b759-cfe7226b4d1d", "embedding": null, "doc_hash": "eebb31cfb999836bb35cefc836e8ffb07ba994377d84c035280bad7c14ec7670", "extra_info": null, "node_info": {"start": 963816, "end": 967289, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "10033000-44b0-48ec-a1bc-4c773ad4a084", "3": "bf82ace2-24fa-45f2-aafe-7efee4de651b"}}, "__type__": "1"}, "bf82ace2-24fa-45f2-aafe-7efee4de651b": {"__data__": {"text": "used.17 These are built from a very large corpus of documents by\na variant of principal components analysis (Section 12.2). The idea is that\nthe positions of words in the embedding space preserve semantic meaning;\ne.g. synonyms should appear near each other.\nSo far, so good. Each document is now represented as a sequence of mvectors\nthat represents the sequence of words. The next step is to limit\neach document to the last L words. Documents that are shorter than L\nget padded with zeros upfront. So now each document is represented by a\nseries consisting of L vectors X = {X1,X2, . . . ,XL}, and each X\u2113 in the\nsequence has m components.\nWe now use the RNN structure in Figure 10.12. The training corpus\nconsists of n separate series (documents) of length L, each of which gets\nprocessed sequentially from left to right. In the process, a parallel series of\nhidden activation vectors A\u2113, \u2113 = 1, . . . ,L is created as in (10.16) for each\ndocument. A\u2113 feeds into the output layer to produce the evolving prediction\n17word2vec is described in Mikolov, Chen, Corrado, and Dean (2013), available\nat https://code.google.com/archive/p/word2vec. GloVe is described in Pennington,\nSocher, and Manning (2014), available at https://nlp.stanford.edu/projects/glove.\n426 10. Deep Learning\nO\u2113. We use the final value OL to predict the response: the sentiment of the\nreview.\nThis is a simple RNN, and has relatively few parameters. If there are K\nhidden units, the common weight matrix W has K \u00d7 (m+ 1) parameters,\nthe matrix U has K \u00d7K parameters, and B has 2(K +1) for the two-class\nlogistic regression as in (10.15). These are used repeatedly as we process\nthe sequence X = {X\u2113}L1\nfrom left to right, much like we use a single\nconvolution filter to process each patch in an image (Section 10.3.1). If the\nembedding layer E is learned, that adds an additional m \u00d7 D parameters\n(D = 10,000 here), and is by far the biggest cost.\nWe fit the RNN as described in Figure 10.12 and the accompaying text to\nthe IMDb data. The model had an embedding matrix E with m = 32 (which\nwas learned in training as opposed to precomputed), followed by a single\nrecurrent layer with K = 32 hidden units. The model was trained with\ndropout regularization on the 25,000 reviews in the designated training\nset, and achieved a disappointing 76% accuracy on the IMDb test data. A\nnetwork using the GloVe pretrained embedding matrix E performed slightly\nworse.\nFor ease of exposition we have presented a very simple RNN. More elaborate\nversions use long term and short term memory (LSTM). Two tracks\nof hidden-layer activations are maintained, so that when the activation A\u2113\nis computed, it gets input from hidden units both further back in time,\nand closer in time \u2014 a so-called LSTM RNN. With long sequences, this\nLSTM RNN\novercomes the problem of early signals being washed out by the time they\nget propagated through the chain to the final activation vector AL.\nWhen we refit our model using the LSTM architecture for the hidden\nlayer, the performance improved to 87% on the IMDb test data. This is comparable\nwith the 88% achieved by the bag-of-words model in Section 10.4.\nWe give details on fitting these models in Section 10.9.6.\nDespite this added LSTM complexity, our RNN is still somewhat \u201centry\nlevel\u201d. We could probably achieve slightly better results by changing the\nsize of the model, changing the regularization, and including additional\nhidden layers. However, LSTM models take a long time to train, which\nmakes exploring many architectures and parameter optimization tedious.\nRNNs provide a rich framework for modeling data", "doc_id": "bf82ace2-24fa-45f2-aafe-7efee4de651b", "embedding": null, "doc_hash": "7702e9cbbdcbf726668b20efa74fb498efd024c4f101bc6d329c7757c6b37380", "extra_info": null, "node_info": {"start": 967301, "end": 970909, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "57c3c531-0ecc-4fc0-b759-cfe7226b4d1d", "3": "14dccfa6-6fe6-4163-881b-b3c52b467a51"}}, "__type__": "1"}, "14dccfa6-6fe6-4163-881b-b3c52b467a51": {"__data__": {"text": "parameter optimization tedious.\nRNNs provide a rich framework for modeling data sequences, and they\ncontinue to evolve. There have been many advances in the development\nof RNNs \u2014 in architecture, data augmentation, and in the learning algorithms.\nAt the time of this writing (early 2020) the leading RNN configurations\nreport accuracy above 95% on the IMDb data. The details are beyond\nthe scope of this book.18\n18An IMDb leaderboard can be found at https://paperswithcode.com/sota/\nsentiment-analysis-on-imdb.\n10.5 Recurrent Neural Networks 427\n10.5.2 Time Series Forecasting\nFigure 10.14 shows historical trading statistics from the New York Stock\nExchange. Shown are three daily time series covering the period December\n3, 1962 to December 31, 1986:19\n\u2022 Log trading volume. This is the fraction of all outstanding shares that\nare traded on that day, relative to a 100-day moving average of past\nturnover, on the log scale.\n\u2022 Dow Jones return. This is the difference between the log of the Dow\nJones Industrial Index on consecutive trading days.\n\u2022 Log volatility. This is based on the absolute values of daily price\nmovements.\nPredicting stock prices is a notoriously hard problem, but it turns out that\npredicting trading volume based on recent past history is more manageable\n(and is useful for planning trading strategies).\nAn observation here consists of the measurements (vt, rt, zt) on day t, in\nthis case the values for log volume, DJ return and log volatility. There are\na total of T = 6,051 such triples, each of which is plotted as a time series\nin Figure 10.14. One feature that strikes us immediately is that the dayto-\nday observations are not independent of each other. The series exhibit\nauto-correlation \u2014 in this case values nearby in time tend to be similar\nautoto\neach other. This distinguishes time series from other data sets we have correlation\nencountered, in which observations can be assumed to be independent of\neach other. To be clear, consider pairs of observations (vt, vt\u2212\u2113), a lag of \u2113\nlag\ndays apart. If we take all such pairs in the vt series and compute their correlation\ncoefficient, this gives the autocorrelation at lag \u2113. Figure 10.15 shows\nthe autocorrelation function for all lags up to 37, and we see considerable\ncorrelation.\nAnother interesting characteristic of this forecasting problem is that the\nresponse variable vt \u2014 log volume \u2014 is also a predictor! In particular, we\nwill use the past values of log volume to predict values in the future.\nRNN forecaster\nWe wish to predict a value vt from past values vt\u22121, vt\u22122, . . ., and also to\nmake use of past values of the other series rt\u22121, rt\u22122, . . . and zt\u22121, zt\u22122, . . ..\nAlthough our combined data is quite a long series with 6,051 trading\ndays, the structure of the problem is different from the previous documentclassification\nexample.\n\u2022 We only have one series of data, not 25,000.\n19These data were assembled by LeBaron and Weigend (1998) IEEE Transactions on\nNeural Networks, 9(1): 213\u2013220.\n428 10. Deep Learning\nLog(Trading Volume)\n\u22121.0 0.0 0.5 1.0\nDow Jones Return\n\u22120.04 0.00 0.04\n1965 1970 1975 1980 1985\n\u221213 \u221211 \u22129 \u22128\nLog(Volatility)\nFIGURE 10.14. Historical trading statistics from the New York Stock Exchange.\nDaily values of the normalized log trading volume, DJIA return, and log volatility\nare shown for a 24-year period from 1962\u20131986. We wish to predict trading volume\non any day, given the history on all earlier days. To the left of the red bar (January\n2, 1980) is training data, and to the right test data.\n\u2022 We have an entire series of targets vt, and the inputs include past\nvalues of this series.\nHow", "doc_id": "14dccfa6-6fe6-4163-881b-b3c52b467a51", "embedding": null, "doc_hash": "47a75c2f66a317781bd1b51a09a436aea95da9178f272bbb6d5a531b12258349", "extra_info": null, "node_info": {"start": 970869, "end": 974491, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "bf82ace2-24fa-45f2-aafe-7efee4de651b", "3": "c354ed06-79de-48e9-be58-189f1ebd6829"}}, "__type__": "1"}, "c354ed06-79de-48e9-be58-189f1ebd6829": {"__data__": {"text": "of targets vt, and the inputs include past\nvalues of this series.\nHow do we represent this problem in terms of the structure displayed in\nFigure 10.12? The idea is to extract many short mini-series of input sequences\nX = {X1,X2, . . . ,XL} with a predefined length L (called the lag\nlag\nin this context), and a corresponding target Y . They have the form\nX1 =\n\u239b\n\u239d\nvt\u2212L\nrt\u2212L\nzt\u2212L\n\u239e\n\u23a0, X2 =\n\u239b\n\u239d\nvt\u2212L+1\nrt\u2212L+1\nzt\u2212L+1\n\u239e\n\u23a0, \u00b7 \u00b7 \u00b7 ,XL =\n\u239b\n\u239d\nvt\u22121\nrt\u22121\nzt\u22121\n\u239e\n\u23a0, and Y = vt.\n(10.20)\nSo here the target Y is the value of log volume vt at a single timepoint t,\nand the input sequence X is the series of 3-vectors {X\u2113}L1\neach consisting\nof the three measurements log volume, DJ return and log volatility from\nday t \u2212 L, t \u2212 L + 1, up to t \u2212 1. Each value of t makes a separate (X, Y )\n10.5 Recurrent Neural Networks 429\n0 5 10 15 20 25 30 35\n0.0 0.4 0.8\nLog( Trading Volume)\nLag\nAutocorrelation Function\nFIGURE 10.15. The autocorrelation function for log volume. We see that\nnearby values are fairly strongly correlated, with correlations above 0.2 as far\nas 20 days apart.\n1980 1982 1984 1986\n\u22121.0 0.0 0.5 1.0\nTest Period: Observed and Predicted\nYear\nlog(Trading Volume)\nFIGURE 10.16. RNN forecast of log volume on the NYSE test data. The black\nlines are the true volumes, and the superimposed orange the forecasts. The forecasted\nseries accounts for 42% of the variance of log volume.\npair, for t running from L + 1 to T. For the NYSE data we will use the past\nfive trading days to predict the next day\u2019s trading volume. Hence, we use\nL = 5. Since T = 6,051, we can create 6,046 such (X, Y ) pairs. Clearly L\nis a parameter that should be chosen with care, perhaps using validation\ndata.\nWe fit this model with K = 12 hidden units using the 4,281 training\nsequences derived from the data before January 2, 1980 (see Figure 10.14),\nand then used it to forecast the 1,770 values of log volume after this date.\nWe achieve an R2 = 0.42 on the test data. Details are given in Section\n10.9.6. As a straw man,20 using yesterday\u2019s value for log volume as\nthe prediction for today has R2 = 0.18. Figure 10.16 shows the forecast\nresults. We have plotted the observed values of the daily log volume for the\n20A straw man here refers to a simple and sensible prediction that can be used as a\nbaseline for comparison.\n430 10. Deep Learning\ntest period 1980\u20131986 in black, and superimposed the predicted series in\norange. The correspondence seems rather good.\nIn forecasting the value of log volume in the test period, we have to use\nthe test data itself in forming the input sequences X. This may feel like\ncheating, but in fact it is not; we are always using past data to predict the\nfuture.\nAutoregression\nThe RNN we just fit has much in common with a traditional autoregression\nauto-\n(AR) linear model, which we present now for comparison. We first consider regression\nthe response sequence vt alone, and construct a response vector y and a\nmatrix M of predictors for least squares regression as follows:\ny =\n\u23a1\n\u23a2\u23a2\u23a2\u23a2\u23a2\u23a3\nvL+1\nvL+2\nvL+3\n...\nvT\n\u23a4\n\u23a5\u23a5\u23a5\u23a5\u23a5\u23a6\nM", "doc_id": "c354ed06-79de-48e9-be58-189f1ebd6829", "embedding": null, "doc_hash": "e45f558ad6517c0a900997e9df507a297e2e2b1f95c6c440596131a1e1d8c3ba", "extra_info": null, "node_info": {"start": 974503, "end": 977534, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "14dccfa6-6fe6-4163-881b-b3c52b467a51", "3": "6e54c8f0-cd49-4df9-90e3-0e36405d62c8"}}, "__type__": "1"}, "6e54c8f0-cd49-4df9-90e3-0e36405d62c8": {"__data__": {"text": "=\n\u23a1\n\u23a2\u23a2\u23a2\u23a2\u23a2\u23a3\n1 vL vL\u22121 \u00b7 \u00b7 \u00b7 v1\n1 vL+1 vL \u00b7 \u00b7 \u00b7 v2\n1 vL+2 vL+1 \u00b7 \u00b7 \u00b7 v3\n...\n...\n...\n. . .\n...\n1 vT\u22121 vT\u22122 \u00b7 \u00b7 \u00b7 vT\u2212L\n\u23a4\n\u23a5\u23a5\u23a5\u23a5\u23a5\u23a6\n. (10.21)\nM and y each have T \u2212 L rows, one per observation. We see that the\npredictors for any given response vt on day t are the previous L values\nof the same series. Fitting a regression of y on M amounts to fitting the\nmodel\n\u02c6vt = \u02c6 \u03b20 + \u02c6 \u03b21vt\u22121 + \u02c6 \u03b22vt\u22122 + \u00b7 \u00b7 \u00b7 + \u02c6 \u03b2Lvt\u2212L, (10.22)\nand is called an order-L autoregressive model, or simply AR(L). For the\nNYSE data we can include lagged versions of DJ return and log volatility,\nrt and zt, in the predictor matrix M, resulting in 3L + 1 columns. An AR\nmodel with L = 5 achieves a test R2 of 0.41, slightly inferior to the 0.42\nachieved by the RNN.\nOf course the RNN and AR models are very similar. They both use\nthe same response Y and input sequences X of length L = 5 and dimension\np = 3 in this case. The RNN processes this sequence from left to\nright with the same weights W (for the input layer), while the AR model\nsimply treats all L elements of the sequence equally as a vector of L \u00d7 p\npredictors \u2014 a process called flattening in the neural network literature.\nflattening\nOf course the RNN also includes the hidden layer activations A\u2113 which\ntransfer information along the sequence, and introduces additional nonlinearity.\nFrom (10.19) with K = 12 hidden units, we see that the RNN has\n13+12\u00d7(1+3+12) = 205 parameters, compared to the 16 for the AR(5)\nmodel.\nAn obvious extension of the AR model is to use the set of lagged predictors\nas the input vector to an ordinary feedforward neural network (10.1),\nand hence add more flexibility. This achieved a test R2 = 0.42, slightly\nbetter than the linear AR, and the same as the RNN.\n10.5 Recurrent Neural Networks 431\nAll the models can be improved by including the variable day of week\ncorresponding to the day t of the target vt (which can be learned from the\ncalendar dates supplied with the data); trading volume is often higher on\nMondays and Fridays. Since there are five trading days, this one-hot encodes\nto five binary variables. The performance of the AR model improved\nto R2 = 0.46 as did the RNN, and the nonlinear AR model improved to\nR2 = 0.47.\nWe used the most simple version of the RNN in our examples here.\nAdditional experiments with the LSTM extension of the RNN yielded small\nimprovements, typically of up to 1% in R2 in these examples.\nWe give details of how we fit all three models in Section 10.9.6.\n10.5.3 Summary of RNNs\nWe have illustrated RNNs through two simple use cases, and have only\nscratched the surface.\nThere are many variations and enhancements of the simple RNN we\nused for sequence modeling. One approach we did not discuss uses a onedimensional\nconvolutional neural network, treating the sequence of vectors\n(say words, as represented in the embedding space) as an image. The convolution\nfilter slides along the sequence in a one-dimensional fashion, with\nthe potential to learn particular phrases or short subsequences relevant to\nthe learning task.\nOne can also have additional hidden layers in an RNN. For example,\nwith two hidden layers, the sequence A\u2113 is treated as an input sequence to\nthe next hidden layer in an obvious fashion.\nThe RNN we used scanned the document from beginning to end;", "doc_id": "6e54c8f0-cd49-4df9-90e3-0e36405d62c8", "embedding": null, "doc_hash": "17f81124dd979e86725e416f0de8b246bb650bcdba024b95230eb358884d1932", "extra_info": null, "node_info": {"start": 977594, "end": 980867, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "c354ed06-79de-48e9-be58-189f1ebd6829", "3": "8f702ea6-b9ab-496a-96ec-ab1b4c378368"}}, "__type__": "1"}, "8f702ea6-b9ab-496a-96ec-ab1b4c378368": {"__data__": {"text": "obvious fashion.\nThe RNN we used scanned the document from beginning to end; alternative\nbidirectional RNNs scan the sequences in both directions.\nbidirectional\nIn language translation the target is also a sequence of words, in a\nlanguage different from that of the input sequence. Both the input sequence\nand the target sequence are represented by a structure similar to\nFigure 10.12, and they share the hidden units. In this so-called Seq2Seq\nSeq2Seq\nlearning, the hidden units are thought to capture the semantic meaning\nof the sentences. Some of the big breakthroughs in language modeling and\ntranslation resulted from the relatively recent improvements in such RNNs.\nAlgorithms used to fit RNNs can be complex and computationally costly.\nFortunately, good software protects users somewhat from these complexities,\nand makes specifying and fitting these models relatively painless. Many\nof the models that we enjoy in daily life (like Google Translate) use stateof-\nthe-art architectures developed by teams of highly skilled engineers, and\nhave been trained using massive computational and data resources.\n432 10. Deep Learning\n10.6 When to Use Deep Learning\nThe performance of deep learning in this chapter has been rather impressive.\nIt nailed the digit classification problem, and deep CNNs have really\nrevolutionized image classification. We see daily reports of new success stories\nfor deep learning. Many of these are related to image classification\ntasks, such as machine diagnosis of mammograms or digital X-ray images,\nophthalmology eye scans, annotations of MRI scans, and so on. Likewise\nthere are numerous successes of RNNs in speech and language translation,\nforecasting, and document modeling. The question that then begs an answer\nis: should we discard all our older tools, and use deep learning on every\nproblem with data? To address this question, we revisit our Hitters dataset\nfrom Chapter 6.\nThis is a regression problem, where the goal is to predict the Salary of\na baseball player in 1987 using his performance statistics from 1986. After\nremoving players with missing responses, we are left with 263 players and\n19 variables. We randomly split the data into a training set of 176 players\n(two thirds), and a test set of 87 players (one third).We used three methods\nfor fitting a regression model to these data.\n\u2022 A linear model was used to fit the training data, and make predictions\non the test data. The model has 20 parameters.\n\u2022 The same linear model was fit with lasso regularization. The tuning\nparameter was selected by 10-fold cross-validation on the training\ndata. It selected a model with 12 variables having nonzero coefficients.\n\u2022 A neural network with one hidden layer consisting of 64 ReLU units\nwas fit to the data. This model has 1,409 parameters.21\nTable 10.2 compares the results. We see similar performance for all three\nmodels. We report the mean absolute error on the test data, as well as\nthe test R2 for each method, which are all respectable (see Exercise 5).\nWe spent a fair bit of time fiddling with the configuration parameters of\nthe neural network to achieve these results. It is possible that if we were to\nspend more time, and got the form and amount of regularization just right,\nthat we might be able to match or even outperform linear regression and\nthe lasso. But with great ease we obtained linear models that work well.\nLinear models are much easier to present and understand than the neural\nnetwork, which is essentially a black box. The lasso selected 12 of the 19\nvariables in making its prediction. So in cases like this we are much better\noff following the Occam\u2019s razor principle: when faced with several methods\nOccam\u2019s\nrazor\n21The model was fit by stochastic gradient descent with a batch size of 32 for 1,000\nepochs, and 10% dropout regularization. The test error performance flattened out and\nstarted to slowly increase after 1,000 epochs. These fitting details are discussed in Section\n10.7.\n10.6 When to Use Deep Learning 433\nModel # Parameters Mean Abs. Error Test Set R2\nLinear Regression 20 254.7 0.56\nLasso 12 252.3", "doc_id": "8f702ea6-b9ab-496a-96ec-ab1b4c378368", "embedding": null, "doc_hash": "12247465d4b517b50d7a7f9ce44451855a3ec7b777ddd3fdcc3ec1b9e660c94e", "extra_info": null, "node_info": {"start": 980803, "end": 984898, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "6e54c8f0-cd49-4df9-90e3-0e36405d62c8", "3": "992befe9-33c0-4af0-a6a9-86853b1e2cb3"}}, "__type__": "1"}, "992befe9-33c0-4af0-a6a9-86853b1e2cb3": {"__data__": {"text": "Regression 20 254.7 0.56\nLasso 12 252.3 0.51\nNeural Network 1409 257.4 0.54\nTABLE 10.2. Prediction results on the Hitters test data for linear models fit\nby ordinary least squares and lasso, compared to a neural network fit by stochastic\ngradient descent with dropout regularization.\nCoefficient Std. error t-statistic p-value\nIntercept -226.67 86.26 -2.63 0.0103\nHits 3.06 1.02 3.00 0.0036\nWalks 0.181 2.04 0.09 0.9294\nCRuns 0.859 0.12 7.09 < 0.0001\nPutOuts 0.465 0.13 3.60 0.0005\nTABLE 10.3. Least squares coefficient estimates associated with the regression\nof Salary on four variables chosen by lasso on the Hitters data set. This\nmodel achieved the best performance on the test data, with a mean absolute error\nof 224.8. The results reported here were obtained from a regression on the test\ndata, which was not used in fitting the lasso model.\nthat give roughly equivalent performance, pick the simplest.\nAfter a bit more exploration with the lasso model, we identified an even\nsimpler model with four variables.We then refit the linear model with these\nfour variables to the training data (the so-called relaxed lasso), and achieved\na test mean absolute error of 224.8, the overall winner! It is tempting to\npresent the summary table from this fit, so we can see coefficients and pvalues;\nhowever, since the model was selected on the training data, there\nwould be selection bias. Instead, we refit the model on the test data, which\nwas not used in the selection. Table 10.3 shows the results.\nWe have a number of very powerful tools at our disposal, including neural\nnetworks, random forests and boosting, support vector machines and\ngeneralized additive models, to name a few. And then we have linear models,\nand simple variants of these. When faced with new data modeling and\nprediction problems, its tempting to always go for the trendy new methods.\nOften they give extremely impressive results, especially when the datasets\nare very large and can support the fitting of high-dimensional nonlinear\nmodels. However, if we can produce models with the simpler tools that\nperform as well, they are likely to be easier to fit and understand, and potentially\nless fragile than the more complex approaches. Wherever possible,\nit makes sense to try the simpler models as well, and then make a choice\nbased on the performance/complexity tradeoff.\nTypically we expect deep learning to be an attractive choice when the\nsample size of the training set is extremely large, and when interpretability\nof the model is not a high priority.\n434 10. Deep Learning\n10.7 Fitting a Neural Network\nFitting neural networks is somewhat complex, and we give a briefoverview\nhere. The ideas generalize to much more complex networks. Readers who\nfind this material challenging can safely skip it. Fortunately, as we see in\nthe lab at the end of the chapter, good software is available to fit neural\nnetwork models in a relatively automated way, without worrying about the\ntechnical details of the model-fitting procedure.\nWe start with the simple network depicted in Figure 10.1 in Section 10.1.\nIn model (10.1) the parameters are \u03b2 = (\u03b20,\u03b21, . . . ,\u03b2K), as well as each of\nthe wk = (wk0, wk1, . . . ,wkp), k = 1, . . . ,K. Given observations (xi, yi), i =\n1, . . . , n, we could fit the model by solving a nonlinear least squares problem\nminimize\n{wk}K1\n, \u03b2\n1\n2\n0n\ni=1\n(yi \u2212 f(xi))2, (10.23)\nwhere\nf(xi) = \u03b20 +\n0K\nk=1\n\u03b2kg\n1\nwk0 +\n0p\nj=1\nwkjxij\n2\n. (10.24)\nThe objective in (10.23) looks simple enough, but", "doc_id": "992befe9-33c0-4af0-a6a9-86853b1e2cb3", "embedding": null, "doc_hash": "8c70a0903065218ac99251adf43c80117a4a77b61c7e9e2d8238f83c299e3120", "extra_info": null, "node_info": {"start": 984930, "end": 988417, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "8f702ea6-b9ab-496a-96ec-ab1b4c378368", "3": "ad578334-4944-4530-83d1-dc0e7c306be4"}}, "__type__": "1"}, "ad578334-4944-4530-83d1-dc0e7c306be4": {"__data__": {"text": "objective in (10.23) looks simple enough, but because of the nested\narrangement of the parameters and the symmetry of the hidden units, it is\nnot straightforward to minimize. The problem is nonconvex in the parameters,\nand hence there are multiple solutions. As an example, Figure 10.17\nshows a simple nonconvex function of a single variable \u03b8; there are two\nsolutions: one is a local minimum and the other is a global minimum. Furlocal\nminimum\nglobal\nminimum\nthermore, (10.1) is the very simplest of neural networks; in this chapter we\nhave presented much more complex ones where these problems are compounded.\nTo overcome some of these issues and to protect from overfitting,\ntwo general strategies are employed when fitting neural networks.\n\u2022 Slow Learning: the model is fit in a somewhat slow iterative fashion,\nusing gradient descent. The fitting process is then stopped when\ngradient\noverfitting is detected. descent\n\u2022 Regularization: penalties are imposed on the parameters, usually lasso\nor ridge as discussed in Section 6.2.\nSuppose we represent all the parameters in one long vector \u03b8. Then we\ncan rewrite the objective in (10.23) as\nR(\u03b8) =\n1\n2\n0n\ni=1\n(yi \u2212 f\u03b8(xi))2, (10.25)\nwhere we make explicit the dependence of f on the parameters. The idea\nof gradient descent is very simple.\n10.7 Fitting a Neural Network 435\n\u22121.0 \u22120.5 0.0 0.5 1.0\n0 1 2 3 4 5 6\n\u03b8\nR(\u03b8)\n\u03b80 \u03b81 \u03b82 \u03b87\n\u25cf\n\u25cf\n\u25cf\n\u25cf\nR(\u03b80)\nR(\u03b81)\nR(\u03b82)\nR(\u03b87)\nFIGURE 10.17. Illustration of gradient descent for one-dimensional \u03b8. The\nobjective function R(\u03b8) is not convex, and has two minima, one at \u03b8 = \u22120.46\n(local), the other at \u03b8 = 1.02 (global). Starting at some value \u03b80 (typically randomly\nchosen), each step in \u03b8 moves downhill \u2014 against the gradient \u2014 until it\ncannot go down any further. Here gradient descent reached the global minimum\nin 7 steps.\n1. Start with a guess \u03b80 for all the parameters in \u03b8, and set t = 0.\n2. Iterate until the objective (10.25) fails to decrease:\n(a) Find a vector \u03b4 that reflects a small change in \u03b8, such that \u03b8t+1 =\n\u03b8t + \u03b4 reduces the objective; i.e. such that R(\u03b8t+1) < R(\u03b8t).\n(b) Set t \u2190 t + 1.\nOne can visualize (Figure 10.17) standing in a mountainous terrain, and\nthe goal is to get to the bottom through a series of steps. As long as each\nstep goes downhill, we must eventually get to the bottom. In this case we\nwere lucky, because with our starting guess \u03b80 we end up at the global\nminimum. In general we can hope to end up at a (good) local minimum.\n10.7.1 Backpropagation\nHow do we find the directions to move \u03b8 so as to decrease the objective\nR(\u03b8) in (10.25)? The gradient of R(\u03b8), evaluated at some current value\ngradient\n\u03b8 = \u03b8m, is the vector of partial derivatives at that point:\n\u2207R(\u03b8m) =\n\u2202R(\u03b8)\n\u2202\u03b8\nVVV\n\u03b8=\u03b8m\n. (10.26)\nThe subscript \u03b8 = \u03b8m means that after computing the vector of derivatives,\nwe evaluate it at the current guess, \u03b8m. This gives the direction in \u03b8-space\nin which R(\u03b8) increases most rapidly. The idea of gradient descent is to\nmove \u03b8 a little in the opposite direction (since we wish to go downhill):\n\u03b8m+1 \u2190 \u03b8m \u2212", "doc_id": "ad578334-4944-4530-83d1-dc0e7c306be4", "embedding": null, "doc_hash": "2ef8a0b683388293d5adfb2f4a1cc371137707810d0046f0ef02053b3a5c83e9", "extra_info": null, "node_info": {"start": 988413, "end": 991450, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "992befe9-33c0-4af0-a6a9-86853b1e2cb3", "3": "24f01d5f-2a25-456e-9f4b-5fde6bbe9cca"}}, "__type__": "1"}, "24f01d5f-2a25-456e-9f4b-5fde6bbe9cca": {"__data__": {"text": "we wish to go downhill):\n\u03b8m+1 \u2190 \u03b8m \u2212 \u03c1\u2207R(\u03b8m). (10.27)\n436 10. Deep Learning\nFor a small enough value of the learning rate \u03c1, this step will decrease the\nlearning rate\nobjective R(\u03b8); i.e. R(\u03b8m+1) \u2264 R(\u03b8m). If the gradient vector is zero, then\nwe may have arrived at a minimum of the objective.\nHow complicated is the calculation (10.26)? It turns out that it is quite\nsimple here, and remains simple even for much more complex networks,\nbecause of the chain rule of differentiation.\nchain rule\nSince R(\u03b8) =\n)n\ni=1 Ri(\u03b8) = 12\n)n\ni=1(yi \u2212 f\u03b8(xi))2 is a sum, its gradient\nis also a sum over the n observations, so we will just examine one of these\nterms,\nRi(\u03b8) =\n1\n2\n1\nyi \u2212 \u03b20 \u2212\n0K\nk=1\n\u03b2kg\n'\nwk0 +\n0p\nj=1\nwkjxij\n(22\n. (10.28)\nTo simplify the expressions to follow, we write zik = wk0 +\n)p\nj=1 wkjxij .\nFirst we take the derivative with respect to \u03b2k:\n\u2202Ri(\u03b8)\n\u2202\u03b2k\n=\n\u2202Ri(\u03b8)\n\u2202f\u03b8(xi) \u00b7\n\u2202f\u03b8(xi)\n\u2202\u03b2k\n= \u2212(yi \u2212 f\u03b8(xi)) \u00b7 g(zik). (10.29)\nAnd now we take the derivative with respect to wkj:\n\u2202Ri(\u03b8)\n\u2202wkj\n=\n\u2202Ri(\u03b8)\n\u2202f\u03b8(xi) \u00b7\n\u2202f\u03b8(xi)\n\u2202g(zik) \u00b7\n\u2202g(zik)\n\u2202zik \u00b7\n\u2202zik\n\u2202wkj\n= \u2212(yi \u2212 f\u03b8(xi)) \u00b7 \u03b2k \u00b7 g\u2032(zik) \u00b7 xij . (10.30)\nNotice that both these expressions contain the residual yi \u2212 f\u03b8(xi). In\n(10.29) we see that a fraction of that residual gets attributed to each of\nthe hidden units according to the value of g(zik). Then in (10.30) we see\na similar attribution to input j via hidden unit k. So the act of differentiation\nassigns a fraction of the residual to each of the parameters via the\nchain rule \u2014 a process known as backpropagation in the neural network\nbackpropliterature.\nAlthough these calculations are straightforward, it takes careful agation\nbookkeeping to keep track of all the pieces.\n10.7.2 Regularization and Stochastic Gradient Descent\nGradient descent usually takes many steps to reach a local minimum. In\npractice, there are a number of approaches for accelerating the process.\nAlso, when n is large, instead of summing (10.29)\u2013(10.30) over all n observations,\nwe can sample a small fraction or minibatch of them each time\nminibatch\nwe compute a gradient step. This process is known as stochastic gradient\ndescent (SGD) and is the state of the art for learning deep neural networks.\nstochastic\ngradient\ndescent\nFortunately, there is very good software for setting up deep learning models,\nand for fitting them to data, so most of the technicalities are hidden\nfrom the user.\n10.7 Fitting a Neural Network 437\n0 5 10 15 20 25 30\n0.1 0.2 0.3 0.4\nEpochs\nValue of Objective Function\nTraining Set\nValidation Set\n0 5 10 15 20 25 30\n0.00 0.02 0.04 0.06 0.08 0.10 0.12\nEpochs\nClassification Error\nFIGURE 10.18. Evolution of training and validation errors for the MNIST neural\nnetwork depicted in Figure 10.4, as a function of training epochs. The objective\nrefers to the log-likelihood (10.14).\nWe now turn to the multilayer network (Figure", "doc_id": "24f01d5f-2a25-456e-9f4b-5fde6bbe9cca", "embedding": null, "doc_hash": "59d029370294957dc7b0cfb4e81137cd41458e48525ccd812c7681d3d00212a4", "extra_info": null, "node_info": {"start": 991461, "end": 994292, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "ad578334-4944-4530-83d1-dc0e7c306be4", "3": "965f9e90-5887-44a8-a0cf-20cd75eae70e"}}, "__type__": "1"}, "965f9e90-5887-44a8-a0cf-20cd75eae70e": {"__data__": {"text": "(10.14).\nWe now turn to the multilayer network (Figure 10.4) used in the digit\nrecognition problem. The network has over 235,000 weights, which is around\nfour times the number of training examples. Regularization is essential here\nto avoid overfitting. The first row in Table 10.1 uses ridge regularization on\nthe weights. This is achieved by augmenting the objective function (10.14)\nwith a penalty term:\nR(\u03b8; \u03bb) = \u2212\n0n\ni=1\n09\nm=0\nyim log(fm(xi)) + \u03bb\n0\nj\n\u03b82\nj . (10.31)\nThe parameter \u03bb is often preset at a small value, or else it is found using the\nvalidation-set approach of Section 5.3.1. We can also use different values of\n\u03bb for the groups of weights from different layers; in this case W1 and W2\nwere penalized, while the relatively few weights B of the output layer were\nnot penalized at all. Lasso regularization is also popular as an additional\nform or regularization, or as an alternative to ridge.\nFigure 10.18 shows some metrics that evolve during the training of the\nnetwork on the MNIST data. It turns out that SGD naturally enforces its\nown form of approximately quadratic regularization.22 Here the minibatch\nsize was 128 observations per gradient update. The term epochs labeling the\nepochs\nhorizontal axis in Figure 10.18 counts the number of times an equivalent of\nthe full training set has been processed. For this network, 20% of the 60,000\ntraining observations were used as a validation set in order to determine\nwhen training should stop. So in fact 48,000 observations were used for\n22This and other properties of SGD for deep learning are the subject of much research\nin the machine learning literature at the time of writing.\n438 10. Deep Learning\nFIGURE 10.19. Dropout Learning. Left: a fully connected network. Right: network\nwith dropout in the input and hidden layer. The nodes in grey are selected\nat random, and ignored in an instance of training.\ntraining, and hence there are 48,000/128 \u2248 375 minibatch gradient updates\nper epoch. We see that the value of the validation objective actually starts\nto increase by 30 epochs, so early stopping can also be used as an additional\nearly\nform of regularization. stopping\n10.7.3 Dropout Learning\nThe second row in Table 10.1 is labeled dropout. This is a relatively new\ndropout\nand efficient form of regularization, similar in some respects to ridge regularization.\nInspired by random forests (Section 8.2), the idea is to randomly\nremove a fraction \u03c6 of the units in a layer when fitting the model.\nFigure 10.19 illustrates this. This is done separately each time a training\nobservation is processed. The surviving units stand in for those missing,\nand their weights are scaled up by a factor of 1/(1 \u2212 \u03c6) to compensate.\nThis prevents nodes from becoming over-specialized, and can be seen as\na form of regularization. In practice dropout is achieved by randomly setting\nthe activations for the \u201cdropped out\u201d units to zero, while keeping the\narchitecture intact.\n10.7.4 Network Tuning\nThe network in Figure 10.4 is considered to be relatively straightforward;\nit nevertheless requires a number of choices that all have an effect on the\nperformance:\n\u2022 The number of hidden layers, and the number of units per layer. Modern\nthinking is that the number of units per hidden layer can be large,\nand overfitting can be controlled via the various forms of regularization.\n10.8 Interpolation and Double Descent 439\n\u2022 Regularization tuning parameters. These include the dropout rate \u03c6\nand the strength \u03bb of lasso and ridge regularization, and are typically\nset separately at each layer.\n\u2022 Details of stochastic gradient descent. These includes the batch size,\nthe number of epochs, and if used, details of data augmentation (Section\n10.3.4.)\nChoices such as these can make a difference. In preparing this MNIST example,\nwe achieved a respectable 1.8% misclassification", "doc_id": "965f9e90-5887-44a8-a0cf-20cd75eae70e", "embedding": null, "doc_hash": "c8aafa230033cc8068cb7265f1b7061cbf68c22aa9d96caf3ee09b666c2f42e5", "extra_info": null, "node_info": {"start": 994275, "end": 998112, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "24f01d5f-2a25-456e-9f4b-5fde6bbe9cca", "3": "70c84b6f-59db-4f1a-978b-7d6c07d4d66a"}}, "__type__": "1"}, "70c84b6f-59db-4f1a-978b-7d6c07d4d66a": {"__data__": {"text": "this MNIST example,\nwe achieved a respectable 1.8% misclassification error after some trial\nand error. Finer tuning and training of a similar network can get under\n1% error on these data, but the tinkering process can be tedious, and can\nresult in overfitting if done carelessly.\n10.8 Interpolation and Double Descent\nThroughout this book, we have repeatedly discussed the bias-variance tradeoff,\nfirst presented in Section 2.2.2. This trade-off indicates that statistical\nlearning methods tend to perform the best, in terms of test-set error, for an\nintermediate level of model complexity. In particular, if we plot \u201cflexibility\u201d\non the x-axis and error on the y-axis, then we generally expect to see that\ntest error has a U-shape, whereas training error decreases monotonically.\nTwo \u201ctypical\u201d examples of this behavior can be seen in the right-hand\npanel of Figure 2.9 on page 31, and in Figure 2.17 on page 42. One implication\nof the bias-variance trade-off is that it is generally not a good idea to\ninterpolate the training data \u2014 that is, to get zero training error \u2014 since\ninterpolate\nthat will often result in very high test error.\nHowever, it turns out that in certain specific settings it can be possible for\na statistical learning method that interpolates the training data to perform\nwell \u2014 or at least, better than a slightly less complex model that does not\nquite interpolate the data. This phenomenon is known as double descent,\nand is displayed in Figure 10.20. \u201cDouble descent\u201d gets its name from the\nfact that the test error has a U-shape before the interpolation threshold is\nreached, and then it descends again (for a while, at least) as an increasingly\nflexible model is fit.\nWe now describe the set-up that resulted in Figure 10.20. We simulated\nn = 20 observations from the model\nY = sin(X) + \u03f5,\nwhere X \u223c U[\u22125, 5] (uniform distribution), and \u03f5 \u223c N(0,\u03c32) with \u03c3 = 0.3.\nWe then fit a natural spline to the data, as described in Section 7.4, with d\ndegrees of freedom.23 Recall from Section 7.4 that fitting a natural spline\n23This implies the choice of d knots, here chosen at d equi-probability quantiles of the\ntraining data. When d > n, the quantiles are found by interpolation.\n440 10. Deep Learning\n2 5 10 20 50\n0.0 0.5 1.0 1.5 2.0\nDegrees of Freedom\nError\nTraining Error\nTest Error\nFIGURE 10.20. Double descent phenomenon, illustrated using error plots for\na one-dimensional natural spline example. The horizontal axis refers to the number\nof spline basis functions on the log scale. The training error hits zero when\nthe degrees of freedom coincides with the sample size n = 20, the \u201cinterpolation\nthreshold\u201d, and remains zero thereafter. The test error increases dramatically at\nthis threshold, but then descends again to a reasonable value before finally increasing\nagain.\nwith d degrees of freedom amounts to fitting a least-squares regression\nof the response onto a set of d basis functions. The upper-left panel of\nFigure 10.21 shows the data, the true function f(X), and \u02c6 f8(X), the fitted\nnatural spline with d = 8 degrees of freedom.\nNext, we fit a natural spline with d = 20 degrees of freedom. Since n = 20,\nthis means that n = d, and we have zero training error; in other words, we\nhave interpolated the training data! We can see from the top-right panel of\nFigure 10.21 that \u02c6 f20(X) makes wild excursions, and hence the test error\nwill be large.\nWe now continue to fit natural splines to the data, with increasing values\nof d. For d > 20, the least squares regression of Y onto d basis functions\nis not unique: there are an infinite number of least squares coefficient", "doc_id": "70c84b6f-59db-4f1a-978b-7d6c07d4d66a", "embedding": null, "doc_hash": "c04f1889c2d0d2259603b6655d22a4149ee1d15ef95dbc88cada89391bac7d57", "extra_info": null, "node_info": {"start": 998099, "end": 1001710, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "965f9e90-5887-44a8-a0cf-20cd75eae70e", "3": "a454ddd4-84d7-4e5d-99e2-85cf6eeb71ae"}}, "__type__": "1"}, "a454ddd4-84d7-4e5d-99e2-85cf6eeb71ae": {"__data__": {"text": "functions\nis not unique: there are an infinite number of least squares coefficient estimates\nthat achieve zero error. To select among them, we choose the one\nwith the smallest sum of squared coefficients,\n)d\nj=1\n\u02c6 \u03b22\nj . This is known as\nthe minimum-norm solution.\nThe two lower panels of Figure 10.21 show the minimum-norm natural\nspline fits with d = 42 and d = 80 degrees of freedom. Incredibly, \u02c6 f42(X)\nis quite a bit less less wild than \u02c6 f20(X), even though it makes use of more\ndegrees of freedom. And \u02c6 f80(X) is not much different. How can this be?\nEssentially, \u02c6 f20(X) is very wild because there is just a single way to interpolate\nn = 20 observations using d = 20 basis functions, and that single\nway results in a somewhat extreme fitted function. By contrast, there are an\n10.8 Interpolation and Double Descent 441\n\u22124 \u22122 0 2 4\n\u22123 \u22122 \u22121 0 1 2 3\n8 Degrees of Freedom\nseq(\u22125, 5, len = 1000)\n\u22124 \u22122 0 2 4\n\u22123 \u22122 \u22121 0 1 2 3\n20 Degrees of Freedom\nseq(\u22125, 5, len = 1000)\nf(seq(\u22125, 5, len = 1000))\n\u22124 \u22122 0 2 4\n\u22123 \u22122 \u22121 0 1 2 3\n42 Degrees of Freedom\n\u22124 \u22122 0 2 4\n\u22123 \u22122 \u22121 0 1 2 3\n80 Degrees of Freedom\nf(seq(\u22125, 5, len = 1000))\nFIGURE 10.21. Fitted functions \u02c6 fd(X) (orange), true function f(X) (black)\nand the observed 20 training data points. A different value of d (degrees of freedom)\nis used in each panel. For d \u2265 20 the orange curves all interpolate the\ntraining points, and hence the training error is zero.\ninfinite number of ways to interpolate n = 20 observations using d = 42 or\nd = 80 basis functions, and the smoothest of them \u2014 that is, the minimum\nnorm solution \u2014 is much less wild than \u02c6 f20(X)!\nIn Figure 10.20, we display the training error and test error associated\nwith \u02c6 fd(X), for a range of values of the degrees of freedom d. We see that\nthe training error drops to zero once d = 20 and beyond; i.e. once the\ninterpolation threshold is reached. By contrast, the test error shows a Ushape\nfor d \u2264 20, grows extremely large around d = 20, and then shows a\nsecond region of descent for d > 20. For this example the signal-to-noise\nratio \u2014 Var(f(X))/\u03c32 \u2014 is 5.9, which is quite high (the data points are\nclose to the true curve). So an estimate that interpolates the data and does\nnot wander too far inbetween the observed data points will likely do well.\nIn Figures 10.20 and 10.21, we have illustrated the double descent phenomenon\nin a simple one-dimensional setting using natural splines. However,\nit turns out that the same phenomenon can arise for deep learning.\nBasically, when we fit neural networks with a huge number of parameters,\nwe are sometimes able to get good results with zero training error. This is\nparticularly true in problems with high signal-to-noise ratio, such as natural\nimage recognition and language translation, for example. This is because\nthe techniques used to fit neural networks, including stochastic gradient\ndescent, naturally lend themselves to selecting a \u201csmooth\u201d interpolating\nmodel that has good test-set performance on these kinds of problems.\n442 10. Deep Learning\nSome points are worth emphasizing:\n\u2022 The double-descent phenomenon does not contradict the bias-variance\ntrade-off, as presented in Section 2.2.2. Rather, the double-descent\ncurve seen in the right-hand side of Figure 10.20 is a consequence of\nthe fact that the x-axis displays the number of spline basis functions\nused, which does not properly", "doc_id": "a454ddd4-84d7-4e5d-99e2-85cf6eeb71ae", "embedding": null, "doc_hash": "60e1c36068989ada774574ab099e154b3429ad5f489cb41e176a4b2ded07532d", "extra_info": null, "node_info": {"start": 1001701, "end": 1005077, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "70c84b6f-59db-4f1a-978b-7d6c07d4d66a", "3": "3cba10fa-f633-4574-9a54-a98c500e64e0"}}, "__type__": "1"}, "3cba10fa-f633-4574-9a54-a98c500e64e0": {"__data__": {"text": "displays the number of spline basis functions\nused, which does not properly capture the true \u201cflexibility\u201d of models\nthat interpolate the training data. Stated another way, in this example,\nthe minimum-norm natural spline with d = 42 has lower variance\nthan the natural spline with d = 20.\n\u2022 Most of the statistical learning methods seen in this book do not exhibit\ndouble descent. For instance, regularization approaches typically do\nnot interpolate the training data, and thus double descent does not\noccur. This is not a drawback of regularized methods: they can give\ngreat results without interpolating the data!\nIn particular, in the examples here, if we had fit the natural splines\nusing ridge regression with an appropriately-chosen penalty rather\nthan least squares, then we would not have seen double descent, and\nin fact would have obtained better test error results.\n\u2022 In Chapter 9, we saw that maximal margin classifiers and SVMs that\nhave zero training error nonetheless often achieve very good test error.\nThis is in part because those methods seek smooth minimum norm\nsolutions. This is similar to the fact that the minimum-norm natural\nspline can give good results with zero training error.\n\u2022 The double-descent phenomenon has been used by the machine learning\ncommunity to explain the successful practice of using an overparametrized\nneural network (many layers, and many hidden units),\nand then fitting all the way to zero training error. However, fitting\nto zero error is not always optimal, and whether it is advisable depends\non the signal-to-noise ratio. For instance, we may use ridge\nregularization to avoid overfitting a neural network, as in (10.31). In\nthis case, provided that we use an appropriate choice for the tuning\nparameter \u03bb, we will never interpolate the training data, and thus\nwill not see the double descent phenomenon. Nonetheless we can get\nvery good test-set performance, likely much better than we would\nhave achieved had we interpolated the training data. Early stopping\nduring stochastic gradient descent can also serve as a form of regularization\nthat prevents us from interpolating the training data, while\nstill getting very good results on test data.\nTo summarize: though double descent can sometimes occur in neural networks,\nwe typically do not want to rely on this behavior. Moreover, it is important\nto remember that the bias-variance trade-off always holds (though\n10.9 Lab: Deep Learning 443\nit is possible that test error as a function of flexibility may not exhibit a Ushape,\ndepending on how we have parametrized the notion of \u201cflexibility\u201d\non the x-axis).\n10.9 Lab: Deep Learning\nIn this section, we show how to fit the examples discussed in the text. We\nuse the keras package, which interfaces to the tensorflow package which in\nturn links to efficient python code. This code is impressively fast, and the\npackage is well-structured. A good companion is the text Deep Learning\nwith R24, and most of our code is adapted from there.\nGetting keras up and running on your computer can be a challenge. The\nbook website www.statlearning.com gives step-by-step instructions on\nhow to achieve this.25 Guidance can also be found at keras.rstudio.com.\n10.9.1 A Single Layer Network on the Hitters Data\nWe start by fitting the models in Section 10.6. We set up the data, and\nseparate out a training and test set.\n> library(ISLR2)\n> Gitters <- na.omit(Hitters)\n> n <- nrow(Gitters)\n> set.seed (13)\n> ntest <- trunc(n / 3)\n> testid <- sample (1:n, ntest)\nThe linear model should be familiar, but we present it anyway.\n> lfit <- lm(Salary \u223c ., data = Gitters[-testid , ])\n> lpred <- predict(lfit , Gitters[testid , ])\n> with(Gitters[testid , ], mean(abs(lpred - Salary)))\n[1] 254.6687\nNotice the use of the with() command: the first argument is a", "doc_id": "3cba10fa-f633-4574-9a54-a98c500e64e0", "embedding": null, "doc_hash": "95e3b7f7efe42cc7a0157b3b647e756ba3de307d0459b7711a8450ae737c6fb4", "extra_info": null, "node_info": {"start": 1005084, "end": 1008877, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "a454ddd4-84d7-4e5d-99e2-85cf6eeb71ae", "3": "175fc67e-412d-4486-8a6f-5e18d2e8faec"}}, "__type__": "1"}, "175fc67e-412d-4486-8a6f-5e18d2e8faec": {"__data__": {"text": "254.6687\nNotice the use of the with() command: the first argument is a dataframe,\nwith()\nand the second an expression that can refer to elements of the dataframe\nby name. In this instance the dataframe corresponds to the test data and\nthe expression computes the mean absolute prediction error on this data.\nNext we fit the lasso using glmnet. Since this package does not use formulas,\nwe create x and y first.\n> x <- scale(model.matrix(Salary \u223c . - 1, data = Gitters))\n> y <- Gitters$Salary\n24F. Chollet and J.J. Allaire, Deep Learning with R (2018), Manning Publications.\n25Many thanks to Balasubramanian Narasimhan for preparing the keras installation\ninstructions.\n444 10. Deep Learning\nThe first line makes a call to model.matrix(), which produces the same\nmatrix that was used by lm() (the -1 omits the intercept). This function\nautomatically converts factors to dummy variables. The scale() function\nstandardizes the matrix so each column has mean zero and variance one.\n> library(glmnet)\n> cvfit <- cv.glmnet(x[-testid , ], y[-testid],\ntype.measure = \"mae\")\n> cpred <- predict(cvfit , x[testid , ], s = \"lambda.min\")\n> mean(abs(y[testid] - cpred))\n[1] 252.2994\nTo fit the neural network, we first set up a model structure that describes\nthe network.\n> library(keras)\n> modnn <- keras_model_sequential () %>%\n+ layer_dense(units = 50, activation = \"relu\",\ninput_shape = ncol(x)) %>%\n+ layer_dropout(rate = 0.4) %>%\n+ layer_dense(units = 1)\nWe have created a vanilla model object called modnn, and have added details\nabout the successive layers in a sequential manner, using the function\nkeras model sequential(). The pipe operator %>% passes the previous term\nkeras model\nsequential\npipe\nas the first argument to the next function, and returns the result. It allows\nus to specify the layers of a neural network in a readable form.\nWe illustrate the use of the pipe operator on a simple example. Earlier,\nwe created x using the command\n> x <- scale(model.matrix(Salary \u223c . - 1, data = Gitters))\nWe first make a matrix, and then we center each of the variables. Compound\nexpressions like this can be difficult to parse. We could have obtained the\nsame result using the pipe operator:\n> x <- model.matrix(Salary \u223c . - 1, data = Gitters) %>% scale ()\nUsing the pipe operator makes it easier to follow the sequence of operations.\nWe now return to our neural network. The object modnn has a single hidden\nlayer with 50 hidden units, and a ReLU activation function. It then has\na dropout layer, in which a random 40% of the 50 activations from the previous\nlayer are set to zero during each iteration of the stochastic gradient\ndescent algorithm. Finally, the output layer has just one unit with no activation\nfunction, indicating that the model provides a single quantitative\noutput.\nNext we add details to modnn that control the fitting algorithm. Here we\nhave simply followed the examples given in the Keras book. We minimize\nsquared-error loss as in (10.23). The algorithm tracks the mean absolute\nerror on the training data, and on validation data if it is supplied.\n> modnn %>% compile(loss = \"mse\",\n10.9 Lab: Deep Learning 445\noptimizer = optimizer_rmsprop (),\nmetrics = list(\"mean_absolute_error\")\n)\nIn the previous line, the pipe operator passes modnn as the first argument\nto compile(). The compile() function does not actually change the R object\ncompile()\nmodnn, but it does communicate these specifications to the corresponding\npython instance of this model that has been created along the way.\nNow we fit the model. We supply the training data and", "doc_id": "175fc67e-412d-4486-8a6f-5e18d2e8faec", "embedding": null, "doc_hash": "04aad70fbe4a58bcfe85d89803ecd5427f257f2c54613a754297d16a3f217ba2", "extra_info": null, "node_info": {"start": 1008884, "end": 1012445, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "3cba10fa-f633-4574-9a54-a98c500e64e0", "3": "d3306d79-7b5d-4985-8532-bfe3150e0606"}}, "__type__": "1"}, "d3306d79-7b5d-4985-8532-bfe3150e0606": {"__data__": {"text": "been created along the way.\nNow we fit the model. We supply the training data and two fitting parameters,\nepochs and batch size. Using 32 for the latter means that at each\nstep of SGD, the algorithm randomly selects 32 training observations for\nthe computation of the gradient. Recall from Sections 10.4 and 10.7 that\nan epoch amounts to the number of SGD steps required to process n observations.\nSince the training set has n = 176, an epoch is 176/32 = 5.5 SGD\nsteps. The fit() function has an argument validation data; these data are\nnot used in the fitting, but can be used to track the progress of the model\n(in this case reporting the mean absolute error). Here we actually supply\nthe test data so we can see the mean absolute error of both the training\ndata and test data as the epochs proceed. To see more options for fitting,\nuse ?fit.keras.engine.training.Model.\n> history <- modnn %>% fit(\nx[-testid , ], y[-testid], epochs = 1500, batch_size = 32,\nvalidation_data = list(x[testid , ], y[testid ])\n)\nWe can plot the history to display the mean absolute error for the training\nand test data. For the best aesthetics, install the ggplot2 package before\ncalling the plot() function. If you have not installed ggplot2, then the code\nbelow will still run, but the plot will be less attractive.\n> plot(history)\nIt is worth noting that if you run the fit() command a second time in the\nsame R session, then the fitting process will pick up where it left off. Try\nre-running the fit() command, and then the plot() command, to see!\nFinally, we predict from the final model, and evaluate its performance\non the test data. Due to the use of SGD, the results vary slightly with each\nfit. Unfortunately the set.seed() function does not ensure identical results\n(since the fitting is done in python), so your results will differ slightly.\n> npred <- predict(modnn , x[testid , ])\n> mean(abs(y[testid] - npred))\n[1] 257.43\n10.9.2 A Multilayer Network on the MNIST Digit Data\nThe keras package comes with a number of example datasets, including\nthe MNIST digit data. Our first step is to load the MNIST data. The\ndataset mnist() function is provided for this purpose.\ndataset mnist()\n446 10. Deep Learning\n> mnist <- dataset_mnist ()\n> x_train <- mnist$train$x\n> g_train <- mnist$train$y\n> x_test <- mnist$test$x\n> g_test <- mnist$test$y\n> dim(x_train)\n[1] 60000 28 28\n> dim(x_test)\n[1] 10000 28 28\nThere are 60,000 images in the training data and 10,000 in the test data.\nThe images are 28\u00d728, and stored as a three-dimensional array, so we need\nto reshape them into a matrix. Also, we need to \u201cone-hot\u201d encode the class\nlabel. Luckily keras has a lot of built-in functions that do this for us.\n> x_train <- array_reshape(x_train , c(nrow(x_train), 784))\n> x_test <- array_reshape(x_test , c(nrow(x_test), 784))\n> y_train <- to_categorical(g_train , 10)\n> y_test <- to_categorical(g_test , 10)\nNeural networks are somewhat sensitive to the scale of the inputs. For\nexample, ridge and lasso regularization are affected by scaling. Here the\ninputs are eight-bit26 grayscale values between 0 and 255, so we rescale to\nthe unit interval.\n> x_train <- x_train / 255\n> x_test <- x_test / 255\nNow we are ready to fit our neural network.\n> modelnn <- keras_model_sequential ()\n> modelnn %>%\n+ layer_dense(units = 256, activation =", "doc_id": "d3306d79-7b5d-4985-8532-bfe3150e0606", "embedding": null, "doc_hash": "f123b96b571eedf2ca4dc4a101e8624577395b5ee706ce79919d050f62eb48e4", "extra_info": null, "node_info": {"start": 1012438, "end": 1015756, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "175fc67e-412d-4486-8a6f-5e18d2e8faec", "3": "ecbd0405-8f15-4e5c-9ba6-f9906fcf3e2d"}}, "__type__": "1"}, "ecbd0405-8f15-4e5c-9ba6-f9906fcf3e2d": {"__data__": {"text": "modelnn %>%\n+ layer_dense(units = 256, activation = \"relu\",\ninput_shape = c(784)) %>%\n+ layer_dropout(rate = 0.4) %>%\n+ layer_dense(units = 128, activation = \"relu\") %>%\n+ layer_dropout(rate = 0.3) %>%\n+ layer_dense(units = 10, activation = \"softmax\")\nThe first layer goes from 28 \u00d7 28 = 784 input units to a hidden layer of\n256 units, which uses the ReLU activation function. This is specified by a\ncall to layer dense(), which takes as input a modelnn object, and returns\nlayer dense()\na modified modelnn object. This is then piped through layer dropout() to\nlayer dropout()\nperform dropout regularization. The second hidden layer comes next, with\n128 hidden units, followed by a dropout layer. The final layer is the output\nlayer, with activation \"softmax\" (10.13) for the 10-class classification\nproblem, which defines the map from the second hidden layer to class probabilities.\nFinally, we use summary() to summarize the model, and to make\nsure we got it all right.\n26Eight bits means 28, which equals 256. Since the convention is to start at 0, the\npossible values range from 0 to 255.\n10.9 Lab: Deep Learning 447\n> summary(modelnn)\n________________________________________________________________\nLayer (type) Output Shape Param #\n================================================================\ndense (Dense) (None , 256) 200960\n________________________________________________________________\ndropout (Dropout) (None , 256) 0\n________________________________________________________________\ndense _1 (Dense) (None , 128) 32896\n________________________________________________________________\ndropout _1 (Dropout) (None , 128) 0\n________________________________________________________________\ndense _2 (Dense) (None , 10) 1290\n================================================================\nTotal params: 235 ,146\nTrainable params: 235 ,146\nNon - trainable params: 0\nThe parameters for each layer include a bias term, which results in a\nparameter count of 235,146. For example, the first hidden layer involves\n(784 + 1) \u00d7 256 = 200,960 parameters.\nNotice that the layer names such as dropout 1 and dense 2 have subscripts.\nThese may appear somewhat random; in fact, if you fit the same\nmodel again, these will change. They are of no consequence: they vary because\nthe model specification code is run in python, and these subscripts\nare incremented every time keras model sequential() is called.\nNext, we add details to the model to specify the fitting algorithm. We\nfit the model by minimizing the cross-entropy function given by (10.14).\n> modelnn %>% compile(loss = \"categorical_crossentropy\",\noptimizer = optimizer_rmsprop (), metrics = c(\"accuracy\")\n)\nNow we are ready to go. The final step is to supply training data, and\nfit the model.\n> system.time(\n+ history <- modelnn %>%\n+ fit(x_train , y_train , epochs = 30, batch_size = 128,\nvalidation_split = 0.2)\n+ )\n> plot(history , smooth = FALSE)\nWe have suppressed the output here, which is a progress report on the\nfitting of the model, grouped by epoch. This is very useful, since on large\ndatasets fitting can take time. Fitting this model took 144 seconds on a\n448 10. Deep Learning\n2.9 GHz MacBook Pro with 4 cores and 32 GB of RAM. Here we specified\na validation split of 20%, so the training is actually performed on\n80% of the 60,000 observations in the training set. This is an alternative\nto actually supplying validation data, like we did in Section 10.9.1. See\n?fit.keras.engine.training.Model for all the optional fitting arguments.\nSGD uses batches of 128 observations in computing the gradient, and doing\nthe arithmetic, we see that an epoch corresponds to 375 gradient steps.\nThe last plot() command produces a figure similar to Figure 10.18.\nTo obtain the test error in Table 10.1, we first write a simple function\naccuracy() that compares predicted and true class labels, and then use it\nto evaluate our", "doc_id": "ecbd0405-8f15-4e5c-9ba6-f9906fcf3e2d", "embedding": null, "doc_hash": "5836573b172a839046305f566e270f76adc39e4c9c701e84c75ee83eeaf39fc8", "extra_info": null, "node_info": {"start": 1015779, "end": 1019665, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "d3306d79-7b5d-4985-8532-bfe3150e0606", "3": "547e7a0f-353a-4706-861a-c24355877ef3"}}, "__type__": "1"}, "547e7a0f-353a-4706-861a-c24355877ef3": {"__data__": {"text": "that compares predicted and true class labels, and then use it\nto evaluate our predictions.\n> accuracy <- function(pred , truth)\n+ mean(drop(pred) == drop(truth))\n> modelnn %>% predict_classes(x_test) %>% accuracy(g_test)\n[1] 0.9813\nThe table also reports LDA (Chapter 4) and multiclass logistic regression.\nAlthough packages such as glmnet can handle multiclass logistic regression,\nthey are quite slow on this large dataset. It is much faster and quite easy\nto fit such a model using the keras software. We just have an input layer\nand output layer, and omit the hidden layers!\n> modellr <- keras_model_sequential () %>%\n+ layer_dense(input_shape = 784, units = 10,\nactivation = \"softmax\")\n> summary(modellr)\n________________________________________________________________\nLayer (type) Output Shape Param #\n================================================================\ndense _6 (Dense) (None , 10) 7850\n================================================================\nTotal params: 7,850\nTrainable params: 7,850\nNon - trainable params: 0\nWe fit the model just as before.\n> modellr %>% compile(loss = \"categorical_crossentropy\",\noptimizer = optimizer_rmsprop (), metrics = c(\"accuracy\"))\n> modellr %>% fit(x_train , y_train , epochs = 30,\nbatch_size = 128, validation_split = 0.2)\n> modellr %>% predict_classes(x_test) %>% accuracy(g_test)\n[1] 0.9286\n10.9.3 Convolutional Neural Networks\nIn this section we fit a CNN to the CIFAR100 data, which is available in the\nkeras package. It is arranged in a similar fashion as the MNIST data.\n10.9 Lab: Deep Learning 449\n> cifar100 <- dataset_cifar100 ()\n> names(cifar100)\n[1] \"train\" \"test\"\n> x_train <- cifar100$train$x\n> g_train <- cifar100$train$y\n> x_test <- cifar100$test$x\n> g_test <- cifar100$test$y\n> dim(x_train)\n[1] 50000 32 32 3\n> range(x_train[1,,, 1])\n[1] 13 255\nThe array of 50,000 training images has four dimensions: each three-color\nimage is represented as a set of three channels, each of which consists of\n32 \u00d7 32 eight-bit pixels. We standardize as we did for the digits, but keep\nthe array structure. We one-hot encode the response factors to produce a\n100-column binary matrix.\n> x_train <- x_train / 255\n> x_test <- x_test / 255\n> y_train <- to_categorical(g_train , 100)\n> dim(y_train)\n[1] 50000 100\nBefore we start, we look at some of the training images using the jpeg\njpeg\npackage; similar code produced Figure 10.5 on page 411.\n> library(jpeg)\n> par(mar = c(0, 0, 0, 0), mfrow = c(5, 5))\n> index <- sample(seq (50000) , 25)\n> for (i in index) plot(as.raster(x_train[i,,, ]))\nThe as.raster() function converts the feature map so that it can be plotted\nas.raster()\nas a color image.\nHere we specify a moderately-sized CNN for demonstration purposes,\nsimilar in structure to Figure 10.8.\n> model <- keras_model_sequential () %>%\n+ layer_conv _2d(filters = 32, kernel_size = c(3, 3),\npadding = \"same\", activation = \"relu\",\ninput_shape = c(32, 32, 3)) %>%\n+ layer_max_pooling _2d(pool_size = c(2, 2)) %>%\n+ layer_conv _2d(filters = 64, kernel_size = c(3,", "doc_id": "547e7a0f-353a-4706-861a-c24355877ef3", "embedding": null, "doc_hash": "f8a459c0beb6650beb760e44d218499224d8825b0d3db931219f7bd7dfc83181", "extra_info": null, "node_info": {"start": 1019645, "end": 1022670, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "ecbd0405-8f15-4e5c-9ba6-f9906fcf3e2d", "3": "dc510195-132a-4ca3-8514-ae846fdeecd3"}}, "__type__": "1"}, "dc510195-132a-4ca3-8514-ae846fdeecd3": {"__data__": {"text": "layer_conv _2d(filters = 64, kernel_size = c(3, 3),\npadding = \"same\", activation = \"relu\") %>%\n+ layer_max_pooling _2d(pool_size = c(2, 2)) %>%\n+ layer_conv _2d(filters = 128, kernel_size = c(3, 3),\npadding = \"same\", activation = \"relu\") %>%\n+ layer_max_pooling _2d(pool_size = c(2, 2)) %>%\n+ layer_conv _2d(filters = 256, kernel_size = c(3, 3),\npadding = \"same\", activation = \"relu\") %>%\n+ layer_max_pooling _2d(pool_size = c(2, 2)) %>%\n+ layer_flatten () %>%\n+ layer_dropout(rate = 0.5) %>%\n+ layer_dense(units = 512, activation = \"relu\") %>%\n450 10. Deep Learning\n+ layer_dense(units = 100, activation = \"softmax\")\n> summary(model)\n________________________________________________________________\nLayer (type) Output Shape Param #\n================================================================\nconv2d (Conv2D) (None , 32, 32, 32) 896\n________________________________________________________________\nmax_pooling2d (MaxPooling2D (None , 16, 16, 32) 0\n________________________________________________________________\nconv2d _1 (Conv2D) (None , 16, 16, 64) 18496\n________________________________________________________________\nmax_pooling2d _1 (MaxPooling (None , 8, 8, 64) 0\n________________________________________________________________\nconv2d _2 (Conv2D) (None , 8, 8, 128) 73856\n________________________________________________________________\nmax_pooling2d _2 (MaxPooling (None , 4, 4, 128) 0\n________________________________________________________________\nconv2d _3 (Conv2D) (None , 4, 4, 256) 295168\n________________________________________________________________\nmax_pooling2d _3 (MaxPooling (None , 2, 2, 256) 0\n________________________________________________________________\nflatten (Flatten) (None , 1024) 0\n________________________________________________________________\ndropout (Dropout) (None , 1024) 0\n________________________________________________________________\ndense (Dense) (None , 512) 524800\n________________________________________________________________\ndense _1 (Dense) (None , 100) 51300\n================================================================\nTotal params: 964 ,516\nTrainable params: 964 ,516\nNon - trainable params: 0\nNotice that we used the padding = \"same\" argument to layer conv 2D(),\nlayer conv 2D()\nwhich ensures that the output channels have the same dimension as the\ninput channels. There are 32 channels in the first hidden layer, in contrast\nto the three channels in the input layer. We use a 3 \u00d7 3 convolution filter\nfor each channel in all the layers. Each convolution is followed by a maxpooling\nlayer over 2 \u00d7 2 blocks. By studying the summary, we can see\n10.9 Lab: Deep Learning 451\nthat the channels halve in both dimensions after each of these max-pooling\noperations. After the last of these we have a layer with 256 channels of\ndimension 2 \u00d7 2. These are then flattened to a dense layer of size 1,024:\nin other words, each of the 2 \u00d7 2 matrices is turned into a 4-vector, and\nput side-by-side in one layer. This is followed by a dropout regularization\nlayer, then another dense layer of size 512, which finally reaches the softmax\noutput layer.\nFinally, we specify the fitting algorithm, and fit the model.\n> model %>% compile(loss = \"categorical_crossentropy\",\noptimizer = optimizer_rmsprop (), metrics = c(\"accuracy\"))\n> history <- model %>% fit(x_train , y_train , epochs = 30,\nbatch_size = 128, validation_split = 0.2)\n> model %>% predict_classes(x_test) %>% accuracy(g_test)\n[1] 0.4561\nThis model takes 10 minutes to run and achieves 46% accuracy on the test\ndata. Although this is not terrible for 100-class data (a random classifier\ngets 1% accuracy), searching the web we see results around 75%. Typically\nit takes a lot of architecture carpentry, fiddling with regularization,", "doc_id": "dc510195-132a-4ca3-8514-ae846fdeecd3", "embedding": null, "doc_hash": "5e1d912002bf8fff518362e6587aeed30fb4d5fd91ad3c75c1bd46ae8b38de4f", "extra_info": null, "node_info": {"start": 1022696, "end": 1026446, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "547e7a0f-353a-4706-861a-c24355877ef3", "3": "25209498-d560-4b3a-a897-f5947df42ec4"}}, "__type__": "1"}, "25209498-d560-4b3a-a897-f5947df42ec4": {"__data__": {"text": "takes a lot of architecture carpentry, fiddling with regularization, and\ntime to achieve such results.\n10.9.4 Using Pretrained CNN Models\nWe now show how to use a CNN pretrained on the imagenet database to\nclassify natural images, and demonstrate how we produced Figure 10.10.\nWe copied six jpeg images from a digital photo album into the directory\nbook images.27 We first read in the images, and convert them into the array\nformat expected by the keras software to match the specifications in\nimagenet. Make sure that your working directory in R is set to the folder in\nwhich the images are stored.\n> img_dir <- \"book_images\"\n> image_names <- list.files(img_dir)\n> num_images <- length(image_names)\n> x <- array(dim = c(num_images , 224, 224, 3))\n> for (i in 1:num_images) {\n+ img_path <- paste(img_dir , image_names[i], sep = \"/\")\n+ img <- image_load(img_path, target_size = c(224 , 224))\n+ x[i,,, ] <- image_to_array(img)\n+ }\n> x <- imagenet_preprocess_input(x)\nWe then load the trained network. The model has 50 layers, with a fair bit\nof complexity.\n27These images are available from the data section of www.statlearning.com, the\nISL book website. Download book images.zip; when clicked it creates the book images\ndirectory.\n452 10. Deep Learning\n> model <- application_resnet50(weights = \"imagenet\")\n> summary(model)\nFinally, we classify our six images, and return the top three class choices\nin terms of predicted probability for each.\n> pred6 <- model %>% predict(x) %>%\n+ imagenet_decode_predictions(top = 3)\n> names(pred6) <- image_names\n> print(pred6)\n10.9.5 IMDb Document Classification\nNow we perform document classification (Section 10.4) on the IMDb dataset,\nwhich is available as part of the keras package. We limit the dictionary size\nto the 10,000 most frequently-used words and tokens.\n> max_features <- 10000\n> imdb <- dataset_imdb(num_words = max_features)\n> c(c(x_train , y_train), c(x_test , y_test)) %<-% imdb\nThe third line is a shortcut for unpacking the list of lists. Each element\nof x train is a vector of numbers between 0 and 9999 (the document),\nreferring to the words found in the dictionary. For example, the first training\ndocument is the positive review on page 419. The indices of the first 12\nwords are given below.\n> x_train[[1]][1:12]\n[1] 1 14 22 16 43 530 973 1622 1385 65 458 4468\nTo see the words, we create a function, decode review(), that provides a\nsimple interface to the dictionary.\n> word_index <- dataset_imdb_word_index ()\n> decode_review <- function(text , word_index) {\n+ word <- names(word_index)\n+ idx <- unlist(word_index , use.names = FALSE)\n+ word <- c(\"<PAD >\", \"<START >\", \"<UNK >\", \"<UNUSED >\", word)\n+ idx <- c(0:3 , idx + 3)\n+ words <- word[match(text, idx , 2)]\n+ paste(words , collapse = \" \")\n+ }\n> decode_review(x_train [[1]][1:12] , word_index)\n[1] \"<START > this film was just brilliant casting location\nscenery story direction everyone \u2019s\"\nNext we write a function to \u201cone-hot\u201d encode each document in a list of\ndocuments, and return a binary matrix in sparse-matrix format.\n> library(Matrix)\n> one_hot <- function(sequences , dimension) {\n+ seqlen <-", "doc_id": "25209498-d560-4b3a-a897-f5947df42ec4", "embedding": null, "doc_hash": "8acf34085440ce1e660fc54f80425db9d743e918e4670b2debae11d25fdd2417", "extra_info": null, "node_info": {"start": 1026428, "end": 1029549, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "dc510195-132a-4ca3-8514-ae846fdeecd3", "3": "79dabdb7-139f-4855-bf15-c9db505e8ae1"}}, "__type__": "1"}, "79dabdb7-139f-4855-bf15-c9db505e8ae1": {"__data__": {"text": "one_hot <- function(sequences , dimension) {\n+ seqlen <- sapply(sequences , length)\n+ n <- length(seqlen)\n10.9 Lab: Deep Learning 453\n+ rowind <- rep (1:n, seqlen)\n+ colind <- unlist(sequences)\n+ sparseMatrix(i = rowind , j = colind ,\ndims = c(n, dimension))\n+ }\nTo construct the sparse matrix, one supplies just the entries that are\nnonzero. In the last line we call the function sparseMatrix() and supply\nthe row indices corresponding to each document and the column indices\ncorresponding to the words in each document, since we omit the values\nthey are taken to be all ones. Words that appear more than once in any\ngiven document still get recorded as a one.\n> x_train_1h <- one_hot(x_train , 10000)\n> x_test_1h <- one_hot(x_test , 10000)\n> dim(x_train_1h)\n[1] 25000 10000\n> nnzero(x_train _1h) / (25000 * 10000)\n[1] 0.01316987\nOnly 1.3% of the entries are nonzero, so this amounts to considerable savings\nin memory. We create a validation set of size 2,000, leaving 23,000 for\ntraining.\n> set.seed (3)\n> ival <- sample(seq(along = y_train), 2000)\nFirst we fit a lasso logistic regression model using glmnet() on the training\ndata, and evaluate its performance on the validation data. Finally, we plot\nthe accuracy, acclmv, as a function of the shrinkage parameter, \u03bb. Similar\nexpressions compute the performance on the test data, and were used to\nproduce the left plot in Figure 10.11. The code takes advantage of the\nsparse-matrix format of x train 1h, and runs in about 5 seconds; in the\nusual dense format it would take about 5 minutes.\n> library(glmnet)\n> fitlm <- glmnet(x_train_1h[-ival , ], y_train[-ival],\nfamily = \"binomial\", standardize = FALSE)\n> classlmv <- predict(fitlm , x_train_1h[ival , ]) > 0\n> acclmv <- apply(classlmv , 2, accuracy, y_train[ival] > 0)\nWe applied the accuracy() function that we wrote in Lab 10.9.2 to every\ncolumn of the prediction matrix classlmv, and since this is a logical matrix\nof TRUE/FALSE values, we supply the second argument truth as a logical\nvector as well.\nBefore making a plot, we adjust the plotting window.\n> par(mar = c(4, 4, 4, 4), mfrow = c(1, 1))\n> plot(-log(fitlm$lambda), acclmv)\nNext we fit a fully-connected neural network with two hidden layers, each\nwith 16 units and ReLU activation.\n454 10. Deep Learning\n> model <- keras_model_sequential () %>%\n+ layer_dense(units = 16, activation = \"relu\",\ninput_shape = c(10000)) %>%\n+ layer_dense(units = 16, activation = \"relu\") %>%\n+ layer_dense(units = 1, activation = \"sigmoid\")\n> model %>% compile(optimizer = \"rmsprop\",\nloss = \"binary_crossentropy\", metrics = c(\"accuracy\"))\n> history <- model %>% fit(x_train _1h[-ival , ], y_train[-ival],\nepochs = 20, batch_size = 512,\nvalidation_data = list(x_train_1h[ival , ], y_train[ival]))\nThe history object has a metrics component that records both the training\nand validation accuracy at each epoch. Figure 10.11 includes test accuracy\nat each epoch as well. To compute the test accuracy, we rerun the entire\nsequence above, replacing the last line with\n> history <- model %>%", "doc_id": "79dabdb7-139f-4855-bf15-c9db505e8ae1", "embedding": null, "doc_hash": "b57f50cb2685dd8dcf6fbeebbaff088b56287e428870f043fc34f54210ddb950", "extra_info": null, "node_info": {"start": 1029561, "end": 1032596, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "25209498-d560-4b3a-a897-f5947df42ec4", "3": "8c8957d2-2c18-4a02-baa8-a8935ea42182"}}, "__type__": "1"}, "8c8957d2-2c18-4a02-baa8-a8935ea42182": {"__data__": {"text": "above, replacing the last line with\n> history <- model %>% fit(\nx_train_1h[-ival , ], y_train[-ival], epochs = 20,\nbatch_size = 512, validation_data = list(x_test_1h, y_test)\n)\n10.9.6 Recurrent Neural Networks\nIn this lab we fit the models illustrated in Section 10.5.\nSequential Models for Document Classification\nHere we fit a simple LSTM RNN for sentiment analysis with the IMDb\nmovie-review data, as discussed in Section 10.5.1. We showed how to input\nthe data in 10.9.5, so we will not repeat that here.\nWe first calculate the lengths of the documents.\n> wc <- sapply(x_train , length)\n> median(wc)\n[1] 178\n> sum(wc <= 500) / length(wc)\n[1] 0.91568\nWe see that over 91% of the documents have fewer than 500 words. Our\nRNN requires all the document sequences to have the same length. We\nhence restrict the document lengths to the last L = 500 words, and pad\nthe beginning of the shorter ones with blanks.\n> maxlen <- 500\n> x_train <- pad_sequences(x_train , maxlen = maxlen)\n> x_test <- pad_sequences(x_test , maxlen = maxlen)\n> dim(x_train)\n[1] 25000 500\n> dim(x_test)\n[1] 25000 500\n> x_train[1, 490:500]\n[1] 16 4472 113 103 32 15 16 5345 19 178 32\n10.9 Lab: Deep Learning 455\nThe last expression shows the last few words in the first document. At this\nstage, each of the 500 words in the document is represented using an integer\ncorresponding to the location of that word in the 10,000-word dictionary.\nThe first layer of the RNN is an embedding layer of size 32, which will be\nlearned during training. This layer one-hot encodes each document as a\nmatrix of dimension 500\u00d710, 000, and then maps these 10, 000 dimensions\ndown to 32.\n> model <- keras_model_sequential () %>%\n+ layer_embedding(input_dim = 10000, output_dim = 32) %>%\n+ layer_lstm(units = 32) %>%\n+ layer_dense(units = 1, activation = \"sigmoid\")\nThe second layer is an LSTM with 32 units, and the output layer is a single\nsigmoid for the binary classification task.\nThe rest is now similar to other networks we have fit. We track the test\nperformance as the network is fit, and see that it attains 87% accuracy.\n> model %>% compile(optimizer = \"rmsprop\",\nloss = \"binary_crossentropy\", metrics = c(\"acc\"))\n> history <- model %>% fit(x_train , y_train , epochs = 10,\nbatch_size = 128, validation_data = list(x_test , y_test))\n> plot(history)\n> predy <- predict(model, x_test) > 0.5\n> mean(abs(y_test == as.numeric(predy)))\n[1] 0.8721\nTime Series Prediction\nWe now show how to fit the models in Section 10.5.2 for time series prediction.\nWe first set up the data, and standardize each of the variables.\n> library(ISLR2)\n> xdata <- data.matrix(\nNYSE[, c(\"DJ_return\", \"log_volume\",\"log_volatility\")]\n)\n> istrain <- NYSE[, \"train\"]\n> xdata <- scale(xdata)\nThe variable istrain contains a TRUE for each year that is in the training\nset, and a FALSE for each year in the test set.\nWe first write functions to create lagged versions of the three time series.\nWe start with a function that takes as input a data matrix and a lag L,\nand returns a lagged version of the matrix. It simply inserts L rows of NA\nat the top, and truncates the bottom.\n> lagm", "doc_id": "8c8957d2-2c18-4a02-baa8-a8935ea42182", "embedding": null, "doc_hash": "744b09a22be0724d0a09408ae0dd6873e035f16712d79a91f7da4e286ef8c6f9", "extra_info": null, "node_info": {"start": 1032597, "end": 1035708, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "79dabdb7-139f-4855-bf15-c9db505e8ae1", "3": "c11d0396-18cf-4af9-a917-a264aa6df6fe"}}, "__type__": "1"}, "c11d0396-18cf-4af9-a917-a264aa6df6fe": {"__data__": {"text": "L rows of NA\nat the top, and truncates the bottom.\n> lagm <- function(x, k = 1) {\n+ n <- nrow(x)\n+ pad <- matrix(NA , k, ncol(x))\n+ rbind(pad , x[1:(n - k), ])\n+ }\n456 10. Deep Learning\nWe now use this function to create a data frame with all the required lags,\nas well as the response variable.\n> arframe <- data.frame(log_volume = xdata[, \"log_volume\"],\nL1 = lagm(xdata , 1), L2 = lagm(xdata , 2),\nL3 = lagm(xdata , 3), L4 = lagm(xdata , 4),\nL5 = lagm(xdata , 5)\n)\nIf we look at the first five rows of this frame, we will see some missing\nvalues in the lagged variables (due to the construction above). We remove\nthese rows, and adjust istrain accordingly.\n> arframe <- arframe[-(1:5), ]\n> istrain <- istrain[-(1:5)]\nWe now fit the linear AR model to the training data using lm(), and predict\non the test data.\n> arfit <- lm(log_volume \u223c ., data = arframe[istrain , ])\n> arpred <- predict(arfit , arframe[!istrain , ])\n> V0 <- var(arframe[!istrain , \"log_volume\"])\n> 1 - mean (( arpred - arframe [! istrain , \"log_volume\"])^2) / V0\n[1] 0.4132\nThe last two lines compute the R2 on the test data, as defined in (3.17).\nWe refit this model, including the factor variable day of week.\n> arframed <-\ndata.frame(day = NYSE [-(1:5), \"day_of_week\"], arframe)\n> arfitd <- lm(log_volume \u223c ., data = arframed[istrain , ])\n> arpredd <- predict(arfitd , arframed[!istrain , ])\n> 1 - mean (( arpredd - arframe [! istrain , \"log_volume\"])^2) / V0\n[1] 0.4599\nTo fit the RNN, we need to reshape these data, since it expects a sequence\nof L = 5 feature vectors X = {X\u2113}L1\nfor each observation, as in (10.20) on\npage 428. These are lagged versions of the time series going back L time\npoints.\n> n <- nrow(arframe)\n> xrnn <- data.matrix(arframe[, -1])\n> xrnn <- array(xrnn , c(n, 3, 5))\n> xrnn <- xrnn[,, 5:1]\n> xrnn <- aperm(xrnn , c(1, 3, 2))\n> dim(xrnn)\n[1] 6046 5 3\nWe have done this in four steps. The first simply extracts the n\u00d715 matrix\nof lagged versions of the three predictor variables from arframe. The second\nconverts this matrix to an n\u00d73\u00d75 array.We can do this by simply changing\nthe dimension attribute, since the new array is filled column wise. The third\nstep reverses the order of lagged variables, so that index 1 is furthest back\nin time, and index 5 closest. The final step rearranges the coordinates of\n10.9 Lab: Deep Learning 457\nthe array (like a partial transpose) into the format that the RNN module\nin keras expects.\nNow we are ready to proceed with the RNN, which uses 12 hidden units.\n> model <- keras_model_sequential () %>%\n+ layer_simple_rnn(units = 12,\ninput_shape = list(5, 3),\ndropout = 0.1, recurrent_dropout = 0.1) %>%\n+ layer_dense(units = 1)\n> model %>% compile(optimizer = optimizer_rmsprop (),\nloss = \"mse\")\nWe specify two forms of dropout for the units feeding into the hidden layer.\nThe first is for the", "doc_id": "c11d0396-18cf-4af9-a917-a264aa6df6fe", "embedding": null, "doc_hash": "a8416b849f159c3cbcc592215269a2366b837476c3d8d14f8da941dcb2b7b4e2", "extra_info": null, "node_info": {"start": 1035711, "end": 1038540, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "8c8957d2-2c18-4a02-baa8-a8935ea42182", "3": "b18860e3-544e-4388-8a7a-57c645aae78b"}}, "__type__": "1"}, "b18860e3-544e-4388-8a7a-57c645aae78b": {"__data__": {"text": "two forms of dropout for the units feeding into the hidden layer.\nThe first is for the input sequence feeding into this layer, and the second is\nfor the previous hidden units feeding into the layer. The output layer has\na single unit for the response.\nWe fit the model in a similar fashion to previous networks. We supply\nthe fit function with test data as validation data, so that when we monitor\nits progress and plot the history function we can see the progress on the\ntest data. Of course we should not use this as a basis for early stopping,\nsince then the test performance would be biased.\n> history <- model %>% fit(\nxrnn[istrain ,, ], arframe[istrain , \"log_volume\"],\nbatch_size = 64, epochs = 200,\nvalidation_data =\nlist(xrnn[!istrain ,, ], arframe[!istrain , \"log_volume\"])\n)\n> kpred <- predict(model, xrnn[!istrain ,, ])\n> 1 - mean (( kpred - arframe [! istrain , \"log_volume\"]) ^2) / V0\n[1] 0.416\nThis model takes about one minute to train.\nWe could replace the keras model sequential() command above with the\nfollowing command:\n> model <- keras_model_sequential () %>%\n+ layer_flatten(input_shape = c(5, 3)) %>%\n+ layer_dense(units = 1)\nHere, layer flatten() simply takes the input sequence and turns it into\na long vector of predictors. This results in a linear AR model. To fit a\nnonlinear AR model, we could add in a hidden layer.\nHowever, since we already have the matrix of lagged variables from the\nAR model that we fit earlier using the lm() command, we can actually fit\na nonlinear AR model without needing to perform flattening. We extract\nthe model matrix x from arframed, which includes the day of week variable.\n> x <- model.matrix(log_volume \u223c . - 1, data = arframed)\n> colnames(x)\n[1] \"dayfri\" \"daymon\" \"daythur\"\n[4] \"daytues\" \"daywed\" \"L1.DJ_return\"\n458 10. Deep Learning\n[7] \"L1.log_volume\" \"L1.log_volatility\" \"L2.DJ_return\"\n[10] \"L2.log_volume\" \"L2.log_volatility\" \"L3.DJ_return\"\n[13] \"L3.log_volume\" \"L3.log_volatility\" \"L4.DJ_return\"\n[16] \"L4.log_volume\" \"L4.log_volatility\" \"L5.DJ_return\"\n[19] \"L5.log_volume\" \"L5.log_volatility\"\nThe -1 in the formula avoids the creation of a column of ones for the intercept.\nThe variable day of week is a five-level factor (there are five trading\ndays), and the -1 results in five rather than four dummy variables.\nThe rest of the steps to fit a nonlinear AR model should by now be\nfamiliar.\n> arnnd <- keras_model_sequential () %>%\n+ layer_dense(units = 32, activation = \u2019relu \u2019,\ninput_shape = ncol(x)) %>%\n+ layer_dropout(rate = 0.5) %>%\n+ layer_dense(units = 1)\n> arnnd %>% compile(loss = \"mse\",\noptimizer = optimizer_rmsprop ())\n> history <- arnnd %>% fit(\nx[istrain , ], arframe[istrain , \"log_volume\"], epochs = 100,\nbatch_size = 32, validation_data =\nlist(x[!istrain , ], arframe [!istrain , \"log_volume\"])\n)\n> plot(history)\n> npred <- predict(arnnd , x[!istrain , ])\n> 1 - mean (( arframe [! istrain , \"log_volume\"] - npred)^2) / V0\n[1] 0.4698\n10.10 Exercises\nConceptual\n1. Consider a neural network with two", "doc_id": "b18860e3-544e-4388-8a7a-57c645aae78b", "embedding": null, "doc_hash": "a51ab9db21ca049fa7bb242dd80a4c706da8911e82fb4efcbe8bbed75d26929a", "extra_info": null, "node_info": {"start": 1038517, "end": 1041503, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "c11d0396-18cf-4af9-a917-a264aa6df6fe", "3": "37709af3-dd92-4d78-b156-a0766c989ea3"}}, "__type__": "1"}, "37709af3-dd92-4d78-b156-a0766c989ea3": {"__data__": {"text": "Exercises\nConceptual\n1. Consider a neural network with two hidden layers: p = 4 input units,\n2 units in the first hidden layer, 3 units in the second hidden layer,\nand a single output.\n(a) Draw a picture of the network, similar to Figures 10.1 or 10.4.\n(b) Write out an expression for f(X), assuming ReLU activation\nfunctions. Be as explicit as you can!\n(c) Now plug in some values for the coefficients and write out the\nvalue of f(X).\n(d) How many parameters are there?\n2. Consider the softmax function in (10.13) (see also (4.13) on page 141)\nfor modeling multinomial probabilities.\n(a) In (10.13), show that if we add a constant c to each of the z\u2113,\nthen the probability is unchanged.\n10.10 Exercises 459\n(b) In (4.13), show that if we add constants cj, j = 0, 1, . . . ,p, to\neach of the corresponding coefficients for each of the classes, then\nthe predictions at any new point x are unchanged.\nThis shows that the softmax function is over-parametrized. However, overregularization\nand SGD typically constrain the solutions so that this parametrized\nis not a problem.\n3. Show that the negative multinomial log-likelihood (10.14) is equivalent\nto the negative log of the likelihood expression (4.5) when there\nare M = 2 classes.\n4. Consider a CNN that takes in 32 \u00d7 32 grayscale images and has a\nsingle convolution layer with three 5 \u00d7 5 convolution filters (without\nboundary padding).\n(a) Draw a sketch of the input and first hidden layer similar to\nFigure 10.8.\n(b) How many parameters are in this model?\n(c) Explain how this model can be thought of as an ordinary feedforward\nneural network with the individual pixels as inputs, and\nwith constraints on the weights in the hidden units. What are\nthe constraints?\n(d) If there were no constraints, then how many weights would there\nbe in the ordinary feed-forward neural network in (c)?\n5. In Table 10.2 on page 433, we see that the ordering of the three\nmethods with respect to mean absolute error is different from the\nordering with respect to test set R2. How can this be?\nApplied\n6. Consider the simple function R(\u03b2) = sin(\u03b2) + \u03b2/10.\n(a) Draw a graph of this function over the range \u03b2 \u2208 [\u22126, 6].\n(b) What is the derivative of this function?\n(c) Given \u03b20 = 2.3, run gradient descent to find a local minimum\nof R(\u03b2) using a learning rate of \u03c1 = 0.1. Show each of \u03b20,\u03b21, . . .\nin your plot, as well as the final answer.\n(d) Repeat with \u03b20 = 1.4.\n7. Fit a neural network to the Default data. Use a single hidden layer\nwith 10 units, and dropout regularization. Have a look at Labs 10.9.1\u2013\n10.9.2 for guidance. Compare the classification performance of your\nmodel with that of linear logistic regression.\n460 10. Deep Learning\n8. From your collection of personal photographs, pick 10 images of animals\n(such as dogs, cats, birds, farm animals, etc.). If the subject\ndoes not occupy a reasonable part of the image, then crop the image.\nNow use a pretrained image classification CNN as in Lab 10.9.4 to\npredict the class of each of your images, and report the probabilities\nfor the top five predicted classes for each image.\n9. Fit a lag-5 autoregressive model to the NYSE data, as described in\nthe text and Lab 10.9.6. Refit the model with a 12-level factor representing\nthe month. Does this factor improve the performance of the\nmodel?\n10. In Section 10.9.6, we showed how to fit a linear AR model to the\nNYSE data using the lm() function. However, we also mentioned that\nwe can \u201cflatten\u201d the short sequences produced for the RNN model in\norder to fit a linear AR model. Use", "doc_id": "37709af3-dd92-4d78-b156-a0766c989ea3", "embedding": null, "doc_hash": "4819aa97b07264784968702b7dfcde09115a0b768056a27bc5ccf7e0b945f3e6", "extra_info": null, "node_info": {"start": 1041523, "end": 1045050, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "b18860e3-544e-4388-8a7a-57c645aae78b", "3": "3b2b7b59-b63c-4e3a-a486-c00047389367"}}, "__type__": "1"}, "3b2b7b59-b63c-4e3a-a486-c00047389367": {"__data__": {"text": "short sequences produced for the RNN model in\norder to fit a linear AR model. Use this latter approach to fit a linear\nAR model to the NYSE data. Compare the test R2 of this linear AR\nmodel to that of the linear AR model that we fit in the lab. What\nare the advantages/disadvantages of each approach?\n11. Repeat the previous exercise, but now fit a nonlinear AR model by\n\u201cflattening\u201d the short sequences produced for the RNN model.\n12. Consider the RNN fit to the NYSE data in Section 10.9.6. Modify the\ncode to allow inclusion of the variable day of week, and fit the RNN.\nCompute the test R2.\n13. Repeat the analysis of Lab 10.9.5 on the IMDb data using a similarly\nstructured neural network. There we used a dictionary of size 10,000.\nConsider the effects of varying the dictionary size. Try the values\n1000, 3000, 5000, and 10,000, and compare the results.\n11\nSurvival Analysis and Censored Data\nIn this chapter, we will consider the topics of survival analysis and censored\nsurvival\ndata. These arise in the analysis of a unique kind of outcome variable: the analysis\ncensored\ndata\ntime until an event occurs.\nFor example, suppose that we have conducted a five-year medical study,\nin which patients have been treated for cancer. We would like to fit a model\nto predict patient survival time, using features such as baseline health measurements\nor type of treatment. At first pass, this may sound like a regression\nproblem of the kind discussed in Chapter 3. But there is an important\ncomplication: hopefully some or many of the patients have survived until\nthe end of the study. Such a patient\u2019s survival time is said to be censored: we\nknow that it is at least five years, but we do not know its true value. We do\nnot want to discard this subset of surviving patients, as the fact that they\nsurvived at least five years amounts to valuable information. However, it is\nnot clear how to make use of this information using the techniques covered\nthus far in this textbook.\nThough the phrase \u201csurvival analysis\u201d evokes a medical study, the applications\nof survival analysis extend far beyond medicine. For example,\nconsider a company that wishes to model churn, the process by which customers\ncancel subscription to a service. The company might collect data on\ncustomers over some time period, in order to model each customer\u2019s time\nto cancellation as a function of demographics or other predictors. However,\npresumably not all customers will have canceled their subscription by the\nend of this time period; for such customers, the time to cancellation is\ncensored.\n\u00a9 Springer Science+Business Media, LLC, part of Springer Nature 2021\nG. James et al., An Introduction to Statistical Learning, Springer Texts in Statistics,\nhttps://doi.org/10.1007/978-1-0716-1418-1_11\n461\n462 11. Survival Analysis and Censored Data\nIn fact, survival analysis is relevant even in application areas that are\nunrelated to time. For instance, suppose we wish to model a person\u2019s weight\nas a function of some covariates, using a dataset with measurements for a\nlarge number of people. Unfortunately, the scale used to weigh those people\nis unable to report weights above a certain number. Then, any weights that\nexceed that number are censored. The survival analysis methods presented\nin this chapter could be used to analyze this dataset.\nSurvival analysis is a very well-studied topic within statistics, due to its\ncritical importance in a variety of applications, both in and out of medicine.\nHowever, it has received relatively little attention in the machine learning\ncommunity.\n11.1 Survival and Censoring Times\nFor each individual, we suppose that there is a true survival time, T, as well\nsurvival time\nas a true censoring time, C. (The survival time is also known as the failure\ncensoring\ntime or the event time.) The survival time represents the time at which the time\nfailure time\nevent time\nevent of interest", "doc_id": "3b2b7b59-b63c-4e3a-a486-c00047389367", "embedding": null, "doc_hash": "3028f2df0267d9191fbb38aca587072265179ef2f158b86a28b1a6a5343533c6", "extra_info": null, "node_info": {"start": 1045036, "end": 1048937, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "37709af3-dd92-4d78-b156-a0766c989ea3", "3": "30b79dd9-8ee4-4f30-9045-fda6ce7040e5"}}, "__type__": "1"}, "30b79dd9-8ee4-4f30-9045-fda6ce7040e5": {"__data__": {"text": "time represents the time at which the time\nfailure time\nevent time\nevent of interest occurs: for instance, the time at which the patient dies,\nor the customer cancels his or her subscription. By contrast, the censoring\ntime is the time at which censoring occurs: for example, the time at which\nthe patient drops out of the study or the study ends.\nWe observe either the survival time T or else the censoring time C.\nSpecifically, we observe the random variable\nY = min(T,C). (11.1)\nIn other words, if the event occurs before censoring (i.e. T < C) then we\nobserve the true survival time T; however, if censoring occurs before the\nevent (T >C) then we observe the censoring time.We also observe a status\nindicator,\n\u03b4 =\n=\n1 if T \u2264 C\n0 if T >C.\nThus, \u03b4 = 1 if we observe the true survival time, and \u03b4 = 0 if we instead\nobserve the censoring time.\nNow, suppose we observe n (Y, \u03b4) pairs, which we denote as (y1, \u03b41), . . . ,\n(yn, \u03b4n). Figure 11.1 displays an example from a (fictitious) medical study\nin which we observe n = 4 patients for a 365-day follow-up period. For\npatients 1 and 3, we observe the time to event (such as death or disease\nrelapse) T = ti. Patient 2 was alive when the study ended, and patient 4\ndropped out of the study, or was \u201clost to follow-up\u201d; for these patients we\nobserve C = ci. Therefore, y1 = t1, y3 = t3, y2 = c2, y4 = c4, \u03b41 = \u03b43 = 1,\nand \u03b42 = \u03b44 = 0.\n11.2 A Closer Look at Censoring 463\n0 100 200 300\n1 2 3 4\nTime in Days\nPatient\nFIGURE 11.1. Illustration of censored survival data. For patients 1 and 3, the\nevent was observed. Patient 2 was alive when the study ended. Patient 4 dropped\nout of the study.\n11.2 A Closer Look at Censoring\nIn order to analyze survival data, we need to make some assumptions about\nwhy censoring has occurred. For instance, suppose that a number of patients\ndrop out of a cancer study early because they are very sick. An analysis that\ndoes not take into consideration the reason why the patients dropped out\nwill likely overestimate the true average survival time. Similarly, suppose\nthat males who are very sick are more likely to drop out of the study than\nfemales who are very sick. Then a comparison of male and female survival\ntimes may wrongly suggest that males survive longer than females.\nIn general, we need to assume that the censoring mechanism is independent:\nconditional on the features, the event time T is independent of the\ncensoring time C. The two examples above violate the assumption of independent\ncensoring. Typically, it is not possible to determine from the data\nitself whether the censoring mechanism is independent. Instead, one has to\ncarefully consider the data collection process in order to determine whether\nindependent censoring is a reasonable assumption. In the remainder of this\nchapter, we will assume that the censoring mechanism is independent.1\nIn this chapter, we focus on right censoring, which occurs when T \u2265 Y ,\ni.e. the true event time T is at least as large as the observed time Y .\n(Notice that T \u2265 Y is a consequence of (11.1). Right censoring derives its\nname from the fact that time is typically displayed from left to right, as in\nFigure 11.1.) However, other types of censoring are possible. For instance,\nin left censoring, the true event time T is less than or equal to the observed\n1The assumption of independent censoring can be relaxed somewhat using the notion\nof non-informative censoring; however, the definition of non-informative censoring is too\ntechnical for this", "doc_id": "30b79dd9-8ee4-4f30-9045-fda6ce7040e5", "embedding": null, "doc_hash": "98126e95bcb66c056450fd6713518b8aa75c47d799b861476d8086394e6d7871", "extra_info": null, "node_info": {"start": 1048932, "end": 1052424, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "3b2b7b59-b63c-4e3a-a486-c00047389367", "3": "4c274c06-e3c0-4179-9e65-30dfa366065f"}}, "__type__": "1"}, "4c274c06-e3c0-4179-9e65-30dfa366065f": {"__data__": {"text": "however, the definition of non-informative censoring is too\ntechnical for this book.\n464 11. Survival Analysis and Censored Data\ntime Y . For example, in a study of pregnancy duration, suppose that we\nsurvey patients 250 days after conception, when some have already had\ntheir babies. Then we know that for those patients, pregnancy duration is\nless than 250 days. More generally, interval censoring refers to the setting\nin which we do not know the exact event time, but we know that it falls\nin some interval. For instance, this setting arises if we survey patients once\nper week in order to determine whether the event has occurred. While left\ncensoring and interval censoring can be accommodated using variants of\nthe ideas presented in this chapter, in what follows we focus specifically on\nright censoring.\n11.3 The Kaplan-Meier Survival Curve\nThe survival curve, or survival function, is defined as\nsurvival\ncurve\nsurvival\nfunction\nS(t) = Pr(T > t). (11.2)\nThis decreasing function quantifies the probability of surviving past time\nt. For example, suppose that a company is interested in modeling customer\nchurn. Let T represent the time that a customer cancels a subscription to\nthe company\u2019s service. Then S(t) represents the probability that a customer\ncancels later than time t. The larger the value of S(t), the less likely that\nthe customer will cancel before time t.\nIn this section, we will consider the task of estimating the survival\ncurve. Our investigation is motivated by the BrainCancer dataset, which\ncontains the survival times for patients with primary brain tumors undergoing\ntreatment with stereotactic radiation methods.2 The predictors\nare gtv (gross tumor volume, in cubic centimeters); sex (male or female);\ndiagnosis (meningioma, LG glioma, HG glioma, or other); loc (the tumor\nlocation: either infratentorial or supratentorial); ki (Karnofsky index); and\nstereo (stereotactic method: either stereotactic radiosurgery or fractionated\nstereotactic radiotherapy, abbreviated as SRS and SRT, respectively).\nOnly 53 of the 88 patients were still alive at the end of the study.\nNow, we consider the task of estimating the survival curve (11.2) for\nthese data. To estimate S(20) = Pr(T > 20), the probability that a patient\nsurvives for at least t = 20 months, it is tempting to simply compute the\nproportion of patients who are known to have survived past 20 months, i.e.\nthe proportion of patients for whom Y > 20. This turns out to be 48/88,\nor approximately 55%. However, this does not seem quite right, since Y\nand T represent different quantities. In particular, 17 of the 40 patients\n2This dataset is described in the following paper: Selingerov\u00b4a et al. (2016) Survival\nof patients with primary brain tumors: Comparison of two statistical approaches. PLoS\nOne, 11(2):e0148733.\n11.3 The Kaplan-Meier Survival Curve 465\nwho did not survive to 20 months were actually censored, and this analysis\nimplicitly assumes that T < 20 for all of those censored patients; of course,\nwe do not know whether that is true.\nAlternatively, to estimate S(20), we could consider computing the proportion\nof patients for whom Y >20, out of the 71 patients who were not\ncensored by time t = 20; this comes out to 48/71, or approximately 68%.\nHowever, this is not quite right either, since it amounts to completely ignoring\nthe patients who were censored before time t = 20, even though the\ntime at which they are censored is potentially informative. For instance, a\npatient who was censored at time t = 19.9 likely would have survived past\nt = 20 had he or she not been censored.\nWe have seen that estimating S(t) is complicated by the presence", "doc_id": "4c274c06-e3c0-4179-9e65-30dfa366065f", "embedding": null, "doc_hash": "2c0df146130d4bf951cb6798ec27ea689ee8ba3107bc69290391e95d8bf26a3b", "extra_info": null, "node_info": {"start": 1052429, "end": 1056085, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "30b79dd9-8ee4-4f30-9045-fda6ce7040e5", "3": "b1c3bcf2-903a-48f2-8837-d7d7b9992cf2"}}, "__type__": "1"}, "b1c3bcf2-903a-48f2-8837-d7d7b9992cf2": {"__data__": {"text": "have seen that estimating S(t) is complicated by the presence of\ncensoring. We now present an approach to overcome these challenges. We\nlet d1 < d2 < \u00b7 \u00b7 \u00b7 < dK denote the K unique death times among the noncensored\npatients, and we let qk denote the number of patients who died\nat time dk. For k = 1, . . . ,K, we let rk denote the number of patients alive\nand in the study just before dk; these are the at risk patients. The set of\npatients that are at risk at a given time are referred to as the risk set.\nrisk set\nBy the law of total probability,3\nPr(T > dk) =Pr(T > dk|T > dk\u22121) Pr(T > dk\u22121)\n+ Pr(T > dk|T \u2264 dk\u22121) Pr(T \u2264 dk\u22121).\nThe fact that dk\u22121 < dk implies that Pr(T > dk\n|T \u2264 dk\u22121) = 0 (it is\nimpossible for a patient to survive past time dk if he or she did not survive\nuntil an earlier time dk\u22121). Therefore,\nS(dk) = Pr(T > dk) = Pr(T > dk|T > dk\u22121) Pr(T > dk\u22121).\nPlugging in (11.2) again, we see that\nS(dk) = Pr(T > dk|T > dk\u22121)S(dk\u22121).\nThis implies that\nS(dk) = Pr(T > dk|T > dk\u22121)\u00d7\u00b7 \u00b7 \u00b7\u00d7Pr(T > d2 |T > d1 ) Pr(T > d1).\nWe now must simply plug in estimates of each of the terms on the righthand\nside of the previous equation. It is natural to use the estimator\n6Pr(T > dj |T > dj \u22121) = (rj \u2212 qj)/rj ,\nwhich is the fraction of the risk set at time dj who survived past time dj .\nThis leads to the Kaplan-Meier estimator of the survival curve:\nKaplan-\nMeier\n3The law of total probability states that for any two events A and B, Pr(A) = estimator\nPr(A|B) Pr(B) + Pr(A|Bc) Pr(Bc), where Bc is the complement of the event B, i.e. it\nis the event that B does not hold.\n466 11. Survival Analysis and Censored Data\n0 20 40 60 80\n0.0 0.2 0.4 0.6 0.8 1.0\nMonths\nEstimated Probability of Survival\nFIGURE 11.2. For the BrainCancer data, we display the Kaplan-Meier survival\ncurve (solid curve), along with standard error bands (dashed curves).\nWS(dk) =\nEk\nj=1\n*\nrj \u2212 qj\nrj\n+\n. (11.3)\nFor times t between dk and dk+1, we set WS(t) = WS(dk). Consequently, the\nKaplan-Meier survival curve has a step-like shape.\nThe Kaplan-Meier survival curve for the BrainCancer data is displayed\nin Figure 11.2. Each point in the solid step-like curve shows the estimated\nprobability of surviving past the time indicated on the horizontal axis. The\nestimated probability of survival past 20 months is 71%, which is quite a\nbit higher than the naive estimates of 55% and 68% presented earlier.\nThe sequential construction of the Kaplan-Meier estimator \u2014 starting\nat time zero and mapping out the observed events as they unfold in time \u2014\nis fundamental to many of the key techniques in survival analysis. These\ninclude the log-rank test of Section 11.4, and Cox\u2019s proportional hazard\nmodel of Section 11.5.2.\n11.4 The Log-Rank Test\nWe now continue our analysis of the BrainCancer data introduced in Section\n11.3. We wish to compare the survival of males to that of females.\nFigure 11.3 shows the Kaplan-Meier survival curves for the two groups.\nFemales seem to fare a little better up to about", "doc_id": "b1c3bcf2-903a-48f2-8837-d7d7b9992cf2", "embedding": null, "doc_hash": "664bc42875a9c101b3dd12df2b0bde350ed98b756bf220f0531aba5a60ccab0e", "extra_info": null, "node_info": {"start": 1056103, "end": 1059077, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "4c274c06-e3c0-4179-9e65-30dfa366065f", "3": "647ac531-c623-473b-a720-2856398b7779"}}, "__type__": "1"}, "647ac531-c623-473b-a720-2856398b7779": {"__data__": {"text": "for the two groups.\nFemales seem to fare a little better up to about 50 months, but then the\ntwo curves both level off to about 50%. How can we carry out a formal test\nof equality of the two survival curves?\nAt first glance, a two-sample t-test seems like an obvious choice: we could\ntest whether the mean survival time among the females equals the mean\n11.4 The Log-Rank Test 467\n0 20 40 60 80\n0.0 0.2 0.4 0.6 0.8 1.0\nMonths\nEstimated Probability of Survival\nFemale\nMale\nFIGURE 11.3. For the BrainCancer data, Kaplan-Meier survival curves for\nmales and females are displayed.\nGroup 1 Group 2 Total\nDied q1k q2k qk\nSurvived r1k \u2212 q1k r2k \u2212 q2k rk \u2212 qk\nTotal r1k r2k rk\nTABLE 11.1. Among the set of patients at risk at time dk, the number of patients\nwho died and survived in each of two groups is reported.\nsurvival time among the males. But the presence of censoring again creates\na complication. To overcome this challenge, we will conduct a log-rank test,4\nlog-rank test\nwhich examines how the events in each group unfold sequentially in time.\nRecall from Section 11.3 that d1 < d2 < \u00b7 \u00b7 \u00b7 < dK are the unique death\ntimes among the non-censored patients, rk is the number of patients at\nrisk at time dk, and qk is the number of patients who died at time dk. We\nfurther define r1k and r2k to be the number of patients in groups 1 and 2,\nrespectively, who are at risk at time dk. Similarly, we define q1k and q2k to\nbe the number of patients in groups 1 and 2, respectively, who died at time\ndk. Note that r1k + r2k = rk and q1k + q2k = qk.\nAt each death time dk, we construct a 2 \u00d7 2 table of counts of the form\nshown in Table 11.1. Note that if the death times are unique (i.e. no two\nindividuals die at the same time), then one of q1k and q2k equals one, and\nthe other equals zero.\nThe main idea behind the log-rank test statistic is as follows. In order\nto test H0 : E(X) = 0 for some random variable X, one approach is to\n4The log-rank test is also known as the Mantel-Haenszel test or Cochran-Mantel-\nHaenszel test.\n468 11. Survival Analysis and Censored Data\nconstruct a test statistic of the form\nW =\nX5\u2212 E(X)\nVar(X)\n, (11.4)\nwhere E(X) and Var(X) are the expectation and variance, respectively, of\nX under H0. In order to construct the log-rank test statistic, we compute\na quantity that takes exactly the form (11.4), with X =\n)K\nk=1 q1k, where\nq1k is given in the top left of Table 11.1.\nIn greater detail, under the null hypothesis of no difference in survival\nbetween the two groups, and conditioning on the row and column totals in\nTable 11.1, the expected value of q1k is\nE(q1k) =\nr1k\nrk\nqk. (11.5)\nFurthermore, it can be shown5 that the variance of q1k is\nVar (q1k) =\nqk(r1k/rk)(1 \u2212 r1k/rk)(rk \u2212 qk)\nrk \u2212 1\n. (11.6)\nThough q11, . . . , q1K may be correlated, we nonetheless estimate\nVar\n>\n0K\nk=1\nq1k\n?\n\u2248\n0K\nk=1\nVar (q1k) =\n0K\nk=1\nqk(r1k/rk)(1 \u2212 r1k/rk)(rk \u2212 qk)\nrk \u2212", "doc_id": "647ac531-c623-473b-a720-2856398b7779", "embedding": null, "doc_hash": "f70a7c51d2b74d7fe354debc9198aca8108bfcccb0be39e87d5c3b8e9710bfa7", "extra_info": null, "node_info": {"start": 1059074, "end": 1061957, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "b1c3bcf2-903a-48f2-8837-d7d7b9992cf2", "3": "fd9c03cc-c7ea-4945-8eed-785ed15a3711"}}, "__type__": "1"}, "fd9c03cc-c7ea-4945-8eed-785ed15a3711": {"__data__": {"text": "\u2212 r1k/rk)(rk \u2212 qk)\nrk \u2212 1\n.\n(11.7)\nTherefore, to compute the log-rank test statistic, we simply proceed as\nin (11.4), with X =\n)K\nk=1 q1k, making use of (11.5) and (11.7). That is, we\ncalculate\nW =\n)K\nk=1 (q1k \u2212 E(q1k)) G)K\nk=1 Var (q1k)\n=\n)K\nk=1\n1\nq1k \u2212 qk\nrk\nr1k\n2\nG)K\nk=1\nqk(r1k/rk)(1\u2212r1k/rk)(rk\u2212qk)\nrk\u22121\n. (11.8)\nWhen the sample size is large, the log-rank test statistic W has approximately\na standard normal distribution; this can be used to compute\na p-value for the null hypothesis that there is no difference between the\nsurvival curves in the two groups.6\nComparing the survival times of females and males on the BrainCancer\ndata gives a log-rank test statistic of W = 1.2, which corresponds to a twosided\np-value of 0.2 using the theoretical null distribution, and a p-value\nof 0.25 using the permutation null distribution with 1,000 permutations.\n5For details, see Exercise 7 at the end of this chapter.\n6Alternatively, we can estimate the p-value via permutations, using ideas that will\nbe presented in Section 13.5. The permutation distribution is obtained by randomly\nswapping the labels for the observations in the two groups.\n11.5 Regression Models With a Survival Response 469\nThus, we cannot reject the null hypothesis of no difference in survival curves\nbetween females and males.\nThe log-rank test is closely related to Cox\u2019s proportional hazards model,\nwhich we discuss in Section 11.5.2.\n11.5 Regression Models With a Survival Response\nWe now consider the task of fitting a regression model to survival data.\nAs in Section 11.1, the observations are of the form (Y, \u03b4), where Y =\nmin(T,C) is the (possibly censored) survival time, and \u03b4 is an indicator\nvariable that equals 1 if T \u2264 C. Furthermore, X \u2208 Rp is a vector of p\nfeatures. We wish to predict the true survival time T.\nSince the observed quantity Y is positive and may have a long right\ntail, we might be tempted to fit a linear regression of log(Y ) on X. But\nas the reader will surely guess, censoring again creates a problem since\nwe are actually interested in predicting T and not Y . To overcome this\ndifficulty, we instead make use of a sequential construction, similar to the\nconstructions of the Kaplan-Meier survival curve in Section 11.3 and the\nlog-rank test in Section 11.4.\n11.5.1 The Hazard Function\nThe hazard function or hazard rate \u2014 also known as the force of mortality\nhazard\n\u2014 is formally defined as function\nh(t) = lim\n\u0394t\u21920\nPr(t < T \u2264 t+\u0394t|T > t)\n\u0394t\n, (11.9)\nwhere T is the (unobserved) survival time. It is the death rate in the instant\nafter time t, given survival past that time.7 In (11.9), we take the limit as\n\u0394t approaches zero, so we can think of \u0394t as being an extremely tiny\nnumber. Thus, more informally, (11.9) implies that\nh(t) \u2248\nPr(t < T \u2264 t+\u0394t|T > t)\n\u0394t\nfor some arbitrarily small \u0394t.\nWhy should we care about the hazard function? First of all, it is closely\nrelated to the survival curve (11.2), as we will see next. Second, it turns out\n7Due to the \u0394t in the denominator of (11.9), the hazard function is a rate of", "doc_id": "fd9c03cc-c7ea-4945-8eed-785ed15a3711", "embedding": null, "doc_hash": "26150c3eb930bc1546de289623f43c214a47c42dc79d611a787b566b0b2a5796", "extra_info": null, "node_info": {"start": 1061995, "end": 1065029, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "647ac531-c623-473b-a720-2856398b7779", "3": "78e95bdf-6fac-43b1-8adf-7b7efcac6873"}}, "__type__": "1"}, "78e95bdf-6fac-43b1-8adf-7b7efcac6873": {"__data__": {"text": "in the denominator of (11.9), the hazard function is a rate of death,\nrather than a probability of death. However, higher values of h(t) directly correspond\nto a higher probability of death, just as higher values of a probability density function\ncorrespond to more likely outcomes for a random variable. In fact, h(t) is the probability\ndensity function for T conditional on T > t.\n470 11. Survival Analysis and Censored Data\nthat a key approach for modeling survival data as a function of covariates\nrelies heavily on the hazard function; we will introduce this approach \u2014\nCox\u2019s proportional hazards model \u2014 in Section 11.5.2.\nWe now consider the hazard function h(t) in a bit more detail. Recall\nthat for two events A and B, the probability of A given B can be expressed\nas Pr(A | B) = Pr(A \u2229 B)/ Pr(B), i.e. the probability that A and B both\noccur divided by the probability that B occurs. Furthermore, recall from\n(11.2) that S(t) = Pr(T > t). Thus,\nh(t) = lim\n\u0394t\u21920\nPr ((t < T \u2264 t+\u0394t) \u2229 (T > t)) /\u0394t\nPr(T > t)\n= lim\n\u0394t\u21920\nPr(t < T \u2264 t+\u0394t)/\u0394t\nPr(T > t)\n=\nf(t)\nS(t)\n, (11.10)\nwhere\nf(t) = lim\n\u0394t\u21920\nPr(t < T \u2264 t+\u0394t)\n\u0394t\n(11.11)\nis the probability density function associated with T, i.e. it is the instantaprobability\ndensity\nfunction\nneous rate of death at time t. The second equality in (11.10) made use of\nthe fact that if t < T \u2264 t+\u0394t, then it must be the case that T > t.\nEquation 11.10 implies a relationship between the hazard function h(t),\nthe survival function S(t), and the probability density function f(t). In\nfact, these are three equivalent ways8 of describing the distribution of T.\nThe likelihood associated with the ith observation is\nLi =\n=\nf(yi) if the ith observation is not censored\nS(yi) if the ith observation is censored\n= f(yi)\u03b4iS(yi)1\u2212\u03b4i . (11.12)\nThe intuition behind (11.12) is as follows: if Y = yi and the ith observation\nis not censored, then the likelihood is the probability of dying in a tiny interval\naround time yi. If the ith observation is censored, then the likelihood\nis the probability of surviving at least until time yi. Assuming that the n\nobservations are independent, the likelihood for the data takes the form\nL =\nEn\ni=1\nf(yi)\u03b4iS(yi)1\u2212\u03b4i =\nEn\ni=1\nh(yi)\u03b4iS(yi), (11.13)\nwhere the second equality follows from (11.10).\nWe now consider the task of modeling the survival times. If we assume exponential\nsurvival, i.e. that the probability density function of the survival\n8See Exercise 8.\n11.5 Regression Models With a Survival Response 471\ntime T takes the form f(t) = \u03bb exp(\u2212\u03bbt), then estimating the parameter \u03bb\nby maximizing the likelihood in (11.13) is straightforward.9 Alternatively,\nwe could assume that the survival times are drawn from a more flexible\nfamily of distributions, such as the Gamma or Weibull family. Another\npossibility is to model the survival times non-parametrically, as was done\nin Section 11.3 using the Kaplan-Meier estimator.\nHowever, what we would really like to do is model the survival time as\na function of the covariates. To do this, it is convenient to work directly\nwith the hazard function, instead of the", "doc_id": "78e95bdf-6fac-43b1-8adf-7b7efcac6873", "embedding": null, "doc_hash": "d7baf329b3cb73a149d6ca0330991aea8fc316e1f4260032c8275d528fe2ab8d", "extra_info": null, "node_info": {"start": 1064998, "end": 1068085, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "fd9c03cc-c7ea-4945-8eed-785ed15a3711", "3": "c9ca773d-9df5-4a37-9b18-377337502b0e"}}, "__type__": "1"}, "c9ca773d-9df5-4a37-9b18-377337502b0e": {"__data__": {"text": "do this, it is convenient to work directly\nwith the hazard function, instead of the probability density function.10\nOne possible approach is to assume a functional form for the hazard function\nh(t|xi), such as h(t|xi) = exp\n1\n\u03b20 +\n)p\nj=1 \u03b2jxij\n2\n, where the exponent\nfunction guarantees that the hazard function is non-negative. Note that\nthe exponential hazard function is special, in that it does not vary with\ntime.11 Given h(t|xi), we could calculate S(t|xi). Plugging these equations\ninto (11.13), we could then maximize the likelihood in order to estimate the\nparameter \u03b2 = (\u03b20,\u03b21, . . . ,\u03b2p)T . However, this approach is quite restrictive,\nin the sense that it requires us to make a very stringent assumption\non the form of the hazard function h(t|xi). In the next section, we will\nconsider a much more flexible approach.\n11.5.2 Proportional Hazards\nThe Proportional Hazards Assumption\nThe proportional hazards assumption states that\nproportional\nhazards\nassumption\nh(t|xi) = h0(t) exp\n\u239b\n\u239d\n0p\nj=1\nxij\u03b2j\n\u239e\n\u23a0, (11.14)\nwhere h0(t) \u2265 0 is an unspecified function, known as the baseline hazard. It\nbaseline\nis the hazard function for an individual with features xi1 = \u00b7 \u00b7 \u00b7 = xip = 0. hazard\nThe name \u201cproportional hazards\u201d arises from the fact that the hazard\nfunction for an individual with feature vector xi is some unknown function\nh0(t) times the factor exp\n1)p\nj=1 xij\u03b2j\n2\n. The quantity exp\n1)p\nj=1 xij\u03b2j\n2\nis called the relative risk for the feature vector xi = (xi1, . . . ,xip)T , relative\nto that for the feature vector xi = (0, . . . , 0)T .\n9See Exercise 9.\n10Given the close relationship between the hazard function h(t) and the density function\nf(t) explored in Exercise 8, posing an assumption about the form of the hazard\nfunction is closely related to posing an assumption about the form of the density function,\nas was done in the previous paragraph.\n11The notation h(t|xi) indicates that we are now considering the hazard function for\nthe ith observation conditional on the values of the covariates, xi.\n472 11. Survival Analysis and Censored Data\n0.5 1.0 1.5 2.0\n\u22123 \u22122 \u22121 0\nTime\nLog Hazard\n0.5 1.0 1.5 2.0\n0.0 0.2 0.4 0.6 0.8 1.0\nTime\nSurvival Probability\n0.5 1.0 1.5 2.0\n\u22124 \u22122 0 1 2\nTime\nLog Hazard\n0.5 1.0 1.5 2.0\n0.0 0.2 0.4 0.6 0.8 1.0\nTime\nSurvival Probability\nFIGURE 11.4. Top: In a simple example with p = 1 and a binary covariate\nxi \u2208 {0, 1}, the log hazard and the survival function under the model (11.14)\nare shown (green for xi = 0 and black for xi = 1). Because of the proportional\nhazards assumption (11.14), the log hazard functions differ by a constant, and the\nsurvival functions do not cross. Bottom: Again we have a single binary covariate\nxi \u2208 {0, 1}. However, the proportional hazards assumption (11.14) does not hold.\nThe log hazard functions cross, as do the survival functions.\nWhat does it mean that the baseline hazard function h0(t) in (11.14) is\nunspecified? Basically, we make no assumptions about its functional form.\nWe allow the instantaneous probability of death at time t, given that one\nhas survived at least until time t, to take any form. This means that the\nhazard function is", "doc_id": "c9ca773d-9df5-4a37-9b18-377337502b0e", "embedding": null, "doc_hash": "dbe95eb0f44b865021d3a5e52dadcc714ae2421bdafc17a6dbb89c1ad74a45da", "extra_info": null, "node_info": {"start": 1068067, "end": 1071204, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "78e95bdf-6fac-43b1-8adf-7b7efcac6873", "3": "025227a1-94de-48fa-a762-a01f9ce77a93"}}, "__type__": "1"}, "025227a1-94de-48fa-a762-a01f9ce77a93": {"__data__": {"text": "least until time t, to take any form. This means that the\nhazard function is very flexible and can model a wide range of relationships\nbetween the covariates and survival time. Our only assumption is that a\none-unit increase in xij corresponds to an increase in h(t|xi) by a factor of\nexp(\u03b2j ).\nAn illustration of the proportional hazards assumption (11.14) is given in\nFigure 11.4, in a simple setting with a single binary covariate xi \u2208 {0, 1} (so\nthat p = 1). In the top row, the proportional hazards assumption (11.14)\nholds. Thus, the hazard functions of the two groups are a constant multiple\nof each other, so that on the log scale, the gap between them is constant.\nFurthermore, the survival curves never cross, and in fact the gap between\nthe survival curves tends to (initially) increase over time. By contrast, in\nthe bottom row, (11.14) does not hold.We see that the log hazard functions\nfor the two groups cross, as do the survival curves.\n11.5 Regression Models With a Survival Response 473\nCox\u2019s Proportional Hazards Model\nBecause the form of h0(t) in the proportional hazards assumption (11.14)\nis unknown, we cannot simply plug h(t|xi) into the likelihood (11.13) and\nthen estimate \u03b2 = (\u03b21, . . . ,\u03b2p)T by maximum likelihood. The magic of\nCox\u2019s proportional hazards model lies in the fact that it is in fact possible\nCox\u2019s\nproportional\nhazards\nmodel\nto estimate \u03b2 without having to specify the form of h0(t).\nTo accomplish this, we make use of the same \u201csequential in time\u201d logic\nthat we used to derive the Kaplan-Meier survival curve and the log-rank\ntest. For simplicity, assume that there are no ties among the failure, or\ndeath, times: i.e. each failure occurs at a distinct time. Assume that \u03b4i =\n1, i.e. the ith observation is uncensored, and thus yi is its failure time.\nThen the hazard function for the ith observation at time yi is h(yi|xi) =\nh0(yi) exp\n1)p\nj=1 xij\u03b2j\n2\n, and the total hazard at time yi for the at risk\nobservations12 is\n0\ni\u2032:yi\u2032\u2265yi\nh0(yi) exp\n\u239b\n\u239d\n0p\nj=1\nxi\u2032j\u03b2j\n\u239e\n\u23a0.\nTherefore, the probability that the ith observation is the one to fail at time\nyi (as opposed to one of the other observations in the risk set) is\nh0(yi) exp\n1)p\nj=1 xij\u03b2j\n2\n)\ni\u2032:yi\u2032\u2265yi h0(yi) exp\n1)p\nj=1 xi\u2032j\u03b2j\n2 =\nexp\n1)p\nj=1 xij\u03b2j\n2\n)\ni\u2032:yi\u2032\u2265yi exp\n1)p\nj=1 xi\u2032j\u03b2j\n2.\n(11.15)\nNotice that the unspecified baseline hazard function h0(yi) cancels out of\nthe numerator and denominator!\nThe partial likelihood is simply the product of these probabilities over all\npartial\nof the uncensored observations, likelihood\nPL(\u03b2) =\nE\ni:\u03b4i=1\nexp\n1)p\nj=1 xij\u03b2j\n2\n)\ni\u2032:yi\u2032\u2265yi exp\n1)p\nj=1 xi\u2032j\u03b2j\n2. (11.16)\nCritically, the partial likelihood is valid regardless of the true value of h0(t),\nmaking the model very flexible and robust.13\nTo estimate \u03b2, we simply maximize the partial likelihood (11.16) with\nrespect to \u03b2. As was the case for logistic regression in Chapter 4, no closedform\nsolution is available, and so iterative", "doc_id": "025227a1-94de-48fa-a762-a01f9ce77a93", "embedding": null, "doc_hash": "e476b6f7a45ab863c80cc514074475f7bd7a2733df7efb74cd4529e2694380e7", "extra_info": null, "node_info": {"start": 1071212, "end": 1074132, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "c9ca773d-9df5-4a37-9b18-377337502b0e", "3": "85de1bb9-1add-4fe9-9f4c-4b8a02b3ed8b"}}, "__type__": "1"}, "85de1bb9-1add-4fe9-9f4c-4b8a02b3ed8b": {"__data__": {"text": "regression in Chapter 4, no closedform\nsolution is available, and so iterative algorithms are required.\n12Recall that the \u201cat risk\u201d observations at time yi are those that are still at risk of\nfailure, i.e. those that have not yet failed or been censored before time yi.\n13In general, the partial likelihood is used in settings where it is difficult to compute\nthe full likelihood for all of the parameters. Instead, we compute a likelihood for just the\nparameters of primary interest: in this case, \u03b21, . . . ,\u03b2p. It can be shown that maximizing\n(11.16) provides good estimates for these parameters.\n474 11. Survival Analysis and Censored Data\nIn addition to estimating \u03b2, we can also obtain other model outputs that\nwe saw in the context of least squares regression in Chapter 3 and logistic\nregression in Chapter 4. For example, we can obtain p-values corresponding\nto particular null hypotheses (e.g. H0 : \u03b2j = 0), as well as confidence\nintervals associated with the coefficients.\nConnection With The Log-Rank Test\nSuppose we have just a single predictor (p = 1), which we assume to be\nbinary, i.e. xi \u2208 {0, 1}. In order to determine whether there is a difference\nbetween the survival times of the observations in the group {i : xi = 0} and those in the group {i : xi = 1}, we can consider taking two possible\napproaches:\nApproach #1: Fit a Cox proportional hazards model, and test the\nnull hypothesis H0 : \u03b2 = 0. (Since p = 1, \u03b2 is a scalar.)\nApproach #2: Perform a log-rank test to compare the two groups, as\nin Section 11.4.\nWhich one should we prefer?\nIn fact, there is a close relationship between these two approaches. In\nparticular, when taking Approach #1, there are a number of possible ways\nto test H0. One way is known as a score test. It turns out that in the case of\na single binary covariate, the score test for H0 : \u03b2 = 0 in Cox\u2019s proportional\nhazards model is exactly equal to the log-rank test. In other words, it does\nnot matter whether we take Approach #1 or Approach #2!\nAdditional Details\nThe discussion of Cox\u2019s proportional hazards model glossed over a few\nsubtleties:\n\u2022 There is no intercept in (11.14) and in the equations that follow,\nbecause an intercept can be absorbed into the baseline hazard h0(t).\n\u2022 We have assumed that there are no tied failure times. In the case\nof ties, the exact form of the partial likelihood (11.16) is a bit more\ncomplicated, and a number of computational approximations must\nbe used.\n\u2022 (11.16) is known as the partial likelihood because it is not exactly a\nlikelihood. That is, it does not correspond exactly to the probability\nof the data under the assumption (11.14). However, it is a very good\napproximation.\n\u2022 We have focused only on estimation of the coefficients \u03b2 = (\u03b21, . . . ,\u03b2p)T .\nHowever, at times we may also wish to estimate the baseline hazard\n11.5 Regression Models With a Survival Response 475\nh0(t), for instance so that we can estimate the survival curve S(t|x)\nfor an individual with feature vector x. The details are beyond the\nscope of this book. Estimation of h0(t) is implemented in the survival\npackage in R.\n11.5.3 Example: Brain Cancer Data\nTable 11.2 shows the result of fitting the proportional hazards model to\nthe BrainCancer data, which was originally described in Section 11.3. The\ncoefficient column displays \u02c6 \u03b2j . The results indicate, for instance, that the\nestimated hazard for a male patient is e0.18 = 1.2 times greater than for\na female patient: in other words, with all other features held fixed, males\nhave a 1.2 times greater chance of dying than", "doc_id": "85de1bb9-1add-4fe9-9f4c-4b8a02b3ed8b", "embedding": null, "doc_hash": "3282b9f9f85e4ee3601611aa129dd6b23b0c9477b08d98b6f51a3568668034ea", "extra_info": null, "node_info": {"start": 1074128, "end": 1077679, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "025227a1-94de-48fa-a762-a01f9ce77a93", "3": "1db1e1bb-bca2-4dcd-86a9-86c0e39b6245"}}, "__type__": "1"}, "1db1e1bb-bca2-4dcd-86a9-86c0e39b6245": {"__data__": {"text": "features held fixed, males\nhave a 1.2 times greater chance of dying than females, at any point in time.\nHowever, the p-value is 0.61, which indicates that this difference between\nmales and females is not significant.\nAs another example, we also see that each one-unit increase in the\nKarnofsky index corresponds to a multiplier of exp(\u22120.05) = 0.95 in the\ninstantaneous chance of dying. In other words, the higher the Karnofsky\nindex, the lower the chance of dying at any given point in time. This effect\nis highly significant, with a p-value of 0.0027.\nCoefficient Std. error z-statistic p-value\nsex[Male] 0.18 0.36 0.51 0.61\ndiagnosis[LG Glioma] 0.92 0.64 1.43 0.15\ndiagnosis[HG Glioma] 2.15 0.45 4.78 0.00\ndiagnosis[Other] 0.89 0.66 1.35 0.18\nloc[Supratentorial] 0.44 0.70 0.63 0.53\nki -0.05 0.02 -3.00 <0.01\ngtv 0.03 0.02 1.54 0.12\nstereo[SRT] 0.18 0.60 0.30 0.77\nTABLE 11.2. Results for Cox\u2019s proportional hazards model fit to the\nBrainCancer data, which was first described in Section 11.3. The variable\ndiagnosis is qualitative with four levels: meningioma, LG glioma, HG glioma,\nor other. The variables sex, loc, and stereo are binary.\n11.5.4 Example: Publication Data\nNext, we consider the dataset Publication involving the time to publication\nof journal papers reporting the results of clinical trials funded by the\nNational Heart, Lung, and Blood Institute.14 For 244 trials, the time in\n14This dataset is described in the following paper: Gordon et al. (2013) Publication of\ntrials funded by the National Heart, Lung, and Blood Institute. New England Journal\nof Medicine, 369(20):1926\u20131934.\n476 11. Survival Analysis and Censored Data\n0 20 40 60 80 100 120\n0.0 0.2 0.4 0.6 0.8 1.0\nMonths\nProbability of Not Being Published\nNegative Result\nPositive Result\nFIGURE 11.5. Survival curves for time until publication for the Publication\ndata described in Section 11.5.4, stratified by whether or not the study produced\na positive result.\nmonths until publication is recorded. Of the 244 trials, only 156 were published\nduring the study period; the remaining studies were censored. The\ncovariates include whether the trial focused on a clinical endpoint (clinend),\nwhether the trial involved multiple centers (multi), the funding mechanism\nwithin the National Institutes of Health (mech), trial sample size (sampsize),\nbudget (budget), impact (impact, related to the number of citations), and\nwhether the trial produced a positive (significant) result (posres). The last\ncovariate is particularly interesting, as a number of studies have suggested\nthat positive trials have a higher publication rate.\nFigure 11.5 shows the Kaplan-Meier curves for the time until publication,\nstratified by whether or not the study produced a positive result. We see\nslight evidence that time until publication is lower for studies with a positive\nresult. However, the log-rank test yields a very unimpressive p-value of 0.36.\nWe now consider a more careful analysis that makes use of all of the\navailable predictors. The results of fitting Cox\u2019s proportional hazards model\nusing all of the available features are shown in Table 11.3. We find that the\nchance of publication of a study with a positive result is e0.55 = 1.74 times\nhigher than the chance of publication of a study with a negative result\nat any point in time, holding all other covariates fixed. The very small\np-value associated with posres in Table 11.3 indicates that this result is\nhighly significant. This is striking, especially in light of our earlier finding\nthat a", "doc_id": "1db1e1bb-bca2-4dcd-86a9-86c0e39b6245", "embedding": null, "doc_hash": "6ad6b61a87191bfbd0f582a66e9861485bef425876e55e2910916a40ab5a7532", "extra_info": null, "node_info": {"start": 1077687, "end": 1081211, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "85de1bb9-1add-4fe9-9f4c-4b8a02b3ed8b", "3": "b7933e28-cebb-4152-b3fc-5d1a27bfb448"}}, "__type__": "1"}, "b7933e28-cebb-4152-b3fc-5d1a27bfb448": {"__data__": {"text": "significant. This is striking, especially in light of our earlier finding\nthat a log-rank test comparing time to publication for studies with positive\nversus negative results yielded a p-value of 0.36. How can we explain this\ndiscrepancy? The answer stems from the fact that the log-rank test did not\nconsider any other covariates, whereas the results in Table 11.3 are based\non a Cox model using all of the available covariates. In other words, after\nwe adjust for all of the other covariates, then whether or not the study\nyielded a positive result is highly predictive of the time to publication.\n11.5 Regression Models With a Survival Response 477\nCoefficient Std. error z-statistic p-value\nposres[Yes] 0.55 0.18 3.02 0.00\nmulti[Yes] 0.15 0.31 0.47 0.64\nclinend[Yes] 0.51 0.27 1.89 0.06\nmech[K01] 1.05 1.06 1.00 0.32\nmech[K23] -0.48 1.05 -0.45 0.65\nmech[P01] -0.31 0.78 -0.40 0.69\nmech[P50] 0.60 1.06 0.57 0.57\nmech[R01] 0.10 0.32 0.30 0.76\nmech[R18] 1.05 1.05 0.99 0.32\nmech[R21] -0.05 1.06 -0.04 0.97\nmech[R24,K24] 0.81 1.05 0.77 0.44\nmech[R42] -14.78 3414.38 -0.00 1.00\nmech[R44] -0.57 0.77 -0.73 0.46\nmech[RC2] -14.92 2243.60 -0.01 0.99\nmech[U01] -0.22 0.32 -0.70 0.48\nmech[U54] 0.47 1.07 0.44 0.66\nsampsize 0.00 0.00 0.19 0.85\nbudget 0.00 0.00 1.67 0.09\nimpact 0.06 0.01 8.23 0.00\nTABLE 11.3. Results for Cox\u2019s proportional hazards model fit to the\nPublication data, using all of the available features. The features posres, multi,\nand clinend are binary. The feature mech is qualitative with 14 levels; it is coded\nso that the baseline level is Contract.\nIn order to gain more insight into this result, in Figure 11.6 we display\nestimates of the survival curves associated with positive and negative results,\nadjusting for the other predictors. To produce these survival curves,\nwe estimated the underlying baseline hazard h0(t): this is implemented in\nthe survival package in R, although the details are beyond the scope of this\nbook. We also needed to select representative values for the other predictors;\nwe used the mean value for each predictor, except for the categorical\npredictor mech, for which we used the most prevalent category (R01). Adjusting\nfor the other predictors, we now see a clear difference in the survival\ncurves between studies with positive versus negative results.\nOther interesting insights can be gleaned from Table 11.3. For example,\nstudies with a clinical endpoint are more likely to be published at any\ngiven point in time than those with a non-clinical endpoint. The funding\nmechanism did not appear to be significantly associated with time until\npublication.\n478 11. Survival Analysis and Censored Data\n0 20 40 60 80 100 120\n0.0 0.2 0.4 0.6 0.8 1.0\nMonths\nProbability of Not Being Published\nNegative Result\nPositive Result\nFIGURE 11.6. For the Publication data, we display survival curves for time\nuntil publication, stratified by whether or not the study produced a positive result,\nafter adjusting for all other covariates.\n11.6 Shrinkage for the Cox Model\nIn this section, we illustrate that the shrinkage methods of Section 6.2\ncan", "doc_id": "b7933e28-cebb-4152-b3fc-5d1a27bfb448", "embedding": null, "doc_hash": "a5de456bb8d7c508f5bafc406eea0c4795c2777fa0dc40e275468cf41fef965b", "extra_info": null, "node_info": {"start": 1081204, "end": 1084284, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "1db1e1bb-bca2-4dcd-86a9-86c0e39b6245", "3": "f21cd616-6c28-4c77-8d53-99708b56184a"}}, "__type__": "1"}, "f21cd616-6c28-4c77-8d53-99708b56184a": {"__data__": {"text": "section, we illustrate that the shrinkage methods of Section 6.2\ncan be applied to the survival data setting. In particular, motivated by\nthe \u201closs+penalty\u201d formulation of Section 6.2, we consider minimizing a\npenalized version of the negative log partial likelihood in (11.16),\n\u2212log\n\u239b\n\u239d\nE\ni:\u03b4i=1\nexp\n1)p\nj=1 xij\u03b2j\n2\n)\ni\u2032:yi\u2032\u2265yi exp\n1)p\nj=1 xi\u2032j\u03b2j\n2\n\u239e\n\u23a0 + \u03bbP(\u03b2), (11.17)\nwith respect to \u03b2 = (\u03b21, . . . ,\u03b2p)T . We might take P(\u03b2) =\n)p\nj=1 \u03b22\nj , which\ncorresponds to a ridge penalty, or P(\u03b2) =\n)p\nj=1 |\u03b2j |, which corresponds to\na lasso penalty.\nIn (11.17), \u03bb is a non-negative tuning parameter; typically we will minimize\nit over a range of values of \u03bb. When \u03bb = 0, then minimizing (11.17) is\nequivalent to simply maximizing the usual Cox partial likelihood (11.16).\nHowever, when \u03bb > 0, then minimizing (11.17) yields a shrunken version of\nthe coefficient estimates. When \u03bb is large, then using a ridge penalty will\ngive small coefficients that are not exactly equal to zero. By contrast, for a\nsufficiently large value of \u03bb, using a lasso penalty will give some coefficients\nthat are exactly equal to zero.\nWe now apply the lasso-penalized Cox model to the Publication data, described\nin Section 11.5.4.We first randomly split the 244 trials into equallysized\ntraining and test sets. The cross-validation results from the training\nset are shown in Figure 11.7. The \u201cpartial likelihood deviance\u201d, shown on\nthe y-axis, is twice the cross-validated negative log partial likelihood; it\n11.6 Shrinkage for the Cox Model 479\n2e\u221204 5e\u221204 1e\u221203 2e\u221203 5e\u221203 1e\u221202 2e\u221202 5e\u221202 1e\u221201 2e\u221201\n9.0 9.1 9.2 9.3 9.4 9.5 9.6 9.7\nPartial Likelihood Deviance\n\u2225 \u02c6 \u03b2L\n\u03bb \u22251\n!\n| \u02c6 \u03b2\u22251\nFIGURE 11.7. For the Publication data described in Section 11.5.4, cross-validation\nresults for the lasso-penalized Cox model are shown. The y-axis displays\nthe partial likelihood deviance, which plays the role of the cross-validation error.\nThe x-axis displays the \u21131 norm (that is, the sum of the absolute values) of the\ncoefficients of the lasso-penalized Cox model with tuning parameter \u03bb, divided by\nthe \u21131 norm of the coefficients of the unpenalized Cox model. The dashed line\nindicates the minimum cross-validation error.\nplays the role of the cross-validation error.15 Note the \u201cU-shape\u201d of the\npartial likelihood deviance: just as we saw in previous chapters, the crossvalidation\nerror is minimized for an intermediate level of model complexity.\nSpecifically, this occurs when just two predictors, budget and impact, have\nnon-zero estimated coefficients.\nNow, how do we apply this model to the test set? This brings up an\nimportant conceptual point: in essence, there is no simple way to compare\npredicted survival times and true survival times on the test set. The first\nproblem is that some of the observations are censored, and so the true survival\ntimes for those observations are unobserved. The second issue arises\nfrom the fact that in the Cox model, rather than predicting a single survival\ntime given a covariate vector x, we instead estimate an entire survival\ncurve, S(t|x), as a function of t.\nTherefore, to assess the model fit, we must take a different approach,\nwhich", "doc_id": "f21cd616-6c28-4c77-8d53-99708b56184a", "embedding": null, "doc_hash": "f897a06452e0057b463b95e8301e659b72e21787a099670463b1c1b6e269ee8c", "extra_info": null, "node_info": {"start": 1084295, "end": 1087449, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "b7933e28-cebb-4152-b3fc-5d1a27bfb448", "3": "5c789962-3d32-448b-82f0-3a27a51d5f7a"}}, "__type__": "1"}, "5c789962-3d32-448b-82f0-3a27a51d5f7a": {"__data__": {"text": "to assess the model fit, we must take a different approach,\nwhich involves stratifying the observations using the coefficient estimates.\nIn particular, for each test observation, we compute the \u201crisk\u201d score\nbudgeti \u00b7 \u02c6 \u03b2budget + impacti \u00b7 \u02c6 \u03b2impact,\nwhere \u02c6 \u03b2budget and \u02c6 \u03b2impact are the coefficient estimates for these two features\nfrom the training set. We then use these risk scores to categorize the observations\nbased on their \u201crisk\u201d. For instance, the high risk group consists of\n15Cross-validation for the Cox model is more involved than for linear or logistic regression,\nbecause the objective function is not a sum over the observations.\n480 11. Survival Analysis and Censored Data\n0 20 40 60 80 100 120\n0.0 0.2 0.4 0.6 0.8 1.0\nMonths\nProbability of Not Being Published\nLow Risk\nMedium Risk\nHigh Risk\nFIGURE 11.8. For the Publication data introduced in Section 11.5.4, we compute\ntertiles of \u201crisk\u201d in the test set using coefficients estimated on the training\nset. There is clear separation between the resulting survival curves.\nthe observations for which budgeti \u00b7 \u02c6 \u03b2budget +impacti \u00b7 \u02c6 \u03b2impact is largest; by\n(11.14), we see that these are the observations for which the instantaneous\nprobability of being published at any moment in time is largest. In other\nwords, the high risk group consists of the trials that are likely to be published\nsooner. On the Publication data, we stratify the observations into\ntertiles of low, medium, and high risk. The resulting survival curves for\neach of the three strata are displayed in Figure 11.8. We see that there is\nclear separation between the three strata, and that the strata are correctly\nordered in terms of low, medium, and high risk of publication.\n11.7 Additional Topics\n11.7.1 Area Under the Curve for Survival Analysis\nIn Chapter 4, we introduced the area under the ROC curve\u2014often referred\nto as the \u201cAUC\u201d\u2014as a way to quantify the performance of a two-class classifier.\nDefine the score for the ith observation to be the classifier\u2019s estimate\nof Pr(Y = 1|X = xi). It turns out that if we consider all pairs consisting of\none observation in Class 1 and one observation in Class 2, then the AUC\nis the fraction of pairs for which the score for the observation in Class 1\nexceeds the score for the observation in Class 2.\nThis suggests a way to generalize the notion of AUC to survival analysis.\nWe calculate an estimated risk score, \u02c6\u03b7i = \u02c6 \u03b21xi1 + \u00b7 \u00b7 \u00b7 + \u02c6 \u03b2pxip, for\ni = 1, . . . ,n, using the Cox model coefficients. If \u02c6\u03b7i\u2032 > \u02c6\u03b7i, then the model\npredicts that the i\u2032th observation has a larger hazard than the ith observation,\nand thus that the survival time ti will be greater than ti\u2032 . Thus, it\nis tempting to try to generalize AUC by computing the proportion of ob11.7\nAdditional Topics 481\nservations for which ti > ti\u2032 and \u02c6\u03b7i\u2032 > \u02c6\u03b7i. However, things are not quite so\neasy, because recall that we do not observe t1, . . . , tn; instead, we observe\nthe (possibly-censored) times y1, . . . , yn, as well as the censoring indicators\n\u03b41, . . . , \u03b4n.\nTherefore, Harrell\u2019s concordance index (or C-index ) computes the pro-\nHarrell\u2019s\nconcordance\nindex\nportion of observation pairs for which \u02c6\u03b7i\u2032 > \u02c6\u03b7i and yi > yi\u2032 :\nC =\n)\ni,i\u2032:yi>yi\u2032\nI(\u02c6\u03b7i\u2032 > \u02c6\u03b7i)\u03b4 )", "doc_id": "5c789962-3d32-448b-82f0-3a27a51d5f7a", "embedding": null, "doc_hash": "173021fe82cfd805c3d22ed428d00dde4a75cceb36e1213d862187bb4e88d77c", "extra_info": null, "node_info": {"start": 1087454, "end": 1090673, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "f21cd616-6c28-4c77-8d53-99708b56184a", "3": "6069de7a-f371-4112-ba0e-3ff092ef1557"}}, "__type__": "1"}, "6069de7a-f371-4112-ba0e-3ff092ef1557": {"__data__": {"text": "> \u02c6\u03b7i)\u03b4 ) i\u2032\ni,i\u2032:yi>yi\u2032\n\u03b4i\u2032\n,\nwhere the indicator variable I(\u02c6\u03b7i\u2032 > \u02c6\u03b7i) equals one if \u02c6\u03b7i\u2032 > \u02c6\u03b7i, and equals\nzero otherwise. The numerator and denominator are multiplied by the status\nindicator \u03b4i\u2032 , since if the i\u2032th observation is uncensored (i.e. if \u03b4i\u2032 = 1),\nthen yi > yi\u2032 implies that ti > ti\u2032 . By contrast, if \u03b4i\u2032 = 0, then yi > yi\u2032 does\nnot imply that ti > ti\u2032 .\nWe fit a Cox proportional hazards model on the training set of the\nPublication data, and computed the C-index on the test set. This yielded\nC = 0.733. Roughly speaking, given two random papers from the test set,\nthe model can predict with 73.3% accuracy which will be published first.\n11.7.2 Choice of Time Scale\nIn the examples considered thus far in this chapter, it has been fairly clear\nhow to define time. For example, in the Publication example, time zero for\neach paper was defined to be the calendar time at the end of the study,\nand the failure time was defined to be the number of months that elapsed\nfrom the end of the study until the paper was published.\nHowever, in other settings, the definitions of time zero and failure time\nmay be more subtle. For example, when examining the association between\nrisk factors and disease occurrence in an epidemiological study, one might\nuse the patient\u2019s age to define time, so that time zero is the patient\u2019s date\nof birth. With this choice, the association between age and survival cannot\nbe measured; however, there is no need to adjust for age in the analysis.\nWhen examining covariates associated with disease-free survival (i.e. the\namount of time elapsed between treatment and disease recurrence), one\nmight use the date of treatment as time zero.\n11.7.3 Time-Dependent Covariates\nA powerful feature of the proportional hazards model is its ability to handle\ntime-dependent covariates, predictors whose value may change over time.\nFor example, suppose we measure a patient\u2019s blood pressure every week\nover the course of a medical study. In this case, we can think of the blood\npressure for the ith observation not as xi, but rather as xi(t) at time t.\n482 11. Survival Analysis and Censored Data\nBecause the partial likelihood in (11.16) is constructed sequentially in\ntime, dealing with time-dependent covariates is straightforward. In particular,\nwe simply replace xij and xi\u2032j in (11.16) with xij(yi) and xi\u2032j(yi),\nrespectively; these are the current values of the predictors at time yi. By\ncontrast, time-dependent covariates would pose a much greater challenge\nwithin the context of a traditional parametric approach, such as (11.13).\nOne example of time-dependent covariates appears in the analysis of data\nfrom the Stanford Heart Transplant Program. Patients in need of a heart\ntransplant were put on a waiting list. Some patients received a transplant,\nbut others died while still on the waiting list. The primary objective of the\nanalysis was to determine whether a transplant was associated with longer\npatient survival.\nA na\u00a8\u0131ve approach would use a fixed covariate to represent transplant\nstatus: that is, xi = 1 if the ith patient ever received a transplant, and xi =\n0 otherwise. But this approach overlooks the fact that patients had to live\nlong enough to get a transplant, and hence, on average, healthier patients\nreceived transplants. This problem can be solved by using a time-dependent\ncovariate for transplant: xi(t) = 1 if the patient received a transplant by\ntime t, and xi(t) = 0 otherwise.\n11.7.4 Checking the Proportional Hazards Assumption\nWe have seen that Cox\u2019s proportional hazards model relies on", "doc_id": "6069de7a-f371-4112-ba0e-3ff092ef1557", "embedding": null, "doc_hash": "1fbf4cd62f07754a639487f6e2e9db112ab0c3972244a45ef431c2e6a319d6ef", "extra_info": null, "node_info": {"start": 1090722, "end": 1094282, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "5c789962-3d32-448b-82f0-3a27a51d5f7a", "3": "c838a348-c060-4fde-aa7f-3d163561eeaa"}}, "__type__": "1"}, "c838a348-c060-4fde-aa7f-3d163561eeaa": {"__data__": {"text": "have seen that Cox\u2019s proportional hazards model relies on the proportional\nhazards assumption (11.14). While results from the Cox model tend\nto be fairly robust to violations of this assumption, it is still a good idea to\ncheck whether it holds. In the case of a qualitative feature, we can plot the\nlog hazard function for each level of the feature. If (11.14) holds, then the\nlog hazard functions should just differ by a constant, as seen in the top-left\npanel of Figure 11.4. In the case of a quantitative feature, we can take a\nsimilar approach by stratifying the feature.\n11.7.5 Survival Trees\nIn Chapter 8, we discussed flexible and adaptive learning procedures such as\ntrees, random forests, and boosting, which we applied in both the regression\nand classification settings. Most of these approaches can be generalized to\nthe survival analysis setting. For example, survival trees are a modification\nsurvival\nof classification and regression trees that use a split criterion that maximizes trees\nthe difference between the survival curves in the resulting daughter nodes.\nSurvival trees can then be used to create random survival forests.\n11.8 Lab: Survival Analysis 483\n11.8 Lab: Survival Analysis\nIn this lab, we perform survival analyses on three separate data sets. In\nSection 11.8.1 we analyze the BrainCancer data that was first described\nin Section 11.3. In Section 11.8.2, we examine the Publication data from\nSection 11.5.4. Finally, Section 11.8.3 explores a simulated call center data\nset.\n11.8.1 Brain Cancer Data\nWe begin with the BrainCancer data set, which is part of the ISLR2 package.\n> library(ISLR2)\nThe rows index the 88 patients, while the columns contain the 8 predictors.\n> names(BrainCancer)\n[1] \"sex\" \"diagnosis\" \"loc\" \"ki\" \"gtv\" \"stereo\"\n[7] \"status\" \"time\"\nWe first briefly examine the data.\n> attach(BrainCancer)\n> table(sex)\nsex\nFemale Male\n45 43\n> table(diagnosis)\nMeningioma LG glioma HG glioma Other\n42 9 22 14\n> table(status)\nstatus\n0 1\n53 35\nBefore beginning an analysis, it is important to know how the status variable\nhas been coded. Most software, including R, uses the convention that\nstatus = 1 indicates an uncensored observation, and status = 0 indicates\na censored observation. But some scientists might use the opposite coding.\nFor the BrainCancer data set 35 patients died before the end of the study.\nTo begin the analysis, we re-create the Kaplan-Meier survival curve\nshown in Figure 11.2, using the survfit() function within the R survival\nsurvfit()\nlibrary. Here time corresponds to yi, the time to the ith event (either censoring\nor death).\n> library(survival)\n> fit.surv <- survfit(Surv(time, status) \u223c 1)\n> plot(fit.surv , xlab = \"Months\",\nylab = \"Estimated Probability of Survival\")\nNext we create Kaplan-Meier survival curves that are stratified by sex, in\norder to reproduce Figure 11.3.\n484 11. Survival Analysis and Censored Data\n> fit.sex <- survfit(Surv(time, status) \u223c sex)\n> plot(fit.sex , xlab = \"Months\",\nylab = \"Estimated Probability of Survival\", col = c(2 ,4))\n> legend(\"bottomleft\", levels(sex), col = c(2,4), lty = 1)\nAs discussed in Section 11.4, we can perform a log-rank test to compare\nthe survival of males to females, using the survdiff() function.\nsurvdiff()\n> logrank.test <- survdiff(Surv(time, status) \u223c sex)\n> logrank.test\nCall:\nsurvdiff(formula = Surv(time, status)", "doc_id": "c838a348-c060-4fde-aa7f-3d163561eeaa", "embedding": null, "doc_hash": "94c4d42f546a5f43bc668c306c1878db341b0a144acfec78594459a41e956073", "extra_info": null, "node_info": {"start": 1094241, "end": 1097592, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "6069de7a-f371-4112-ba0e-3ff092ef1557", "3": "284b48ad-53ec-4183-87ca-b7c6697a3be4"}}, "__type__": "1"}, "284b48ad-53ec-4183-87ca-b7c6697a3be4": {"__data__": {"text": "= Surv(time, status) \u223c sex)\nN Observed Expected (O-E)^2/E (O-E)^2/V\nsex=Female 45 15 18.5 0.676 1.44\nsex=Male 43 20 16.5 0.761 1.44\nChisq= 1.4 on 1 degrees of freedom , p= 0.23\nThe resulting p-value is 0.23, indicating no evidence of a difference in survival\nbetween the two sexes.\nNext, we fit Cox proportional hazards models using the coxph() function.\ncoxph()\nTo begin, we consider a model that uses sex as the only predictor.\n> fit.cox <- coxph(Surv(time, status) \u223c sex)\n> summary(fit.cox)\nCall:\ncoxph(formula = Surv(time , status) \u223c sex)\nn= 88, number of events= 35\ncoef exp(coef) se(coef) z Pr(>|z|)\nsexMale 0.4077 1.5033 0.3420 1.192 0.233\nexp(coef) exp(-coef) lower .95 upper .95\nsexMale 1.503 0.6652 0.769 2.939\nConcordance= 0.565 (se = 0.045 )\nLikelihood ratio test= 1.44 on 1 df , p=0.23\nWald test = 1.42 on 1 df , p=0.233\nScore (logrank) test = 1.44 on 1 df , p=0.23\nNote that the values of the likelihood ratio, Wald, and score tests have been\nrounded. It is possible to display additional digits.\n> summary(fit.cox)$logtest [1]\ntest\n1.4388222\n> summary(fit.cox)$waldtest [1]\ntest\n1.4200000\n> summary(fit.cox)$sctest [1]\ntest\n1.44049511\nRegardless of which test we use, we see that there is no clear evidence for\na difference in survival between males and females.\n11.8 Lab: Survival Analysis 485\n> logrank.test$chisq\n[1] 1.44049511\nAs we learned in this chapter, the score test from the Cox model is exactly\nequal to the log rank test statistic!\nNow we fit a model that makes use of additional predictors.\n> fit.all <- coxph(\nSurv(time, status) \u223c sex + diagnosis + loc + ki + gtv +\nstereo)\n> fit.all\nCall:\ncoxph(formula = Surv(time , status) \u223c sex + diagnosis + loc +\nki + gtv + stereo)\ncoef exp(coef) se(coef) z p\nsexMale 0.1837 1.2017 0.3604 0.51 0.6101\ndiagnosisLG glioma 0.9150 2.4968 0.6382 1.43 0.1516\ndiagnosisHG glioma 2.1546 8.6241 0.4505 4.78 1.7e-06\ndiagnosisOther 0.8857 2.4247 0.6579 1.35 0.1782\nlocSupratentorial 0.4412 1.5546 0.7037 0.63 0.5307\nki -0.0550 0.9465 0.0183 -3.00 0.0027\ngtv 0.0343 1.0349 0.0223 1.54 0.1247\nstereoSRT 0.1778 1.1946 0.6016 0.30 0.7676\nLikelihood ratio test =41.4 on 8 df , p=1.78e-06\nn= 87, number of events= 35\n(1 observation deleted due to missingness )\nThe diagnosis variable has been coded so that the baseline corresponds to\nmeningioma. The results indicate that the risk associated with HG glioma\nis more than eight times (i.e. e2.15 = 8.62) the risk associated with meningioma.\nIn other words, after adjusting for the other predictors, patients\nwith HG glioma have much worse survival compared to those with meningioma.\nIn addition, larger values of the Karnofsky index, ki,", "doc_id": "284b48ad-53ec-4183-87ca-b7c6697a3be4", "embedding": null, "doc_hash": "1cb30ad7b2bda23d3e6b963e22a687c959542ab91ecfa9d47e6765ff642c1c1e", "extra_info": null, "node_info": {"start": 1097624, "end": 1100262, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "c838a348-c060-4fde-aa7f-3d163561eeaa", "3": "8892484d-8100-4f1c-9cdb-a08d46f9e4f1"}}, "__type__": "1"}, "8892484d-8100-4f1c-9cdb-a08d46f9e4f1": {"__data__": {"text": "addition, larger values of the Karnofsky index, ki, are associated\nwith lower risk, i.e. longer survival.\nFinally, we plot survival curves for each diagnosis category, adjusting for\nthe other predictors. To make these plots, we set the values of the other\npredictors equal to the mean for quantitative variables, and the modal value\nfor factors. We first create a data frame with four rows, one for each level\nof diagnosis. The survfit() function will produce a curve for each of the\nrows in this data frame, and one call to plot() will display them all in the\nsame plot.\n> modaldata <- data.frame(\ndiagnosis = levels(diagnosis),\nsex = rep(\"Female\", 4),\nloc = rep(\"Supratentorial\", 4),\nki = rep(mean(ki), 4),\ngtv = rep(mean(gtv), 4),\nstereo = rep(\"SRT\", 4)\n)\n486 11. Survival Analysis and Censored Data\n> survplots <- survfit(fit.all, newdata = modaldata)\n> plot(survplots , xlab = \"Months\",\nylab = \"Survival Probability\", col = 2:5)\n> legend(\"bottomleft\", levels(diagnosis), col = 2:5, lty = 1)\n11.8.2 Publication Data\nThe Publication data presented in Section 11.5.4 can be found in the ISLR2\nlibrary. We first reproduce Figure 11.5 by plotting the Kaplan-Meier curves\nstratified on the posres variable, which records whether the study had a\npositive or negative result.\n> fit.posres <- survfit(\nSurv(time, status) \u223c posres , data = Publication\n)\n> plot(fit.posres , xlab = \"Months\",\nylab = \"Probability of Not Being Published\", col = 3:4)\n> legend(\"topright\", c(\"Negative Result\", \"Positive Result\"),\ncol = 3:4, lty = 1)\nAs discussed previously, the p-values from fitting Cox\u2019s proportional hazards\nmodel to the posres variable are quite large, providing no evidence of a\ndifference in time-to-publication between studies with positive versus negative\nresults.\n> fit.pub <- coxph(Surv(time, status) \u223c posres ,\ndata = Publication)\n> fit.pub\nCall:\ncoxph(formula = Surv(time , status) \u223c posres , data = Publication\n)\ncoef exp(coef) se(coef) z p\nposres 0.148 1.160 0.162 0.92 0.36\nLikelihood ratio test =0.83 on 1 df , p=0.361\nn= 244, number of events= 156\nAs expected, the log-rank test provides an identical conclusion.\n> logrank.test <- survdiff(Surv(time, status) \u223c posres ,\ndata = Publication)\n> logrank.test\nCall:\nsurvdiff(formula = Surv(time, status) \u223c posres ,data=Publication\n)\nN Observed Expected (O-E)^2/E (O-E)^2/V\nposres =0 146 87 92.6 0.341 0.844\nposres =1 98 69 63.4 0.498 0.844\nChisq= 0.8 on 1 degrees of freedom , p= 0.358\n11.8 Lab: Survival Analysis 487\nHowever, the results change dramatically when we include other predictors\nin the model. Here we have excluded the funding mechanism variable.\n> fit.pub2 <- coxph(Surv(time, status) \u223c . - mech,\ndata = Publication)\n> fit.pub2\nCall:\ncoxph(formula = Surv(time , status) \u223c . - mech, data=Publication\n)\ncoef exp(coef) se(coef) z p\nposres 0.571 1.770 0.176 3.24 0.0012\nmulti -0.041 0.960 0.251 -0.16 0.8708\nclinend 0.546 1.727 0.262 2.08 0.0371\nsampsize 0.000 1.000", "doc_id": "8892484d-8100-4f1c-9cdb-a08d46f9e4f1", "embedding": null, "doc_hash": "b170aa1e906c6e68a226021fdb6a3ddc36b3d1796ca5fd26792efa9fd07ee4e3", "extra_info": null, "node_info": {"start": 1100237, "end": 1103166, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "284b48ad-53ec-4183-87ca-b7c6697a3be4", "3": "c3b52c9e-8c5a-4157-90ee-5997f9b95329"}}, "__type__": "1"}, "c3b52c9e-8c5a-4157-90ee-5997f9b95329": {"__data__": {"text": "0.262 2.08 0.0371\nsampsize 0.000 1.000 0.000 0.32 0.7507\nbudget 0.004 1.004 0.002 1.78 0.0752\nimpact 0.058 1.060 0.007 8.74 <2e-16\nLikelihood ratio test =149 on 6 df , p=0\nn= 244, number of events= 156\nWe see that there are a number of statistically significant variables, including\nwhether the trial focused on a clinical endpoint, the impact of the\nstudy, and whether the study had positive or negative results.\n11.8.3 Call Center Data\nIn this section, we will simulate survival data using the sim.survdata()\nsim.survdata()\nfunction, which is part of the coxed library. Our simulated data will represent\nthe observed wait times (in seconds) for 2,000 customers who have\nphoned a call center. In this context, censoring occurs if a customer hangs\nup before his or her call is answered.\nThere are three covariates: Operators (the number of call center operators\navailable at the time of the call, which can range from 5 to 15), Center\n(either A, B, or C), and Time of day (Morning, Afternoon, or Evening). We\ngenerate data for these covariates so that all possibilities are equally likely:\nfor instance, morning, afternoon and evening calls are equally likely, and\nany number of operators from 5 to 15 is equally likely.\n> set.seed (4)\n> N <- 2000\n> Operators <- sample (5:15 , N, replace = T)\n> Center <- sample(c(\"A\", \"B\", \"C\"), N, replace = T)\n> Time <- sample(c(\"Morn.\", \"After.\", \"Even.\"), N, replace = T)\n> X <- model.matrix( \u223c Operators + Center + Time)[, -1]\nIt is worthwhile to take a peek at the design matrix X, so that we can be\nsure that we understand how the variables have been coded.\n> X[1:5, ]\nOperators CenterB CenterC TimeEven. TimeMorn.\n1 12 1 0 0 1\n488 11. Survival Analysis and Censored Data\n2 15 0 0 0 0\n3 7 0 1 1 0\n4 7 0 0 0 0\n5 11 0 1 0 1\nNext, we specify the coefficients and the hazard function.\n> true.beta <- c(0.04 , -0.3, 0, 0.2, -0.2)\n> h.fn <- function(x) return (0.00001 * x)\nHere, we have set the coefficient associated with Operators to equal 0.04; in\nother words, each additional operator leads to a e0.04 = 1.041-fold increase\nin the \u201crisk\u201d that the call will be answered, given the Center and Time\ncovariates. This makes sense: the greater the number of operators at hand,\nthe shorter the wait time! The coefficient associated with Center = B is\n\u22120.3, and Center = A is treated as the baseline. This means that the risk\nof a call being answered at Center B is 0.74 times the risk that it will be\nanswered at Center A; in other words, the wait times are a bit longer at\nCenter B.\nWe are now ready to generate data under the Cox proportional hazards\nmodel. The sim.survdata() function allows us to specify the maximum\npossible failure time, which in this case corresponds to the longest possible\nwait time for a customer; we set this to equal 1,000 seconds.\n> library(coxed)\n> queuing <- sim.survdata(N = N, T = 1000, X = X,\nbeta = true.beta , hazard.fun = h.fn)\n> names(queuing)\n[1] \"data\" \"xdata\" \"baseline\"\n[4] \"xb\" \"exp.xb\" \"betas\"\n[7] \"ind.survive\" \"marg.effect\" \"marg.effect.data\"\nThe \u201cobserved\u201d data is stored in queuing$data, with y corresponding to\nthe event time and failed an indicator of whether the call was answered\n(failed = T) or the customer hung", "doc_id": "c3b52c9e-8c5a-4157-90ee-5997f9b95329", "embedding": null, "doc_hash": "e0447eaa39fa7efdb65aeac864254910fca68dfe834283013104a45df1baf7a3", "extra_info": null, "node_info": {"start": 1103177, "end": 1106377, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "8892484d-8100-4f1c-9cdb-a08d46f9e4f1", "3": "0a39bd57-4692-43b2-abae-79a39122d3f8"}}, "__type__": "1"}, "0a39bd57-4692-43b2-abae-79a39122d3f8": {"__data__": {"text": "an indicator of whether the call was answered\n(failed = T) or the customer hung up before the call was answered (failed\n= F). We see that almost 90% of calls were answered.\n> head(queuing$data)\nOperators CenterB CenterC TimeEven. TimeMorn. y failed\n1 12 1 0 0 1 344 TRUE\n2 15 0 0 0 0 241 TRUE\n3 7 0 1 1 0187 TRUE\n4 7 0 0 0 0279 TRUE\n5 11 0 1 0 1 954 TRUE\n6 7 1 0 0 1455 TRUE\n> mean(queuing$data$failed)\n[1] 0.89\nWe now plot Kaplan-Meier survival curves. First, we stratify by Center.\n> par(mfrow = c(1, 2))\n> fit.Center <- survfit(Surv(y, failed) \u223c Center ,\ndata = queuing$data)\n11.8 Lab: Survival Analysis 489\n> plot(fit.Center , xlab = \"Seconds\",\nylab = \"Probability of Still Being on Hold\",\ncol = c(2, 4, 5))\n> legend(\"topright\",\nc(\"Call Center A\", \"Call Center B\", \"Call Center C\"),\ncol = c(2, 4, 5), lty = 1)\nNext, we stratify by Time.\n> fit.Time <- survfit(Surv(y, failed) \u223c Time ,\ndata = queuing$data)\n> plot(fit.Time , xlab = \"Seconds\",\nylab = \"Probability of Still Being on Hold\",\ncol = c(2, 4, 5))\n> legend(\"topright\", c(\"Morning\", \"Afternoon\", \"Evening\"),\ncol = c(5, 2, 4), lty = 1)\nIt seems that calls at Call Center B take longer to be answered than calls\nat Centers A and C. Similarly, it appears that wait times are longest in the\nmorning and shortest in the evening hours. We can use a log-rank test to\ndetermine whether these differences are statistically significant.\n> survdiff(Surv(y, failed) \u223c Center , data = queuing$data)\nCall:\nsurvdiff(formula = Surv(y, failed)\u223cCenter ,data = queuing$data)\nN Observed Expected (O-E)^2/E (O-E)^2/V\nCenter=A 683 603 579 0.971 1.45\nCenter=B 667 600 701 14.641 24.64\nCenter=C 650 577 499 12.062 17.05\nChisq= 28.3 on 2 degrees of freedom , p= 7e-07\n> survdiff(Surv(y, failed) \u223c Time , data = queuing$data)\nCall:\nsurvdiff(formula = Surv(y, failed) \u223c Time , data = queuing$data)\nN Observed Expected (O-E)^2/E (O-E)^2/V\nTime=After. 688 616 619 0.0135 0.021\nTime=Even. 653 582 468 27.6353 38.353\nTime=Morn. 659 582 693 17.7381 29.893\nChisq= 46.8 on 2 degrees of freedom , p= 7e-11\nWe find that differences between centers are highly significant, as are\ndifferences between times of day.\nFinally, we fit Cox\u2019s proportional hazards model to the data.\n> fit.queuing <- coxph(Surv(y, failed) \u223c .,\ndata = queuing$data)\n> fit.queuing\nCall:\ncoxph(formula = Surv(y, failed) \u223c ., data = queuing$data)\ncoef exp(coef) se(coef) z p\nOperators 0.04174 1.04263 0.00759 5.500 3.8e-08\n490 11. Survival Analysis and Censored Data\nCenterB -0.21879 0.80349 0.05793 -3.777 0.000159\nCenterC 0.07930 1.08253 0.05850 1.356 0.175256\nTimeEven. 0.20904 1.23249 0.05820 3.592 0.000328\nTimeMorn. -0.17352 0.84070 0.05811 -2.986", "doc_id": "0a39bd57-4692-43b2-abae-79a39122d3f8", "embedding": null, "doc_hash": "2f236a48fa3062be0c4b1ed35677c80b27732717d4b094c2afb37ffe875e0542", "extra_info": null, "node_info": {"start": 1106346, "end": 1108993, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "c3b52c9e-8c5a-4157-90ee-5997f9b95329", "3": "23289a7d-aa14-4d51-88ff-15291ffd2bfb"}}, "__type__": "1"}, "23289a7d-aa14-4d51-88ff-15291ffd2bfb": {"__data__": {"text": "-0.17352 0.84070 0.05811 -2.986 0.002828\nLikelihood ratio test =102.8 on 5 df , p=< 2.2e-16\nn= 2000, number of events= 1780\nThe p-values for Center = B, Time = Even. and Time = Morn. are very small.\nIt is also clear that the hazard \u2014 that is, the instantaneous risk that a call\nwill be answered \u2014 increases with the number of operators. Since we generated\nthe data ourselves, we know that the true coefficients for Operators,\nCenter = B, Center = C, Time = Even. and Time = Morn. are 0.04, \u22120.3, 0,\n0.2, and \u22120.2, respectively. The coefficient estimates resulting from the Cox\nmodel are fairly accurate.\n11.9 Exercises\nConceptual\n1. For each example, state whether or not the censoring mechanism is\nindependent. Justify your answer.\n(a) In a study of disease relapse, due to a careless research scientist,\nall patients whose phone numbers begin with the number \u201c2\u201d\nare lost to follow up.\n(b) In a study of longevity, a formatting error causes all patient ages\nthat exceed 99 years to be lost (i.e. we know that those patients\nare more than 99 years old, but we do not know their exact\nages).\n(c) Hospital A conducts a study of longevity. However, very sick\npatients tend to be transferred to Hospital B, and are lost to\nfollow up.\n(d) In a study of unemployment duration, the people who find work\nearlier are less motivated to stay in touch with study investigators,\nand therefore are more likely to be lost to follow up.\n(e) In a study of pregnancy duration, women who deliver their babies\npre-term are more likely to do so away from their usual\nhospital, and thus are more likely to be censored, relative to\nwomen who deliver full-term babies.\n(f) A researcher wishes to model the number of years of education\nof the residents of a small town. Residents who enroll in college\nout of town are more likely to be lost to follow up, and are\nalso more likely to attend graduate school, relative to those who\nattend college in town.\n11.9 Exercises 491\n(g) Researchers conduct a study of disease-free survival (i.e. time\nuntil disease relapse following treatment). Patients who have\nnot relapsed within five years are considered to be cured, and\nthus their survival time is censored at five years.\n(h) We wish to model the failure time for some electrical component.\nThis component can be manufactured in Iowa or in Pittsburgh,\nwith no difference in quality. The Iowa factory opened five years\nago, and so components manufactured in Iowa are censored at\nfive years. The Pittsburgh factory opened two years ago, so those\ncomponents are censored at two years.\n(i) We wish to model the failure time of an electrical component\nmade in two different factories, one of which opened before the\nother. We have reason to believe that the components manufactured\nin the factory that opened earlier are of higher quality.\n2. We conduct a study with n = 4 participants who have just purchased\ncell phones, in order to model the time until phone replacement. The\nfirst participant replaces her phone after 1.2 years. The second participant\nstill has not replaced her phone at the end of the two-year\nstudy period. The third participant changes her phone number and is\nlost to follow up (but has not yet replaced her phone) 1.5 years into\nthe study. The fourth participant replaces her phone after 0.2 years.\nFor each of the four participants (i = 1, . . . , 4), answer the following\nquestions using the notation introduced in Section 11.1:\n(a) Is the participant\u2019s cell phone replacement time censored?\n(b) Is the value of ci known, and if so, then what is it?\n(c) Is the value of ti known, and if so, then what is it?\n(d) Is the value of yi known, and if so, then what is", "doc_id": "23289a7d-aa14-4d51-88ff-15291ffd2bfb", "embedding": null, "doc_hash": "3a2f8ec716a8184446d07eaacc0e294c3ed1e2f0b32fac193e60163efef58f6f", "extra_info": null, "node_info": {"start": 1109032, "end": 1112686, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "0a39bd57-4692-43b2-abae-79a39122d3f8", "3": "8191ca02-d0ad-4c53-bdeb-5c38e73e8466"}}, "__type__": "1"}, "8191ca02-d0ad-4c53-bdeb-5c38e73e8466": {"__data__": {"text": "it?\n(d) Is the value of yi known, and if so, then what is it?\n(e) Is the value of \u03b4i known, and if so, then what is it?\n3. For the example in Exercise 2, report the values of K, d1, . . . ,dK,\nr1, . . . , rK, and q1, . . . , qK, where this notation was defined in Section\n11.3.\n4. This problem makes use of the Kaplan-Meier survival curve displayed\nin Figure 11.9. The raw data that went into plotting this survival\ncurve is given in Table 11.4. The covariate column of that table is\nnot needed for this problem.\n(a) What is the estimated probability of survival past 50 days?\n(b) Write out an analytical expression for the estimated survival\nfunction. For instance, your answer might be something along\n492 11. Survival Analysis and Censored Data\nObservation (Y ) Censoring Indicator (\u03b4) Covariate (X)\n26.5 1 0.1\n37.2 1 11\n57.3 1 -0.3\n90.8 0 2.8\n20.2 0 1.8\n89.8 0 0.4\nTABLE 11.4. Data used in Exercise 4.\nthe lines of\nWS(t) =\n\u23a7\u23aa\u23a8\n\u23aa\u23a9\n0.8 if t < 31\n0.5 if 31 \u2264 t < 77\n0.22 if 77 \u2264 t.\n(The previous equation is for illustration only: it is not the correct\nanswer!)\n5. Sketch the survival function given by the equation\nWS(t) =\n\u23a7\u23aa\u23a8\n\u23aa\u23a9\n0.8 if t < 31\n0.5 if 31 \u2264 t < 77\n0.22 if 77 \u2264 t.\nYour answer should look something like Figure 11.9.\n0 20 40 60 80\n0.0 0.2 0.4 0.6 0.8 1.0\nTime in Days\nEstimated Probability of Survival\nFIGURE 11.9. A Kaplan-Meier survival curve used in Exercise 4.\n6. This problem makes use of the data displayed in Figure 11.1. In\ncompleting this problem, you can refer to the observation times as\ny1, . . . , y4. The ordering of these observation times can be seen from\nFigure 11.1; their exact values are not required.\n11.9 Exercises 493\n(a) Report the values of \u03b41, . . . , \u03b44, K, d1, . . . ,dK, r1, . . . , rK, and\nq1, . . . , qK. The relevant notation is defined in Sections 11.1 and\n11.3.\n(b) Sketch the Kaplan-Meier survival curve corresponding to this\ndata set. (You do not need to use any software to do this \u2014 you\ncan sketch it by hand using the results obtained in (a).)\n(c) Based on the survival curve estimated in (b), what is the probability\nthat the event occurs within 200 days? What is the probability\nthat the event does not occur within 310 days?\n(d) Write out an expression for the estimated survival curve from\n(b).\n7. In this problem, we will derive (11.5) and (11.6), which are needed\nfor the construction of the log-rank test statistic (11.8). Recall the\nnotation in Table 11.1.\n(a) Assume that there is no difference between the survival functions\nof the two groups. Then we can think of q1k as the number of\nfailures if we draw r1k observations, without replacement, from\na risk set of rk observations that contains a total of qk failures.\nArgue that q1k follows a hypergeometric distribution. Write the\nhypergeometric\nparameters of this distribution in terms of r1k, rk, and qk. distribution\n(b) Given your previous answer, and the properties of the hypergeometric\ndistribution, what are the mean and variance of q1k?\nCompare your answer", "doc_id": "8191ca02-d0ad-4c53-bdeb-5c38e73e8466", "embedding": null, "doc_hash": "c3d6860e8529a5e0cca607ceb09eb0153558874f7dd4e5065995e5f7c6433828", "extra_info": null, "node_info": {"start": 1112670, "end": 1115651, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "23289a7d-aa14-4d51-88ff-15291ffd2bfb", "3": "558347ef-c01f-4909-b2b7-7823a5046394"}}, "__type__": "1"}, "558347ef-c01f-4909-b2b7-7823a5046394": {"__data__": {"text": "what are the mean and variance of q1k?\nCompare your answer to (11.5) and (11.6).\n8. Recall that the survival function S(t), the hazard function h(t), and\nthe density function f(t) are defined in (11.2), (11.9), and (11.11),\nrespectively. Furthermore, define F(t) = 1 \u2212 S(t). Show that the\nfollowing relationships hold:\nf(t) = dF(t)/dt\nS(t) = exp\n*\n\u2212\nL t\n0\nh(u)du\n+\n.\n9. In this exercise, we will explore the consequences of assuming that\nthe survival times follow an exponential distribution.\n(a) Suppose that a survival time follows an Exp(\u03bb) distribution,\nso that its density function is f(t) = \u03bb exp(\u2212\u03bbt). Using the\nrelationships provided in Exercise 8, show that S(t) = exp(\u2212\u03bbt).\n(b) Now suppose that each of n independent survival times follows\nan Exp(\u03bb) distribution. Write out an expression for the likelihood\nfunction (11.13).\n494 11. Survival Analysis and Censored Data\n(c) Show that the maximum likelihood estimator for \u03bb is\n\u02c6\u03bb\n=\n0n\ni=1\n\u03b4i/\n0n\ni=1\nyi.\n(d) Use your answer to (c) to derive an estimator of the mean survival\ntime.\nHint: For (d), recall that the mean of an Exp(\u03bb) random variable is\n1/\u03bb.\nApplied\n10. This exercise focuses on the brain tumor data, which is included in\nthe ISLR2 R library.\n(a) Plot the Kaplan-Meier survival curve with \u00b11 standard error\nbands, using the survfit() function in the survival package.\n(b) Draw a bootstrap sample of size n = 88 from the pairs (yi, \u03b4i),\nand compute the resulting Kaplan-Meier survival curve. Repeat\nthis process B = 200 times. Use the results to obtain an estimate\nof the standard error of the Kaplan-Meier survival curve at each\ntimepoint. Compare this to the standard errors obtained in (a).\n(c) Fit a Cox proportional hazards model that uses all of the predictors\nto predict survival. Summarize the main findings.\n(d) Stratify the data by the value of ki. (Since only one observation\nhas ki=40, you can group that observation together with the observations\nthat have ki=60.) Plot Kaplan-Meier survival curves\nfor each of the five strata, adjusted for the other predictors.\n11. This example makes use of the data in Table 11.4.\n(a) Create two groups of observations. In Group 1, X <2, whereas\nin Group 2, X \u2265 2. Plot the Kaplan-Meier survival curves corresponding\nto the two groups. Be sure to label the curves so that\nit is clear which curve corresponds to which group. By eye, does\nthere appear to be a difference between the two groups\u2019 survival\ncurves?\n(b) Fit Cox\u2019s proportional hazards model, using the group indicator\nas a covariate. What is the estimated coefficient? Write a sentence\nproviding the interpretation of this coefficient, in terms\nof the hazard or the instantaneous probability of the event. Is\nthere evidence that the true coefficient value is non-zero?\n11.9 Exercises 495\n(c) Recall from Section 11.5.2 that in the case of a single binary\ncovariate, the log-rank test statistic should be identical to the\nscore statistic for the Cox model. Conduct a log-rank test to determine\nwhether there is a difference between the survival curves\nfor the two groups. How does the p-value for the log-rank test\nstatistic compare to the p-value for the score statistic for the\nCox model from (b)?\n12\nUnsupervised Learning\nMost of this book concerns supervised learning methods such as\nregression and classification. In the supervised", "doc_id": "558347ef-c01f-4909-b2b7-7823a5046394", "embedding": null, "doc_hash": "a3f9e7ffb537bdc07f13d745fe3d370a9cd52b0a9a561640ec7ec73f277c77f7", "extra_info": null, "node_info": {"start": 1115648, "end": 1118961, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "8191ca02-d0ad-4c53-bdeb-5c38e73e8466", "3": "6a421505-d263-4981-9dc9-19a964ad0549"}}, "__type__": "1"}, "6a421505-d263-4981-9dc9-19a964ad0549": {"__data__": {"text": "supervised learning methods such as\nregression and classification. In the supervised learning setting, we typically\nhave access to a set of p features X1,X2, . . . ,Xp, measured on n observations,\nand a response Y also measured on those same n observations.\nThe goal is then to predict Y using X1,X2, . . . ,Xp.\nThis chapter will instead focus on unsupervised learning, a set of statistical\ntools intended for the setting in which we have only a set of features\nX1,X2, . . . ,Xp measured on n observations. We are not interested\nin prediction, because we do not have an associated response variable Y .\nRather, the goal is to discover interesting things about the measurements\non X1,X2, . . . ,Xp. Is there an informative way to visualize the data? Can\nwe discover subgroups among the variables or among the observations?\nUnsupervised learning refers to a diverse set of techniques for answering\nquestions such as these. In this chapter, we will focus on two particular\ntypes of unsupervised learning: principal components analysis, a tool\nused for data visualization or data pre-processing before supervised techniques\nare applied, and clustering, a broad class of methods for discovering\nunknown subgroups in data.\n12.1 The Challenge of Unsupervised Learning\nSupervised learning is a well-understood area. In fact, if you have read\nthe preceding chapters in this book, then you should by now have a good\n\u00a9 Springer Science+Business Media, LLC, part of Springer Nature 2021\nG. James et al., An Introduction to Statistical Learning, Springer Texts in Statistics,\nhttps://doi.org/10.1007/978-1-0716-1418-1_12\n497\n498 12. Unsupervised Learning\ngrasp of supervised learning. For instance, if you are asked to predict a\nbinary outcome from a data set, you have a very well developed set of tools\nat your disposal (such as logistic regression, linear discriminant analysis,\nclassification trees, support vector machines, and more) as well as a clear\nunderstanding of how to assess the quality of the results obtained (using\ncross-validation, validation on an independent test set, and so forth).\nIn contrast, unsupervised learning is often much more challenging. The\nexercise tends to be more subjective, and there is no simple goal for the\nanalysis, such as prediction of a response. Unsupervised learning is often\nperformed as part of an exploratory data analysis. Furthermore, it can be\nexploratory\ndata\nanalysis\nhard to assess the results obtained from unsupervised learning methods,\nsince there is no universally accepted mechanism for performing crossvalidation\nor validating results on an independent data set. The reason\nfor this difference is simple. If we fit a predictive model using a supervised\nlearning technique, then it is possible to check our work by seeing how\nwell our model predicts the response Y on observations not used in fitting\nthe model. However, in unsupervised learning, there is no way to check our\nwork because we don\u2019t know the true answer\u2014the problem is unsupervised.\nTechniques for unsupervised learning are of growing importance in a\nnumber of fields. A cancer researcher might assay gene expression levels in\n100 patients with breast cancer. He or she might then look for subgroups\namong the breast cancer samples, or among the genes, in order to obtain\na better understanding of the disease. An online shopping site might try\nto identify groups of shoppers with similar browsing and purchase histories,\nas well as items that are of particular interest to the shoppers within\neach group. Then an individual shopper can be preferentially shown the\nitems in which he or she is particularly likely to be interested, based on\nthe purchase histories of similar shoppers. A search engine might choose\nwhich search results to display to a particular individual based on the click\nhistories of other individuals with similar search patterns. These statistical\nlearning tasks, and many more, can be performed via unsupervised learning\ntechniques.\n12.2 Principal Components Analysis\nPrincipal", "doc_id": "6a421505-d263-4981-9dc9-19a964ad0549", "embedding": null, "doc_hash": "17122fc80db1c53a1033e4e261518523a84dcca96ccb0aac0d520826331307b4", "extra_info": null, "node_info": {"start": 1118936, "end": 1122950, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "558347ef-c01f-4909-b2b7-7823a5046394", "3": "73b19d30-d135-4480-aa40-ca7841fd77f5"}}, "__type__": "1"}, "73b19d30-d135-4480-aa40-ca7841fd77f5": {"__data__": {"text": "unsupervised learning\ntechniques.\n12.2 Principal Components Analysis\nPrincipal components are discussed in Section 6.3.1 in the context of\nprincipal components regression. When faced with a large set of correlated\nvariables, principal components allow us to summarize this set with\na smaller number of representative variables that collectively explain most\nof the variability in the original set. The principal component directions\nare presented in Section 6.3.1 as directions in feature space along which\nthe original data are highly variable. These directions also define lines and\nsubspaces that are as close as possible to the data cloud. To perform\n12.2 Principal Components Analysis 499\nprincipal components regression, we simply use principal components as\npredictors in a regression model in place of the original larger set of variables.\nPrincipal components analysis (PCA) refers to the process by which prinprincipal\ncomponents\nanalysis\ncipal components are computed, and the subsequent use of these components\nin understanding the data. PCA is an unsupervised approach, since\nit involves only a set of features X1,X2, . . . ,Xp, and no associated response\nY . Apart from producing derived variables for use in supervised learning\nproblems, PCA also serves as a tool for data visualization (visualization of\nthe observations or visualization of the variables). It can also be used as a\ntool for data imputation \u2014 that is, for filling in missing values in a data\nmatrix.\nWe now discuss PCA in greater detail, focusing on the use of PCA as\na tool for unsupervised data exploration, in keeping with the topic of this\nchapter.\n12.2.1 What Are Principal Components?\nSuppose that we wish to visualize n observations with measurements on a\nset of p features, X1,X2, . . . ,Xp, as part of an exploratory data analysis.\nWe could do this by examining two-dimensional scatterplots of the data,\neach of which contains the n observations\u2019 measurements on two of the\nfeatures. However, there are\n'p\n2\n(\n= p(p\u22121)/2 such scatterplots; for example,\nwith p = 10 there are 45 plots! If p is large, then it will certainly not be\npossible to look at all of them; moreover, most likely none of them will\nbe informative since they each contain just a small fraction of the total\ninformation present in the data set. Clearly, a better method is required to\nvisualize the n observations when p is large. In particular, we would like to\nfind a low-dimensional representation of the data that captures as much of\nthe information as possible. For instance, if we can obtain a two-dimensional\nrepresentation of the data that captures most of the information, then we\ncan plot the observations in this low-dimensional space.\nPCA provides a tool to do just this. It finds a low-dimensional representation\nof a data set that contains as much as possible of the variation. The\nidea is that each of the n observations lives in p-dimensional space, but not\nall of these dimensions are equally interesting. PCA seeks a small number\nof dimensions that are as interesting as possible, where the concept of interesting\nis measured by the amount that the observations vary along each\ndimension. Each of the dimensions found by PCA is a linear combination\nof the p features. We now explain the manner in which these dimensions,\nor principal components, are found.\nThe first principal component of a set of features X1,X2, . . . ,Xp is the\nnormalized linear combination of the features\nZ1 = \u03c611X1 + \u03c621X2 + \u00b7 \u00b7 \u00b7 + \u03c6p1Xp (12.1)\n500 12. Unsupervised Learning\nthat has the largest variance. By normalized, we mean that\n)p\nj=1 \u03c62j\n1 = 1.\nWe refer to the elements \u03c611, . . . ,\u03c6p1 as the loadings of the first principal\nloading\ncomponent; together, the loadings make up the", "doc_id": "73b19d30-d135-4480-aa40-ca7841fd77f5", "embedding": null, "doc_hash": "93f1c65523836fcf367943c4e748e1c87f8194b6843492533c1058b357767d38", "extra_info": null, "node_info": {"start": 1122952, "end": 1126690, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "6a421505-d263-4981-9dc9-19a964ad0549", "3": "7f52a7c2-671d-48b0-ae94-6ba21626c8a7"}}, "__type__": "1"}, "7f52a7c2-671d-48b0-ae94-6ba21626c8a7": {"__data__": {"text": "of the first principal\nloading\ncomponent; together, the loadings make up the principal component loading\nvector, \u03c61 = (\u03c611 \u03c621 . . . \u03c6p1)T . We constrain the loadings so that\ntheir sum of squares is equal to one, since otherwise setting these elements\nto be arbitrarily large in absolute value could result in an arbitrarily large\nvariance.\nGiven a n \u00d7 p data set X, how do we compute the first principal component?\nSince we are only interested in variance, we assume that each of\nthe variables in X has been centered to have mean zero (that is, the column\nmeans of X are zero). We then look for the linear combination of the\nsample feature values of the form\nzi1 = \u03c611xi1 + \u03c621xi2 + \u00b7 \u00b7 \u00b7 + \u03c6p1xip (12.2)\nthat has largest sample variance, subject to the constraint that\n)p\nj=1 \u03c62j\n1=1.\nIn other words, the first principal component loading vector solves the optimization\nproblem\nmaximize\n\u03c611,...,\u03c6p1\n\u23a7\u23aa\u23a8\n\u23aa\u23a9\n1\nn\n0n\ni=1\n\u239b\n\u239d\n0p\nj=1\n\u03c6j1xij\n\u239e\n\u23a0\n2\n\u23ab\u23aa\u23ac\n\u23aa\u23ad\nsubject to\n0p\nj=1\n\u03c62j\n1 = 1. (12.3)\nFrom (12.2) we can write the objective in (12.3) as 1n\n)n\ni=1 z2\ni1. Since\n1n\n)n\ni=1 xij = 0, the average of the z11, . . . , zn1 will be zero as well. Hence\nthe objective that we are maximizing in (12.3) is just the sample variance of\nthe n values of zi1. We refer to z11, . . . , zn1 as the scores of the first princi- score\npal component. Problem (12.3) can be solved via an eigen decomposition,\neigen dea\nstandard technique in linear algebra, but details are outside of the scope composition\nof this book.1\nThere is a nice geometric interpretation for the first principal component.\nThe loading vector \u03c61 with elements \u03c611,\u03c621, . . . ,\u03c6p1 defines a direction in\nfeature space along which the data vary the most. If we project the n data\npoints x1, . . . ,xn onto this direction, the projected values are the principal\ncomponent scores z11, . . . , zn1 themselves. For instance, Figure 6.14 on\npage 253 displays the first principal component loading vector (green solid\nline) on an advertising data set. In these data, there are only two features,\nand so the observations as well as the first principal component loading\nvector can be easily displayed. As can be seen from (6.19), in that data set\n\u03c611 = 0.839 and \u03c621 = 0.544.\nAfter the first principal component Z1 of the features has been determined,\nwe can find the second principal component Z2. The second prin-\n1As an alternative to the eigen decomposition, a related technique called the singular\nvalue decomposition can be used. This will be explored in the lab at the end of this\nchapter.\n12.2 Principal Components Analysis 501\ncipal component is the linear combination of X1, . . . ,Xp that has maximal\nvariance out of all linear combinations that are uncorrelated with Z1. The\nsecond principal component scores z12, z22, . . . , zn2 take the form\nzi2 = \u03c612xi1 + \u03c622xi2 + \u00b7 \u00b7 \u00b7 + \u03c6p2xip, (12.4)\nwhere \u03c62 is the second principal component loading vector, with elements\n\u03c612,\u03c622, . . . ,\u03c6p2. It turns out that constraining Z2 to be uncorrelated with\nZ1 is equivalent to constraining the direction \u03c62 to be orthogonal", "doc_id": "7f52a7c2-671d-48b0-ae94-6ba21626c8a7", "embedding": null, "doc_hash": "6846862576ba32219510acf1ad631ab295ce111955a4a36f2f3bd5b2e4c8dc77", "extra_info": null, "node_info": {"start": 1126698, "end": 1129760, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "73b19d30-d135-4480-aa40-ca7841fd77f5", "3": "3f79da35-8cec-48a2-ba96-d398881f3028"}}, "__type__": "1"}, "3f79da35-8cec-48a2-ba96-d398881f3028": {"__data__": {"text": "is equivalent to constraining the direction \u03c62 to be orthogonal (perpendicular)\nto the direction \u03c61. In the example in Figure 6.14, the observations\nlie in two-dimensional space (since p = 2), and so once we have found \u03c61,\nthere is only one possibility for \u03c62, which is shown as a blue dashed line.\n(From Section 6.3.1, we know that \u03c612 = 0.544 and \u03c622 = \u22120.839.) But in\na larger data set with p > 2 variables, there are multiple distinct principal\ncomponents, and they are defined in a similar manner. To find \u03c62, we solve\na problem similar to (12.3) with \u03c62 replacing \u03c61, and with the additional\nconstraint that \u03c62 is orthogonal to \u03c61.2\nOnce we have computed the principal components, we can plot them\nagainst each other in order to produce low-dimensional views of the data.\nFor instance, we can plot the score vector Z1 against Z2, Z1 against Z3,\nZ2 against Z3, and so forth. Geometrically, this amounts to projecting\nthe original data down onto the subspace spanned by \u03c61, \u03c62, and \u03c63, and\nplotting the projected points.\nWe illustrate the use of PCA on the USArrests data set. For each of the\n50 states in the United States, the data set contains the number of arrests\nper 100, 000 residents for each of three crimes: Assault, Murder, and Rape.\nWe also record UrbanPop (the percent of the population in each state living\nin urban areas). The principal component score vectors have length n = 50,\nand the principal component loading vectors have length p = 4. PCA was\nperformed after standardizing each variable to have mean zero and standard\ndeviation one. Figure 12.1 plots the first two principal components of these\ndata. The figure represents both the principal component scores and the\nloading vectors in a single biplot display. The loadings are also given in\nbiplot\nTable 12.1.\nIn Figure 12.1, we see that the first loading vector places approximately\nequal weight on Assault, Murder, and Rape, but with much less weight on\nUrbanPop. Hence this component roughly corresponds to a measure of overall\nrates of serious crimes. The second loading vector places most of its weight\non UrbanPop and much less weight on the other three features. Hence, this\ncomponent roughly corresponds to the level of urbanization of the state.\nOverall, we see that the crime-related variables (Murder, Assault, and Rape)\nare located close to each other, and that the UrbanPop variable is far from the\n2On a technical note, the principal component directions \u03c61, \u03c62, \u03c63, . . . are the\nordered sequence of eigenvectors of the matrix XTX, and the variances of the components\nare the eigenvalues. There are at most min(n \u2212 1, p) principal components.\n502 12. Unsupervised Learning\n\u22123 \u22122 \u22121 0 1 2 3\n\u22123 \u22122 \u22121 0 1 2 3\nFirst Principal Component\nSecond Principal Component\nAlabama Alaska\nArizona\nArkansas\nCalifornia\nColorado\nConnecticut\nDelaware\nFlorida\nGeorgia\nHawaii\nIdaho\nIllinois\nIowa Indiana\nKansas\nKentucky Louisiana\nMaine Maryland\nMassachusetts\nMichigan\nMinnesota\nMississippi\nMissouri\nMontana\nNebraska\nNevada\nNew Hampshire\nNew Jersey\nNew Mexico\nNew York\nNorth Carolina\nNorth Dakota\nOhio\nOklahoma\nPennsylvania Oregon\nRhode Island\nSouth Carolina\nSouth Dakota Tennessee\nTexas\nUtah\nVermont\nVirginia\nWashington\nWest Virginia\nWisconsin\nWyoming\n\u22120.5 0.0 0.5\n\u22120.5 0.0 0.5\nMurder\nAssault\nUrbanPop\nRape\nFIGURE 12.1. The first two principal components for the USArrests data. The\nblue state names represent the scores for the first two principal components. The\norange arrows indicate the first two principal component loading vectors", "doc_id": "3f79da35-8cec-48a2-ba96-d398881f3028", "embedding": null, "doc_hash": "9e7d70743b774aea4b3dfc73643ff575d4aee0f4c007fca36dfcd4472110cc31", "extra_info": null, "node_info": {"start": 1129774, "end": 1133285, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "7f52a7c2-671d-48b0-ae94-6ba21626c8a7", "3": "9ee39cab-1571-4edf-ab54-dae165ddbe15"}}, "__type__": "1"}, "9ee39cab-1571-4edf-ab54-dae165ddbe15": {"__data__": {"text": "components. The\norange arrows indicate the first two principal component loading vectors (with\naxes on the top and right). For example, the loading for Rape on the first component\nis 0.54, and its loading on the second principal component 0.17 (the word\nRape is centered at the point (0.54, 0.17)). This figure is known as a biplot, because\nit displays both the principal component scores and the principal component\nloadings.\nother three. This indicates that the crime-related variables are correlated\nwith each other\u2014states with high murder rates tend to have high assault\nand rape rates\u2014and that the UrbanPop variable is less correlated with the\nother three.\nWe can examine differences between the states via the two principal component\nscore vectors shown in Figure 12.1. Our discussion of the loading\nvectors suggests that states with large positive scores on the first component,\nsuch as California, Nevada and Florida, have high crime rates, while\nstates like North Dakota, with negative scores on the first component, have\n12.2 Principal Components Analysis 503\nPC1 PC2\nMurder 0.5358995 \u22120.4181809\nAssault 0.5831836 \u22120.1879856\nUrbanPop 0.2781909 0.8728062\nRape 0.5434321 0.1673186\nTABLE 12.1. The principal component loading vectors, \u03c61 and \u03c62, for the\nUSArrests data. These are also displayed in Figure 12.1.\nlow crime rates. California also has a high score on the second component,\nindicating a high level of urbanization, while the opposite is true for states\nlike Mississippi. States close to zero on both components, such as Indiana,\nhave approximately average levels of both crime and urbanization.\n12.2.2 Another Interpretation of Principal Components\nThe first two principal component loading vectors in a simulated threedimensional\ndata set are shown in the left-hand panel of Figure 12.2; these\ntwo loading vectors span a plane along which the observations have the\nhighest variance.\nIn the previous section, we describe the principal component loading vectors\nas the directions in feature space along which the data vary the most,\nand the principal component scores as projections along these directions.\nHowever, an alternative interpretation for principal components can also be\nuseful: principal components provide low-dimensional linear surfaces that\nare closest to the observations. We expand upon that interpretation here.3\nThe first principal component loading vector has a very special property:\nit is the line in p-dimensional space that is closest to the n observations\n(using average squared Euclidean distance as a measure of closeness). This\ninterpretation can be seen in the left-hand panel of Figure 6.15; the dashed\nlines indicate the distance between each observation and the line defined\nby the first principal component loading vector. The appeal of this interpretation\nis clear: we seek a single dimension of the data that lies as close\nas possible to all of the data points, since such a line will likely provide a\ngood summary of the data.\nThe notion of principal components as the dimensions that are closest\nto the n observations extends beyond just the first principal component.\nFor instance, the first two principal components of a data set\nspan the plane that is closest to the n observations, in terms of average\nsquared Euclidean distance. An example is shown in the left-hand panel\nof Figure 12.2. The first three principal components of a data set span\n3In this section, we continue to assume that each column of the data matrix X has\nbeen centered to have mean zero\u2014that is, the column mean has been subtracted from\neach column.\n504 12. Unsupervised Learning\nFirst principal component\nSecond principal component\n\u22121.0 \u22120.5 0.0 0.5 1.0\n\u22121.0 \u22120.5 0.0 0.5 1.0\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022", "doc_id": "9ee39cab-1571-4edf-ab54-dae165ddbe15", "embedding": null, "doc_hash": "4e6d90ac2a4d74b2b0dc9cd9acaa72a0882472aa422f4b4df27ad884b70bc072", "extra_info": null, "node_info": {"start": 1133262, "end": 1136998, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "3f79da35-8cec-48a2-ba96-d398881f3028", "3": "201475b7-8ee0-4428-aa50-5d0f393797c6"}}, "__type__": "1"}, "201475b7-8ee0-4428-aa50-5d0f393797c6": {"__data__": {"text": "\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\u2022\n\u2022\u2022\n\u2022\n\u2022\n\u2022 \u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022 \u2022\n\u2022 \u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022 \u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022 \u2022\n\u2022\n\u2022 \u2022\n\u2022\n\u2022\n\u2022 \u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022 \u2022\n\u2022\n\u2022\n\u2022\n\u2022 \u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022 \u2022\nFIGURE 12.2. Ninety observations simulated in three dimensions. The observations\nare displayed in color for ease of visualization. Left: the first two principal\ncomponent directions span the plane that best fits the data. The plane is positioned\nto minimize the sum of squared distances to each point. Right: the first\ntwo principal component score vectors give the coordinates of the projection of the\n90 observations onto the plane.\nthe three-dimensional hyperplane that is closest to the n observations, and\nso forth.\nUsing this interpretation, together the first M principal component score\nvectors and the first M principal component loading vectors provide the\nbest M-dimensional approximation (in terms of Euclidean distance) to\nthe ith observation xij . This representation can be written as\nxij \u2248\nM0\nm=1\nzim\u03c6jm. (12.5)\nWe can state this more formally by writing down an optimization problem.\nSuppose the data matrix X is column-centered. Out of all approximations\nof the form xij \u2248\n)M\nm=1 aimbjm, we could ask for the one with the\nsmallest residual sum of squares:\nminimize\nA\u2208Rn\u00d7M,B\u2208Rp\u00d7M\n\u23a7\u23a8 \u23a9\n0p\nj=1\n0n\ni=1\n>\nxij \u2212\nM0\nm=1\naimbjm\n?2\n\u23ab\u23ac\n\u23ad. (12.6)\nHere, A is a n \u00d7M matrix whose (i,m) element is aim, and B is a p \u00d7M\nelement whose (j,m) element is bjm.\nIt can be shown that for any value of M, the columns of the matrices\n\u02c6A\nand \u02c6B that solve (12.6) are in fact the first M principal components\nscore and loading vectors. In other words, if \u02c6A and \u02c6B solve (12.6), then\n12.2 Principal Components Analysis 505\n\u02c6aim = zim and \u02c6bjm = \u03c6jm.4 This means that the smallest possible value of\nthe objective in (12.6) is\n0p\nj=1\n0n\ni=1\n>\nxij \u2212\nM0\nm=1\nzim\u03c6jm\n?2\n. (12.7)\nIn summary, together the M principal component score vectors and M\nprincipal component loading vectors can give a good approximation to the\ndata when M is sufficiently large. When M = min(n \u2212 1, p), then the\nrepresentation is exact: xij =\n)M\nm=1 zim\u03c6jm.\n12.2.3 The Proportion of Variance Explained\nIn Figure 12.2, we performed PCA on a three-dimensional data set (lefthand\npanel) and projected the data onto the first two principal component\nloading vectors in order to obtain a two-dimensional view of the data (i.e.\nthe principal component score vectors; right-hand panel). We see that this\ntwo-dimensional representation of the three-dimensional data does successfully\ncapture the major pattern in the data: the orange, green, and cyan\nobservations that are near each other in three-dimensional space remain\nnearby in the two-dimensional representation. Similarly, we have seen on\nthe USArrests data set that we can summarize the 50 observations and 4\nvariables using just the first two principal component score vectors and the\nfirst two principal component loading vectors.\nWe can now ask a natural question: how much of the information", "doc_id": "201475b7-8ee0-4428-aa50-5d0f393797c6", "embedding": null, "doc_hash": "4cd1b465522c7c59a85b5560384b58d9ea87b134ceec921c33262d13737f4e87", "extra_info": null, "node_info": {"start": 1137077, "end": 1140027, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "9ee39cab-1571-4edf-ab54-dae165ddbe15", "3": "39d624de-728b-4f94-af9b-cdb3f55f5164"}}, "__type__": "1"}, "39d624de-728b-4f94-af9b-cdb3f55f5164": {"__data__": {"text": "component loading vectors.\nWe can now ask a natural question: how much of the information in\na given data set is lost by projecting the observations onto the first few\nprincipal components? That is, how much of the variance in the data is not\ncontained in the first few principal components? More generally, we are\ninterested in knowing the proportion of variance explained (PVE) by each\nproportion\nof variance\nexplained\nprincipal component. The total variance present in a data set (assuming\nthat the variables have been centered to have mean zero) is defined as\n0p\nj=1\nVar(Xj) =\n0p\nj=1\n1\nn\n0n\ni=1\nx2\nij , (12.8)\nand the variance explained by the mth principal component is\n1\nn\n0n\ni=1\nz2\nim =\n1\nn\n0n\ni=1\n\u239b\n\u239d\n0p\nj=1\n\u03c6jmxij\n\u239e\n\u23a0\n2\n. (12.9)\n4Technically, the solution to (12.6) is not unique. Thus, it is more precise to state\nthat any solution to (12.6) can be easily transformed to yield the principal components.\n506 12. Unsupervised Learning\nTherefore, the PVE of the mth principal component is given by\n)n\ni=1 z2\n) im p\nj=1\n)n\ni=1 x2\nij\n=\n)n\ni=1\n1)p\nj=1 \u03c6jmxij\n22\n)p\nj=1\n)n\ni=1 x2\nij\n. (12.10)\nThe PVE of each principal component is a positive quantity. In order to\ncompute the cumulative PVE of the first M principal components, we can\nsimply sum (12.10) over each of the first M PVEs. In total, there are\nmin(n \u2212 1, p) principal components, and their PVEs sum to one.\nIn Section 12.2.2, we showed that the first M principal component loading\nand score vectors can be interpreted as the best M-dimensional approximation\nto the data, in terms of residual sum of squares. It turns out that\nthe variance of the data can be decomposed into the variance of the first M\nprincipal components plus the mean squared error of this M-dimensional\napproximation, as follows:\n'p\nj=1\n1\nn\n'n\ni=1\nx2\nij\n( )* +\nVar. of data\n=\nM'\nm=1\n1\nn\n'n\ni=1\nz2\nim\n( )* +\nVar. of first M PCs\n+\n1\nn\n'p\nj=1\n'n\ni=1\n,\nxij \u2212\nM'\nm=1\nzim\u03c6jm\n-2\n( )* +\nMSE of M-dimensional approximation\n(12.11)\nThe three terms in this decomposition are discussed in (12.8), (12.9), and\n(12.7), respectively. Since the first term is fixed, we see that by maximizing\nthe variance of the first M principal components, we minimize the mean\nsquared error of the M-dimensional approximation, and vice versa. This explains\nwhy principal components can be equivalently viewed as minimizing\nthe approximation error (as in Section 12.2.2) or maximizing the variance\n(as in Section 12.2.1).\nMoreover, we can use (12.11) to see that the PVE defined in (12.10)\nequals\n1 \u2212\n)p\nj=1\n)n\ni=1\n1\nxij \u2212\n)M\nm=1 zim\u03c6jm\n22\n)p\nj=1\n)n\ni=1 x2\nij\n= 1\u2212\nRSS\nTSS\n,\nwhere TSS represents the total sum of squared elements of X, and RSS\nrepresents the residual sum of squares of the M-dimensional approximation\ngiven by the", "doc_id": "39d624de-728b-4f94-af9b-cdb3f55f5164", "embedding": null, "doc_hash": "db5dc2bdb49ff6cfef5492f2a06731144b7ba14904397b8b6dc2e55e7a001053", "extra_info": null, "node_info": {"start": 1139952, "end": 1142686, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "201475b7-8ee0-4428-aa50-5d0f393797c6", "3": "1c7bbad0-7e6d-49d4-b7f3-1ade925dba64"}}, "__type__": "1"}, "1c7bbad0-7e6d-49d4-b7f3-1ade925dba64": {"__data__": {"text": "the residual sum of squares of the M-dimensional approximation\ngiven by the principal components. Recalling the definition of R2 from\n(3.17), this means that we can interpret the PVE as the R2 of the approximation\nfor X given by the first M principal components.\nIn the USArrests data, the first principal component explains 62.0% of\nthe variance in the data, and the next principal component explains 24.7%\nof the variance. Together, the first two principal components explain almost\n87% of the variance in the data, and the last two principal components\nexplain only 13% of the variance. This means that Figure 12.1 provides a\npretty accurate summary of the data using just two dimensions. The PVE\nof each principal component, as well as the cumulative PVE, is shown\nin Figure 12.3. The left-hand panel is known as a scree plot, and will be\nscree plot\ndiscussed later in this chapter.\n12.2 Principal Components Analysis 507\n1.0 1.5 2.0 2.5 3.0 3.5 4.0\n0.0 0.2 0.4 0.6 0.8 1.0\nPrincipal Component\nProp. Variance Explained\n1.0 1.5 2.0 2.5 3.0 3.5 4.0\n0.0 0.2 0.4 0.6 0.8 1.0\nPrincipal Component\nCumulative Prop. Variance Explained\nFIGURE 12.3. Left: a scree plot depicting the proportion of variance explained\nby each of the four principal components in the USArrests data. Right: the cumulative\nproportion of variance explained by the four principal components in the\nUSArrests data.\n12.2.4 More on PCA\nScaling the Variables\nWe have already mentioned that before PCA is performed, the variables\nshould be centered to have mean zero. Furthermore, the results obtained\nwhen we perform PCA will also depend on whether the variables have been\nindividually scaled (each multiplied by a different constant). This is in\ncontrast to some other supervised and unsupervised learning techniques,\nsuch as linear regression, in which scaling the variables has no effect. (In\nlinear regression, multiplying a variable by a factor of c will simply lead to\nmultiplication of the corresponding coefficient estimate by a factor of 1/c,\nand thus will have no substantive effect on the model obtained.)\nFor instance, Figure 12.1 was obtained after scaling each of the variables\nto have standard deviation one. This is reproduced in the left-hand plot in\nFigure 12.4. Why does it matter that we scaled the variables? In these data,\nthe variables are measured in different units; Murder, Rape, and Assault are\nreported as the number of occurrences per 100, 000 people, and UrbanPop is\nthe percentage of the state\u2019s population that lives in an urban area. These\nfour variables have variances of 18.97, 87.73, 6945.16, and 209.5, respectively.\nConsequently, if we perform PCA on the unscaled variables, then\nthe first principal component loading vector will have a very large loading\nfor Assault, since that variable has by far the highest variance. The righthand\nplot in Figure 12.4 displays the first two principal components for the\nUSArrests data set, without scaling the variables to have standard deviation\none. As predicted, the first principal component loading vector places\nalmost all of its weight on Assault, while the second principal component\n508 12. Unsupervised Learning\n\u22123 \u22122 \u22121 0 1 2 3\n\u22123 \u22122 \u22121 0 1 2 3\nFirst Principal Component\nSecond Principal Component\n* *\n*\n*\n*\n* *\n*\n*\n*\n*\n*\n*\n* *\n*\n* *\n* *\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n* *\n*\n*\n*", "doc_id": "1c7bbad0-7e6d-49d4-b7f3-1ade925dba64", "embedding": null, "doc_hash": "9d827ed0bf50620e286e63d9b0af5dd77c6b8f9e35a5a82db976df10c23030ca", "extra_info": null, "node_info": {"start": 1142698, "end": 1146031, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "39d624de-728b-4f94-af9b-cdb3f55f5164", "3": "58863ca4-96e9-476f-bad3-dc0c33e274e1"}}, "__type__": "1"}, "58863ca4-96e9-476f-bad3-dc0c33e274e1": {"__data__": {"text": "*\n*\n*\n* *\n*\n*\n*\n*\n*\n*\n*\n*\n\u22120.5 0.0 0.5\n\u22120.5 0.0 0.5\nMurder\nAssault\nUrbanPop\nRape\nScaled\n\u2212100 \u221250 0 50 100 150\n\u2212100 \u221250 0 50 100 150\nFirst Principal Component\nSecond Principal Component\n* *\n*\n*\n*\n* *\n* *\n*\n*\n*\n*\n*\n**\n* * *\n*\n* *\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n* * *\n*\n* *\n*\n* *\n*\n*\n*\n*\n*\n*\n\u22120.5 0.0 0.5 1.0\n\u22120.5 0.0 0.5 1.0\nMurder Assault\nUrbanPop\nRape\nUnscaled\nFIGURE 12.4. Two principal component biplots for the USArrests data. Left:\nthe same as Figure 12.1, with the variables scaled to have unit standard deviations.\nRight: principal components using unscaled data. Assault has by far the largest\nloading on the first principal component because it has the highest variance among\nthe four variables. In general, scaling the variables to have standard deviation one\nis recommended.\nloading vector places almost all of its weight on UrpanPop. Comparing this\nto the left-hand plot, we see that scaling does indeed have a substantial\neffect on the results obtained.\nHowever, this result is simply a consequence of the scales on which the\nvariables were measured. For instance, if Assault were measured in units\nof the number of occurrences per 100 people (rather than number of occurrences\nper 100, 000 people), then this would amount to dividing all of\nthe elements of that variable by 1, 000. Then the variance of the variable\nwould be tiny, and so the first principal component loading vector would\nhave a very small value for that variable. Because it is undesirable for the\nprincipal components obtained to depend on an arbitrary choice of scaling,\nwe typically scale each variable to have standard deviation one before we\nperform PCA.\nIn certain settings, however, the variables may be measured in the same\nunits. In this case, we might not wish to scale the variables to have standard\ndeviation one before performing PCA. For instance, suppose that the\nvariables in a given data set correspond to expression levels for p genes.\nThen since expression is measured in the same \u201cunits\u201d for each gene, we\nmight choose not to scale the genes to each have standard deviation one.\n12.2 Principal Components Analysis 509\nUniqueness of the Principal Components\nEach principal component loading vector is unique, up to a sign flip. This\nmeans that two different software packages will yield the same principal\ncomponent loading vectors, although the signs of those loading vectors\nmay differ. The signs may differ because each principal component loading\nvector specifies a direction in p-dimensional space: flipping the sign has no\neffect as the direction does not change. (Consider Figure 6.14\u2014the principal\ncomponent loading vector is a line that extends in either direction, and\nflipping its sign would have no effect.) Similarly, the score vectors are unique\nup to a sign flip, since the variance of Z is the same as the variance of \u2212Z.\nIt is worth noting that when we use (12.5) to approximate xij we multiply\nzim by \u03c6jm. Hence, if the sign is flipped on both the loading and score\nvectors, the final product of the two quantities is unchanged.\nDeciding How Many Principal Components to Use\nIn general, a n \u00d7 p data matrix X has min(n \u2212 1, p) distinct principal\ncomponents. However, we usually are not interested in all of them; rather,\nwe would like to use just the first few principal components in order to\nvisualize or interpret the data. In fact, we would like to use the smallest\nnumber of principal components required to get a good understanding of the\ndata. How many principal components are needed? Unfortunately, there is\nno single (or", "doc_id": "58863ca4-96e9-476f-bad3-dc0c33e274e1", "embedding": null, "doc_hash": "db03be5d4f43efbeaa0e678fb1c5c3051223f23ccd7dc3037aea0c8086aee157", "extra_info": null, "node_info": {"start": 1146090, "end": 1149627, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "1c7bbad0-7e6d-49d4-b7f3-1ade925dba64", "3": "d9d58a4e-7f1d-49c2-a867-b7f61e4117eb"}}, "__type__": "1"}, "d9d58a4e-7f1d-49c2-a867-b7f61e4117eb": {"__data__": {"text": "How many principal components are needed? Unfortunately, there is\nno single (or simple!) answer to this question.\nWe typically decide on the number of principal components required\nto visualize the data by examining a scree plot, such as the one shown\nin the left-hand panel of Figure 12.3. We choose the smallest number of\nprincipal components that are required in order to explain a sizable amount\nof the variation in the data. This is done by eyeballing the scree plot, and\nlooking for a point at which the proportion of variance explained by each\nsubsequent principal component drops off. This drop is often referred to\nas an elbow in the scree plot. For instance, by inspection of Figure 12.3,\none might conclude that a fair amount of variance is explained by the first\ntwo principal components, and that there is an elbow after the second\ncomponent. After all, the third principal component explains less than ten\npercent of the variance in the data, and the fourth principal component\nexplains less than half that and so is essentially worthless.\nHowever, this type of visual analysis is inherently ad hoc. Unfortunately,\nthere is no well-accepted objective way to decide how many principal components\nare enough. In fact, the question of how many principal components\nare enough is inherently ill-defined, and will depend on the specific\narea of application and the specific data set. In practice, we tend to look\nat the first few principal components in order to find interesting patterns\nin the data. If no interesting patterns are found in the first few principal\ncomponents, then further principal components are unlikely to be of interest.\nConversely, if the first few principal components are interesting, then\n510 12. Unsupervised Learning\nwe typically continue to look at subsequent principal components until no\nfurther interesting patterns are found. This is admittedly a subjective approach,\nand is reflective of the fact that PCA is generally used as a tool for\nexploratory data analysis.\nOn the other hand, if we compute principal components for use in a\nsupervised analysis, such as the principal components regression presented\nin Section 6.3.1, then there is a simple and objective way to determine how\nmany principal components to use: we can treat the number of principal\ncomponent score vectors to be used in the regression as a tuning parameter\nto be selected via cross-validation or a related approach. The comparative\nsimplicity of selecting the number of principal components for a supervised\nanalysis is one manifestation of the fact that supervised analyses tend to\nbe more clearly defined and more objectively evaluated than unsupervised\nanalyses.\n12.2.5 Other Uses for Principal Components\nWe saw in Section 6.3.1 that we can perform regression using the principal\ncomponent score vectors as features. In fact, many statistical techniques,\nsuch as regression, classification, and clustering, can be easily adapted to\nuse the n \u00d7M matrix whose columns are the first M \u226a p principal component\nscore vectors, rather than using the full n \u00d7 p data matrix. This\ncan lead to less noisy results, since it is often the case that the signal (as\nopposed to the noise) in a data set is concentrated in its first few principal\ncomponents.\n12.3 Missing Values and Matrix Completion\nOften datasets have missing values, which can be a nuisance. For example,\nsuppose that we wish to analyze the USArrests data, and discover that 20\nof the 200 values have been randomly corrupted and marked as missing.\nUnfortunately, the statistical learning methods that we have seen in this\nbook cannot handle missing values. How should we proceed?\nWe could remove the rows that contain missing observations and perform\nour data analysis on the complete rows. But this seems wasteful, and\ndepending on the fraction missing, unrealistic. Alternatively, if xij is missing,\nthen we could replace it by the mean of the jth column (using the\nnon-missing entries to compute the mean). Although this is a common and\nconvenient strategy, often", "doc_id": "d9d58a4e-7f1d-49c2-a867-b7f61e4117eb", "embedding": null, "doc_hash": "2e4ea6913fd95564b6dc39a1155edd33c45c48adaa60e0510546f879de6ddfe5", "extra_info": null, "node_info": {"start": 1149566, "end": 1153605, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "58863ca4-96e9-476f-bad3-dc0c33e274e1", "3": "03d70e88-b874-47d4-a3f3-5f4da48ca3b9"}}, "__type__": "1"}, "03d70e88-b874-47d4-a3f3-5f4da48ca3b9": {"__data__": {"text": "to compute the mean). Although this is a common and\nconvenient strategy, often we can do better by exploiting the correlation\nbetween the variables.\nIn this section we show how principal components can be used to impute\nimpute\nimputation\nthe missing values, through a process known as matrix completion. The\nmatrix\ncompletion\n12.3 Missing Values and Matrix Completion 511\ncompleted matrix can then be used in a statistical learning method, such\nas linear regression or LDA.\nThis approach for imputing missing data is appropriate if the missingness\nis random. For example, it is suitable if a patient\u2019s weight is missing because\nmissing at\nthe battery of the electronic scale was flat at the time of his exam. By random\ncontrast, if the weight is missing because the patient was too heavy to\nclimb on the scale, then this is not missing at random; the missingness is\ninformative, and the approach described here for handling missing data is\nnot suitable.\nSometimes data is missing by necessity. For example, if we form a matrix\nof the ratings (on a scale from 1 to 5) that n customers have given to the\nentire Netflix catalog of p movies, then most of the matrix will be missing,\nsince no customer will have seen and rated more than a tiny fraction of the\ncatalog. If we can impute the missing values well, then we will have an idea\nof what each customer will think of movies they have not yet seen. Hence\nmatrix completion can be used to power recommender systems.\nrecommender\nsystems\nPrincipal Components with Missing Values\nIn Section 12.2.2, we showed that the first M principal component score\nand loading vectors provide the \u201cbest\u201d approximation to the data matrix\nX, in the sense of (12.6). Suppose that some of the observations xij are\nmissing. We now show how one can both impute the missing values and\nsolve the principal component problem at the same time. We return to a\nmodified form of the optimization problem (12.6),\nminimize\nA\u2208Rn\u00d7M,B\u2208Rp\u00d7M\n\u23a7\u23a8\n\u23a9\n0\n(i,j)\u2208O\n>\nxij \u2212\nM0\nm=1\naimbjm\n?2\n\u23ab\u23ac\n\u23ad, (12.12)\nwhere O is the set of all observed pairs of indices (i, j), a subset of the\npossible n \u00d7 p pairs.\nOnce we solve this problem:\n\u2022 we can estimate a missing observation xij using \u02c6xij =\n)M\nm=1 \u02c6aim\u02c6bjm,\nwhere \u02c6aim and \u02c6bjm are the (i,m) and (j,m) elements, respectively,\nof the matrices \u02c6A and \u02c6B that solve (12.12); and\n\u2022 we can (approximately) recover the M principal component scores\nand loadings, as we did when the data were complete.\nIt turns out that solving (12.12) exactly is difficult, unlike in the case of\ncomplete data: the eigen decomposition no longer applies. But the sim512\n12. Unsupervised Learning\nAlgorithm 12.1 Iterative Algorithm for Matrix Completion\n1. Create a complete data matrix \u02dcX of dimension n \u00d7 p of which the\n(i, j) element equals\n\u02dcxij =\nK\nxij if (i, j) \u2208 O \u00afxj if (i, j) /\u2208 O,\nwhere \u00afxj is the average of the observed values for the jth variable in\nthe incomplete data matrix X. Here, O indexes the observations that\nare observed in X.\n2. Repeat steps (a)\u2013(c) until the objective (12.14) fails to decrease:\n(a) Solve\nminimize\nA\u2208Rn\u00d7M,B\u2208Rp\u00d7M\n\u23a7\u23a8\n\u23a9\n0p\nj=1\n0n\ni=1\n>\n\u02dcxij \u2212\nM0\nm=1\naimbjm\n?2\n\u23ab\u23ac\n\u23ad (12.13)\nby computing", "doc_id": "03d70e88-b874-47d4-a3f3-5f4da48ca3b9", "embedding": null, "doc_hash": "2a27294f36f9cf41cb47bc83495e058fcb4fbbd37f6bc947edfcc0d8b7f0ef68", "extra_info": null, "node_info": {"start": 1153608, "end": 1156758, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "d9d58a4e-7f1d-49c2-a867-b7f61e4117eb", "3": "8093e99a-f11a-44c2-b001-7e3bf2adeb12"}}, "__type__": "1"}, "8093e99a-f11a-44c2-b001-7e3bf2adeb12": {"__data__": {"text": "(12.13)\nby computing the principal components of \u02dcX.\n(b) For each element (i, j) /\u2208 O, set \u02dcxij \u2190\n)M\nm=1 \u02c6aim\u02c6bjm.\n(c) Compute the objective\n0\n(i,j)\u2208O\n>\nxij \u2212\nM0\nm=1\n\u02c6aim\u02c6bjm\n?2\n. (12.14)\n3. Return the estimated missing entries \u02dcxij , (i, j) /\u2208 O.\nple iterative approach in Algorithm 12.1, which is demonstrated in Section\n12.5.2, typically provides a good solution.56\nWe illustrate Algorithm 12.1 on the USArrests data. There are p = 4\nvariables and n = 50 observations (states). We first standardized the data\nso each variable has mean zero and standard deviation one. We then randomly\nselected 20 of the 50 states, and then for each of these we randomly\nset one of the four variables to be missing. Thus, 10% of the elements of the\ndata matrix were missing. We applied Algorithm 12.1 with M = 1 principal\ncomponent. Figure 12.5 shows that the recovery of the missing elements\n5This algorithm is referred to as \u201cHard-Impute\u201d in Mazumder, Hastie, and Tibshirani\n(2010) \u201cSpectral regularization algorithms for learning large incomplete matrices\u201d,\npublished in Journal of Machine Learning Research, pages 2287\u20132322.\n6Each iteration of Step 2 of this algorithm decreases the objective (12.14). However,\nthe algorithm is not guaranteed to achieve the global optimum of (12.12).\n12.3 Missing Values and Matrix Completion 513\n\u22121.5 \u22121.0 \u22120.5 0.0 0.5 1.0 1.5\n\u22121.5 \u22121.0 \u22120.5 0.0 0.5 1.0 1.5\nOriginal Value\nImputed Value\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\nOR\nWA\nTN\nND\nPA\nCA\nMO\nID\nMD\nVA\nAL\nTX\nWY\nMN\nAK\nUT\nGA\nMT\nMA\nNY\n\u25cf\n\u25cf\n\u25cf\n\u25cf\nMurder\nAssault\nUrbanPop\nRape\nFIGURE 12.5. Missing value imputation on the USArrests data. Twenty values\n(10% of the total number of matrix elements) were artificially set to be missing,\nand then imputed via Algorithm 12.1 with M = 1. The figure displays the true\nvalue xij and the imputed value \u02c6xij for all twenty missing values. For each of the\ntwenty missing values, the color indicates the variable, and the label indicates the\nstate. The correlation between the true and imputed values is around 0.63.\nis pretty accurate. Over 100 random runs of this experiment, the average\ncorrelation between the true and imputed values of the missing elements\nis 0.63, with a standard deviation of 0.11. Is this good performance? To\nanswer this question, we can compare this correlation to what we would\nhave gotten if we had estimated these 20 values using the complete data\n\u2014 that is, if we had simply computed \u02c6xij = zi1\u03c6j1, where zi1 and \u03c6j1 are\nelements of the first principal component score and loading vectors of the\ncomplete data.7 Using the complete data in this way results in an average\ncorrelation of 0.79 between the true and estimated values for these 20 elements,\nwith a standard deviation of 0.08. Thus, our imputation method\ndoes worse than the method that uses all of the data (0.63 \u00b1 0.11 versus\n0.79 \u00b1 0.08), but its performance is still pretty good. (And of course, the\n7This is an unattainable gold standard, in the sense that with missing data, we of\ncourse cannot compute the principal components of the complete data.\n514 12. Unsupervised Learning\n\u22123 \u22122 \u22121 0 1 2 3\n\u22123 \u22122 \u22121", "doc_id": "8093e99a-f11a-44c2-b001-7e3bf2adeb12", "embedding": null, "doc_hash": "fa18826f62564ad54898c1f148dc79df55a8d3d5a35e635f473ca06d7f332bdb", "extra_info": null, "node_info": {"start": 1156807, "end": 1159918, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "03d70e88-b874-47d4-a3f3-5f4da48ca3b9", "3": "2965e681-5294-45f8-9dba-570bb184d1f3"}}, "__type__": "1"}, "2965e681-5294-45f8-9dba-570bb184d1f3": {"__data__": {"text": "Learning\n\u22123 \u22122 \u22121 0 1 2 3\n\u22123 \u22122 \u22121 0 1 2 3\nTrue First Principal Component\nImputed First Principal Component\n\u25cf\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\u25cf\u25cf\u25cf\u25cf\n\u25cf\u25cf\u25cf\n\u25cf\u25cf\u25cf\u25cf\n\u25cf\n\u25cf\n\u25cf\u25cf\n\u25cf\u25cf\u25cf\u25cf\n\u25cf\u25cf\u25cf\n\u25cf\n\u25cf\u25cf\u25cf\u25cf\u25cf\n\u25cf\u25cf\u25cf\n\u25cf\u25cf\n\u25cf\u25cf\u25cf\n\u25cf\n\u25cf\u25cf\n\u25cf\n\u25cf\n2 4 6 8 10 12\n2 4 6 8 10 12\nTrue PC Variances\nImputed PC Variances\n\u25cf\n\u25cf\n\u25cf\n\u25cf\nFIGURE 12.6. As described in the text, in each of 100 trials, we left out 20\nelements of the USArrests dataset. In each trial, we applied Algorithm 12.1 with\nM = 1 to impute the missing elements and compute the principal components.\nLeft: For each of the 50 states, the imputed first principal component scores (averaged\nover 100 trials, and displayed with a standard deviation bar) are plotted\nagainst the first principal component scores computed using all the data. Right:\nThe imputed principal component loadings (averaged over 100 trials, and displayed\nwith a standard deviation bar) are plotted against the true principal component\nloadings.\nmethod that uses all of the data cannot be applied in a real-world setting\nwith missing data.)\nFigure 12.6 further indicates that Algorithm 12.1 performs fairly well on\nthis dataset.\nWe close with a few observations:\n\u2022 The USArrests data has only four variables, which is on the low end\nfor methods like Algorithm 12.1 to work well. For this reason, for this\ndemonstration we randomly set at most one variable per state to be\nmissing, and only used M = 1 principal component.\n\u2022 In general, in order to apply Algorithm 12.1, we must select M, the\nnumber of principal components to use for the imputation. One approach\nis to randomly leave out a few additional elements from the\nmatrix, and select M based on how well those known values are recovered.\nThis is closely related to the validation-set approach seen in\nChapter 5.\nRecommender Systems\nDigital streaming services like Netflix and Amazon use data about the content\nthat a customer has viewed in the past, as well as data from other\n12.3 Missing Values and Matrix Completion 515\nJerry Maguire\nOceans\nRoad to Perdition\nA Fortunate Man\nCatch Me If You Can\nDriving Miss Daisy\nThe Two Popes\nThe Laundromat\nCode 8\nThe Social Network\n\u00b7\u00b7\u00b7\nCustomer 1 \u2022 \u2022 \u2022 \u2022 4 \u2022 \u2022 \u2022 \u2022 \u2022 \u00b7 \u00b7 \u00b7 Customer 2 \u2022 \u2022 3 \u2022 \u2022 \u2022 3 \u2022 \u2022 3 \u00b7 \u00b7 \u00b7 Customer 3 \u2022 2 \u2022 4 \u2022 \u2022 \u2022 \u2022 2 \u2022 \u00b7 \u00b7 \u00b7 Customer 4 3 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u00b7 \u00b7 \u00b7 Customer 5 5 1 \u2022 \u2022 4 \u2022 \u2022 \u2022 \u2022 \u2022 \u00b7 \u00b7 \u00b7 Customer 6 \u2022 \u2022 \u2022 \u2022 \u2022 2 4 \u2022 \u2022 \u2022 \u00b7 \u00b7 \u00b7 Customer 7 \u2022 \u2022 5 \u2022 \u2022 \u2022 \u2022 3 \u2022 \u2022 \u00b7 \u00b7 \u00b7 Customer 8 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u00b7 \u00b7 \u00b7 Customer 9 3 \u2022 \u2022 \u2022 5 \u2022 \u2022 1 \u2022 \u2022 \u00b7 \u00b7 \u00b7 ...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n. . .\nTABLE 12.2. Excerpt of the Netflix movie rating data. The movies are rated\nfrom 1 (worst) to 5 (best). The symbol \u2022 represents a missing value: a movie that\nwas not rated by the corresponding customer.\ncustomers, to suggest other content for the customer. As a concrete example,\nsome years back, Netflix had customers rate each movie that they\nhad seen with a score from 1\u20135. This resulted in a very big n \u00d7 p matrix\nfor which the (i, j) element is the rating given by the ith customer to the\njth movie. One specific early example of this matrix had n = 480,189 customers\nand p = 17,770 movies. However, on average each customer had seen\naround 200 movies, so 99% of the matrix had missing elements. Table 12.3\nillustrates the setup.\nIn order to suggest a movie that a particular customer might like, Netflix\nneeded a way", "doc_id": "2965e681-5294-45f8-9dba-570bb184d1f3", "embedding": null, "doc_hash": "5154e679cc4d0aa70e6ccc950ce8d322cee08399e5dcf376ee30ad1237d34e3e", "extra_info": null, "node_info": {"start": 1159912, "end": 1163205, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "8093e99a-f11a-44c2-b001-7e3bf2adeb12", "3": "11550390-0ff4-45c9-a627-433d6fc841eb"}}, "__type__": "1"}, "11550390-0ff4-45c9-a627-433d6fc841eb": {"__data__": {"text": "order to suggest a movie that a particular customer might like, Netflix\nneeded a way to impute the missing values of this data matrix. The key idea\nis as follows: the set of movies that the ith customer has seen will overlap\nwith those that other customers have seen. Furthermore, some of those\nother customers will have similar movie preferences to the ith customer.\nThus, it should be possible to use similar customers\u2019 ratings of movies that\nthe ith customer has not seen to predict whether the ith customer will like\nthose movies.\nMore concretely, by applying Algorithm 12.1, we can predict the ith customer\u2019s\nrating for the jth movie using \u02c6xij =\n)M\nm=1 \u02c6aim\u02c6bjm. Furthermore,\nwe can interpret the M components in terms of \u201ccliques\u201d and \u201cgenres\u201d:\n\u2022 \u02c6aim represents the strength with which the ith user belongs to the\nmth clique, where a clique is a group of customers that enjoys movies\nof the mth genre;\n\u2022 \u02c6bjm represents the strength with which the jth movie belongs to the\nmth genre.\n516 12. Unsupervised Learning\nExamples of genres include Romance, Western, and Action.\nPrincipal component models similar to Algorithm 12.1 are at the heart\nof many recommender systems. Although the data matrices involved are\ntypically massive, algorithms have been developed that can exploit the high\nlevel of missingness in order to perform efficient computations.\n12.4 Clustering Methods\nClustering refers to a very broad set of techniques for finding subgroups, or\nclustering\nclusters, in a data set. When we cluster the observations of a data set, we\nseek to partition them into distinct groups so that the observations within\neach group are quite similar to each other, while observations in different\ngroups are quite different from each other. Of course, to make this concrete,\nwe must define what it means for two or more observations to be similar\nor different. Indeed, this is often a domain-specific consideration that must\nbe made based on knowledge of the data being studied.\nFor instance, suppose that we have a set of n observations, each with p\nfeatures. The n observations could correspond to tissue samples for patients\nwith breast cancer, and the p features could correspond to measurements\ncollected for each tissue sample; these could be clinical measurements, such\nas tumor stage or grade, or they could be gene expression measurements.\nWe may have a reason to believe that there is some heterogeneity among\nthe n tissue samples; for instance, perhaps there are a few different unknown\nsubtypes of breast cancer. Clustering could be used to find these\nsubgroups. This is an unsupervised problem because we are trying to discover\nstructure\u2014in this case, distinct clusters\u2014on the basis of a data set.\nThe goal in supervised problems, on the other hand, is to try to predict\nsome outcome vector such as survival time or response to drug treatment.\nBoth clustering and PCA seek to simplify the data via a small number\nof summaries, but their mechanisms are different:\n\u2022 PCA looks to find a low-dimensional representation of the observations\nthat explain a good fraction of the variance;\n\u2022 Clustering looks to find homogeneous subgroups among the observations.\nAnother application of clustering arises in marketing. We may have access\nto a large number of measurements (e.g. median household income,\noccupation, distance from nearest urban area, and so forth) for a large\nnumber of people. Our goal is to perform market segmentation by identifying\nsubgroups of people who might be more receptive to a particular form\nof advertising, or more likely to purchase a particular product. The task of\nperforming market segmentation amounts to clustering the people in the\ndata set.\n12.4 Clustering Methods 517\nSince clustering is popular in many fields, there exist a great number of\nclustering methods. In this section we focus on perhaps the two best-known\nclustering approaches: K-means clustering and hierarchical clustering.", "doc_id": "11550390-0ff4-45c9-a627-433d6fc841eb", "embedding": null, "doc_hash": "52c057ae21383031644013458f7361ecadcd094d249d7e73c9bc5626c910599a", "extra_info": null, "node_info": {"start": 1163161, "end": 1167093, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "2965e681-5294-45f8-9dba-570bb184d1f3", "3": "2eed722b-6fa6-49f6-9a14-b47a57e77e6d"}}, "__type__": "1"}, "2eed722b-6fa6-49f6-9a14-b47a57e77e6d": {"__data__": {"text": "approaches: K-means clustering and hierarchical clustering. In\nK-means\nclustering\nhierarchical\nclustering\nK-means clustering, we seek to partition the observations into a pre-specified\nnumber of clusters. On the other hand, in hierarchical clustering, we do\nnot know in advance how many clusters we want; in fact, we end up with\na tree-like visual representation of the observations, called a dendrogram,\ndendrogram\nthat allows us to view at once the clusterings obtained for each possible\nnumber of clusters, from 1 to n. There are advantages and disadvantages\nto each of these clustering approaches, which we highlight in this chapter.\nIn general, we can cluster observations on the basis of the features in\norder to identify subgroups among the observations, or we can cluster features\non the basis of the observations in order to discover subgroups among\nthe features. In what follows, for simplicity we will discuss clustering observations\non the basis of the features, though the converse can be performed\nby simply transposing the data matrix.\n12.4.1 K-Means Clustering\nK-means clustering is a simple and elegant approach for partitioning a\ndata set into K distinct, non-overlapping clusters. To perform K-means\nclustering, we must first specify the desired number of clusters K; then the\nK-means algorithm will assign each observation to exactly one of the K\nclusters. Figure 12.7 shows the results obtained from performing K-means\nclustering on a simulated example consisting of 150 observations in two\ndimensions, using three different values of K.\nThe K-means clustering procedure results from a simple and intuitive\nmathematical problem.We begin by defining some notation. Let C1, . . . ,CK\ndenote sets containing the indices of the observations in each cluster. These\nsets satisfy two properties:\n1. C1 \u222a C2 \u222a . . . \u222a CK = {1, . . . ,n}. In other words, each observation\nbelongs to at least one of the K clusters.\n2. Ck \u2229 Ck\u2032 = \u2205 for all k \u0338= k\u2032. In other words, the clusters are nonoverlapping:\nno observation belongs to more than one cluster.\nFor instance, if the ith observation is in the kth cluster, then i \u2208 Ck. The\nidea behind K-means clustering is that a good clustering is one for which the\nwithin-cluster variation is as small as possible. The within-cluster variation\nfor cluster Ck is a measure W(Ck) of the amount by which the observations\nwithin a cluster differ from each other. Hence we want to solve the problem\nminimize\nC1,...,CK\n=\n0K\nk=1\nW(Ck)\nX\n. (12.15)\n518 12. Unsupervised Learning\nK=2 K=3 K=4\nFIGURE 12.7. A simulated data set with 150 observations in two-dimensional\nspace. Panels show the results of applying K-means clustering with different values\nof K, the number of clusters. The color of each observation indicates the cluster\nto which it was assigned using the K-means clustering algorithm. Note that\nthere is no ordering of the clusters, so the cluster coloring is arbitrary. These\ncluster labels were not used in clustering; instead, they are the outputs of the\nclustering procedure.\nIn words, this formula says that we want to partition the observations into\nK clusters such that the total within-cluster variation, summed over all K\nclusters, is as small as possible.\nSolving (12.15) seems like a reasonable idea, but in order to make it\nactionable we need to define the within-cluster variation. There are many\npossible ways to define this concept, but by far the most common choice\ninvolves squared", "doc_id": "2eed722b-6fa6-49f6-9a14-b47a57e77e6d", "embedding": null, "doc_hash": "17387e5fef76f6378069942df3d8038f32b6c70a3db24eed9ff2e13255b5ebb7", "extra_info": null, "node_info": {"start": 1167111, "end": 1170560, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "11550390-0ff4-45c9-a627-433d6fc841eb", "3": "3a6594b0-73c6-497b-a8d0-e51ee6c21e08"}}, "__type__": "1"}, "3a6594b0-73c6-497b-a8d0-e51ee6c21e08": {"__data__": {"text": "ways to define this concept, but by far the most common choice\ninvolves squared Euclidean distance. That is, we define\nW(Ck) =\n1\n|Ck|\n0\ni,i\u2032\u2208Ck\n0p\nj=1\n(xij \u2212 xi\u2032j)2, (12.16)\nwhere |Ck| denotes the number of observations in the kth cluster. In other\nwords, the within-cluster variation for the kth cluster is the sum of all of\nthe pairwise squared Euclidean distances between the observations in the\nkth cluster, divided by the total number of observations in the kth cluster.\nCombining (12.15) and (12.16) gives the optimization problem that defines\nK-means clustering,\nminimize\nC1,...,CK\n\u23a7\u23a8\n\u23a9\n0K\nk=1\n1\n|Ck|\n0\ni,i\u2032\u2208Ck\n0p\nj=1\n(xij \u2212 xi\u2032j)2\n\u23ab\u23ac\n\u23ad. (12.17)\nNow, we would like to find an algorithm to solve (12.17)\u2014that is, a\nmethod to partition the observations into K clusters such that the objective\n12.4 Clustering Methods 519\nof (12.17) is minimized. This is in fact a very difficult problem to solve\nprecisely, since there are almost Kn ways to partition n observations into K\nclusters. This is a huge number unless K and n are tiny! Fortunately, a very\nsimple algorithm can be shown to provide a local optimum\u2014a pretty good\nsolution\u2014to the K-means optimization problem (12.17). This approach is\nlaid out in Algorithm 12.2.\nAlgorithm 12.2 K-Means Clustering\n1. Randomly assign a number, from 1 to K, to each of the observations.\nThese serve as initial cluster assignments for the observations.\n2. Iterate until the cluster assignments stop changing:\n(a) For each of the K clusters, compute the cluster centroid. The\nkth cluster centroid is the vector of the p feature means for the\nobservations in the kth cluster.\n(b) Assign each observation to the cluster whose centroid is closest\n(where closest is defined using Euclidean distance).\nAlgorithm 12.2 is guaranteed to decrease the value of the objective\n(12.17) at each step. To understand why, the following identity is illuminating:\n1\n|Ck|\n0\ni,i\u2032\u2208Ck\n0p\nj=1\n(xij \u2212 xi\u2032j)2 = 2\n0\ni\u2208Ck\n0p\nj=1\n(xij \u2212 \u00afxkj)2, (12.18)\nwhere \u00afxkj = 1\n|Ck|\n)\ni\u2208Ck\nxij is the mean for feature j in cluster Ck.\nIn Step 2(a) the cluster means for each feature are the constants that\nminimize the sum-of-squared deviations, and in Step 2(b), reallocating the\nobservations can only improve (12.18). This means that as the algorithm\nis run, the clustering obtained will continually improve until the result no\nlonger changes; the objective of (12.17) will never increase. When the result\nno longer changes, a local optimum has been reached. Figure 12.8 shows\nthe progression of the algorithm on the toy example from Figure 12.7.\nK-means clustering derives its name from the fact that in Step 2(a), the\ncluster centroids are computed as the mean of the observations assigned to\neach cluster.\nBecause the K-means algorithm finds a local rather than a global optimum,\nthe results obtained will depend on the initial (random) cluster assignment\nof each observation in Step 1 of Algorithm 12.2. For this reason,\nit is important to run the algorithm multiple times from different random\ninitial configurations. Then one selects the best solution, i.e. that", "doc_id": "3a6594b0-73c6-497b-a8d0-e51ee6c21e08", "embedding": null, "doc_hash": "c88f753b5706c9883e045773854095736e718d4e85a39d9859995388f2fa03d4", "extra_info": null, "node_info": {"start": 1170548, "end": 1173621, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "2eed722b-6fa6-49f6-9a14-b47a57e77e6d", "3": "e11ffff3-34e0-46e7-b77f-2db36ad95198"}}, "__type__": "1"}, "e11ffff3-34e0-46e7-b77f-2db36ad95198": {"__data__": {"text": "random\ninitial configurations. Then one selects the best solution, i.e. that for which\nthe objective (12.17) is smallest. Figure 12.9 shows the local optima obtained\nby running K-means clustering six times using six different initial\n520 12. Unsupervised Learning\nData Step 1 Iteration 1, Step 2a\nIteration 1, Step 2b Iteration 2, Step 2a Final Results\nFIGURE 12.8. The progress of the K-means algorithm on the example of Figure\n12.7 with K=3. Top left: the observations are shown. Top center: in Step 1\nof the algorithm, each observation is randomly assigned to a cluster. Top right:\nin Step 2(a), the cluster centroids are computed. These are shown as large colored\ndisks. Initially the centroids are almost completely overlapping because the\ninitial cluster assignments were chosen at random. Bottom left: in Step 2(b),\neach observation is assigned to the nearest centroid. Bottom center: Step 2(a) is\nonce again performed, leading to new cluster centroids. Bottom right: the results\nobtained after ten iterations.\ncluster assignments, using the toy data from Figure 12.7. In this case, the\nbest clustering is the one with an objective value of 235.8.\nAs we have seen, to perform K-means clustering, we must decide how\nmany clusters we expect in the data. The problem of selecting K is far from\nsimple. This issue, along with other practical considerations that arise in\nperforming K-means clustering, is addressed in Section 12.4.3.\n12.4 Clustering Methods 521\n320.9 235.8 235.8\n235.8 235.8 310.9\nFIGURE 12.9. K-means clustering performed six times on the data from Figure\n12.7 with K = 3, each time with a different random assignment of the observations\nin Step 1 of the K-means algorithm. Above each plot is the value of\nthe objective (12.17). Three different local optima were obtained, one of which\nresulted in a smaller value of the objective and provides better separation between\nthe clusters. Those labeled in red all achieved the same best solution, with an\nobjective value of 235.8.\n12.4.2 Hierarchical Clustering\nOne potential disadvantage of K-means clustering is that it requires us to\npre-specify the number of clusters K. Hierarchical clustering is an alternative\napproach which does not require that we commit to a particular\nchoice of K. Hierarchical clustering has an added advantage over K-means\nclustering in that it results in an attractive tree-based representation of the\nobservations, called a dendrogram.\nIn this section, we describe bottom-up or agglomerative clustering.\nbottom-up\nagglomerative\nThis is the most common type of hierarchical clustering, and refers to\n522 12. Unsupervised Learning\n\u22126 \u22124 \u22122 0 2\n\u22122 0 2 4\nX1\nX2\nFIGURE 12.10. Forty-five observations generated in two-dimensional space. In\nreality there are three distinct classes, shown in separate colors. However, we will\ntreat these class labels as unknown and will seek to cluster the observations in\norder to discover the classes from the data.\nthe fact that a dendrogram (generally depicted as an upside-down tree; see\nFigure 12.11) is built starting from the leaves and combining clusters up to\nthe trunk.We will begin with a discussion of how to interpret a dendrogram\nand then discuss how hierarchical clustering is actually performed\u2014that is,\nhow the dendrogram is built.\nInterpreting a Dendrogram\nWe begin with the simulated data set shown in Figure 12.10, consisting of\n45 observations in two-dimensional space. The data were generated from a\nthree-class model; the true class labels for each observation are shown in\ndistinct colors. However, suppose that the data were observed without the\nclass labels, and that we wanted to", "doc_id": "e11ffff3-34e0-46e7-b77f-2db36ad95198", "embedding": null, "doc_hash": "b3b6fba3041ca4da1c9a69f99757dcd6900949932948bfa77d8b447cd8bd8ddc", "extra_info": null, "node_info": {"start": 1173622, "end": 1177254, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "3a6594b0-73c6-497b-a8d0-e51ee6c21e08", "3": "b32f7654-af3d-469f-be55-7b3b96100a65"}}, "__type__": "1"}, "b32f7654-af3d-469f-be55-7b3b96100a65": {"__data__": {"text": "that the data were observed without the\nclass labels, and that we wanted to perform hierarchical clustering of the\ndata. Hierarchical clustering (with complete linkage, to be discussed later)\nyields the result shown in the left-hand panel of Figure 12.11. How can we\ninterpret this dendrogram?\nIn the left-hand panel of Figure 12.11, each leaf of the dendrogram represents\none of the 45 observations in Figure 12.10. However, as we move\nup the tree, some leaves begin to fuse into branches. These correspond to\nobservations that are similar to each other. As we move higher up the tree,\nbranches themselves fuse, either with leaves or other branches. The earlier\n(lower in the tree) fusions occur, the more similar the groups of observations\nare to each other. On the other hand, observations that fuse later\n(near the top of the tree) can be quite different. In fact, this statement\ncan be made precise: for any two observations, we can look for the point in\n12.4 Clustering Methods 523\n0 2 4 6 8 10\n0 2 4 6 8 10\n0 2 4 6 8 10\nFIGURE 12.11. Left: dendrogram obtained from hierarchically clustering the\ndata from Figure 12.10 with complete linkage and Euclidean distance. Center:\nthe dendrogram from the left-hand panel, cut at a height of nine (indicated by the\ndashed line). This cut results in two distinct clusters, shown in different colors.\nRight: the dendrogram from the left-hand panel, now cut at a height of five. This\ncut results in three distinct clusters, shown in different colors. Note that the colors\nwere not used in clustering, but are simply used for display purposes in this figure.\nthe tree where branches containing those two observations are first fused.\nThe height of this fusion, as measured on the vertical axis, indicates how\ndifferent the two observations are. Thus, observations that fuse at the very\nbottom of the tree are quite similar to each other, whereas observations\nthat fuse close to the top of the tree will tend to be quite different.\nThis highlights a very important point in interpreting dendrograms that\nis often misunderstood. Consider the left-hand panel of Figure 12.12, which\nshows a simple dendrogram obtained from hierarchically clustering nine\nobservations. One can see that observations 5 and 7 are quite similar to\neach other, since they fuse at the lowest point on the dendrogram. Observations\n1 and 6 are also quite similar to each other. However, it is tempting\nbut incorrect to conclude from the figure that observations 9 and 2 are\nquite similar to each other on the basis that they are located near each\nother on the dendrogram. In fact, based on the information contained in\nthe dendrogram, observation 9 is no more similar to observation 2 than it\nis to observations 8, 5, and 7. (This can be seen from the right-hand panel\nof Figure 12.12, in which the raw data are displayed.) To put it mathematically,\nthere are 2n\u22121 possible reorderings of the dendrogram, where n\nis the number of leaves. This is because at each of the n \u2212 1 points where\nfusions occur, the positions of the two fused branches could be swapped\nwithout affecting the meaning of the dendrogram. Therefore, we cannot\ndraw conclusions about the similarity of two observations based on their\nproximity along the horizontal axis. Rather, we draw conclusions about\n524 12. Unsupervised Learning\n3\n4\n1\n6\n9\n2\n8\n5\n7\n0.0 0.5 1.0 1.5 2.0 2.5 3.0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\u22121.5 \u22121.0 \u22120.5 0.0 0.5 1.0\n\u22121.5 \u22121.0 \u22120.5 0.0 0.5\nX1\nX2\nFIGURE 12.12. An illustration of how to properly interpret a dendrogram with\nnine observations in", "doc_id": "b32f7654-af3d-469f-be55-7b3b96100a65", "embedding": null, "doc_hash": "23860c3990bc67dced5da49fd93d3754f248c607139ad017d97d94fb4fbb3bb2", "extra_info": null, "node_info": {"start": 1177259, "end": 1180794, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "e11ffff3-34e0-46e7-b77f-2db36ad95198", "3": "24665681-a5ce-42e4-90de-41acc954664b"}}, "__type__": "1"}, "24665681-a5ce-42e4-90de-41acc954664b": {"__data__": {"text": "illustration of how to properly interpret a dendrogram with\nnine observations in two-dimensional space. Left: a dendrogram generated using\nEuclidean distance and complete linkage. Observations 5 and 7 are quite similar\nto each other, as are observations 1 and 6. However, observation 9 is no more\nsimilar to observation 2 than it is to observations 8, 5, and 7, even though observations\n9 and 2 are close together in terms of horizontal distance. This is because\nobservations 2, 8, 5, and 7 all fuse with observation 9 at the same height, approximately\n1.8. Right: the raw data used to generate the dendrogram can be used to\nconfirm that indeed, observation 9 is no more similar to observation 2 than it is\nto observations 8, 5, and 7.\nthe similarity of two observations based on the location on the vertical axis\nwhere branches containing those two observations first are fused.\nNow that we understand how to interpret the left-hand panel of Figure\n12.11, we can move on to the issue of identifying clusters on the basis\nof a dendrogram. In order to do this, we make a horizontal cut across the\ndendrogram, as shown in the center and right-hand panels of Figure 12.11.\nThe distinct sets of observations beneath the cut can be interpreted as clusters.\nIn the center panel of Figure 12.11, cutting the dendrogram at a height\nof nine results in two clusters, shown in distinct colors. In the right-hand\npanel, cutting the dendrogram at a height of five results in three clusters.\nFurther cuts can be made as one descends the dendrogram in order to obtain\nany number of clusters, between 1 (corresponding to no cut) and n\n(corresponding to a cut at height 0, so that each observation is in its own\ncluster). In other words, the height of the cut to the dendrogram serves\nthe same role as the K in K-means clustering: it controls the number of\nclusters obtained.\nFigure 12.11 therefore highlights a very attractive aspect of hierarchical\nclustering: one single dendrogram can be used to obtain any number of\nclusters. In practice, people often look at the dendrogram and select by eye\na sensible number of clusters, based on the heights of the fusion and the\nnumber of clusters desired. In the case of Figure 12.11, one might choose\n12.4 Clustering Methods 525\nto select either two or three clusters. However, often the choice of where to\ncut the dendrogram is not so clear.\nThe term hierarchical refers to the fact that clusters obtained by cutting\nthe dendrogram at a given height are necessarily nested within the clusters\nobtained by cutting the dendrogram at any greater height. However, on\nan arbitrary data set, this assumption of hierarchical structure might be\nunrealistic. For instance, suppose that our observations correspond to a\ngroup of men and women, evenly split among Americans, Japanese, and\nFrench. We can imagine a scenario in which the best division into two\ngroups might split these people by gender, and the best division into three\ngroups might split them by nationality. In this case, the true clusters are\nnot nested, in the sense that the best division into three groups does not\nresult from taking the best division into two groups and splitting up one\nof those groups. Consequently, this situation could not be well-represented\nby hierarchical clustering. Due to situations such as this one, hierarchical\nclustering can sometimes yield worse (i.e. less accurate) results than Kmeans\nclustering for a given number of clusters.\nThe Hierarchical Clustering Algorithm\nThe hierarchical clustering dendrogram is obtained via an extremely simple\nalgorithm.We begin by defining some sort of dissimilarity measure between\neach pair of observations. Most often, Euclidean distance is used; we will\ndiscuss the choice of dissimilarity measure later in this chapter. The algorithm\nproceeds iteratively. Starting out at the bottom of the dendrogram,\neach of the n", "doc_id": "24665681-a5ce-42e4-90de-41acc954664b", "embedding": null, "doc_hash": "8ac99abec660c535bd316e7efeba5c30bfd5977b711bcfff5034e7e2811d462b", "extra_info": null, "node_info": {"start": 1180788, "end": 1184664, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "b32f7654-af3d-469f-be55-7b3b96100a65", "3": "768ef977-89ca-42db-b4f1-b711f6e53789"}}, "__type__": "1"}, "768ef977-89ca-42db-b4f1-b711f6e53789": {"__data__": {"text": "iteratively. Starting out at the bottom of the dendrogram,\neach of the n observations is treated as its own cluster. The two clusters\nthat are most similar to each other are then fused so that there now are\nn\u22121 clusters. Next the two clusters that are most similar to each other are\nfused again, so that there now are n \u2212 2 clusters. The algorithm proceeds\nin this fashion until all of the observations belong to one single cluster, and\nthe dendrogram is complete. Figure 12.13 depicts the first few steps of the\nalgorithm, for the data from Figure 12.12. To summarize, the hierarchical\nclustering algorithm is given in Algorithm 12.3.\nThis algorithm seems simple enough, but one issue has not been addressed.\nConsider the bottom right panel in Figure 12.13. How did we\ndetermine that the cluster {5, 7} should be fused with the cluster {8}?\nWe have a concept of the dissimilarity between pairs of observations, but\nhow do we define the dissimilarity between two clusters if one or both of\nthe clusters contains multiple observations? The concept of dissimilarity\nbetween a pair of observations needs to be extended to a pair of groups\nof observations. This extension is achieved by developing the notion of\nlinkage, which defines the dissimilarity between two groups of observalinkage\ntions. The four most common types of linkage\u2014complete, average, single,\nand centroid\u2014are briefly described in Table 12.3. Average, complete, and\n526 12. Unsupervised Learning\nAlgorithm 12.3 Hierarchical Clustering\n1. Begin with n observations and a measure (such as Euclidean distance)\nof all the\n'n\n2\n(\n= n(n\u22121)/2 pairwise dissimilarities. Treat each\nobservation as its own cluster.\n2. For i = n, n \u2212 1, . . . , 2:\n(a) Examine all pairwise inter-cluster dissimilarities among the i\nclusters and identify the pair of clusters that are least dissimilar\n(that is, most similar). Fuse these two clusters. The dissimilarity\nbetween these two clusters indicates the height in the dendrogram\nat which the fusion should be placed.\n(b) Compute the new pairwise inter-cluster dissimilarities among\nthe i \u2212 1 remaining clusters.\nLinkage Description\nComplete\nMaximal intercluster dissimilarity. Compute all pairwise dissimilarities\nbetween the observations in cluster A and the\nobservations in cluster B, and record the largest of these\ndissimilarities.\nSingle\nMinimal intercluster dissimilarity. Compute all pairwise dissimilarities\nbetween the observations in cluster A and the\nobservations in cluster B, and record the smallest of these\ndissimilarities. Single linkage can result in extended, trailing\nclusters in which single observations are fused one-at-a-time.\nAverage\nMean intercluster dissimilarity. Compute all pairwise dissimilarities\nbetween the observations in cluster A and the\nobservations in cluster B, and record the average of these\ndissimilarities.\nCentroid\nDissimilarity between the centroid for cluster A (a mean\nvector of length p) and the centroid for cluster B. Centroid\nlinkage can result in undesirable inversions.\nTABLE 12.3. A summary of the four most commonly-used types of linkage in\nhierarchical clustering.\nsingle linkage are most popular among statisticians. Average and complete\nlinkage are generally preferred over single linkage, as they tend to yield\nmore balanced dendrograms. Centroid linkage is often used in genomics,\nbut suffers from a major drawback in that an inversion can occur, whereby\ninversion\ntwo clusters are fused at a height below either of the individual clusters in\nthe dendrogram. This can lead to difficulties in visualization as well as in interpretation\nof the dendrogram. The dissimilarities computed in Step 2(b)\nof the hierarchical clustering algorithm", "doc_id": "768ef977-89ca-42db-b4f1-b711f6e53789", "embedding": null, "doc_hash": "7add91d5f5b9b451ccfc85fafbe574d6d6c60f390fb1d3af9b641992ac9c7b74", "extra_info": null, "node_info": {"start": 1184674, "end": 1188363, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "24665681-a5ce-42e4-90de-41acc954664b", "3": "10d6f798-87da-43a5-82d4-594ea0a7aa8d"}}, "__type__": "1"}, "10d6f798-87da-43a5-82d4-594ea0a7aa8d": {"__data__": {"text": "computed in Step 2(b)\nof the hierarchical clustering algorithm will depend on the type of linkage\n12.4 Clustering Methods 527\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\u22121.5 \u22121.0 \u22120.5 0.0 0.5 1.0\n\u22121.5 \u22121.0 \u22120.5 0.0 0.5\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\u22121.5 \u22121.0 \u22120.5 0.0 0.5 1.0\n\u22121.5 \u22121.0 \u22120.5 0.0 0.5\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\u22121.5 \u22121.0 \u22120.5 0.0 0.5 1.0\n\u22121.5 \u22121.0 \u22120.5 0.0 0.5\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\u22121.5 \u22121.0 \u22120.5 0.0 0.5 1.0\n\u22121.5 \u22121.0 \u22120.5 0.0 0.5\nX1 X1\nX1 X1\nX2\nX2\nX2\nX2\nFIGURE 12.13. An illustration of the first few steps of the hierarchical\nclustering algorithm, using the data from Figure 12.12, with complete linkage\nand Euclidean distance. Top Left: initially, there are nine distinct clusters,\n{1}, {2}, . . . , {9}. Top Right: the two clusters that are closest together, {5} and\n{7}, are fused into a single cluster. Bottom Left: the two clusters that are closest\ntogether, {6} and {1}, are fused into a single cluster. Bottom Right: the two clusters\nthat are closest together using complete linkage, {8} and the cluster {5, 7},\nare fused into a single cluster.\nused, as well as on the choice of dissimilarity measure. Hence, the resulting\ndendrogram typically depends quite strongly on the type of linkage used,\nas is shown in Figure 12.14.\nChoice of Dissimilarity Measure\nThus far, the examples in this chapter have used Euclidean distance as the\ndissimilarity measure. But sometimes other dissimilarity measures might\nbe preferred. For example, correlation-based distance considers two observations\nto be similar if their features are highly correlated, even though the\n528 12. Unsupervised Learning\nAverage Linkage Complete Linkage Single Linkage\nFIGURE 12.14. Average, complete, and single linkage applied to an example\ndata set. Average and complete linkage tend to yield more balanced clusters.\nobserved values may be far apart in terms of Euclidean distance. This is\nan unusual use of correlation, which is normally computed between variables;\nhere it is computed between the observation profiles for each pair\nof observations. Figure 12.15 illustrates the difference between Euclidean\nand correlation-based distance. Correlation-based distance focuses on the\nshapes of observation profiles rather than their magnitudes.\nThe choice of dissimilarity measure is very important, as it has a strong\neffect on the resulting dendrogram. In general, careful attention should be\npaid to the type of data being clustered and the scientific question at hand.\nThese considerations should determine what type of dissimilarity measure\nis used for hierarchical clustering.\nFor instance, consider an online retailer interested in clustering shoppers\nbased on their past shopping histories. The goal is to identify subgroups\nof similar shoppers, so that shoppers within each subgroup can be shown\nitems and advertisements that are particularly likely to interest them. Suppose\nthe data takes the form of a matrix where the rows are the shoppers\nand the columns are the items available for purchase; the elements of the\ndata matrix indicate the number of times a given shopper has purchased a\ngiven item (i.e. a 0 if the shopper has never purchased this item, a 1 if the\nshopper has purchased it once, etc.) What type of", "doc_id": "10d6f798-87da-43a5-82d4-594ea0a7aa8d", "embedding": null, "doc_hash": "e4101a0b3a5b39a438599f08c9574cedd56e96fe5783464e196427deadd0c00e", "extra_info": null, "node_info": {"start": 1188370, "end": 1191540, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "768ef977-89ca-42db-b4f1-b711f6e53789", "3": "b1011d14-f38d-4a84-a75e-a918e03b3c29"}}, "__type__": "1"}, "b1011d14-f38d-4a84-a75e-a918e03b3c29": {"__data__": {"text": "a 1 if the\nshopper has purchased it once, etc.) What type of dissimilarity measure\nshould be used to cluster the shoppers? If Euclidean distance is used, then\nshoppers who have bought very few items overall (i.e. infrequent users of\nthe online shopping site) will be clustered together. This may not be desirable.\nOn the other hand, if correlation-based distance is used, then shoppers\n12.4 Clustering Methods 529\n5 10 15 20\n0 5 10 15 20\nVariable Index\nObservation 1\nObservation 2\nObservation 3\n1\n2\n3\nFIGURE 12.15. Three observations with measurements on 20 variables are\nshown. Observations 1 and 3 have similar values for each variable and so there\nis a small Euclidean distance between them. But they are very weakly correlated,\nso they have a large correlation-based distance. On the other hand, observations\n1 and 2 have quite different values for each variable, and so there is a large\nEuclidean distance between them. But they are highly correlated, so there is a\nsmall correlation-based distance between them.\nwith similar preferences (e.g. shoppers who have bought items A and B but\nnever items C or D) will be clustered together, even if some shoppers with\nthese preferences are higher-volume shoppers than others. Therefore, for\nthis application, correlation-based distance may be a better choice.\nIn addition to carefully selecting the dissimilarity measure used, one must\nalso consider whether or not the variables should be scaled to have standard\ndeviation one before the dissimilarity between the observations is\ncomputed. To illustrate this point, we continue with the online shopping\nexample just described. Some items may be purchased more frequently than\nothers; for instance, a shopper might buy ten pairs of socks a year, but a\ncomputer very rarely. High-frequency purchases like socks therefore tend\nto have a much larger effect on the inter-shopper dissimilarities, and hence\non the clustering ultimately obtained, than rare purchases like computers.\nThis may not be desirable. If the variables are scaled to have standard deviation\none before the inter-observation dissimilarities are computed, then\neach variable will in effect be given equal importance in the hierarchical\nclustering performed. We might also want to scale the variables to have\nstandard deviation one if they are measured on different scales; otherwise,\nthe choice of units (e.g. centimeters versus kilometers) for a particular variable\nwill greatly affect the dissimilarity measure obtained. It should come\nas no surprise that whether or not it is a good decision to scale the variables\nbefore computing the dissimilarity measure depends on the application at\n530 12. Unsupervised Learning\nSocks Computers\n0 2 4 6 8 10\nSocks Computers\n0.0 0.2 0.4 0.6 0.8 1.0 1.2\nSocks Computers\n0 500 1000 1500\nFIGURE 12.16. An eclectic online retailer sells two items: socks and computers.\nLeft: the number of pairs of socks, and computers, purchased by eight online\nshoppers is displayed. Each shopper is shown in a different color. If inter-observation\ndissimilarities are computed using Euclidean distance on the raw variables,\nthen the number of socks purchased by an individual will drive the dissimilarities\nobtained, and the number of computers purchased will have little effect. This\nmight be undesirable, since (1) computers are more expensive than socks and so\nthe online retailer may be more interested in encouraging shoppers to buy computers\nthan socks, and (2) a large difference in the number of socks purchased by two\nshoppers may be less informative about the shoppers\u2019 overall shopping preferences\nthan a small difference in the number of computers purchased. Center: the same\ndata are shown, after scaling each variable by its standard deviation. Now the\ntwo products will have a comparable effect on the inter-observation", "doc_id": "b1011d14-f38d-4a84-a75e-a918e03b3c29", "embedding": null, "doc_hash": "c1566c8554d64e440d4f486649ae20d312e55d04c5a9207410027b51821f5dd1", "extra_info": null, "node_info": {"start": 1191547, "end": 1195368, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "10d6f798-87da-43a5-82d4-594ea0a7aa8d", "3": "2e841ef2-1686-45bb-a3e4-00beeb73dabb"}}, "__type__": "1"}, "2e841ef2-1686-45bb-a3e4-00beeb73dabb": {"__data__": {"text": "Now the\ntwo products will have a comparable effect on the inter-observation dissimilarities\nobtained. Right: the same data are displayed, but now the y-axis represents the\nnumber of dollars spent by each online shopper on socks and on computers. Since\ncomputers are much more expensive than socks, now computer purchase history\nwill drive the inter-observation dissimilarities obtained.\nhand. An example is shown in Figure 12.16. We note that the issue of\nwhether or not to scale the variables before performing clustering applies\nto K-means clustering as well.\n12.4.3 Practical Issues in Clustering\nClustering can be a very useful tool for data analysis in the unsupervised\nsetting. However, there are a number of issues that arise in performing\nclustering. We describe some of these issues here.\nSmall Decisions with Big Consequences\nIn order to perform clustering, some decisions must be made.\n12.4 Clustering Methods 531\n\u2022 Should the observations or features first be standardized in some way?\nFor instance, maybe the variables should be scaled to have standard\ndeviation one.\n\u2022 In the case of hierarchical clustering,\n\u2013 What dissimilarity measure should be used?\n\u2013 What type of linkage should be used?\n\u2013 Where should we cut the dendrogram in order to obtain clusters?\n\u2022 In the case of K-means clustering, how many clusters should we look\nfor in the data?\nEach of these decisions can have a strong impact on the results obtained.\nIn practice, we try several different choices, and look for the one with\nthe most useful or interpretable solution. With these methods, there is no\nsingle right answer\u2014any solution that exposes some interesting aspects of\nthe data should be considered.\nValidating the Clusters Obtained\nAny time clustering is performed on a data set we will find clusters. But we\nreally want to know whether the clusters that have been found represent\ntrue subgroups in the data, or whether they are simply a result of clustering\nthe noise. For instance, if we were to obtain an independent set of observations,\nthen would those observations also display the same set of clusters?\nThis is a hard question to answer. There exist a number of techniques for\nassigning a p-value to a cluster in order to assess whether there is more\nevidence for the cluster than one would expect due to chance. However,\nthere has been no consensus on a single best approach. More details can\nbe found in ESL.8\nOther Considerations in Clustering\nBoth K-means and hierarchical clustering will assign each observation to\na cluster. However, sometimes this might not be appropriate. For instance,\nsuppose that most of the observations truly belong to a small number of\n(unknown) subgroups, and a small subset of the observations are quite\ndifferent from each other and from all other observations. Then since Kmeans\nand hierarchical clustering force every observation into a cluster, the\nclusters found may be heavily distorted due to the presence of outliers that\ndo not belong to any cluster. Mixture models are an attractive approach\nfor accommodating the presence of such outliers. These amount to a soft\nversion of K-means clustering, and are described in ESL.\n8ESL: The Elements of Statistical Learning by Hastie, Tibshirani and Friedman.\n532 12. Unsupervised Learning\nIn addition, clustering methods generally are not very robust to perturbations\nto the data. For instance, suppose that we cluster n observations,\nand then cluster the observations again after removing a subset of the n\nobservations at random. One would hope that the two sets of clusters obtained\nwould be quite similar, but often this is not the case!\nA Tempered Approach to Interpreting the Results of Clustering\nWe have described some of the issues associated with clustering. However,\nclustering can be a very useful and valid statistical tool if used properly. We\nmentioned that small decisions in how clustering is performed, such as", "doc_id": "2e841ef2-1686-45bb-a3e4-00beeb73dabb", "embedding": null, "doc_hash": "770096459318f9eb2f5358afd3078f6c7b7ecfe9ac131338546089d5aace324d", "extra_info": null, "node_info": {"start": 1195353, "end": 1199260, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "b1011d14-f38d-4a84-a75e-a918e03b3c29", "3": "5c8957ae-04b9-442d-9e75-9b0d46be6559"}}, "__type__": "1"}, "5c8957ae-04b9-442d-9e75-9b0d46be6559": {"__data__": {"text": "We\nmentioned that small decisions in how clustering is performed, such as how\nthe data are standardized and what type of linkage is used, can have a large\neffect on the results. Therefore, we recommend performing clustering with\ndifferent choices of these parameters, and looking at the full set of results\nin order to see what patterns consistently emerge. Since clustering can be\nnon-robust, we recommend clustering subsets of the data in order to get a\nsense of the robustness of the clusters obtained. Most importantly, we must\nbe careful about how the results of a clustering analysis are reported. These\nresults should not be taken as the absolute truth about a data set. Rather,\nthey should constitute a starting point for the development of a scientific\nhypothesis and further study, preferably on an independent data set.\n12.5 Lab: Unsupervised Learning\n12.5.1 Principal Components Analysis\nIn this lab, we perform PCA on the USArrests data set, which is part of\nthe base R package. The rows of the data set contain the 50 states, in\nalphabetical order.\n> states <- row.names(USArrests)\n> states\nThe columns of the data set contain the four variables.\n> names(USArrests)\n[1] \"Murder\" \"Assault\" \"UrbanPop\" \"Rape\"\nWe first briefly examine the data. We notice that the variables have vastly\ndifferent means.\n> apply(USArrests , 2, mean)\nMurder Assault UrbanPop Rape\n7.79 170.76 65.54 21.23\nNote that the apply() function allows us to apply a function\u2014in this case,\nthe mean() function\u2014to each row or column of the data set. The second\ninput here denotes whether we wish to compute the mean of the rows, 1,\nor the columns, 2. We see that there are on average three times as many\n12.5 Lab: Unsupervised Learning 533\nrapes as murders, and more than eight times as many assaults as rapes.\nWe can also examine the variances of the four variables using the apply()\nfunction.\n> apply(USArrests , 2, var)\nMurder Assault UrbanPop Rape\n19.0 6945.2 209.5 87.7\nNot surprisingly, the variables also have vastly different variances: the\nUrbanPop variable measures the percentage of the population in each state\nliving in an urban area, which is not a comparable number to the number\nof rapes in each state per 100,000 individuals. If we failed to scale the\nvariables before performing PCA, then most of the principal components\nthat we observed would be driven by the Assault variable, since it has by\nfar the largest mean and variance. Thus, it is important to standardize the\nvariables to have mean zero and standard deviation one before performing\nPCA.\nWe now perform principal components analysis using the prcomp() funcprcomp()\ntion, which is one of several functions in R that perform PCA.\n> pr.out <- prcomp(USArrests , scale = TRUE)\nBy default, the prcomp() function centers the variables to have mean zero.\nBy using the option scale = TRUE, we scale the variables to have standard\ndeviation one. The output from prcomp() contains a number of useful quantities.\n> names(pr.out)\n[1] \"sdev\" \"rotation\" \"center\" \"scale\" \"x\"\nThe center and scale components correspond to the means and standard\ndeviations of the variables that were used for scaling prior to implementing\nPCA.\n> pr.out$center\nMurder Assault UrbanPop Rape\n7.79 170.76 65.54 21.23\n> pr.out$scale\nMurder Assault UrbanPop Rape\n4.36 83.34 14.47 9.37\nThe rotation matrix provides the principal component loadings; each column\nof pr.out$rotation contains the corresponding principal component\nloading vector.9\n> pr.out$rotation\nPC1 PC2 PC3 PC4\nMurder -0.536 0.418 -0.341 0.649\n9This function names it the rotation", "doc_id": "5c8957ae-04b9-442d-9e75-9b0d46be6559", "embedding": null, "doc_hash": "73955af3e5b82ee5de80c2bad5ff93fdffe91d81a433d47c519f3acce442f99e", "extra_info": null, "node_info": {"start": 1199263, "end": 1202831, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "2e841ef2-1686-45bb-a3e4-00beeb73dabb", "3": "94e01a32-60ac-4c2d-8e75-d5f580606e79"}}, "__type__": "1"}, "94e01a32-60ac-4c2d-8e75-d5f580606e79": {"__data__": {"text": "0.418 -0.341 0.649\n9This function names it the rotation matrix, because when we matrix-multiply the\nX matrix by pr.out$rotation, it gives us the coordinates of the data in the rotated\ncoordinate system. These coordinates are the principal component scores.\n534 12. Unsupervised Learning\nAssault -0.583 0.188 -0.268 -0.743\nUrbanPop -0.278 -0.873 -0.378 0.134\nRape -0.543 -0.167 0.818 0.089\nWe see that there are four distinct principal components. This is to be\nexpected because there are in general min(n \u2212 1, p) informative principal\ncomponents in a data set with n observations and p variables.\nUsing the prcomp() function, we do not need to explicitly multiply the\ndata by the principal component loading vectors in order to obtain the\nprincipal component score vectors. Rather the 50 \u00d7 4 matrix x has as its\ncolumns the principal component score vectors. That is, the kth column is\nthe kth principal component score vector.\n> dim(pr.out$x)\n[1] 50 4\nWe can plot the first two principal components as follows:\n> biplot(pr.out , scale = 0)\nThe scale = 0 argument to biplot() ensures that the arrows are scaled to\nbiplot()\nrepresent the loadings; other values for scale give slightly different biplots\nwith different interpretations.\nNotice that this figure is a mirror image of Figure 12.1. Recall that\nthe principal components are only unique up to a sign change, so we can\nreproduce Figure 12.1 by making a few small changes:\n> pr.out$rotation = -pr.out$rotation\n> pr.out$x = -pr.out$x\n> biplot(pr.out , scale = 0)\nThe prcomp() function also outputs the standard deviation of each principal\ncomponent. For instance, on the USArrests data set, we can access\nthese standard deviations as follows:\n> pr.out$sdev\n[1] 1.575 0.995 0.597 0.416\nThe variance explained by each principal component is obtained by squaring\nthese:\n> pr.var <- pr.out$sdev^2\n> pr.var\n[1] 2.480 0.990 0.357 0.173\nTo compute the proportion of variance explained by each principal component,\nwe simply divide the variance explained by each principal component\nby the total variance explained by all four principal components:\n> pve <- pr.var / sum(pr.var)\n> pve\n[1] 0.6201 0.2474 0.0891 0.0434\nWe see that the first principal component explains 62.0% of the variance\nin the data, the next principal component explains 24.7% of the variance,\n12.5 Lab: Unsupervised Learning 535\nand so forth. We can plot the PVE explained by each component, as well\nas the cumulative PVE, as follows:\n> par(mfrow = c(1, 2))\n> plot(pve , xlab = \"Principal Component\",\nylab = \"Proportion of Variance Explained\", ylim = c(0, 1),\ntype = \"b\")\n> plot(cumsum(pve), xlab = \"Principal Component\",\nylab = \"Cumulative Proportion of Variance Explained\",\nylim = c(0, 1), type = \"b\")\nThe result is shown in Figure 12.3. Note that the function cumsum() comcumsum()\nputes the cumulative sum of the elements of a numeric vector. For instance:\n> a <- c(1, 2, 8, -3)\n> cumsum(a)\n[1] 1 3 11 8\n12.5.2 Matrix Completion\nWe now re-create the analysis carried out on the USArrests data in Section\n12.3. We turn the data frame into a matrix, after centering and scaling\neach column to have mean zero and variance one.\n>", "doc_id": "94e01a32-60ac-4c2d-8e75-d5f580606e79", "embedding": null, "doc_hash": "834e026d0eb0a2eea51ad44a5de557c2694e1a2de794a55d55b6a8d98ac6c220", "extra_info": null, "node_info": {"start": 1202847, "end": 1205993, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "5c8957ae-04b9-442d-9e75-9b0d46be6559", "3": "ff738cc9-e1eb-481d-ae88-5c195909e1d0"}}, "__type__": "1"}, "ff738cc9-e1eb-481d-ae88-5c195909e1d0": {"__data__": {"text": "after centering and scaling\neach column to have mean zero and variance one.\n> X <- data.matrix(scale(USArrests))\n> pcob <- prcomp(X)\n> summary(pcob)\nImportance of components:\nPC1 PC2 PC3 PC4\nStandard deviation 1.5749 0.9949 0.59713 0.41645\nProportion of Variance 0.6201 0.2474 0.08914 0.04336\nCumulative Proportion 0.6201 0.8675 0.95664 1.00000\nWe see that the first principal component explains 62% of the variance.\nWe saw in Section 12.2.2 that solving the optimization problem (12.6)\non a centered data matrix X is equivalent to computing the first M principal\ncomponents of the data. The singular value decomposition (SVD) is\nsingular\nvalue decomposition\na general algorithm for solving (12.6).\n> sX <- svd(X)\n> names(sX)\n[1] \"d\" \"u\" \"v\"\n> round(sX$v, 3)\n[,1] [,2] [,3] [,4]\n[1,] -0.536 0.418 -0.341 0.649\n[2,] -0.583 0.188 -0.268 -0.743\n[3,] -0.278 -0.873 -0.378 0.134\n[4,] -0.543 -0.167 0.818 0.089\nThe svd() function returns three components, u, d, and v. The matrix v\nsvd()\nis equivalent to the loading matrix from principal components (up to an\nunimportant sign flip).\n536 12. Unsupervised Learning\n> pcob$rotation\nPC1 PC2 PC3 PC4\nMurder -0.536 0.418 -0.341 0.649\nAssault -0.583 0.188 -0.268 -0.743\nUrbanPop -0.278 -0.873 -0.378 0.134\nRape -0.543 -0.167 0.818 0.089\nThe matrix u is equivalent to the matrix of standardized scores, and the\nstandard deviations are in the vector d. We can recover the score vectors\nusing the output of svd(). They are identical to the score vectors output\nby prcomp().\n> t(sX$d * t(sX$u))\n[,1] [,2] [,3] [,4]\n[1,] -0.976 1.122 -0.440 0.155\n[2,] -1.931 1.062 2.020 -0.434\n[3,] -1.745 -0.738 0.054 -0.826\n[4,] 0.140 1.109 0.113 -0.182\n[5,] -2.499 -1.527 0.593 -0.339\n...\n> pcob$x\nPC1 PC2 PC3 PC4\nAlabama -0.976 1.122 -0.440 0.155\nAlaska -1.931 1.062 2.020 -0.434\nArizona -1.745 -0.738 0.054 -0.826\nArkansas 0.140 1.109 0.113 -0.182\nCalifornia -2.499 -1.527 0.593 -0.339\n...\nWhile it would be possible to carry out this lab using the prcomp() function,\nhere we use the svd() function in order to illustrate its use.\nWe now omit 20 entries in the 50 \u00d7 2 data matrix at random. We do\nso by first selecting 20 rows (states) at random, and then selecting one of\nthe four entries in each row at random. This ensures that every row has at\nleast three observed values.\n> nomit <- 20\n> set.seed (15)\n> ina <- sample(seq (50) , nomit)\n> inb <- sample (1:4, nomit , replace = TRUE)\n> Xna <- X\n> index.na <- cbind(ina , inb)\n> Xna[index.na] <- NA\nHere, ina", "doc_id": "ff738cc9-e1eb-481d-ae88-5c195909e1d0", "embedding": null, "doc_hash": "71aea9ac6a5f78d5b2788d6447331e77b44e4436a4b1d073b06e6b2c00063153", "extra_info": null, "node_info": {"start": 1205976, "end": 1208458, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "94e01a32-60ac-4c2d-8e75-d5f580606e79", "3": "6f61f3ac-bbfb-4c0e-b3b1-09c833651488"}}, "__type__": "1"}, "6f61f3ac-bbfb-4c0e-b3b1-09c833651488": {"__data__": {"text": ", inb)\n> Xna[index.na] <- NA\nHere, ina contains 20 integers from 1 to 50; this represents the states that\nare selected to contain missing values. And inb contains 20 integers from\n1 to 4, representing the features that contain the missing values for each\nof the selected states. To perform the final indexing, we create index.na,\na two-column matrix whose columns are ina and inb. We have indexed a\nmatrix with a matrix of indices!\nWe now write some code to implement Algorithm 12.1. We first write a\nfunction that takes in a matrix, and returns an approximation to the matrix\n12.5 Lab: Unsupervised Learning 537\nusing the svd() function. This will be needed in Step 2 of Algorithm 12.1.\nAs mentioned earlier, we could do this using the prcomp() function, but\ninstead we use the svd() function for illustration.\n> fit.svd <- function(X, M = 1) {\n+ svdob <-svd(X)\n+ with(svdob ,\nu[, 1:M, drop = FALSE] %*%\n(d[1:M] * t(v[, 1:M, drop = FALSE ]))\n)\n+ }\nHere, we did not bother to explicitly call the return() function to return\na value from fit.svd(); however, the computed quantity is automatically\nreturned by R. We use the with() function to make it a little easier to index\nthe elements of svdob. As an alternative to using with(), we could have\nwritten\nsvdob$u[, 1:M, drop = FALSE] %*%\n(svdob$d[1:M]*t(svdob$v[, 1:M, drop = FALSE]))\ninside the fit.svd() function.\nTo conduct Step 1 of the algorithm, we initialize Xhat \u2014 this is \u02dcX in\nAlgorithm 12.1 \u2014 by replacing the missing values with the column means\nof the non-missing entries.\n> Xhat <- Xna\n> xbar <- colMeans(Xna , na.rm = TRUE)\n> Xhat[index.na] <- xbar[inb]\nBefore we begin Step 2, we set ourselves up to measure the progress of\nour iterations:\n> thresh <- 1e-7\n> rel_err <- 1\n> iter <- 0\n> ismiss <- is.na(Xna)\n> mssold <- mean (( scale(Xna , xbar , FALSE)[!ismiss])^2)\n> mss0 <- mean(Xna[!ismiss ]^2)\nHere ismiss is a new logical matrix with the same dimensions as Xna; a\ngiven element equals TRUE if the corresponding matrix element is missing.\nThis is useful because it allows us to access both the missing and nonmissing\nentries. We store the mean of the squared non-missing elements\nin mss0. We store the mean squared error of the non-missing elements of\nthe old version of Xhat in mssold. We plan to store the mean squared error\nof the non-missing elements of the current version of Xhat in mss, and will\nthen iterate Step 2 of Algorithm 12.1 until the relative error, defined as\n(mssold - mss) / mss0, falls below thresh = 1e-7.10\n10Algorithm 12.1 tells us to iterate Step 2 until (12.14) is no longer decreasing. Determining\nwhether (12.14) is decreasing requires us only to keep track of mssold - mss.\n538 12. Unsupervised Learning\nIn Step 2(a) of Algorithm 12.1, we approximate Xhat using fit.svd();\nwe call this Xapp. In Step 2(b), we use Xapp to update the estimates for\nelements in Xhat that are missing in Xna. Finally, in Step 2(c), we compute\nthe relative error. These three steps are contained in this while() loop:\n> while(rel_err > thresh) {\n+ iter <- iter + 1\n+ # Step 2(a)\n+ Xapp <- fit.svd(Xhat", "doc_id": "6f61f3ac-bbfb-4c0e-b3b1-09c833651488", "embedding": null, "doc_hash": "3830601cd784f30401b73d35a0a1ec9f7170b24b8c4ddda5b58d28823902e70d", "extra_info": null, "node_info": {"start": 1208492, "end": 1211569, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "ff738cc9-e1eb-481d-ae88-5c195909e1d0", "3": "63fc7223-2611-40b3-b057-48d65a5ce209"}}, "__type__": "1"}, "63fc7223-2611-40b3-b057-48d65a5ce209": {"__data__": {"text": "# Step 2(a)\n+ Xapp <- fit.svd(Xhat , M = 1)\n+ # Step 2(b)\n+ Xhat [ ismiss ] <- Xapp [ ismiss ]\n+ # Step 2(c)\n+ mss <- mean ((( Xna - Xapp)[! ismiss ])^2)\n+ rel_ err <- ( mssold - mss ) / mss0\n+ mssold <- mss\n+ cat(\"Iter:\", iter, \"MSS:\", mss,\n+ \"Rel. Err:\", rel_err, \"\\n\")\n+ }\nIter: 1 MSS: 0.3822 Rel. Err: 0.6194\nIter: 2 MSS: 0.3705 Rel. Err: 0.0116\nIter: 3 MSS: 0.3693 Rel. Err: 0.0012\nIter: 4 MSS: 0.3691 Rel. Err: 0.0002\nIter: 5 MSS: 0.3691 Rel. Err: 2.1992e-05\nIter: 6 MSS: 0.3691 Rel. Err: 3.3760e-06\nIter: 7 MSS: 0.3691 Rel. Err: 5.4651e-07\nIter: 8 MSS: 0.3691 Rel. Err: 9.2531e-08\nWe see that after eight iterations, the relative error has fallen below thresh\n= 1e-7, and so the algorithm terminates. When this happens, the mean\nsquared error of the non-missing elements equals 0.369.\nFinally, we compute the correlation between the 20 imputed values and\nthe actual values:\n> cor(Xapp[ismiss], X[ismiss])\n[1] 0.6535\nIn this lab, we implemented Algorithm 12.1 ourselves for didactic purposes.\nHowever, a reader who wishes to apply matrix completion to their\ndata should use the softImpute package on CRAN, which provides a very\nsoftImpute\nefficient implementation of a generalization of this algorithm.\n12.5.3 Clustering\nK-Means Clustering\nThe function kmeans() performs K-means clustering in R. We begin with\nkmeans()\na simple simulated example in which there truly are two clusters in the\nHowever, in practice, we keep track of (mssold - mss) / mss0 instead: this makes\nit so that the number of iterations required for Algorithm 12.1 to converge does not\ndepend on whether we multiplied the raw data X by a constant factor.\n12.5 Lab: Unsupervised Learning 539\ndata: the first 25 observations have a mean shift relative to the next 25\nobservations.\n> set.seed (2)\n> x <- matrix(rnorm (50 * 2), ncol = 2)\n> x[1:25, 1] <- x[1:25, 1] + 3\n> x[1:25, 2] <- x[1:25, 2] - 4\nWe now perform K-means clustering with K = 2.\n> km.out <- kmeans(x, 2, nstart = 20)\nThe cluster assignments of the 50 observations are contained in\nkm.out$cluster.\n> km.out$cluster\n[1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2\n[29] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\nThe K-means clustering perfectly separated the observations into two clusters\neven though we did not supply any group information to kmeans(). We\ncan plot the data, with each observation colored according to its cluster\nassignment.\n> par(mfrow = c(1, 2))\n> plot(x, col = (km.out$cluster + 1),\nmain = \"K-Means Clustering Results with K = 2\",\nxlab = \"\", ylab = \"\", pch = 20, cex = 2)\nHere the observations can be easily plotted because they are two-dimensional.\nIf there were more than two variables then we could instead perform PCA\nand plot the first two principal components score", "doc_id": "63fc7223-2611-40b3-b057-48d65a5ce209", "embedding": null, "doc_hash": "d96a01785ccdeb8fb4c60ab8d00874513304895771e1d4ab619ece53ff61f82d", "extra_info": null, "node_info": {"start": 1211574, "end": 1214318, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "6f61f3ac-bbfb-4c0e-b3b1-09c833651488", "3": "3410287e-5432-4e8a-87a5-bdb86ce996af"}}, "__type__": "1"}, "3410287e-5432-4e8a-87a5-bdb86ce996af": {"__data__": {"text": "then we could instead perform PCA\nand plot the first two principal components score vectors.\nIn this example, we knew that there really were two clusters because\nwe generated the data. However, for real data, in general we do not know\nthe true number of clusters. We could instead have performed K-means\nclustering on this example with K = 3.\n> set.seed (4)\n> km.out <- kmeans(x, 3, nstart = 20)\n> km.out\nK-means clustering with 3 clusters of sizes 17, 23, 10\nCluster means:\n[,1] [,2]\n1 3.7790 -4.5620\n2 -0.3820 -0.0874\n3 2.3002 -2.6962\nClustering vector:\n[1] 1 3 1 3 1 1 1 3 1 3 1 3 1 3 1 3 1 1 1 1 1 3 1 1 1 2 2 2\n[29] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 2 3 2 2 2 2\nWithin cluster sum of squares by cluster:\n[1] 25.7409 52.6770 19.5614\n(between_SS / total_SS = 79.3 %)\nAvailable components:\n540 12. Unsupervised Learning\n[1] \"cluster\" \"centers\" \"totss\"\n[4] \"withinss\" \"tot.withinss\" \"betweenss\"\n[7] \"size\" \"iter\" \"ifault\"\n> plot(x, col = (km.out$cluster + 1),\nmain = \"K-Means Clustering Results with K = 3\",\nxlab = \"\", ylab = \"\", pch = 20, cex = 2)\nWhen K = 3, K-means clustering splits up the two clusters.\nTo run the kmeans() function in R with multiple initial cluster assignments,\nwe use the nstart argument. If a value of nstart greater than one\nis used, then K-means clustering will be performed using multiple random\nassignments in Step 1 of Algorithm 12.2, and the kmeans() function will\nreport only the best results. Here we compare using nstart = 1 to nstart\n= 20.\n> set.seed (4)\n> km.out <- kmeans(x, 3, nstart = 1)\n> km.out$tot.withinss\n[1] 104.3319\n> km.out <- kmeans(x, 3, nstart = 20)\n> km.out$tot.withinss\n[1] 97.9793\nNote that km.out$tot.withinss is the total within-cluster sum of squares,\nwhich we seek to minimize by performing K-means clustering (Equation\n12.17). The individual within-cluster sum-of-squares are contained in the\nvector km.out$withinss.\nWe strongly recommend always running K-means clustering with a large\nvalue of nstart, such as 20 or 50, since otherwise an undesirable local\noptimum may be obtained.\nWhen performing K-means clustering, in addition to using multiple initial\ncluster assignments, it is also important to set a random seed using the\nset.seed() function. This way, the initial cluster assignments in Step 1 can\nbe replicated, and the K-means output will be fully reproducible.\nHierarchical Clustering\nThe hclust() function implements hierarchical clustering in R. In the folhclust()\nlowing example we use the data from the previous lab to plot the hierarchical\nclustering dendrogram using complete, single, and average linkage\nclustering, with Euclidean distance as the dissimilarity measure. We begin\nby clustering observations using complete linkage. The dist() function is\ndist()\nused to compute the 50 \u00d7 50 inter-observation Euclidean distance matrix.\n> hc.complete <- hclust(dist(x), method = \"complete\")\nWe could just as easily perform hierarchical clustering with average or\nsingle linkage instead:\n> hc.average <- hclust(dist(x), method =", "doc_id": "3410287e-5432-4e8a-87a5-bdb86ce996af", "embedding": null, "doc_hash": "36d054f00dce5e863392c132c97b37b31a3848c7906d909430f43c31d7848a76", "extra_info": null, "node_info": {"start": 1214277, "end": 1217276, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "63fc7223-2611-40b3-b057-48d65a5ce209", "3": "f434ef29-1cc4-438a-b9e9-04095722a3c3"}}, "__type__": "1"}, "f434ef29-1cc4-438a-b9e9-04095722a3c3": {"__data__": {"text": "instead:\n> hc.average <- hclust(dist(x), method = \"average\")\n> hc.single <- hclust(dist(x), method = \"single\")\nWe can now plot the dendrograms obtained using the usual plot() function.\nThe numbers at the bottom of the plot identify each observation.\n12.5 Lab: Unsupervised Learning 541\n> par(mfrow = c(1, 3))\n> plot(hc.complete , main = \"Complete Linkage\",\nxlab = \"\", sub = \"\", cex = .9)\n> plot(hc.average , main = \"Average Linkage\",\nxlab = \"\", sub = \"\", cex = .9)\n> plot(hc.single, main = \"Single Linkage\",\nxlab = \"\", sub = \"\", cex = .9)\nTo determine the cluster labels for each observation associated with a\ngiven cut of the dendrogram, we can use the cutree() function:\ncutree()\n> cutree(hc.complete , 2)\n[1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2\n[30] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n> cutree(hc.average , 2)\n[1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2\n[30] 2 2 2 1 2 2 2 2 2 2 2 2 2 2 1 2 1 2 2 2 2\n> cutree(hc.single, 2)\n[1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1\n[30] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\nThe second argument to cutree() is the number of clusters we wish to\nobtain. For this data, complete and average linkage generally separate the\nobservations into their correct groups. However, single linkage identifies one\npoint as belonging to its own cluster. A more sensible answer is obtained\nwhen four clusters are selected, although there are still two singletons.\n> cutree(hc.single, 4)\n[1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 3 3 3 3\n[30] 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3\nTo scale the variables before performing hierarchical clustering of the\nobservations, we use the scale() function:\nscale()\n> xsc <- scale(x)\n> plot(hclust(dist(xsc), method = \"complete\"),\nmain = \"Hierarchical Clustering with Scaled Features\")\nCorrelation-based distance can be computed using the as.dist() funcas.\ndist()\ntion, which converts an arbitrary square symmetric matrix into a form that\nthe hclust() function recognizes as a distance matrix. However, this only\nmakes sense for data with at least three features since the absolute correlation\nbetween any two observations with measurements on two features is\nalways 1. Hence, we will cluster a three-dimensional data set. This data set\ndoes not contain any true clusters.\n> x <- matrix(rnorm (30 * 3), ncol = 3)\n> dd <- as.dist (1 - cor(t(x)))\n> plot(hclust(dd, method = \"complete\"),\nmain = \"Complete Linkage with Correlation -Based Distance\",\nxlab = \"\", sub = \"\")\n542 12. Unsupervised Learning\n12.5.4 NCI60 Data Example\nUnsupervised techniques are often used in the analysis of genomic data.\nIn particular, PCA and hierarchical clustering are popular tools. We illustrate\nthese techniques on the NCI60 cancer cell line microarray data, which\nconsists of 6,830 gene expression measurements on 64 cancer cell lines.\n> library(ISLR2)\n> nci.labs <- NCI60$labs\n> nci.data <- NCI60$data\nEach cell line is", "doc_id": "f434ef29-1cc4-438a-b9e9-04095722a3c3", "embedding": null, "doc_hash": "29f6d08c668153446f4de68584820eab8574bed7f8652671e122d8c36b77b86d", "extra_info": null, "node_info": {"start": 1217304, "end": 1220247, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "3410287e-5432-4e8a-87a5-bdb86ce996af", "3": "1b9c5276-3fb5-440b-8ca5-c07fa335a947"}}, "__type__": "1"}, "1b9c5276-3fb5-440b-8ca5-c07fa335a947": {"__data__": {"text": "nci.data <- NCI60$data\nEach cell line is labeled with a cancer type, given in nci.labs. We do not\nmake use of the cancer types in performing PCA and clustering, as these\nare unsupervised techniques. But after performing PCA and clustering, we\nwill check to see the extent to which these cancer types agree with the\nresults of these unsupervised techniques.\nThe data has 64 rows and 6,830 columns.\n> dim(nci.data)\n[1] 64 6830\nWe begin by examining the cancer types for the cell lines.\n> nci.labs[1:4]\n[1] \"CNS\" \"CNS\" \"CNS\" \"RENAL\"\n> table(nci.labs)\nnci.labs\nBREAST CNS COLON K562A -repro K562B -repro\n7 5 7 1 1\nLEUKEMIA MCF7A -repro MCF7D -repro MELANOMA NSCLC\n6 1 1 8 9\nOVARIAN PROSTATE RENAL UNKNOWN\n6 2 9 1\nPCA on the NCI60 Data\nWe first perform PCA on the data after scaling the variables (genes) to\nhave standard deviation one, although one could reasonably argue that it\nis better not to scale the genes.\n> pr.out <- prcomp(nci.data , scale = TRUE)\nWe now plot the first few principal component score vectors, in order to\nvisualize the data. The observations (cell lines) corresponding to a given\ncancer type will be plotted in the same color, so that we can see to what\nextent the observations within a cancer type are similar to each other. We\nfirst create a simple function that assigns a distinct color to each element\nof a numeric vector. The function will be used to assign a color to each of\nthe 64 cell lines, based on the cancer type to which it corresponds.\n> Cols <- function(vec) {\n+ cols <-rainbow(length(unique(vec)))\n+ return(cols[as.numeric(as.factor(vec))])\n+ }\n12.5 Lab: Unsupervised Learning 543\n\u221240 \u221220 0 20 40 60\n\u221260 \u221240 \u221220 0 20\n\u221240 \u221220 0 20 40 60\n\u221240 \u221220 0 20 40\nZ1 Z1\nZ2\nZ3\nFIGURE 12.17. Projections of the NCI60 cancer cell lines onto the first three\nprincipal components (in other words, the scores for the first three principal components).\nOn the whole, observations belonging to a single cancer type tend to\nlie near each other in this low-dimensional space. It would not have been possible\nto visualize the data without using a dimension reduction method such as PCA,\nsince based on the full data set there are\n.6,830\n2\n/\npossible scatterplots, none of\nwhich would have been particularly informative.\nNote that the rainbow() function takes as its argument a positive integer,\nrainbow()\nand returns a vector containing that number of distinct colors. We now can\nplot the principal component score vectors.\n> par(mfrow = c(1, 2))\n> plot(pr.out$x[, 1:2], col = Cols(nci.labs), pch = 19,\nxlab = \"Z1\", ylab = \"Z2\")\n> plot(pr.out$x[, c(1, 3)], col = Cols(nci.labs), pch = 19,\nxlab = \"Z1\", ylab = \"Z3\")\nThe resulting plots are shown in Figure 12.17. On the whole, cell lines\ncorresponding to a single cancer type do tend to have similar values on the\nfirst few principal component score vectors. This indicates that cell lines\nfrom the same cancer type tend to have pretty similar gene expression\nlevels.\nWe can obtain a summary of the proportion of variance explained (PVE)\nof the first few principal components using the summary() method for a\nprcomp object (we have truncated the printout):\n> summary(pr.out)\nImportance of components:\nPC1 PC2 PC3", "doc_id": "1b9c5276-3fb5-440b-8ca5-c07fa335a947", "embedding": null, "doc_hash": "694ec3c5e66eac1dc081d5dc56108ccaa056c9b9dcd382a8e445c769cf06c005", "extra_info": null, "node_info": {"start": 1220257, "end": 1223434, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "f434ef29-1cc4-438a-b9e9-04095722a3c3", "3": "586d0e29-2b0a-4e29-ace1-3a4ff4efd3e3"}}, "__type__": "1"}, "586d0e29-2b0a-4e29-ace1-3a4ff4efd3e3": {"__data__": {"text": "summary(pr.out)\nImportance of components:\nPC1 PC2 PC3 PC4 PC5\nStandard deviation 27.853 21.4814 19.8205 17.0326 15.9718\nProportion of Variance 0.114 0.0676 0.0575 0.0425 0.0374\nCumulative Proportion 0.114 0.1812 0.2387 0.2812 0.3185\nUsing the plot() function, we can also plot the variance explained by the\nfirst few principal components.\n> plot(pr.out)\n544 12. Unsupervised Learning\n0 10 20 30 40 50 60\n0 2 4 6 8 10\nPrincipal Component\nPVE\n0 10 20 30 40 50 60\n20 40 60 80 100\nPrincipal Component\nCumulative PVE\nFIGURE 12.18. The PVE of the principal components of the NCI60 cancer cell\nline microarray data set. Left: the PVE of each principal component is shown.\nRight: the cumulative PVE of the principal components is shown. Together, all\nprincipal components explain 100% of the variance.\nNote that the height of each bar in the bar plot is given by squaring the\ncorresponding element of pr.out$sdev. However, it is more informative to\nplot the PVE of each principal component (i.e. a scree plot) and the cumulative\nPVE of each principal component. This can be done with just a\nlittle work.\n> pve <- 100 * pr.out$sdev^2 / sum(pr.out$sdev ^2)\n> par(mfrow = c(1, 2))\n> plot(pve , type = \"o\", ylab = \"PVE\",\nxlab = \"Principal Component\", col = \"blue\")\n> plot(cumsum(pve), type = \"o\", ylab = \"Cumulative PVE\",\nxlab = \"Principal Component\", col = \"brown3\")\n(Note that the elements of pve can also be computed directly from the summary,\nsummary(pr.out)$importance[2, ], and the elements of cumsum(pve)\nare given by summary(pr.out)$importance[3, ].) The resulting plots are\nshown in Figure 12.18. We see that together, the first seven principal components\nexplain around 40% of the variance in the data. This is not a huge\namount of the variance. However, looking at the scree plot, we see that\nwhile each of the first seven principal components explain a substantial\namount of variance, there is a marked decrease in the variance explained\nby further principal components. That is, there is an elbow in the plot\nafter approximately the seventh principal component. This suggests that\nthere may be little benefit to examining more than seven or so principal\ncomponents (though even examining seven principal components may be\ndifficult).\nClustering the Observations of the NCI60 Data\nWe now proceed to hierarchically cluster the cell lines in the NCI60 data,\nwith the goal of finding out whether or not the observations cluster into\ndistinct types of cancer. To begin, we standardize the variables to have\n12.5 Lab: Unsupervised Learning 545\nmean zero and standard deviation one. As mentioned earlier, this step is\noptional and should be performed only if we want each gene to be on the\nsame scale.\n> sd.data <- scale(nci.data)\nWe now perform hierarchical clustering of the observations using complete,\nsingle, and average linkage. Euclidean distance is used as the dissimilarity\nmeasure.\n> par(mfrow = c(1, 3))\n> data.dist <- dist(sd.data)\n> plot(hclust(data.dist), xlab = \"\", sub = \"\", ylab = \"\",\nlabels = nci.labs , main = \"Complete Linkage\")\n> plot(hclust(data.dist , method = \"average\"),\nlabels = nci.labs , main = \"Average Linkage\",\nxlab = \"\", sub = \"\", ylab = \"\")\n> plot(hclust(data.dist , method =", "doc_id": "586d0e29-2b0a-4e29-ace1-3a4ff4efd3e3", "embedding": null, "doc_hash": "a92c79eab5c87b0b5f968b69780ddd59b6f413d9dceaeb01f8814c9190bd4910", "extra_info": null, "node_info": {"start": 1223421, "end": 1226623, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "1b9c5276-3fb5-440b-8ca5-c07fa335a947", "3": "afb10792-2a35-45dc-b1ff-1f17d9e9aa05"}}, "__type__": "1"}, "afb10792-2a35-45dc-b1ff-1f17d9e9aa05": {"__data__": {"text": "ylab = \"\")\n> plot(hclust(data.dist , method = \"single\"),\nlabels = nci.labs , main = \"Single Linkage\",\nxlab = \"\", sub = \"\", ylab = \"\")\nThe results are shown in Figure 12.19. We see that the choice of linkage\ncertainly does affect the results obtained. Typically, single linkage will tend\nto yield trailing clusters: very large clusters onto which individual observations\nattach one-by-one. On the other hand, complete and average linkage\ntend to yield more balanced, attractive clusters. For this reason, complete\nand average linkage are generally preferred to single linkage. Clearly cell\nlines within a single cancer type do tend to cluster together, although the\nclustering is not perfect. We will use complete linkage hierarchical clustering\nfor the analysis that follows.\nWe can cut the dendrogram at the height that will yield a particular\nnumber of clusters, say four:\n> hc.out <- hclust(dist(sd.data))\n> hc.clusters <- cutree(hc.out , 4)\n> table(hc.clusters , nci.labs)\nThere are some clear patterns. All the leukemia cell lines fall in cluster 3,\nwhile the breast cancer cell lines are spread out over three different clusters.\nWe can plot the cut on the dendrogram that produces these four clusters:\n> par(mfrow = c(1, 1))\n> plot(hc.out , labels = nci.labs)\n> abline(h = 139, col = \"red\")\nThe abline() function draws a straight line on top of any existing plot\nin R. The argument h = 139 plots a horizontal line at height 139 on the\ndendrogram; this is the height that results in four distinct clusters. It is easy\nto verify that the resulting clusters are the same as the ones we obtained\nusing cutree(hc.out, 4).\n546 12. Unsupervised Learning\nBREAST\nBREAST\nCNS\nCNS\nRENAL\nBREAST\nNSCLC\nRENAL\nMELANOMA\nOVARIAN\nOVARIAN\nNSCLC\nOVARIAN\nCOLON\nCOLON\nOVARIAN\nPROSTATE\nNSCLC\nNSCLC\nNSCLC\nPROSTATE\nNSCLC\nMELANOMA\nRENAL\nRENAL\nRENAL\nOVARIAN\nUNKNOWN\nOVARIAN\nNSCLC\nCNS\nCNS\nCNS\nNSCLC\nRENAL\nRENAL\nRENAL\nRENAL\nNSCLC\nMELANOMA\nMELANOMA\nMELANOMA\nMELANOMA\nMELANOMA\nMELANOMA\nBREAST\nBREAST\nCOLON\nCOLON\nCOLON\nCOLON\nCOLON\nBREAST\nMCF7A\u2212repro\nBREAST\nMCF7D\u2212repro\nLEUKEMIA\nLEUKEMIA\nLEUKEMIA\nLEUKEMIA\nK562B\u2212repro\nK562A\u2212repro\nLEUKEMIA\nLEUKEMIA\n40 80 120 160\nComplete", "doc_id": "afb10792-2a35-45dc-b1ff-1f17d9e9aa05", "embedding": null, "doc_hash": "9e4a458cb0626a3bab4545f5cee203ce70b200636406ca18337b82c410ed57bb", "extra_info": null, "node_info": {"start": 1226634, "end": 1228777, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "586d0e29-2b0a-4e29-ace1-3a4ff4efd3e3", "3": "8e8de8cb-6c28-4757-bbf1-e5a516b37557"}}, "__type__": "1"}, "8e8de8cb-6c28-4757-bbf1-e5a516b37557": {"__data__": {"text": "80 120 160\nComplete Linkage\nLEUKEMIA\nLEUKEMIA\nLEUKEMIA\nLEUKEMIA\nLEUKEMIA\nLEUKEMIA\nK562B\u2212repro\nK562A\u2212repro\nRENAL\nNSCLC\nBREAST\nNSCLC\nBREAST\nMCF7A\u2212repro\nBREAST\nMCF7D\u2212repro\nCOLON\nCOLON\nCOLON\nRENAL\nMELANOMA\nMELANOMA\nBREAST\nBREAST\nMELANOMA\nMELANOMA\nMELANOMA\nMELANOMA\nMELANOMA\nOVARIAN\nOVARIAN\nNSCLC\nOVARIAN\nUNKNOWN\nOVARIAN\nNSCLC\nMELANOMA\nCNS\nCNS\nCNS\nRENAL\nRENAL\nRENAL\nRENAL\nRENAL\nRENAL\nRENAL\nPROSTATE\nNSCLC\nNSCLC\nNSCLC\nNSCLC\nOVARIAN\nPROSTATE\nNSCLC\nCOLON\nCOLON\nOVARIAN\nCOLON\nCOLON\nCNS\nCNS\nBREAST\nBREAST\n40 60 80 100 120\nAverage Linkage\nLEUKEMIA\nRENAL\nBREAST\nLEUKEMIA\nLEUKEMIA\nCNS\nLEUKEMIA\nLEUKEMIA\nK562B\u2212repro\nK562A\u2212repro\nNSCLC\nLEUKEMIA\nOVARIAN\nNSCLC\nCNS\nBREAST\nNSCLC\nOVARIAN\nCOLON\nBREAST\nMELANOMA\nRENAL\nMELANOMA\nBREAST\nBREAST\nMELANOMA\nMELANOMA\nMELANOMA\nMELANOMA\nMELANOMA\nBREAST\nOVARIAN\nCOLON\nMCF7A\u2212repro\nBREAST\nMCF7D\u2212repro\nUNKNOWN\nOVARIAN\nNSCLC\nNSCLC\nPROSTATE\nMELANOMA\nCOLON\nOVARIAN\nNSCLC\nRENAL\nCOLON\nPROSTATE\nCOLON\nOVARIAN\nCOLON\nCOLON\nNSCLC\nNSCLC\nRENAL\nNSCLC\nRENAL\nRENAL\nRENAL\nRENAL\nRENAL\nCNS\nCNS\nCNS\n40 60 80 100\nSingle Linkage\nFIGURE 12.19. The NCI60 cancer cell line microarray data, clustered with average,\ncomplete, and single linkage, and using Euclidean distance as the dissimilarity\nmeasure. Complete and average linkage tend to yield evenly sized clusters\nwhereas single linkage tends to yield extended clusters to which single leaves are\nfused one by one.\n12.5 Lab: Unsupervised Learning 547\nPrinting the output of hclust gives a useful brief summary of the object:\n> hc.out\nCall:\nhclust(d = dist(sd.data))\nCluster method : complete\nDistance : euclidean\nNumber of objects: 64\nWe claimed earlier in Section 12.4.2 that K-means clustering and hierarchical\nclustering with the dendrogram cut to obtain the same number\nof clusters can yield very different results. How do these NCI60 hierarchical\nclustering results compare to what we get if we perform K-means clustering\nwith K = 4?\n> set.seed (2)\n> km.out <- kmeans(sd.data, 4, nstart = 20)\n> km.clusters <- km.out$cluster\n> table(km.clusters , hc.clusters)\nhc.clusters\nkm.clusters 1 2 3 4\n1 11 0 0 9\n2 20 7 0 0\n3 9 0 0 0\n4 0 0 8 0\nWe see that the four clusters obtained using hierarchical clustering and Kmeans\nclustering are somewhat different. Cluster 4 in K-means clustering is\nidentical to cluster 3 in hierarchical clustering. However, the other clusters\ndiffer: for instance, cluster 2 in K-means clustering contains a portion of\nthe observations assigned to cluster 1", "doc_id": "8e8de8cb-6c28-4757-bbf1-e5a516b37557", "embedding": null, "doc_hash": "466bc1bef10d4e09e73691b0618b705c5dc24b47f4fca4182623c12f8ce43897", "extra_info": null, "node_info": {"start": 1228800, "end": 1231227, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "afb10792-2a35-45dc-b1ff-1f17d9e9aa05", "3": "28da8162-e475-44e4-8c9b-818e82110e29"}}, "__type__": "1"}, "28da8162-e475-44e4-8c9b-818e82110e29": {"__data__": {"text": "clustering contains a portion of\nthe observations assigned to cluster 1 by hierarchical clustering, as well as\nall of the observations assigned to cluster 2 by hierarchical clustering.\nRather than performing hierarchical clustering on the entire data matrix,\nwe can simply perform hierarchical clustering on the first few principal\ncomponent score vectors, as follows:\n> hc.out <- hclust(dist(pr.out$x[, 1:5]))\n> plot(hc.out , labels = nci.labs ,\nmain = \"Hier. Clust. on First Five Score Vectors\")\n> table(cutree(hc.out , 4), nci.labs)\nNot surprisingly, these results are different from the ones that we obtained\nwhen we performed hierarchical clustering on the full data set. Sometimes\nperforming clustering on the first few principal component score vectors\ncan give better results than performing clustering on the full data. In this\nsituation, we might view the principal component step as one of denoising\nthe data. We could also perform K-means clustering on the first few\nprincipal component score vectors rather than the full data set.\n548 12. Unsupervised Learning\n12.6 Exercises\nConceptual\n1. This problem involves the K-means clustering algorithm.\n(a) Prove (12.18).\n(b) On the basis of this identity, argue that the K-means clustering\nalgorithm (Algorithm 12.2) decreases the objective (12.17) at\neach iteration.\n2. Suppose that we have four observations, for which we compute a\ndissimilarity matrix, given by\n\u23a1\n\u23a2\u23a2\u23a3\n0.3 0.4 0.7\n0.3 0.5 0.8\n0.4 0.5 0.45\n0.7 0.8 0.45\n\u23a4\n\u23a5\u23a5\u23a6\n.\nFor instance, the dissimilarity between the first and second observations\nis 0.3, and the dissimilarity between the second and fourth\nobservations is 0.8.\n(a) On the basis of this dissimilarity matrix, sketch the dendrogram\nthat results from hierarchically clustering these four observations\nusing complete linkage. Be sure to indicate on the plot the\nheight at which each fusion occurs, as well as the observations\ncorresponding to each leaf in the dendrogram.\n(b) Repeat (a), this time using single linkage clustering.\n(c) Suppose that we cut the dendrogram obtained in (a) such that\ntwo clusters result. Which observations are in each cluster?\n(d) Suppose that we cut the dendrogram obtained in (b) such that\ntwo clusters result. Which observations are in each cluster?\n(e) It is mentioned in the chapter that at each fusion in the dendrogram,\nthe position of the two clusters being fused can be\nswapped without changing the meaning of the dendrogram. Draw\na dendrogram that is equivalent to the dendrogram in (a), for\nwhich two or more of the leaves are repositioned, but for which\nthe meaning of the dendrogram is the same.\n3. In this problem, you will perform K-means clustering manually, with\nK = 2, on a small example with n = 6 observations and p = 2\nfeatures. The observations are as follows.\n12.6 Exercises 549\nObs. X1 X2\n1 1 4\n2 1 3\n3 0 4\n4 5 1\n5 6 2\n6 4 0\n(a) Plot the observations.\n(b) Randomly assign a cluster label to each observation. You can\nuse the sample() command in R to do this. Report the cluster\nlabels for each observation.\n(c) Compute the centroid for each cluster.\n(d) Assign each observation to the centroid to which it is closest, in\nterms of Euclidean distance. Report the cluster labels for", "doc_id": "28da8162-e475-44e4-8c9b-818e82110e29", "embedding": null, "doc_hash": "7ef42c5414c5e2a8ebda9f6d2fd37155262a3920ae3b2cbaa64f0defec0491a3", "extra_info": null, "node_info": {"start": 1231183, "end": 1234392, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "8e8de8cb-6c28-4757-bbf1-e5a516b37557", "3": "5d3cb99a-13a2-41bb-9858-d6558cd6f7b5"}}, "__type__": "1"}, "5d3cb99a-13a2-41bb-9858-d6558cd6f7b5": {"__data__": {"text": "in\nterms of Euclidean distance. Report the cluster labels for each\nobservation.\n(e) Repeat (c) and (d) until the answers obtained stop changing.\n(f) In your plot from (a), color the observations according to the\ncluster labels obtained.\n4. Suppose that for a particular data set, we perform hierarchical clustering\nusing single linkage and using complete linkage. We obtain two\ndendrograms.\n(a) At a certain point on the single linkage dendrogram, the clusters\n{1, 2, 3} and {4, 5} fuse. On the complete linkage dendrogram,\nthe clusters {1, 2, 3} and {4, 5} also fuse at a certain point.\nWhich fusion will occur higher on the tree, or will they fuse at\nthe same height, or is there not enough information to tell?\n(b) At a certain point on the single linkage dendrogram, the clusters\n{5} and {6} fuse. On the complete linkage dendrogram, the clusters\n{5} and {6} also fuse at a certain point. Which fusion will\noccur higher on the tree, or will they fuse at the same height, or\nis there not enough information to tell?\n5. In words, describe the results that you would expect if you performed\nK-means clustering of the eight shoppers in Figure 12.16, on the\nbasis of their sock and computer purchases, with K = 2. Give three\nanswers, one for each of the variable scalings displayed. Explain.\n6. We saw in Section 12.2.2 that the principal component loading and\nscore vectors provide an approximation to a matrix, in the sense of\n(12.5). Specifically, the principal component score and loading vectors\nsolve the optimization problem given in (12.6).\n550 12. Unsupervised Learning\nNow, suppose that theM principal component score vectors zim, m =\n1, . . . ,M, are known. Using (12.6), explain that the first M principal\ncomponent loading vectors \u03c6jm, m = 1, . . . ,M, can be obtaining\nby performing M separate least squares linear regressions. In each\nregression, the principal component score vectors are the predictors,\nand one of the features of the data matrix is the response.\nApplied\n7. In the chapter, we mentioned the use of correlation-based distance\nand Euclidean distance as dissimilarity measures for hierarchical clustering.\nIt turns out that these two measures are almost equivalent: if\neach observation has been centered to have mean zero and standard\ndeviation one, and if we let rij denote the correlation between the ith\nand jth observations, then the quantity 1\u2212rij is proportional to the\nsquared Euclidean distance between the ith and jth observations.\nOn the USArrests data, show that this proportionality holds.\nHint: The Euclidean distance can be calculated using the dist() function,\nand correlations can be calculated using the cor() function.\n8. In Section 12.2.3, a formula for calculating PVE was given in Equation\n12.10. We also saw that the PVE can be obtained using the sdev\noutput of the prcomp() function.\nOn the USArrests data, calculate PVE in two ways:\n(a) Using the sdev output of the prcomp() function, as was done in\nSection 12.2.3.\n(b) By applying Equation 12.10 directly. That is, use the prcomp()\nfunction to compute the principal component loadings. Then,\nuse those loadings in Equation 12.10 to obtain the PVE.\nThese two approaches should give the same results.\nHint: You will only obtain the same results in (a) and (b) if the same\ndata is used in both cases. For instance, if in (a) you performed\nprcomp() using centered and scaled variables, then you must center\nand scale the variables before applying Equation 12.10 in (b).\n9. Consider the USArrests", "doc_id": "5d3cb99a-13a2-41bb-9858-d6558cd6f7b5", "embedding": null, "doc_hash": "02de25e4f24ab900351a6b33af577c39b0a6483e0d051bde4b90925bbfe8f51e", "extra_info": null, "node_info": {"start": 1234402, "end": 1237897, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "28da8162-e475-44e4-8c9b-818e82110e29", "3": "6ba22e10-5130-48a3-8382-ffa3b4183f8d"}}, "__type__": "1"}, "6ba22e10-5130-48a3-8382-ffa3b4183f8d": {"__data__": {"text": "applying Equation 12.10 in (b).\n9. Consider the USArrests data. We will now perform hierarchical clustering\non the states.\n(a) Using hierarchical clustering with complete linkage and\nEuclidean distance, cluster the states.\n(b) Cut the dendrogram at a height that results in three distinct\nclusters. Which states belong to which clusters?\n12.6 Exercises 551\n(c) Hierarchically cluster the states using complete linkage and Euclidean\ndistance, after scaling the variables to have standard deviation\none.\n(d) What effect does scaling the variables have on the hierarchical\nclustering obtained? In your opinion, should the variables be\nscaled before the inter-observation dissimilarities are computed?\nProvide a justification for your answer.\n10. In this problem, you will generate simulated data, and then perform\nPCA and K-means clustering on the data.\n(a) Generate a simulated data set with 20 observations in each of\nthree classes (i.e. 60 observations total), and 50 variables.\nHint: There are a number of functions in R that you can use to\ngenerate data. One example is the rnorm() function; runif() is\nanother option. Be sure to add a mean shift to the observations\nin each class so that there are three distinct classes.\n(b) Perform PCA on the 60 observations and plot the first two principal\ncomponent score vectors. Use a different color to indicate\nthe observations in each of the three classes. If the three classes\nappear separated in this plot, then continue on to part (c). If\nnot, then return to part (a) and modify the simulation so that\nthere is greater separation between the three classes. Do not\ncontinue to part (c) until the three classes show at least some\nseparation in the first two principal component score vectors.\n(c) Perform K-means clustering of the observations with K = 3.\nHow well do the clusters that you obtained in K-means clustering\ncompare to the true class labels?\nHint: You can use the table() function in R to compare the true\nclass labels to the class labels obtained by clustering. Be careful\nhow you interpret the results: K-means clustering will arbitrarily\nnumber the clusters, so you cannot simply check whether the true\nclass labels and clustering labels are the same.\n(d) Perform K-means clustering with K = 2. Describe your results.\n(e) Now perform K-means clustering with K = 4, and describe your\nresults.\n(f) Now perform K-means clustering with K = 3 on the first two\nprincipal component score vectors, rather than on the raw data.\nThat is, perform K-means clustering on the 60 \u00d7 2 matrix of\nwhich the first column is the first principal component score\nvector, and the second column is the second principal component\nscore vector. Comment on the results.\n552 12. Unsupervised Learning\n(g) Using the scale() function, perform K-means clustering with\nK = 3 on the data after scaling each variable to have standard\ndeviation one. How do these results compare to those obtained\nin (b)? Explain.\n11. Write an R function to perform matrix completion as in Algorithm 12.1,\nand as outlined in Section 12.5.2. In each iteration, the function\nshould keep track of the relative error, as well as the iteration count.\nIterations should continue until the relative error is small enough or\nuntil some maximum number of iterations is reached (set a default\nvalue for this maximum number). Furthermore, there should be an\noption to print out the progress in each iteration.\nTest your function on the Boston data. First, standardize the features\nto have mean zero and standard deviation one using the scale() function.\nRun an experiment where you randomly leave out an increasing\n(and nested) number of observations from 5% to 30%, in steps of\n5%. Apply Algorithm 12.1 with M = 1, 2, . . . , 8. Display", "doc_id": "6ba22e10-5130-48a3-8382-ffa3b4183f8d", "embedding": null, "doc_hash": "a49fe9ab7824d0d0a6ab633ec38339328ee009ad9f36cae73d632df146e3b92b", "extra_info": null, "node_info": {"start": 1237901, "end": 1241638, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "5d3cb99a-13a2-41bb-9858-d6558cd6f7b5", "3": "9a497bb9-67e0-408b-8a34-e7d90186c013"}}, "__type__": "1"}, "9a497bb9-67e0-408b-8a34-e7d90186c013": {"__data__": {"text": "Apply Algorithm 12.1 with M = 1, 2, . . . , 8. Display the approximation\nerror as a function of the fraction of observations that are\nmissing, and the value of M, averaged over 10 repetitions of the experiment.\n12. In Section 12.5.2, Algorithm 12.1 was implemented using the svd()\nfunction. However, given the connection between the svd() function\nand the prcomp() function highlighted in the lab, we could have instead\nimplemented the algorithm using prcomp().\nWrite a function to implement Algorithm 12.1 that makes use of\nprcomp() rather than svd().\n13. On the book website, www.statlearning.com, there is a gene expression\ndata set (Ch12Ex13.csv) that consists of 40 tissue samples with\nmeasurements on 1,000 genes. The first 20 samples are from healthy\npatients, while the second 20 are from a diseased group.\n(a) Load in the data using read.csv(). You will need to select\nheader = F.\n(b) Apply hierarchical clustering to the samples using correlationbased\ndistance, and plot the dendrogram. Do the genes separate\nthe samples into the two groups? Do your results depend on the\ntype of linkage used?\n(c) Your collaborator wants to know which genes differ the most\nacross the two groups. Suggest a way to answer this question,\nand apply it here.\n13\nMultiple Testing\nThus far, this textbook has mostly focused on estimation and its close\ncousin, prediction. In this chapter, we instead focus on hypothesis testing,\nwhich is key to conducting inference. We remind the reader that inference\nwas briefly discussed in Chapter 2.\nWhile Section 13.1 provides a brief review of null hypotheses, p-values,\ntest statistics, and other key ideas in hypothesis testing, this chapter assumes\nthat the reader has had previous exposure to these topics. In particular,\nwe will not focus on why or how to conduct a hypothesis test \u2014\na topic on which entire books can be (and have been) written! Instead, we\nwill assume that the reader is interested in testing some particular set of\nnull hypotheses, and has a specific plan in mind for how to conduct the\ntests and obtain p-values.\nMuch of the emphasis in classical statistics focuses on testing a single null\nhypothesis, such as H0: the mean blood pressure of mice in the control group\nequals the mean blood pressure of mice in the treatment group. Of course,\nwe would probably like to discover that there is a difference between the\nmean blood pressure in the two groups. But for reasons that will become\nclear, we construct a null hypothesis corresponding to no difference.\nIn contemporary settings, we are often faced with huge amounts of data,\nand consequently may wish to test a great many null hypotheses. For instance,\nrather than simply testing H0, we might want to test m null hypotheses,\nH01, . . . ,H0m, where H0j : the mean value of the jth biomarker\namong mice in the control group equals the mean value of the jth biomarker\namong mice in the treatment group. When conducting multiple testing, we\n\u00a9 Springer Science+Business Media, LLC, part of Springer Nature 2021\nG. James et al., An Introduction to Statistical Learning, Springer Texts in Statistics,\n553\nhttps://doi.org/10.1007/978-1-0716-1418-1_13\n554 13. Multiple Testing\nneed to be very careful about how we interpret the results, in order to avoid\nerroneously rejecting far too many null hypotheses.\nThis chapter discusses classical as well as more contemporary ways to\nconduct multiple testing in a big-data setting. In Section 13.2, we highlight\nthe challenges associated with multiple testing. Classical solutions to these\nchallenges are presented in Section 13.3, and more contemporary solutions\nin Sections 13.4 and 13.5.\nIn particular, Section 13.4 focuses on the false discovery rate. The notion\nof the false discovery rate dates back to the 1990s. It quickly rose", "doc_id": "9a497bb9-67e0-408b-8a34-e7d90186c013", "embedding": null, "doc_hash": "836beefc7617ea97854518476f47563acdddff91cfae56c343a05a6d5c570e74", "extra_info": null, "node_info": {"start": 1241648, "end": 1245426, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "6ba22e10-5130-48a3-8382-ffa3b4183f8d", "3": "b14f7317-923e-49d7-be78-93f242f633b7"}}, "__type__": "1"}, "b14f7317-923e-49d7-be78-93f242f633b7": {"__data__": {"text": "notion\nof the false discovery rate dates back to the 1990s. It quickly rose in\npopularity in the early 2000s, when large-scale data sets began to come out\nof genomics. These datasets were unique not only because of their large\nsize,1 but also because they were typically collected for exploratory purposes:\nresearchers collected these datasets in order to test a huge number\nof null hypotheses, rather than just a very small number of pre-specified\nnull hypotheses. Today, of course, huge datasets are collected without a\npre-specified null hypothesis across virtually all fields. As we will see, the\nfalse discovery rate is perfectly-suited for this modern-day reality.\nThis chapter naturally centers upon p-values, which are a classical approach\nin statistics to quantify the results of a hypothesis test. At the time\nof writing of this book (2020), p-values have recently been the topic of\nextensive commentary in the social science research community, to the extent\nthat some social science journals have gone so far as to ban the use\nof p-values altogether! We will simply comment that when properly understood\nand applied, p-values provide a powerful tool for drawing inferential\nconclusions from our data.\n13.1 A Quick Review of Hypothesis Testing\nHypothesis tests provide a rigorous statistical framework for answering\nsimple \u201cyes-or-no\u201d questions about data, such as the following:\n1. Is the coefficient \u03b2j in a linear regression of Y onto X1, . . . ,Xp equal\nto zero?2\n2. Is there a difference in the mean blood pressure of laboratory mice in\nthe control group and laboratory mice in the treatment group?3\n1Microarray data was viewed as \u201cbig data\u201d at the time, although by today\u2019s standards,\nthis label seems quaint: a microarray dataset can be (and typically was) stored\nin a Microsoft Excel spreadsheet!\n2This hypothesis test was discussed on page 67 of Chapter 3.\n3The \u201ctreatment group\u201d refers to the set of mice that receive an experimental treatment,\nand the \u201ccontrol group\u201d refers to those that do not.\n13.1 A Quick Review of Hypothesis Testing 555\nIn Section 13.1.1, we briefly review the steps involved in hypothesis testing.\nSection 13.1.2 discusses the different types of mistakes, or errors, that\ncan occur in hypothesis testing.\n13.1.1 Testing a Hypothesis\nConducting a hypothesis test typically proceeds in four steps. First, we define\nthe null and alternative hypotheses. Next, we construct a test statistic\nthat summarizes the strength of evidence against the null hypothesis. We\nthen compute a p-value that quantifies the probability of having obtained\na comparable or more extreme value of the test statistic under the null\nhypothesis. Finally, based on the p-value, we decide whether to reject the\nnull hypothesis. We now briefly discuss each of these steps in turn.\nStep 1: Define the Null and Alternative Hypotheses\nIn hypothesis testing, we divide the world into two possibilities: the null\nhypothesis and the alternative hypothesis. The null hypothesis, denoted H0,\nnull\nhypothesis\nalternative\nhypothesis\nis the default state of belief about the world4. For instance, null hypotheses\nassociated with the two questions posed earlier in this chapter are as follows:\n1. The coefficient \u03b2j in a linear regression of Y onto X1, . . . ,Xp equals\nzero.\n2. There is no difference between the mean blood pressure of mice in\nthe control and treatment groups.\nThe null hypothesis is boring by construction: it may well be true, but we\nmight hope that our data will tell us otherwise.\nThe alternative hypothesis, denoted Ha, represents something different\nand unexpected: for instance, that there is a difference between the mean\nblood pressure of the mice in the two groups. Typically, the alternative\nhypothesis simply posits that the null hypothesis does not hold: if the", "doc_id": "b14f7317-923e-49d7-be78-93f242f633b7", "embedding": null, "doc_hash": "c423f77e4512e95f6055bdf336cd993424460f0676d4402f560e2b2c5bb95c6f", "extra_info": null, "node_info": {"start": 1245405, "end": 1249199, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "9a497bb9-67e0-408b-8a34-e7d90186c013", "3": "9e2e516b-7663-4157-a66c-329857b98c54"}}, "__type__": "1"}, "9e2e516b-7663-4157-a66c-329857b98c54": {"__data__": {"text": "simply posits that the null hypothesis does not hold: if the null\nhypothesis states that there is no difference between A and B, then the\nalternative hypothesis states that there is a difference between A and B.\nIt is important to note that the treatment of H0 and Ha is asymmetric.\nH0 is treated as the default state of the world, and we focus on using data\nto reject H0. If we reject H0, then this provides evidence in favor of Ha. We\ncan think of rejecting H0 as making a discovery about our data: namely, we\nare discovering that H0 does not hold! By contrast, if we fail to reject H0,\nthen our findings are more nebulous: we will not know whether we failed\nto reject H0 because our sample size was too small (in which case testing\nH0 again on a larger or higher-quality dataset might lead to rejection), or\nwhether we failed to reject H0 because H0 really holds.\n4H0 is pronounced \u201cH naught\u201d or \u201cH zero\u201d.\n556 13. Multiple Testing\nStep 2: Construct the Test Statistic\nNext, we wish to use our data in order to find evidence for or against\nthe null hypothesis. In order to do this, we must compute a test statistic,\ntest statistic\ndenoted T, which summarizes the extent to which our data are consistent\nwith H0. The way in which we construct T depends on the nature of the\nnull hypothesis that we are testing.\nTo make things concrete, let xt\n1, . . . ,xt\nnt denote the blood pressure measurements\nfor the nt mice in the treatment group, and let xc\n1, . . . ,xc\nnc denote\nthe blood pressure measurements for the nc mice in the control group, and\n\u03bct = E(Xt), \u03bcc = E(Xc). To test H0 : \u03bct = \u03bcc, we make use of a two-sample\nt-statistic,5 defined as\ntwo-sample\nT = t-statistic\n\u02c6\u03bct \u2212 \u02c6\u03bcc\ns\nG\n1\nnt\n+ 1\nnc\n(13.1)\nwhere \u02c6\u03bct = 1\nnt\n)nt\ni=1 xti\n, \u02c6\u03bcc = 1\nnc\n)nc\ni=1 xci\n, and\ns =\n@\n(nt \u2212 1)s2t\n+ (nc \u2212 1)s2c\nnt + nc \u2212 2\n(13.2)\nis an estimator of the pooled standard deviation of the two samples.6 Here,\ns2t\nand s2c\nare unbiased estimators of the variance of the blood pressure in\nthe treatment and control groups, respectively. A large (absolute) value of\nT provides evidence against H0 : \u03bct = \u03bcc, and hence evidence in support\nof Ha : \u03bct \u0338= \u03bcc.\nStep 3: Compute the p-Value\nIn the previous section, we noted that a large (absolute) value of a twosample\nt-statistic provides evidence against H0. This begs the question: how\nlarge is large? In other words, how much evidence against H0 is provided\nby a given value of the test statistic?\nThe notion of a p-value provides us with a way to formalize as well as\np-value\nanswer this question. The p-value is defined as the probability of observing\na test statistic equal to or more extreme than the observed statistic, under\nthe assumption that H0 is in fact true. Therefore, a small p-value provides\nevidence against H0.\nTo make this concrete, suppose that T = 2.33 for the test statistic in\n(13.1). Then, we can ask: what is the probability of having observed such\na large value of T, if indeed H0 holds? It turns out that under H0, the\n5The t-statistic derives its name from the fact that, under H0, it follows a tdistribution.\n6Note that (13.2) assumes that the control and treatment groups have equal variance.\nWithout this assumption, (13.2) would take a slightly different form.\n13.1 A Quick Review of Hypothesis Testing 557\n\u22124 \u22122 0 2", "doc_id": "9e2e516b-7663-4157-a66c-329857b98c54", "embedding": null, "doc_hash": "1888aa80d81428e6221dd5f9bc377a8576c88388287e338e221579adde7908bb", "extra_info": null, "node_info": {"start": 1249213, "end": 1252488, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "b14f7317-923e-49d7-be78-93f242f633b7", "3": "57eed4ef-46a8-4529-946c-33b2f715007f"}}, "__type__": "1"}, "57eed4ef-46a8-4529-946c-33b2f715007f": {"__data__": {"text": "A Quick Review of Hypothesis Testing 557\n\u22124 \u22122 0 2 4\n0.0 0.1 0.2 0.3 0.4\nValue of Test Statistic\nProbability Density Function\nT=2.33\nFIGURE 13.1. The density function for the N(0, 1) distribution, with the vertical\nline indicating a value of 2.33. 1% of the area under the curve falls to the\nright of the vertical line, so there is only a 2% chance of observing a N(0, 1) value\nthat is greater than 2.33 or less than \u22122.33. Therefore, if a test statistic has a\nN(0, 1) null distribution, then an observed test statistic of T = 2.33 leads to a\np-value of 0.02.\ndistribution of T in (13.1) follows approximately a N(0, 1) distribution7 \u2014\nthat is, a normal distribution with mean 0 and variance 1. This distribution\nis displayed in Figure 13.1. We see that the vast majority \u2014 98% \u2014 of the\nN(0, 1) distribution falls between \u22122.33 and 2.33. This means that under\nH0, we would expect to see such a large value of |T| only 2% of the time.\nTherefore, the p-value corresponding to T = 2.33 is 0.02.\nThe distribution of the test statistic under H0 (also known as the test\nstatistic\u2019s null distribution) will depend on the details of what type of null\nnull\nhypothesis is being tested, and what type of test statistic is used. In gen- distribution\neral, most commonly-used test statistics follow a well-known statistical\ndistribution under the null hypothesis \u2014 such as a normal distribution,\na t-distribution, a \u03c72-distribution, or an F-distribution \u2014 provided that\nthe sample size is sufficiently large and that some other assumptions hold.\nTypically, the R function that is used to compute a test statistic will make\nuse of this null distribution in order to output a p-value. In Section 13.5,\nwe will see an approach to estimate the null distribution of a test statistic\nusing re-sampling; in many contemporary settings, this is a very attractive\noption, as it exploits the availability of fast computers in order to avoid\nhaving to make potentially problematic assumptions about the data.\n7More precisely, assuming that the observations are drawn from a normal distribution,\nthen T follows a t-distribution with nt + nc \u2212 2 degrees of freedom. Provided that nt +\nnc\u22122 is larger than around 40, this is very well-approximated by a N(0, 1) distribution.\nIn Section 13.5, we will see an alternative and often more attractive way to approximate\nthe null distribution of T, which avoids making stringent assumptions about the data.\n558 13. Multiple Testing\nThe p-value is perhaps one of the most used and abused notions in all of\nstatistics. In particular, it is sometimes said that the p-value is the probability\nthat H0 holds, i.e., that the null hypothesis is true. This is not correct!\nThe one and only correct interpretation of the p-value is as the fraction\nof the time that we would expect to see such an extreme value of the test\nstatistic8 if we repeated the experiment many many times, provided H0\nholds.\nIn Step 2 we computed a test statistic, and noted that a large (absolute)\nvalue of the test statistic provides evidence against H0. In Step 3 the test\nstatistic was converted to a p-value, with small p-values providing evidence\nagainst H0. What, then, did we accomplish by converting the test statistic\nfrom Step 2 into a p-value in Step 3? To answer this question, suppose\na data analyst conducts a statistical test, and reports a test statistic of\nT = 17.3. Does this provide strong evidence against H0? It\u2019s impossible\nto know, without more information: in particular, we would need to know\nwhat value of the test statistic should be expected, under H0. This is exactly\nwhat a p-value gives us. In other words,", "doc_id": "57eed4ef-46a8-4529-946c-33b2f715007f", "embedding": null, "doc_hash": "786bc5f036c4bef4f6ad0754b973c22e4f542af6d511c05ef1db973bde1ee2ff", "extra_info": null, "node_info": {"start": 1252498, "end": 1256116, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "9e2e516b-7663-4157-a66c-329857b98c54", "3": "58ae8eff-e07e-4182-92c0-e735a9214716"}}, "__type__": "1"}, "58ae8eff-e07e-4182-92c0-e735a9214716": {"__data__": {"text": "This is exactly\nwhat a p-value gives us. In other words, a p-value allows us to transform\nour test statistic, which is measured on some arbitrary and uninterpretable\nscale, into a number between 0 and 1 that can be more easily interpreted.\nStep 4: Decide Whether to Reject the Null Hypothesis\nOnce we have computed a p-value corresponding to H0, it remains for\nus to decide whether or not to reject H0. (We do not usually talk about\n\u201caccepting\u201d H0: instead, we talk about \u201cfailing to reject\u201d H0.) A small\np-value indicates that such a large value of the test statistic is unlikely to\noccur under H0, and thereby provides evidence against H0. If the p-value\nis sufficiently small, then we will want to reject H0 (and, therefore, make\na \u201cdiscovery\u201d). But how small is small enough to reject H0?\nIt turns out that the answer to this question is very much in the eyes\nof the beholder, or more specifically, the data analyst. The smaller the pvalue,\nthe stronger the evidence against H0. In some fields, it is typical to\nreject H0 if the p-value is below 0.05; this means that, if H0 holds, we would\nexpect to see such a small p-value no more than 5% of the time.9 However,\n8A one-sided p-value is the probability of seeing such an extreme value of the test\nstatistic; e.g. the probability of seeing a test statistic greater than or equal to T = 2.33.\nA two-sided p-value is the probability of seeing such an extreme value of the absolute\ntest statistic; e.g. the probability of seeing a test statistic greater than or equal to 2.33\nor less than or equal to \u22122.33. The default recommendation is to report a two-sided\np-value rather than a one-sided p-value, unless there is a clear and compelling reason\nthat only one direction of the test statistic is of scientific interest.\n9Though a threshold of 0.05 to reject H0 is ubiquitous in some areas of science, we\nadvise against blind adherence to this arbitrary choice. Furthermore, a data analyst\nshould typically report the p-value itself, rather than just whether or not it exceeds a\nspecified threshold value.\n13.1 A Quick Review of Hypothesis Testing 559\nTruth\nH0 Ha\nDecision\nReject H0 Type I Error Correct\nDo Not Reject H0 Correct Type II Error\nTABLE 13.1. A summary of the possible scenarios associated with testing the\nnull hypothesis H0. Type I errors are also known as false positives, and Type II\nerrors as false negatives.\nin other fields, a much higher burden of proof is required: for example, in\nsome areas of physics, it is typical to reject H0 only if the p-value is below\n10\u22129!\nIn the example displayed in Figure 13.1, if we use a threshold of 0.05 as\nour cut-off for rejecting the null hypothesis, then we will reject the null. By\ncontrast, if we use a threshold of 0.01, then we will fail to reject the null.\nThese ideas are formalized in the next section.\n13.1.2 Type I and Type II Errors\nIf the null hypothesis holds, then we say that it is a true null hypothesis;\ntrue null\notherwise, it is a false null hypothesis. For instance, if we test H0 : \u03bct = \u03bcc hypothesis\nfalse null\nhypothesis\nas in Section 13.1.1, and there is indeed no difference in the population\nmean blood pressure for mice in the treatment group and mice in the\ncontrol group, then H0 is true; otherwise, it is false. Of course, we do not\nknow a priori whether H0 is true or whether it is false: this is why we need\nto conduct a hypothesis test!\nTable 13.1 summarizes the possible scenarios associated with testing the\nnull hypothesis H0.10 Once the hypothesis test is performed, the row of the\ntable is known (based on", "doc_id": "58ae8eff-e07e-4182-92c0-e735a9214716", "embedding": null, "doc_hash": "9d92457e908dee234b7efd47acb2508474de9c76487ebd21c2dc5884098853a7", "extra_info": null, "node_info": {"start": 1256111, "end": 1259663, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "57eed4ef-46a8-4529-946c-33b2f715007f", "3": "ebb87e1d-b348-4724-9c59-6a3f1cca192d"}}, "__type__": "1"}, "ebb87e1d-b348-4724-9c59-6a3f1cca192d": {"__data__": {"text": "the hypothesis test is performed, the row of the\ntable is known (based on whether or not we have rejected H0); however, it\nis impossible for us to know which column we are in. If we reject H0 when\nH0 is false (i.e., when Ha is true), or if we do not reject H0 when it is true,\nthen we arrived at the correct result. However, if we erroneously reject H0\nwhen H0 is in fact true, then we have committed a Type I error. The Type I\nType I error\nerror rate is defined as the probability of making a Type I error given that\nType I error\nH0 holds, i.e., the probability of incorrectly rejecting H0. Alternatively, if rate\nwe do not reject H0 when H0 is in fact false, then we have committed a\nType II error. The power of the hypothesis test is defined as the probability\nType II\nerror\npower\nof not making a Type II error given that Ha holds, i.e., the probability of\ncorrectly rejecting H0.\n10There are parallels between Table 13.1 and Table 4.6, which has to do with the\noutput of a binary classifier. In particular, recall from Table 4.6 that a false positive\nresults from predicting a positive (non-null) label when the true label is in fact negative\n(null). This is closely related to a Type I error, which results from rejecting the null\nhypothesis when in fact the null hypothesis holds.\n560 13. Multiple Testing\nIdeally we would like both the Type I and Type II error rates to be small.\nBut in practice, this is hard to achieve! There typically is a trade-off: we\ncan make the Type I error small by only rejecting H0 if we are quite sure\nthat it doesn\u2019t hold; however, this will result in an increase in the Type II\nerror. Alternatively, we can make the Type II error small by rejecting H0\nin the presence of even modest evidence that it does not hold, but this will\ncause the Type I error to be large. In practice, we typically view Type I\nerrors as more \u201cserious\u201d than Type II errors, because the former involves\ndeclaring a scientific finding that is not correct. Hence, when we perform\nhypothesis testing, we typically require a low Type I error rate \u2014 e.g.,\nat most \u03b1 = 0.05 \u2014 while trying to make the Type II error small (or,\nequivalently, the power large).\nIt turns out that there is a direct correspondence between the p-value\nthreshold that causes us to reject H0, and the Type I error rate. By only\nrejecting H0 when the p-value is below \u03b1, we ensure that the Type I error\nrate will be less than or equal to \u03b1.\n13.2 The Challenge of Multiple Testing\nIn the previous section, we saw that rejecting H0 if the p-value is below\n(say) 0.01 provides us with a simple way to control the Type I error for H0\nat level 0.01: if H0 is true, then there is no more than a 1% probability that\nwe will reject it. But now suppose that we wish to test m null hypotheses,\nH01, . . . ,H0m. Will it do to simply reject all null hypotheses for which the\ncorresponding p-value falls below (say) 0.01? Stated another way, if we\nreject all null hypotheses for which the p-value falls below 0.01, then how\nmany Type I errors should we expect to make?\nAs a first step towards answering this question, consider a stockbroker\nwho wishes to drum up new clients by convincing them of her trading\nacumen. She tells 1,024 (1,024 = 210) potential new clients that she can\ncorrectly predict whether Apple\u2019s stock price will increase or decrease for 10\ndays running. There are 210 possibilities for how Apple\u2019s stock price might\nchange over the course of these 10 days. Therefore, she emails each client\none of these 210 possibilities. The vast majority of her potential clients\nwill find that the stockbroker\u2019s predictions are no better than chance", "doc_id": "ebb87e1d-b348-4724-9c59-6a3f1cca192d", "embedding": null, "doc_hash": "abef31b2e32838dd5f6a66259e9628a929857f70a6f41f8cd53c66ebb566832b", "extra_info": null, "node_info": {"start": 1259650, "end": 1263274, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "58ae8eff-e07e-4182-92c0-e735a9214716", "3": "6b2daf9a-78e6-446a-ad10-c2f90c707359"}}, "__type__": "1"}, "6b2daf9a-78e6-446a-ad10-c2f90c707359": {"__data__": {"text": "clients\nwill find that the stockbroker\u2019s predictions are no better than chance (and\nmany will find them to be even worse than chance). But a broken clock is\nright twice a day, and one of her potential clients will be really impressed\nto find that her predictions were correct for all 10 of the days! And so the\nstockbroker gains a new client.\nWhat happened here? Does the stockbroker have any actual insight into\nwhether Apple\u2019s stock price will increase or decrease? No. How, then, did\nshe manage to predict Apple\u2019s stock price perfectly for 10 days running?\n13.3 The Family-Wise Error Rate 561\nThe answer is that she made a lot of guesses, and one of them happened\nto be exactly right.\nHow does this relate to multiple testing? Suppose that we flip 1,024 fair\ncoins11 ten times each. Then we would expect (on average) one coin to\ncome up all tails. (There\u2019s a 1/210 = 1/1,024 chance that any single coin\nwill come up all tails. So if we flip 1,024 coins, then we expect one coin to\ncome up all tails, on average.) If one of our coins comes up all tails, then\nwe might therefore conclude that this particular coin is not fair. In fact, a\nstandard hypothesis test for the null hypothesis that this particular coin\nis fair would lead to a p-value below 0.002!12 But it would be incorrect to\nconclude that the coin is not fair: in fact, the null hypothesis holds, and we\njust happen to have gotten ten tails in a row by chance.\nThese examples illustrate the main challenge of multiple testing: when\nmultiple\ntesting a huge number of null hypotheses, we are bound to get some very testing\nsmall p-values by chance. If we make a decision about whether to reject each\nnull hypothesis without accounting for the fact that we have performed a\nvery large number of tests, then we may end up rejecting a great number\nof true null hypotheses \u2014 that is, making a large number of Type I errors.\nHow severe is the problem? Recall from the previous section that if we\nreject a single null hypothesis, H0, if its p-value is less than, say, \u03b1 = 0.01,\nthen there is a 1% chance of making a false rejection if H0 is in fact true.\nNow what if we test m null hypotheses, H01, . . . ,H0m, all of which are true?\nThere\u2019s a 1% chance of rejecting any individual null hypothesis; therefore,\nwe expect to falsely reject approximately 0.01\u00d7m null hypotheses. If m =\n10,000, then that means that we expect to falsely reject 100 null hypotheses\nby chance! That is a lot of Type I errors.\nThe crux of the issue is as follows: rejecting a null hypothesis if the p-value\nis below \u03b1 controls the probability of falsely rejecting that null hypothesis\nat level \u03b1. However, if we do this for m null hypotheses, then the chance of\nfalsely rejecting at least one of the m null hypotheses is quite a bit higher!\nWe will investigate this issue in greater detail, and pose a solution to it, in\nSection 13.3.\n13.3 The Family-Wise Error Rate\nIn the following sections, we will discuss testing multiple hypotheses while\ncontrolling the probability of making at least one Type I error.\n11A fair coin is one that has an equal chance of landing heads or tails.\n12Recall that the p-value is the probability of observing data at least this extreme,\nunder the null hypothesis. If the coin is fair, then the probability of observing at least\nten tails is (1/2)10 = 1/1,024 < 0.001. The p-value is therefore 2/1,024 < 0.002, since\nthis is the probability of observing ten heads or ten tails.\n562 13. Multiple Testing\nH0 is True H0 is False Total\nReject H0 V S R\nDo Not Reject H0 U W m \u2212 R\nTotal m0 m \u2212 m0 m\nTABLE", "doc_id": "6b2daf9a-78e6-446a-ad10-c2f90c707359", "embedding": null, "doc_hash": "4faae7437c5a48fb99934f82f648c41eaa468e4295e46dbd2961f96fa9a06480", "extra_info": null, "node_info": {"start": 1263268, "end": 1266829, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "ebb87e1d-b348-4724-9c59-6a3f1cca192d", "3": "428a7937-94f8-4d6d-8b7e-6f42e1f28e4a"}}, "__type__": "1"}, "428a7937-94f8-4d6d-8b7e-6f42e1f28e4a": {"__data__": {"text": "Reject H0 U W m \u2212 R\nTotal m0 m \u2212 m0 m\nTABLE 13.2. A summary of the results of testing m null hypotheses. A given\nnull hypothesis is either true or false, and a test of that null hypothesis can either\nreject or fail to reject it. In practice, the individual values of V , S, U, and W are\nunknown. However, we do have access to V +S = R and U +W = m\u2212R, which\nare the numbers of null hypotheses rejected and not rejected, respectively.\n13.3.1 What is the Family-Wise Error Rate?\nRecall that the Type I error rate is the probability of rejecting H0 if H0 is\ntrue. The family-wise error rate (FWER) generalizes this notion to the setfamily-\nwise\nting of m null hypotheses, H01, . . . ,H0m, and is defined as the probability error rate\nof making at least one Type I error. To state this idea more formally, consider\nTable 13.2, which summarizes the possible outcomes when performing\nm hypothesis tests. Here, V represents the number of Type I errors (also\nknown as false positives or false discoveries), S the number of true positives,\nU the number of true negatives, and W the number of Type II errors\n(also known as false negatives). Then the family-wise error rate is given by\nFWER = Pr(V \u2265 1). (13.3)\nA strategy of rejecting any null hypothesis for which the p-value is below\n\u03b1 (i.e. controlling the Type I error for each null hypothesis at level \u03b1) leads\nto a FWER of\nFWER(\u03b1) = 1\u2212 Pr(V = 0)\n= 1\u2212 Pr(do not falsely reject any null hypotheses)\n= 1\u2212 Pr\n1Ym\nj=1 {do not falsely reject H0j}\n2\n. (13.4)\nRecall from basic probability that if two events A and B are independent,\nthen Pr(A\u2229B) = Pr(A) Pr(B). Therefore, if we make the additional rather\nstrong assumptions that the m tests are independent and that all m null\nhypotheses are true, then\nFWER(\u03b1) = 1 \u2212\nmE\nj=1\n(1 \u2212 \u03b1) = 1 \u2212 (1 \u2212 \u03b1)m. (13.5)\nHence, if we test only one null hypothesis, then FWER(\u03b1) = 1\u2212(1\u2212\u03b1)1 =\n\u03b1, so the Type I error rate and the FWER are equal. However, if we perform\nm = 100 independent tests, then FWER(\u03b1) = 1\u2212(1\u2212\u03b1)100. For instance,\ntaking \u03b1 = 0.05 leads to a FWER of 1 \u2212 (1 \u2212 0.05)100 = 0.994. In other\nwords, we are virtually guaranteed to make at least one Type I error!\n13.3 The Family-Wise Error Rate 563\n1 2 5 10 20 50 100 200 500\n0.0 0.2 0.4 0.6 0.8 1.0\nNumber of Hypotheses\nFamily\u2212Wise Error Rate\n\u03b1 = 0.05\n\u03b1 = 0.01\n\u03b1 = 0.001\nFIGURE 13.2. The family-wise error rate, as a function of the number of hypotheses\ntested (displayed on the log scale), for three values of \u03b1: \u03b1 = 0.05 (orange),\n\u03b1 = 0.01 (blue), and \u03b1 = 0.001 (purple). The dashed line indicates 0.05.\nFor example, in order to control the FWER at 0.05 when testing m = 50 null\nhypotheses, we must control the Type I error for each null hypothesis at level\n\u03b1 = 0.001.\nFigure 13.2 displays (13.5) for various values of m, the number of hypotheses,\nand \u03b1, the Type I error. We see that setting \u03b1 = 0.05 results in\na high FWER even for moderate m. With \u03b1 = 0.01, we can test no more\nthan five null hypotheses before the FWER exceeds 0.05. Only for very\nsmall values, such as \u03b1 = 0.001, do we manage to ensure a small FWER,\nat least", "doc_id": "428a7937-94f8-4d6d-8b7e-6f42e1f28e4a", "embedding": null, "doc_hash": "877a7362a6214ba3bce3766c9f85c359d4a0591826a111999304f84554467a0d", "extra_info": null, "node_info": {"start": 1266866, "end": 1269931, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "6b2daf9a-78e6-446a-ad10-c2f90c707359", "3": "51c950c0-87bf-483b-813c-baf18aae64bb"}}, "__type__": "1"}, "51c950c0-87bf-483b-813c-baf18aae64bb": {"__data__": {"text": "0.001, do we manage to ensure a small FWER,\nat least for moderately-sized m.\nWe now briefly return to the example in Section 13.1.1, in which we\nconsider testing a single null hypothesis of the form H0 : \u03bct = \u03bcc using a\ntwo-sample t-statistic. Recall from Figure 13.1 that in order to guarantee\nthat the Type I error does not exceed 0.02, we decide whether or not to\nreject H0 using a cutpoint of 2.33 (i.e. we reject H0 if |T| \u2265 2.33). Now,\nwhat if we wish to test 10 null hypotheses using two-sample t-statistics,\ninstead of just one? We will see in Section 13.3.2 that we can guarantee\nthat the FWER does not exceed 0.02 by rejecting only null hypotheses\nfor which the p-value falls below 0.002. This corresponds to a much more\nstringent cutpoint of 3.09 (i.e. we should reject H0j only if its test statistic\n|Tj| \u2265 3.09, for j = 1, . . . , 10). In other words, controlling the FWER at\nlevel \u03b1 amounts to a much higher bar, in terms of evidence required to\nreject any given null hypothesis, than simply controlling the Type I error\nfor each null hypothesis at level \u03b1.\n564 13. Multiple Testing\nManager Mean, \u00afx Standard Deviation,s t-statistic p-value\nOne 3.0 7.4 2.86 0.006\nTwo -0.1 6.9 -0.10 0.918\nThree 2.8 7.5 2.62 0.012\nFour 0.5 6.7 0.53 0.601\nFive 0.3 6.8 0.31 0.756\nTABLE 13.3. The first two columns correspond to the sample mean and sample\nstandard deviation of the percentage excess return, over n = 50 months, for the\nfirst five managers in the Fund dataset. The last two columns provide the t-statistic\n(\u221an \u00b7 \u00afX/S) and associated p-value for testing H0j : \u03bcj = 0, the null hypothesis\nthat the (population) mean return for the jth hedge fund manager equals zero.\n13.3.2 Approaches to Control the Family-Wise Error Rate\nIn this section, we briefly survey some approaches to control the FWER.\nWe will illustrate these approaches on the Fund dataset, which records the\nmonthly percentage excess returns for 2,000 fund managers over n = 50\nmonths.13 Table 13.3 provides relevant summary statistics for the first five\nmanagers.\nWe first present the Bonferroni method and Holm\u2019s step-down procedure,\nwhich are very general-purpose approaches for controlling the FWER\nthat can be applied whenever m p-values have been computed, regardless\nof the form of the null hypotheses, the choice of test statistics, or the\n(in)dependence of the p-values. We then briefly discuss Tukey\u2019s method\nand Scheff\u00b4e\u2019s method in order to illustrate the fact that, in certain situations,\nmore specialized approaches for controlling the FWER may be\npreferable.\nThe Bonferroni Method\nAs in the previous section, suppose we wish to test H01, . . . ,H0m. Let Aj\ndenote the event that we make a Type I error for the jth null hypothesis,\nfor j = 1, . . . ,m. Then\nFWER(\u03b1) = Pr(falsely reject at least one null hypothesis)\n= Pr(\u222amj\n=1Aj)\n\u2264\n0m\nj=1\nPr(Aj). (13.6)\nIn (13.6), the inequality results from the fact that for any two events A\nand B, Pr(A \u222a B) \u2264 Pr(A) + Pr(B), regardless of whether A and B are\n13Excess returns correspond to the additional return the fund manager achieves beyond\nthe market\u2019s overall return. So if the market increases by 5% during a given period\nand", "doc_id": "51c950c0-87bf-483b-813c-baf18aae64bb", "embedding": null, "doc_hash": "d0bf05096e9628328b195cc077613ebc217d3e7371c5c83d0bd2b2b0901ec2dd", "extra_info": null, "node_info": {"start": 1269921, "end": 1273076, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "428a7937-94f8-4d6d-8b7e-6f42e1f28e4a", "3": "b88b54bb-fe09-40ba-8dde-8d0488fb72ef"}}, "__type__": "1"}, "b88b54bb-fe09-40ba-8dde-8d0488fb72ef": {"__data__": {"text": "overall return. So if the market increases by 5% during a given period\nand the fund manager achieves a 7% return, their excess return would be 7%\u22125% = 2%.\n13.3 The Family-Wise Error Rate 565\nindependent. The Bonferroni method, or Bonferroni correction, sets the\nthreshold for rejecting each hypothesis test to \u03b1/m, so that Pr(Aj) \u2264 \u03b1/m.\nEquation 13.6 implies that\nFWER(\u03b1) \u2264 m \u00d7\n\u03b1\nm\n= \u03b1,\nso this procedure controls the FWER at level \u03b1. For instance, in order to\ncontrol the FWER at level 0.1 while testing m = 100 null hypotheses, the\nBonferroni procedure requires us to control the Type I error for each null\nhypothesis at level 0.1/100 = 0.001, i.e. to reject all null hypotheses for\nwhich the p-value is below 0.001.\nWe now consider the Fund dataset in Table 13.3. If we control the Type\nI error at level \u03b1 = 0.05 for each fund manager separately, then we will\nconclude that the first and third managers have significantly non-zero excess\nreturns; in other words, we will reject H01 : \u03bc1 = 0 and H03 : \u03bc3 = 0.\nHowever, as discussed in previous sections, this procedure does not account\nfor the fact that we have tested multiple hypotheses, and therefore it will\nlead to a FWER greater than 0.05. If we instead wish to control the FWER\nat level 0.05, then, using a Bonferroni correction, we must control the Type\nI error for each individual manager at level \u03b1/m = 0.05/5 = 0.01. Consequently,\nwe will reject the null hypothesis only for the first manager, since\nthe p-values for all other managers exceed 0.01. The Bonferroni correction\ngives us peace of mind that we have not falsely rejected too many null\nhypotheses, but for a price: we reject few null hypotheses, and thus will\ntypically make quite a few Type II errors.\nThe Bonferroni correction is by far the best-known and most commonlyused\nmultiplicity correction in all of statistics. Its ubiquity is due in large\npart to the fact that it is very easy to understand and simple to implement,\nand also from the fact that it successfully controls Type I error regardless\nof whether the m hypothesis tests are independent. However, as we will see,\nit is typically neither the most powerful nor the best approach for multiple\ntesting correction. In particular, the Bonferroni correction can be quite\nconservative, in the sense that the true FWER is often quite a bit lower\nthan the nominal (or target) FWER; this results from the inequality in\n(13.6). By contrast, a less conservative procedure might allow us to control\nthe FWER while rejecting more null hypotheses, and therefore making\nfewer Type II errors.\nHolm\u2019s Step-Down Procedure\nHolm\u2019s method, also known as Holm\u2019s step-down procedure or the Holm-\nHolm\u2019s\nBonferroni method, is an alternative to the Bonferroni procedure. Holm\u2019s method\nmethod controls the FWER, but it is less conservative than Bonferroni, in\nthe sense that it will reject more null hypotheses, typically resulting in fewer\nType II errors and hence greater power. The procedure is summarized in\nAlgorithm 13.1. The proof that this method controls the FWER is similar\n566 13. Multiple Testing\nAlgorithm 13.1 Holm\u2019s Step-Down Procedure to Control the FWER\n1. Specify \u03b1, the level at which to control the FWER.\n2. Compute p-values, p1, . . . ,pm, for the m null hypotheses\nH01, . . . ,H0m.\n3. Order the m p-values so that p(1) \u2264 p(2) \u2264 \u00b7 \u00b7 \u00b7 \u2264 p(m).\n4. Define\nL = min\nK\nj : p(j) >\n\u03b1\nm + 1 \u2212", "doc_id": "b88b54bb-fe09-40ba-8dde-8d0488fb72ef", "embedding": null, "doc_hash": "8e4d6f22a513bda6ae3314e5794662fe12e2f18d10a9e0a639fadb92084affde", "extra_info": null, "node_info": {"start": 1273058, "end": 1276425, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "51c950c0-87bf-483b-813c-baf18aae64bb", "3": "47ef91a7-6d1e-461e-8165-ad1a7205a51b"}}, "__type__": "1"}, "47ef91a7-6d1e-461e-8165-ad1a7205a51b": {"__data__": {"text": "= min\nK\nj : p(j) >\n\u03b1\nm + 1 \u2212 j\nZ\n. (13.7)\n5. Reject all null hypotheses H0j for which pj < p(L).\nto, but slightly more complicated than, the argument in (13.6) that the\nBonferroni method controls the FWER. It is worth noting that in Holm\u2019s\nprocedure, the threshold that we use to reject each null hypothesis \u2014 p(L)\nin Step 5\u2014 actually depends on the values of all m of the p-values. (See the\ndefinition of L in (13.7).) This is in contrast to the Bonferroni procedure,\nin which to control the FWER at level \u03b1, we reject any null hypotheses for\nwhich the p-value is below \u03b1/m, regardless of the other p-values. Holm\u2019s\nmethod makes no independence assumptions about the m hypothesis tests,\nand is uniformly more powerful than the Bonferroni method \u2014 it will\nalways reject at least as many null hypotheses as Bonferroni \u2014 and so it\nshould always be preferred.\nWe now consider applying Holm\u2019s method to the first five fund managers\nin the Fund dataset in Table 13.3, while controlling the FWER at level 0.05.\nThe ordered p-values are p(1) = 0.006, p(2) = 0.012, p(3) = 0.601, p(4) =\n0.756 and p(5) = 0.918. The Holm procedure rejects the first two null\nhypotheses, because p(1) = 0.006 < 0.05/(5 + 1 \u2212 1) = 0.01 and p(2) =\n0.012 < 0.05/(5 + 1 \u2212 2) = 0.0125, but p(3) = 0.601 > 0.05/(5 + 1 \u2212 3) =\n0.167, which implies that L = 3. We note that, in this setting, Holm is\nmore powerful than Bonferroni: the former rejects the null hypotheses for\nthe first and third managers, whereas the latter rejects the null hypothesis\nonly for the first manager.\nFigure 13.3 provides an illustration of the Bonferroni and Holm methods\non three simulated data sets in a setting involving m = 10 hypothesis tests,\nof which m0 = 2 of the null hypotheses are true. Each panel displays the\nten corresponding p-values, ordered from smallest to largest, and plotted\non a log scale. The eight red points represent the false null hypotheses, and\nthe two black points represent the true null hypotheses. We wish to control\nthe FWER at level 0.05. The Bonferroni procedure requires us to reject all\nnull hypotheses for which the p-value is below 0.005; this is represented by\nthe black horizontal line. The Holm procedure requires us to reject all null\n13.3 The Family-Wise Error Rate 567\n2 4 6 8 10\n1e\u221205 1e\u221204 1e\u221203 1e\u221202 1e\u221201\nOrdering of p\u2212values\np\u2212values (log scale)\n2 4 6 8 10\n1e\u221207 1e\u221205 1e\u221203 1e\u221201\nOrdering of p\u2212values\np\u2212values (log scale)\n2 4 6 8 10\n1e\u221205 1e\u221204 1e\u221203 1e\u221202 1e\u221201\nOrdering of p\u2212values\np\u2212values (log scale)\nFIGURE 13.3. Each panel displays, for a separate simulation, the sorted\np-values for tests of m = 10 null hypotheses. The p-values corresponding to the\nm0 = 2 true null hypotheses are displayed in black, and the rest are in red. When\ncontrolling the FWER at level 0.05, the Bonferroni procedure rejects all null hypotheses\nthat fall below the black line, and the Holm procedure rejects all null\nhypotheses that fall below the blue line. The region between the blue and black\nlines indicates null hypotheses that are rejected using the Holm procedure but not\nusing the Bonferroni", "doc_id": "47ef91a7-6d1e-461e-8165-ad1a7205a51b", "embedding": null, "doc_hash": "cbc9687ed3025df4f64a69cf666b3e53fb1036abdb63104f2cde7dcdbbdc960a", "extra_info": null, "node_info": {"start": 1276467, "end": 1279546, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "b88b54bb-fe09-40ba-8dde-8d0488fb72ef", "3": "2ea28d4e-1fab-42b3-b955-bc1372db5765"}}, "__type__": "1"}, "2ea28d4e-1fab-42b3-b955-bc1372db5765": {"__data__": {"text": "that are rejected using the Holm procedure but not\nusing the Bonferroni procedure. In the center panel, the Holm procedure rejects\none more null hypothesis than the Bonferroni procedure. In the right-hand panel,\nit rejects five more null hypotheses.\nhypotheses that fall below the blue line. The blue line always lies above the\nblack line, so Holm will always reject more tests than Bonferroni; the region\nbetween the two lines corresponds to the hypotheses that are only rejected\nby Holm. In the left-hand panel, both Bonferroni and Holm successfully\nreject seven of the eight false null hypotheses. In the center panel, Holm\nsuccessfully rejects all eight of the false null hypotheses, while Bonferroni\nfails to reject one. In the right-hand panel, Bonferroni only rejects three of\nthe false null hypotheses, while Holm rejects all eight. Neither Bonferroni\nnor Holm makes any Type I errors in these examples.\nTwo Special Cases: Tukey\u2019s Method and Scheff\u00b4e\u2019s Method\nBonferroni\u2019s method and Holm\u2019s method can be used in virtually any setting\nin which we wish to control the FWER for m null hypotheses: they\nmake no assumptions about the nature of the null hypotheses, the type\nof test statistic used, or the (in)dependence of the p-values. However, in\ncertain very specific settings, we can achieve higher power by controlling\nthe FWER using approaches that are more tailored to the task at hand.\nTukey\u2019s method and Scheff\u00b4e\u2019s method provide two such examples.\nTable 13.3 indicates that for the Fund dataset, Managers One and Two\nhave the greatest difference in their sample mean returns. This finding\nmight motivate us to test the null hypothesis H0 : \u03bc1 = \u03bc2, where \u03bcj is the\n568 13. Multiple Testing\n(population) mean return for the jth fund manager. A two-sample t-test\n(13.1) for H0 yields a p-value of 0.0349, suggesting modest evidence against\nH0. However, this p-value is misleading, since we decided to compare the\naverage returns of Managers One and Two only after having examined the\nreturns for all five managers; this essentially amounts to having performed\nm = 5 \u00d7 (5 \u2212 1)/2 = 10 hypothesis tests, and selecting the one with the\nsmallest p-value. This suggests that in order to control the FWER at level\n0.05, we should make a Bonferroni correction for m = 10 hypothesis tests,\nand therefore should only reject a null hypothesis for which the p-value\nis below 0.005. If we do this, then we will be unable to reject the null\nhypothesis that Managers One and Two have identical performance.\nHowever, in this setting, a Bonferroni correction is actually a bit too\nstringent, since it fails to consider the fact that the m = 10 hypothesis\ntests are all somewhat related: for instance, Managers Two and Five have\nsimilar mean returns, as do Managers Two and Four; this guarantees that\nthe mean returns of Managers Four and Five are similar. Stated another\nway, the m p-values for the m pairwise comparisons are not independent.\nTherefore, it should be possible to control the FWER in a way that is\nless conservative. This is exactly the idea behind Tukey\u2019s method: when\nTukey\u2019s\nperforming m = G(G \u2212 1)/2 pairwise comparisons of G means, it allows method\nus to control the FWER at level \u03b1 while rejecting all null hypotheses for\nwhich the p-value falls below \u03b1T , for some \u03b1T > \u03b1/m.\nFigure 13.4 illustrates Tukey\u2019s method on three simulated data sets in a\nsetting with G = 6 means, with \u03bc1 = \u03bc2 = \u03bc3 = \u03bc4 = \u03bc5 \u0338= \u03bc6. Therefore,\nof the m = G(G \u2212 1)/2 = 15 null hypotheses of the form H0 : \u03bcj = \u03bck,\nten are true and", "doc_id": "2ea28d4e-1fab-42b3-b955-bc1372db5765", "embedding": null, "doc_hash": "5c5698a77c5ce50a9f9a7c418b4864fdab94b73f8a42da548a5dedf3c56f4289", "extra_info": null, "node_info": {"start": 1279507, "end": 1283029, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "47ef91a7-6d1e-461e-8165-ad1a7205a51b", "3": "560c344c-79e1-4c51-98b7-0172112ae634"}}, "__type__": "1"}, "560c344c-79e1-4c51-98b7-0172112ae634": {"__data__": {"text": "hypotheses of the form H0 : \u03bcj = \u03bck,\nten are true and five are false. In each panel, the true null hypotheses\nare displayed in black, and the false ones are in red. The horizontal lines\nindicate that Tukey\u2019s method always results in at least as many rejections\nas Bonferroni\u2019s method. In the left-hand panel, Tukey correctly rejects two\nmore null hypotheses than Bonferroni.\nNow, suppose that we once again examine the data in Table 13.3, and notice\nthat Managers One and Three have higher mean returns than Managers\nTwo, Four, and Five. This might motivate us to test the null hypothesis\nH0 :\n1\n2\n(\u03bc1 + \u03bc3) =\n1\n3\n(\u03bc2 + \u03bc4 + \u03bc5) . (13.8)\n(Recall that \u03bcj is the population mean return for the jth hedge fund\nmanager.) It turns out that we could test (13.8) using a variant of the\ntwo-sample t-test presented in (13.1), leading to a p-value of 0.004. This\nsuggests strong evidence of a difference between Mangers One and Three\ncompared to Managers Two, Four, and Five. However, there is a problem:\nwe decided to test the null hypothesis in (13.8) only after peeking at the\ndata in Table 13.3. In a sense, this means that we have conducted multiple\ntesting. In this setting, using Bonferroni to control the FWER at level \u03b1\n13.3 The Family-Wise Error Rate 569\n2 4 6 8 10 12 14\n1e\u221204 1e\u221203 1e\u221202 1e\u221201 1e+00\nOrdering of p\u2212values\np\u2212values (log scale)\n2 4 6 8 10 12 14\n1e\u221206 1e\u221204 1e\u221202 1e+00\nOrdering of p\u2212values\np\u2212values (log scale)\n2 4 6 8 10 12 14\n1e\u221204 1e\u221203 1e\u221202 1e\u221201 1e+00\nOrdering of p\u2212values\np\u2212values (log scale)\nFIGURE 13.4. Each panel displays, for a separate simulation, the sorted\np-values for tests of m = 15 hypotheses, corresponding to pairwise tests for the\nequality of G = 6 means. The m0 = 10 true null hypotheses are displayed in black,\nand the rest are in red. When controlling the FWER at level 0.05, the Bonferroni\nprocedure rejects all null hypotheses that fall below the black line, whereas Tukey\nrejects all those that fall below the blue line. Thus, Tukey\u2019s method has slightly\nhigher power than Bonferroni\u2019s method. Controlling the Type I error without adjusting\nfor multiple testing involves rejecting all those that fall below the green\nline.\nwould require a p-value threshold of \u03b1/m, for an extremely large value of\nm14.\nScheff\u00b4e\u2019s method is designed for exactly this setting. It allows us to com-\nScheff\u00b4e\u2019s\npute a value \u03b1S such that rejecting the null hypothesis H0 in (13.8) if the method\np-value is below \u03b1S will control the Type I error at level \u03b1. It turns out that\nfor the Fund example, in order to control the Type I error at level \u03b1 = 0.05,\nwe must set \u03b1S = 0.002. Therefore, we are unable to reject H0 in (13.8), despite\nthe apparently very small p-value of 0.004. An important advantage of\nScheff\u00b4e\u2019s method is that we can use this same threshold of \u03b1S = 0.002 in order\nto perform a pairwise comparison of any split of the managers into two\ngroups: for instance, we could also test H0 : 13\n(\u03bc1 + \u03bc2 + \u03bc3) = 12\n(\u03bc4 + \u03bc5)\nand H0 : 14\n(\u03bc1 + \u03bc2 + \u03bc3 + \u03bc4) = \u03bc5 using the same threshold of 0.002,\nwithout needing to further adjust for multiple testing.\nTo summarize, Holm\u2019s procedure and Bonferroni\u2019s", "doc_id": "560c344c-79e1-4c51-98b7-0172112ae634", "embedding": null, "doc_hash": "d0cc891babf73df4b02c0dbe218ae790d0b46f506cc21d2d443e846cdc1fd4c6", "extra_info": null, "node_info": {"start": 1283049, "end": 1286181, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "2ea28d4e-1fab-42b3-b955-bc1372db5765", "3": "d026852c-013b-4190-8ec6-458a73a17d0a"}}, "__type__": "1"}, "d026852c-013b-4190-8ec6-458a73a17d0a": {"__data__": {"text": "summarize, Holm\u2019s procedure and Bonferroni\u2019s procedure are very\ngeneral approaches for multiple testing correction that can be applied under\nall circumstances. However, in certain special cases, more powerful procedures\nfor multiple testing correction may be available, in order to control\nthe FWER while achieving higher power (i.e. committing fewer Type II\n14In fact, calculating the \u201ccorrect\u201d value of m is quite technical, and outside the scope\nof this book.\n570 13. Multiple Testing\n\u25cf\n0.0 0.2 0.4 0.6 0.8 1.0\n0.0 0.2 0.4 0.6 0.8 1.0\nFamily\u2212Wise Error Rate\nPower\nm = 10\nm = 100\nm = 500\nFIGURE 13.5. In a simulation setting in which 90% of the m null hypotheses\nare true, we display the power (the fraction of false null hypotheses that we\nsuccessfully reject) as a function of the family-wise error rate. The curves correspond\nto m = 10 (orange), m = 100 (blue), and m = 500 (purple). As the value\nof m increases, the power decreases. The vertical dashed line indicates a FWER\nof 0.05.\nerrors) than would be possible using Holm or Bonferroni. In this section,\nwe have illustrated two such examples.\n13.3.3 Trade-Off Between the FWER and Power\nIn general, there is a trade-off between the FWER threshold that we choose,\nand our power to reject the null hypotheses. Recall that power is defined\nas the number of false null hypotheses that we reject divided by the total\nnumber of false null hypotheses, i.e. S/(m\u2212m0) using the notation of Table\n13.2. Figure 13.5 illustrates the results of a simulation setting involving\nm null hypotheses, of which 90% are true and the remaining 10% are false;\npower is displayed as a function of the FWER. In this particular simulation\nsetting, when m = 10, a FWER of 0.05 corresponds to power of approximately\n60%. However, as m increases, the power decreases. With m = 500,\nthe power is below 0.2 at a FWER of 0.05, so that we successfully reject\nonly 20% of the false null hypotheses.\nFigure 13.5 indicates that it is reasonable to control the FWER when m\ntakes on a small value, like 5 or 10. However, for m = 100 or m = 1,000,\nattempting to control the FWER will make it almost impossible to reject\nany of the false null hypotheses. In other words, the power will be extremely\nlow.\n13.4 The False Discovery Rate 571\nWhy is this the case? Recall that, using the notation in Table 13.2, the\nFWER is defined as Pr(V \u2265 1) (13.3). In other other words, controlling the\nFWER at level \u03b1 guarantees that the data analyst is very unlikely (with\nprobability no more than \u03b1) to reject any true null hypotheses, i.e. to have\nany false positives. In order to make good on this guarantee when m is\nlarge, the data analyst may be forced to reject very few null hypotheses, or\nperhaps even none at all (since if R = 0 then also V = 0; see Table 13.2).\nThis is scientifically uninteresting, and typically results in very low power,\nas in Figure 13.5.\nIn practice, when m is large, we may be willing to tolerate a few false\npositives, in the interest of making more discoveries, i.e. more rejections of\nthe null hypothesis. This is the motivation behind the false discovery rate,\nwhich we present next.\n13.4 The False Discovery Rate\n13.4.1 Intuition for the False Discovery Rate\nAs we just discussed, when m is large, then trying to prevent any false\npositives (as in FWER control) is simply too stringent. Instead, we might\ntry to make sure that the ratio of false positives (V ) to total positives\n(V + S = R) is sufficiently low, so that most", "doc_id": "d026852c-013b-4190-8ec6-458a73a17d0a", "embedding": null, "doc_hash": "22c60f4e86a77e3b49cb72d4499f447ac1a7a89e4d3b013ed01c09b1d478664d", "extra_info": null, "node_info": {"start": 1286184, "end": 1289653, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "560c344c-79e1-4c51-98b7-0172112ae634", "3": "1e534c83-92da-446e-9c7d-7bbe7f33a937"}}, "__type__": "1"}, "1e534c83-92da-446e-9c7d-7bbe7f33a937": {"__data__": {"text": "to total positives\n(V + S = R) is sufficiently low, so that most of the rejected null hypotheses\nare not false positives. The ratio V/R is known as the false discovery\nproportion (FDP).\nfalse\ndiscovery\nproportion\nIt might be tempting to ask the data analyst to control the FDP: to\nmake sure that no more than, say, 20% of the rejected null hypotheses are\nfalse positives. However, in practice, controlling the FDP is an impossible\ntask for the data analyst, since she has no way to be certain, on any particular\ndataset, which hypotheses are true and which are false. This is very\nsimilar to the fact that the data analyst can control the FWER, i.e. she\ncan guarantee that Pr(V \u2265 1) \u2264 \u03b1 for any pre-specified \u03b1, but she cannot\nguarantee that V = 0 on any particular dataset (short of failing to reject\nany null hypotheses, i.e. setting R = 0).\nTherefore, we instead control the false discovery rate (FDR)15, defined\nfalse\ndiscovery\nrate\nas\nFDR = E(FDP) = E(V/R). (13.9)\nWhen we control the FDR at (say) level q = 20%, we are rejecting as many\nnull hypotheses as possible while guaranteeing that no more than 20% of\nthose rejected null hypotheses are false positives, on average.\n15If R = 0, then we replace the ratio V/R with 0, to avoid computing 0/0. Formally,\nFDR = E(V/R|R > 0) Pr(R > 0).\n572 13. Multiple Testing\nIn the definition of the FDR in (13.9), the expectation is taken over the\npopulation from which the data are generated. For instance, suppose we\ncontrol the FDR for m null hypotheses at q = 0.2. This means that if we\nrepeat this experiment a huge number of times, and each time control the\nFDR at q = 0.2, then we should expect that, on average, 20% of the rejected\nnull hypotheses will be false positives. On a given dataset, the fraction of\nfalse positives among the rejected hypotheses may be greater than or less\nthan 20%.\nThus far, we have motivated the use of the FDR from a pragmatic perspective,\nby arguing that when m is large, controlling the FWER is simply\ntoo stringent, and will not lead to \u201cenough\u201d discoveries. An additional motivation\nfor the use of the FDR is that it aligns well with the way that data\nare often collected in contemporary applications. As datasets continue to\ngrow in size across a variety of fields, it is increasingly common to conduct a\nhuge number of hypothesis tests for exploratory, rather than confirmatory,\npurposes. For instance, a genomic researcher might sequence the genomes\nof individuals with and without some particular medical condition, and\nthen, for each of 20,000 genes, test whether sequence variants in that gene\nare associated with the medical condition of interest. This amounts to performing\nm = 20,000 hypothesis tests. The analysis is exploratory in nature,\nin the sense that the researcher does not have any particular hypothesis\nin mind; instead she wishes to see whether there is modest evidence for\nthe association between each gene and the disease, with a plan to further\ninvestigate any genes for which there is such evidence. She is likely willing\nto tolerate some number of false positives in the set of genes that she will\ninvestigate further; thus, the FWER is not an appropriate choice. However,\nsome correction for multiple testing is required: it would not be a\ngood idea for her to simply investigate all genes with p-values less than\n(say) 0.05, since we would expect 1,000 genes to have such small p-values\nsimply by chance, even if no genes are associated with the disease (since\n0.05 \u00d7 20,000 = 1,000). Controlling the FDR for her exploratory analysis\nat 20% guarantees that \u2014 on average \u2014 no more than", "doc_id": "1e534c83-92da-446e-9c7d-7bbe7f33a937", "embedding": null, "doc_hash": "af36be58858afe620ce13ffd4b39edd03debd013e41d435a62546725c06c2262", "extra_info": null, "node_info": {"start": 1289642, "end": 1293240, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "d026852c-013b-4190-8ec6-458a73a17d0a", "3": "bf137ce9-4cf3-419d-b94f-33e4b186206d"}}, "__type__": "1"}, "bf137ce9-4cf3-419d-b94f-33e4b186206d": {"__data__": {"text": "her exploratory analysis\nat 20% guarantees that \u2014 on average \u2014 no more than 20% of the genes\nthat she investigates further are false positives.\nIt is worth noting that unlike p-values, for which a threshold of 0.05\nis typically viewed as the minimum standard of evidence for a \u201cpositive\u201d\nresult, and a threshold of 0.01 or even 0.001 is viewed as much more compelling,\nthere is no standard accepted threshold for FDR control. Instead,\nthe choice of FDR threshold is typically context-dependent, or even datasetdependent.\nFor instance, the genomic researcher in the previous example\nmight seek to control the FDR at a threshold of 10% if the planned followup\nanalysis is time-consuming or expensive. Alternatively, a much larger\nthreshold of 30% might be suitable if she plans an inexpensive follow-up\nanalysis.\n13.4 The False Discovery Rate 573\n13.4.2 The Benjamini-Hochberg Procedure\nWe now focus on the task of controlling the FDR: that is, deciding which\nnull hypotheses to reject while guaranteeing that the FDR, E(V/R), is less\nthan or equal to some pre-specified value q. In order to do this, we need\nsome way to connect the p-values, p1, . . . ,pm, from the m null hypotheses\nto the desired FDR value, q. It turns out that a very simple procedure,\noutlined in Algorithm 13.2, can be used to control the FDR.\nAlgorithm 13.2 Benjamini-Hochberg Procedure to Control the FDR\n1. Specify q, the level at which to control the FDR.\n2. Compute p-values, p1, . . . ,pm, for the m null hypotheses\nH01, . . . ,H0m.\n3. Order the m p-values so that p(1) \u2264 p(2) \u2264 \u00b7 \u00b7 \u00b7 \u2264 p(m).\n4. Define\nL = max{j : p(j) < qj/m}. (13.10)\n5. Reject all null hypotheses H0j for which pj \u2264 p(L).\nAlgorithm 13.2 is known as the Benjamini-Hochberg procedure. The crux\nBenjamini-\nHochberg\nprocedure\nof this procedure lies in (13.10). For example, consider again the first five\nmanagers in the Fund dataset, presented in Table 13.3. (In this example,\nm = 5, although typically we control the FDR in settings involving a much\ngreater number of null hypotheses.) We see that p(1) = 0.006 < 0.05\u00d71/5,\np(2) = 0.012 < 0.05 \u00d7 2/5, p(3) = 0.601 > 0.05 \u00d7 3/5, p(4) = 0.756 >\n0.05 \u00d7 4/5, and p(5) = 0.918 > 0.05 \u00d7 5/5. Therefore, to control the FDR\nat 5%, we reject the null hypotheses that the first and third fund managers\nperform no better than chance.\nAs long as the m p-values are independent or only mildly dependent,\nthen the Benjamini-Hochberg procedure guarantees16 that\nFDR \u2264 q.\nIn other words, this procedure ensures that, on average, no more than a\nfraction q of the rejected null hypotheses are false positives. Remarkably,\nthis holds regardless of how many null hypotheses are true, and regardless\nof the distribution of the p-values for the null hypotheses that are false.\nTherefore, the Benjamini-Hochberg procedure gives us a very easy way to\ndetermine, given a set of m p-values, which null hypotheses to reject in\norder to control the FDR at any pre-specified level q.\n16However, the proof is well beyond the scope of this book.\n574 13. Multiple Testing\n\u03b1 = 0.05 \u03b1 = 0.1 \u03b1 = 0.3\n1 5 50 500\n1e\u221205 1e\u221203 1e\u221201\nIndex\nP\u2212Value\n1 5 50", "doc_id": "bf137ce9-4cf3-419d-b94f-33e4b186206d", "embedding": null, "doc_hash": "8add4b92919c60ce7c7080199039f44d39fa17bfbf37f21aec725cd9d62b90a4", "extra_info": null, "node_info": {"start": 1293230, "end": 1296337, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "1e534c83-92da-446e-9c7d-7bbe7f33a937", "3": "03794dd0-d752-4151-8131-25803d72a3b8"}}, "__type__": "1"}, "03794dd0-d752-4151-8131-25803d72a3b8": {"__data__": {"text": "1e\u221203 1e\u221201\nIndex\nP\u2212Value\n1 5 50 500\n1e\u221205 1e\u221203 1e\u221201\nIndex\nP\u2212Value\n1 5 50 500\n1e\u221205 1e\u221203 1e\u221201\nIndex\nP\u2212Value\nFIGURE 13.6. Each panel displays the same set of m = 2,000 ordered p-values\nfor the Fund data. The green lines indicate the p-value thresholds corresponding\nto FWER control, via the Bonferroni procedure, at levels \u03b1 = 0.05 (left), \u03b1 = 0.1\n(center), and \u03b1 = 0.3 (right). The orange lines indicate the p-value thresholds\ncorresponding to FDR control, via Benjamini-Hochberg, at levels q = 0.05 (left),\nq = 0.1 (center), and q = 0.3 (right). When the FDR is controlled at level q = 0.1,\n146 null hypotheses are rejected (center); the corresponding p-values are shown\nin blue. When the FDR is controlled at level q = 0.3, 279 null hypotheses are\nrejected (right); the corresponding p-values are shown in blue.\nThere is a fundamental difference between the Bonferroni procedure of\nSection 13.3.2 and the Benjamini-Hochberg procedure. In the Bonferroni\nprocedure, in order to control the FWER for m null hypotheses at level\n\u03b1, we must simply reject null hypotheses for which the p-value is below\n\u03b1/m. This threshold of \u03b1/m does not depend on anything about the data\n(beyond the value of m), and certainly does not depend on the p-values\nthemselves. By contrast, the rejection threshold used in the Benjamini-\nHochberg procedure is more complicated: we reject all null hypotheses for\nwhich the p-value is less than or equal to the Lth smallest p-value, where\nL is itself a function of all m p-values, as in (13.10). Therefore, when conducting\nthe Benjamini-Hochberg procedure, we cannot plan out in advance\nwhat threshold we will use to reject p-values; we need to first see our data.\nFor instance, in the abstract, there is no way to know whether we will reject\na null hypothesis corresponding to a p-value of 0.01 when using an FDR\nthreshold of 0.1 with m = 100; the answer depends on the values of the\nother m\u2212 1 p-values. This property of the Benjamini-Hochberg procedure\nis shared by the Holm procedure, which also involves a data-dependent\np-value threshold.\nFigure 13.6 displays the results of applying the Bonferroni and Benjamini-\nHochberg procedures on the Fund data set, using the full set of m = 2,000\n13.5 A Re-Sampling Approach to p-Values and False Discovery Rates 575\nfund managers, of which the first five were displayed in Table 13.3. When\nthe FWER is controlled at level 0.3 using Bonferroni, only one null hypothesis\nis rejected; that is, we can conclude only that a single fund manager is\nbeating the market. This is despite the fact that a substantial portion of\nthe m = 2,000 fund managers appear to have beaten the market without\nperforming correction for multiple testing \u2014 for instance, 13 of them have\np-values below 0.001. By contrast, when the FDR is controlled at level 0.3,\nwe can conclude that 279 fund managers are beating the market: we expect\nthat no more than around 279\u00d70.3 = 83.7 of these fund managers had good\nperformance only due to chance. Thus, we see that FDR control is much\nmilder \u2014 and more powerful \u2014 than FWER control, in the sense that it\nallows us to reject many more null hypotheses, with a cost of substantially\nmore false positives.\nThe Benjamini-Hochberg procedure has been around since the mid-1990s.\nWhile a great many papers have been published since then proposing alternative\napproaches for FDR control that can perform better in particular\nscenarios, the", "doc_id": "03794dd0-d752-4151-8131-25803d72a3b8", "embedding": null, "doc_hash": "a0a04e3d6813448eafb9f1a1979a57b1de7acc70d8185c3ddcbe40226bab6fa1", "extra_info": null, "node_info": {"start": 1296372, "end": 1299792, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "bf137ce9-4cf3-419d-b94f-33e4b186206d", "3": "7401088e-99ad-4c5a-9fda-59f09addd904"}}, "__type__": "1"}, "7401088e-99ad-4c5a-9fda-59f09addd904": {"__data__": {"text": "for FDR control that can perform better in particular\nscenarios, the Benjamini-Hochberg procedure remains a very useful and\nwidely-applicable approach.\n13.5 A Re-Sampling Approach to p-Values and\nFalse Discovery Rates\nThus far, the discussion in this chapter has assumed that we are interested\nin testing a particular null hypothesis H0 using a test statistic T, which\nhas some known (or assumed) distribution under H0, such as a normal\ndistribution, a t-distribution, a \u03c72-distribution, or an F-distribution. This\nis referred to as the theoretical null distribution. We typically rely upon\ntheoretical\nnull\ndistribution\nthe availability of a theoretical null distribution in order to obtain a pvalue\nassociated with our test statistic. Indeed, for most of the types of\nnull hypotheses that we might be interested in testing, a theoretical null\ndistribution is available, provided that we are willing to make stringent\nassumptions about our data.\nHowever, if our null hypothesis H0 or test statistic T is somewhat unusual,\nthen it may be the case that no theoretical null distribution is available.\nAlternatively, even if a theoretical null distribution exists, then we\nmay be wary of relying upon it, perhaps because some assumption that is\nrequired for it to hold is violated. For instance, maybe the sample size is\ntoo small.\nIn this section, we present a framework for performing inference in this\nsetting, which exploits the availability of fast computers in order to approximate\nthe null distribution of T, and thereby to obtain a p-value. While this\nframework is very general, it must be carefully instantiated for a specific\nproblem of interest. Therefore, in what follows, we consider a specific ex576\n13. Multiple Testing\nample in which we wish to test whether the means of two random variables\nare equal, using a two-sample t-test.\nThe discussion in this section is more challenging than the preceding\nsections in this chapter, and can be safely skipped by a reader who is\ncontent to use the theoretical null distribution to compute p-values for his\nor her test statistics.\n13.5.1 A Re-Sampling Approach to the p-Value\nWe return to the example of Section 13.1.1, in which we wish to test whether\nthe mean of a random variable X equals the mean of a random variable Y ,\ni.e. H0 : E(X) = E(Y ), against the alternative Ha : E(X) \u0338= E(Y ). Given\nnX independent observations from X and nY independent observations\nfrom Y , the two-sample t-statistic takes the form\nT =\n\u02c6\u03bcX \u2212 \u02c6\u03bcY\ns\nG\n1\nnX\n+ 1\nnY\n(13.11)\nwhere \u02c6\u03bcX = 1\nnX\n)nX\ni=1 xi, \u02c6\u03bcY = 1\nnY\n)nY\ni=1 yi, s =\nG\n(nX\u22121)s2\nX+(nY \u22121)s2\nY\nnX+nY \u22122 ,\nand s2\nX and s2\nY are unbiased estimators of the variances in the two groups.\nA large (absolute) value of T provides evidence against H0.\nIf nX and nY are large, then T in (13.11) approximately follows a N(0, 1)\ndistribution. But if nX and nY are small, then in the absence of a strong\nassumption about the distribution of X and Y , we do not know the theoretical\nnull distribution of T.17 In this case, it turns out that we can\napproximate the null distribution of T using a re-sampling approach, or\nre-sampling\nmore specifically, a permutation approach.\npermutation\nTo do this, we conduct a thought experiment. If H0 holds, so that E(X) =\nE(Y ), and we make the stronger assumption that the distributions of X\nand Y are the same, then the distribution of T is invariant under swapping\nobservations of X with observations of Y . That is, if", "doc_id": "7401088e-99ad-4c5a-9fda-59f09addd904", "embedding": null, "doc_hash": "dec0bcbd70b7dc2fe967afb9116ca9a2ea6ae625c25330bd87bbfd8a59cfd7b7", "extra_info": null, "node_info": {"start": 1299763, "end": 1303206, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "03794dd0-d752-4151-8131-25803d72a3b8", "3": "7d3c3325-db24-4420-b640-6766d5540665"}}, "__type__": "1"}, "7d3c3325-db24-4420-b640-6766d5540665": {"__data__": {"text": "under swapping\nobservations of X with observations of Y . That is, if we randomly swap\nsome of the observations in X with the observations in Y , then the test\nstatistic T in (13.11) computed based on this swapped data has the same\ndistribution as T based on the original data. This is true only if H0 holds,\nand the distributions of X and Y are the same.\nThis suggests that in order to approximate the null distribution of T,\nwe can take the following approach. We randomly permute the nX + nY\nobservations B times, for some large value of B, and each time we compute\n17If we assume that X and Y are normally distributed, then T in (13.11) follows a\nt-distribution with nX +nY \u22122 degrees of freedom under H0. However, in practice, the\ndistribution of random variables is rarely known, and so it can be preferable to perform\na re-sampling approach instead of making strong and unjustified assumptions. If the\nresults of the re-sampling approach disagree with the results of assuming a theoretical\nnull distribution, then the results of the re-sampling approach are more trustworthy.\n13.5 A Re-Sampling Approach to p-Values and False Discovery Rates 577\n(13.11). We let T\u22171, . . . ,T\u2217B denote the values of (13.11) on the permuted\ndata. These can be viewed as an approximation of the null distribution\nof T under H0. Recall that by definition, a p-value is the probability of\nobserving a test statistic at least this extreme under H0. Therefore, to\ncompute a p-value for T, we can simply compute\np-value =\n)B\nb=1 1(|T\u2217b|\u2265|T|)\nB\n, (13.12)\nthe fraction of permuted datasets for which the value of the test statistic\nis at least as extreme as the value observed on the original data. This\nprocedure is summarized in Algorithm 13.3.\nAlgorithm 13.3 Re-Sampling p-Value for a Two-Sample t-Test\n1. Compute T, defined in (13.11), on the original data x1, . . . ,xnX and\ny1, . . . , ynY .\n2. For b = 1, . . . ,B, where B is a large number (e.g. B = 10,000):\n(a) Permute the nX +nY observations at random. Call the first nX\npermuted observations x\u22171 , . . . ,x\u2217nX, and call the remaining nY\nobservations y\u22171, . . . , y\u2217nY .\n(b) Compute (13.11) on the permuted data x\u22171, . . . ,x\u2217nX and\ny\u22171, . . . , y\u2217nY , and call the result T\u2217b.\n3. The p-value is given by\n!Bb\n=1 1(|T\u2217b|\u2265|T|)\nB .\nWe try out this procedure on the Khan dataset, which consists of expression\nmeasurements for 2,308 genes in four sub-types of small round blood\ncell tumors, a type of cancer typically seen in children. This dataset is part\nof the ISLR2 package. We restrict our attention to the two sub-types for\nwhich the most observations are available: rhabdomyosarcoma (nX = 29)\nand Burkitt\u2019s lymphoma (nY = 25).\nA two-sample t-test for the null hypothesis that the 11th gene\u2019s mean\nexpression values are equal in the two groups yields T = \u22122.09. Using\nthe theoretical null distribution, which is a t52 distribution (since nX +\nnY \u2212 2 = 52), we obtain a p-value of 0.041. (Note that a t52 distribution\nis virtually indistinguishable from a N(0, 1) distribution.) If we instead\napply Algorithm 13.3 with B =", "doc_id": "7d3c3325-db24-4420-b640-6766d5540665", "embedding": null, "doc_hash": "74c979f59f687aa49685a138592825bb6143be0264566337e519e4c61877cc69", "extra_info": null, "node_info": {"start": 1303208, "end": 1306272, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "7401088e-99ad-4c5a-9fda-59f09addd904", "3": "8ed20a7e-0d0b-44d0-8adf-ee32a8b43c63"}}, "__type__": "1"}, "8ed20a7e-0d0b-44d0-8adf-ee32a8b43c63": {"__data__": {"text": "1) distribution.) If we instead\napply Algorithm 13.3 with B = 10,000, then we obtain a p-value of 0.042.\nFigure 13.7 displays the theoretical null distribution, the re-sampling null\ndistribution, and the actual value of the test statistic (T = \u22122.09) for this\ngene. In this example, we see very little difference between the p-values\nobtained using the theoretical null distribution and the re-sampling null\ndistribution.\n578 13. Multiple Testing\nNull Distribution of Test Statistic for 11th Gene\n\u22124 \u22122 0 2 4\n0 100 200 300 400\nT=\u22122.0936\nFIGURE 13.7. The 11th gene in the Khan dataset has a test statistic of\nT = \u22122.09. Its theoretical and re-sampling null distributions are almost identical.\nThe theoretical p-value equals 0.041 and the re-sampling p-value equals 0.042.\nBy contrast, Figure 13.8 shows an analogous set of results for the 877th\ngene. In this case, there is a substantial difference between the theoretical\nand re-sampling null distributions, which results in a difference between\ntheir p-values.\nIn general, in settings with a smaller sample size or a more skewed data\ndistribution (so that the theoretical null distribution is less accurate), the\ndifference between the re-sampling and theoretical p-values will tend to\nbe more pronounced. In fact, the substantial difference between the resampling\nand theoretical null distributions in Figure 13.8 is due to the\nfact that a single observation in the 877th gene is very far from the other\nobservations, leading to a very skewed distribution.\n13.5.2 A Re-Sampling Approach to the False Discovery Rate\nNow, suppose that we wish to control the FDR for m null hypotheses,\nH01, . . . ,H0m, in a setting in which either no theoretical null distribution\nis available, or else we simply prefer to avoid the use of a theoretical null distribution.\nAs in Section 13.5.1, we make use of a two-sample t-statistic for\neach hypothesis, leading to the test statistics T1, . . . ,Tm. We could simply\ncompute a p-value for each of the m null hypotheses, as in Section 13.5.1,\nand then apply the Benjamini-Hochberg procedure of Section 13.4.2 to\nthese p-values. However, it turns out that we can do this in a more direct\nway, without even needing to compute p-values.\nRecall from Section 13.4 that the FDR is defined as E(V/R), using the\nnotation in Table 13.2. In order to estimate the FDR via re-sampling, we\nfirst make the following approximation:\nFDR = E\n*\nV\nR\n+\n\u2248\nE(V )\nR\n. (13.13)\n13.5 A Re-Sampling Approach to p-Values and False Discovery Rates 579\nNull Distribution of Test Statistic for 877th Gene\n\u22124 \u22122 0 2 4\n0 100 200 300 400\nT=\u22120.5696\nFIGURE 13.8. The 877th gene in the Khan dataset has a test statistic of\nT = \u22120.57. Its theoretical and re-sampling null distributions are quite different.\nThe theoretical p-value equals 0.571, and the re-sampling p-value equals 0.673.\nNow suppose we reject any null hypothesis for which the test statistic\nexceeds c in absolute value. Then computing R in the denominator on the\nright-hand side of (13.13) is straightforward: R =\n)m\nj=1 1(|Tj |\u2265c).\nHowever, the numerator E(V ) on the right-hand side of (13.13) is more\nchallenging. This is the expected number of false positives associated with\nrejecting any null hypothesis for which the test statistic exceeds c in absolute\nvalue. At the risk of stating the", "doc_id": "8ed20a7e-0d0b-44d0-8adf-ee32a8b43c63", "embedding": null, "doc_hash": "1f564695b203d0684c169bd5db254d57f7a063c85c33cb01f1306111cf0af677", "extra_info": null, "node_info": {"start": 1306279, "end": 1309585, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "7d3c3325-db24-4420-b640-6766d5540665", "3": "012e421b-45fb-48c5-a98c-6bf83cf82e00"}}, "__type__": "1"}, "012e421b-45fb-48c5-a98c-6bf83cf82e00": {"__data__": {"text": "the test statistic exceeds c in absolute\nvalue. At the risk of stating the obvious, estimating V is challenging\nbecause we do not know which of H01, . . . ,H0m are really true, and so we\ndo not know which rejected hypotheses are false positives. To overcome this\nproblem, we take a re-sampling approach, in which we simulate data under\nH01, . . . ,H0m, and then compute the resulting test statistics. The number\nof re-sampled test statistics that exceed c provides an estimate of V .\nIn greater detail, in the case of a two-sample t-statistic (13.11) for each\nof the null hypotheses H01, . . . ,H0m, we can estimate E(V ) as follows. Let\nx(j)\n1 , . . . ,x(j)\nnX and y(j)\n1 , . . . , y(j)\nnY denote the data associated with the jth\nnull hypothesis, j = 1, . . . ,m. We permute these nX + nY observations at\nrandom, and then compute the t-statistic on the permuted data. For this\npermuted data, we know that all of the null hypotheses H01, . . . ,H0m hold;\ntherefore, the number of permuted t-statistics that exceed the threshold c in\nabsolute value provides an estimate for E(V ). This estimate can be further\nimproved by repeating the permutation process B times, for a large value\nof B, and averaging the results.\nAlgorithm 13.4 details this procedure.18 It provides what is known as a\nplug-in estimate of the FDR, because the approximation in (13.13) allows us\n18To implement Algorithm 13.4 efficiently, the same set of permutations in Step 2(b)i.\nshould be used for all m null hypotheses. An example of such an efficient implementation\ncan be found in the R package samr.\n580 13. Multiple Testing\nAlgorithm 13.4 Plug-In FDR for a Two-Sample T-Test\n1. Select a threshold c, where c > 0.\n2. For j = 1, . . . ,m:\n(a) Compute T(j), the two-sample t-statistic (13.11) for the null\nhypothesis H0j on the basis of the original data, x(j)\n1 , . . . ,x(j)\nnX\nand y(j)\n1 , . . . , y(j)\nnY .\n(b) For b = 1, . . . ,B, where B is a large number (e.g. B = 10,000):\ni. Permute the nX +nY observations at random. Call the first\nnX observations x\u2217(j)\n1 , . . . ,x\u2217(j)\nnX , and call the remaining observations\ny\u2217(j)\n1 , . . . , y\u2217(j)\nnY .\nii. Compute (13.11) on the permuted data x\u2217(j)\n1 , . . . ,x\u2217(j)\nnX and\ny\u2217(j)\n1 , . . . , y\u2217(j)\nnY , and call the result T(j),\u2217b.\n3. Compute R =\n)m\nj=1 1(|T(j)|\u2265c).\n4. Compute WV =\n!Bb\n=1\n!mj\n=1 1(|T(j),\u2217b|\u2265c)\nB .\n5. The estimated FDR associated with the threshold c is WV /R.\nto estimate the FDR by plugging R into the denominator and an estimate\nfor E(V ) into the numerator.\nWe apply the re-sampling approach to the FDR from Algorithm 13.4,\nas well as the Benjamini-Hochberg approach from Algorithm 13.2 using\ntheoretical p-values, to the m = 2,308 genes in the Khan dataset. Results are\nshown in Figure 13.9.We see that for a given number of rejected hypotheses,\nthe estimated", "doc_id": "012e421b-45fb-48c5-a98c-6bf83cf82e00", "embedding": null, "doc_hash": "56948c9c6e009e3a0dac1e8e4f297ba4306a7df0c247ce7b90d7dd49da10cc74", "extra_info": null, "node_info": {"start": 1309576, "end": 1312379, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "8ed20a7e-0d0b-44d0-8adf-ee32a8b43c63", "3": "fe63311a-faeb-428d-83fe-d15d1084df34"}}, "__type__": "1"}, "fe63311a-faeb-428d-83fe-d15d1084df34": {"__data__": {"text": "see that for a given number of rejected hypotheses,\nthe estimated FDRs are almost identical for the two methods.\nWe began this section by noting that in order to control the FDR for m\nhypothesis tests using a re-sampling approach, we could simply compute\nm re-sampling p-values as in Section 13.5.1, and then apply the Benjamini-\nHochberg procedure of Section 13.4.2 to these p-values. It turns out that if\nwe define the jth re-sampling p-value as\npj =\n)m\nj\u2032=1\n)B\nb=1 1(|T\u2217b\nj\u2032 |\u2265|Tj |)\nBm\n(13.14)\nfor j = 1, . . . ,m, instead of as in (13.12), then applying the Benjamini-\nHochberg procedure to these re-sampled p-values is exactly equivalent to\nAlgorithm 13.4. Note that (13.14) is an alternative to (13.12) that pools\nthe information across all m hypothesis tests in approximating the null\ndistribution.\n13.5 A Re-Sampling Approach to p-Values and False Discovery Rates 581\n0 500 1000 1500 2000\n0.0 0.2 0.4 0.6 0.8 1.0\nNumber of Rejections\nFalse Discovery Rate\nFIGURE 13.9. For j = 1, . . . , m = 2,308, we tested the null hypothesis that\nfor the jth gene in the Khan dataset, the mean expression in Burkitt\u2019s lymphoma\nequals the mean expression in rhabdomyosarcoma. For each value of k from 1 to\n2,308, the y-axis displays the estimated FDR associated with rejecting the null hypotheses\ncorresponding to the k smallest p-values. The orange dashed curve shows\nthe FDR obtained using the Benjamini-Hochberg procedure, whereas the blue solid\ncurve shows the FDR obtained using the re-sampling approach of Algorithm 13.4,\nwith B = 10,000. There is very little difference between the two FDR estimates.\nAccording to either estimate, rejecting the null hypothesis for the 500 genes with\nthe smallest p-values corresponds to an FDR of around 17.7%.\n13.5.3 When Are Re-Sampling Approaches Useful?\nIn Sections 13.5.1 and 13.5.2, we considered testing null hypotheses of the\nform H0 : E(X) = E(Y ) using a two-sample t-statistic (13.11), for which we\napproximated the null distribution via a re-sampling approach.We saw that\nusing the re-sampling approach gave us substantially different results from\nusing the theoretical p-value approach in Figure 13.8, but not in Figure 13.7.\nIn general, there are two settings in which a re-sampling approach is\nparticularly useful:\n1. Perhaps no theoretical null distribution is available. This may be the\ncase if you are testing an unusual null hypothesis H0, or using an\nunsual test statistic T.\n2. Perhaps a theoretical null distribution is available, but the assumptions\nrequired for its validity do not hold. For instance, the twosample\nt-statistic in (13.11) follows a tnX+nY \u22122 distribution only if\nthe observations are normally distributed. Furthermore, it follows a\nN(0, 1) distribution only if nX and nY are quite large. If the data are\nnon-normal and nX and nY are small, then p-values that make use\nof the theoretical null distribution will not be valid (i.e. they will not\nproperly control the Type I error).\nIn general, if you can come up with a way to re-sample or permute\nyour observations in order to generate data that follow the null distribu582\n13. Multiple Testing\ntion, then you can compute p-values or estimate the FDR using variants\nof Algorithms 13.3 and 13.4. In many real-world settings, this provides", "doc_id": "fe63311a-faeb-428d-83fe-d15d1084df34", "embedding": null, "doc_hash": "3f08577440a93f416d420b5f8a520ca949e17af806aa4f42deda6ac2ca1526f6", "extra_info": null, "node_info": {"start": 1312386, "end": 1315647, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "012e421b-45fb-48c5-a98c-6bf83cf82e00", "3": "6c2e0e83-9cc0-467a-b5e8-35ba35eb3e2a"}}, "__type__": "1"}, "6c2e0e83-9cc0-467a-b5e8-35ba35eb3e2a": {"__data__": {"text": "13.3 and 13.4. In many real-world settings, this provides a\npowerful tool for hypothesis testing when no out-of-box hypothesis tests are\navailable, or when the key assumptions underlying those out-of-box tests\nare violated.\n13.6 Lab: Multiple Testing\n13.6.1 Review of Hypothesis Tests\nWe begin by performing some one-sample t-tests using the t.test() funct.\ntest()\ntion. First we create 100 variables, each consisting of 10 observations. The\nfirst 50 variables have mean 0.5 and variance 1, while the others have mean\n0 and variance 1.\n> set.seed (6)\n> x <- matrix(rnorm (10 * 100) , 10, 100)\n> x[, 1:50] <- x[, 1:50] + 0.5\nThe t.test() function can perform a one-sample or a two-sample t-test.\nBy default, a one-sample test is performed. To begin, we test H0 : \u03bc1 = 0,\nthe null hypothesis that the first variable has mean zero.\n> t.test(x[, 1], mu = 0)\nOne Sample t-test\ndata: x[, 1]\nt = 2.08, df = 9, p-value = 0.067\nalternative hypothesis: true mean is not equal to 0\n95 percent confidence interval:\n-0.05171 1.26243\nsample estimates:\nmean of x\n0.6054\nThe p-value comes out to 0.067, which is not quite low enough to reject\nthe null hypothesis at level \u03b1 = 0.05. In this case, \u03bc1 = 0.5, so the null\nhypothesis is false. Therefore, we have made a Type II error by failing to\nreject the null hypothesis when the null hypothesis is false.\nWe now test H0j : \u03bcj = 0 for j = 1, . . . , 100. We compute the 100 pvalues,\nand then construct a vector recording whether the jth p-value is\nless than or equal to 0.05, in which case we reject H0j , or greater than 0.05,\nin which case we do not reject H0j , for j = 1, . . . , 100.\n> p.values <- rep(0, 100)\n> for (i in 1:100)\n+ p.values[i] <- t.test(x[, i], mu = 0)$p.value\n> decision <- rep(\"Do not reject H0\", 100)\n> decision[p.values <= .05] <- \"Reject H0\"\nSince this is a simulated data set, we can create a 2 \u00d7 2 table similar to\nTable 13.2.\n13.6 Lab: Multiple Testing 583\n> table(decision ,\nc(rep(\"H0 is False\", 50), rep(\"H0 is True\", 50))\n)\ndecision H0 is False H0 is True\nDo not reject H0 40 47\nReject H0 10 3\nTherefore, at level \u03b1 = 0.05, we reject just 10 of the 50 false null hypotheses,\nand we incorrectly reject 3 of the true null hypotheses. Using the notation\nfrom Section 13.3, we have W = 40, U = 47, S = 10, and V = 3. Note\nthat the rows and columns of this table are reversed relative to Table 13.2.\nWe have set \u03b1 = 0.05, which means that we expect to reject around 5% of\nthe true null hypotheses. This is in line with the 2 \u00d7 2 table above, which\nindicates that we rejected V = 3 of the 50 true null hypotheses.\nIn the simulation above, for the false null hypotheses, the ratio of the\nmean to the standard deviation was only 0.5/1 = 0.5. This amounts to\nquite a weak signal, and it resulted in a high number of Type II errors. If\nwe instead simulate data with a stronger signal, so that the ratio of the\nmean to the standard deviation for the false null hypotheses equals 1, then\nwe make only 9 Type II errors.\n> x <- matrix(rnorm (10 * 100) , 10, 100)\n> x[,", "doc_id": "6c2e0e83-9cc0-467a-b5e8-35ba35eb3e2a", "embedding": null, "doc_hash": "e7b9af43155b545e6ba718fe58e7f4c1b95117f01b24f289d7f8b22dcc278c84", "extra_info": null, "node_info": {"start": 1315655, "end": 1318674, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "fe63311a-faeb-428d-83fe-d15d1084df34", "3": "4bd165db-6de7-48f5-90d7-a35585bb153b"}}, "__type__": "1"}, "4bd165db-6de7-48f5-90d7-a35585bb153b": {"__data__": {"text": "matrix(rnorm (10 * 100) , 10, 100)\n> x[, 1:50] <- x[, 1:50] + 1\n> for (i in 1:100)\n+ p.values[i] <- t.test(x[, i], mu = 0)$p.value\n> decision <- rep(\"Do not reject H0\", 100)\n> decision[p.values <= .05] <- \"Reject H0\"\n> table(decision ,\nc(rep(\"H0 is False\", 50), rep(\"H0 is True\", 50))\n)\ndecision H0 is False H0 is True\nDo not reject H0 9 49\nReject H0 41 1\n13.6.2 The Family-Wise Error Rate\nRecall from (13.5) that if the null hypothesis is true for each of m independent\nhypothesis tests, then the FWER is equal to 1\u2212(1\u2212\u03b1)m. We can use\nthis expression to compute the FWER for m = 1, . . . , 500 and \u03b1 = 0.05,\n0.01, and 0.001.\n> m <- 1:500\n> fwe1 <- 1 - (1 - 0.05)^m\n> fwe2 <- 1 - (1 - 0.01)^m\n> fwe3 <- 1 - (1 - 0.001)^m\nWe plot these three vectors in order to reproduce Figure 13.2. The red,\nblue, and green lines correspond to \u03b1 = 0.05, 0.01, and 0.001, respectively.\n> par(mfrow = c(1, 1))\n> plot(m, fwe1 , type = \"l\", log = \"x\", ylim = c(0, 1), col = 2,\n584 13. Multiple Testing\nylab = \"Family - Wise Error Rate\",\nxlab = \"Number of Hypotheses\")\n> lines(m, fwe2 , col = 4)\n> lines(m, fwe3 , col = 3)\n> abline(h = 0.05, lty = 2)\nAs discussed previously, even for moderate values of m such as 50, the\nFWER exceeds 0.05 unless \u03b1 is set to a very low value, such as 0.001. Of\ncourse, the problem with setting \u03b1 to such a low value is that we are likely\nto make a number of Type II errors: in other words, our power is very low.\nWe now conduct a one-sample t-test for each of the first five managers\nin the Fund dataset, in order to test the null hypothesis that the jth fund\nmanager\u2019s mean return equals zero, H0j : \u03bcj = 0.\n> library(ISLR2)\n> fund.mini <- Fund[, 1:5]\n> t.test(fund.mini[, 1], mu = 0)\nOne Sample t-test\ndata: fund.mini[, 1]\nt = 2.86, df = 49, p-value = 0.006\nalternative hypothesis: true mean is not equal to 0\n95 percent confidence interval:\n0.8923 5.1077\nsample estimates:\nmean of x\n3\n> fund.pvalue <- rep(0, 5)\n> for (i in 1:5)\n+ fund.pvalue[i] <- t.test(fund.mini[, i], mu = 0)$p.value\n> fund.pvalue\n[1] 0.00620 0.91827 0.01160 0.60054 0.75578\nThe p-values are low for Managers One and Three, and high for the other\nthree managers. However, we cannot simply reject H01 and H03, since this\nwould fail to account for the multiple testing that we have performed.\nInstead, we will conduct Bonferroni\u2019s method and Holm\u2019s method to control\nthe FWER.\nTo do this, we use the p.adjust() function. Given the p-values, the funcp.\nadjust()\ntion outputs adjusted p-values, which can be thought of as a new set of\nadjusted\np-values p-values that have been corrected for multiple testing. If the adjusted pvalue\nfor a given hypothesis is less than or equal to \u03b1, then that hypothesis\ncan be rejected while maintaining a FWER of no more", "doc_id": "4bd165db-6de7-48f5-90d7-a35585bb153b", "embedding": null, "doc_hash": "b09602033a6987724967f91f09b83507bc491ee40d57540dccf2dbe8e92a34e9", "extra_info": null, "node_info": {"start": 1318691, "end": 1321430, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "6c2e0e83-9cc0-467a-b5e8-35ba35eb3e2a", "3": "69bb24f0-3ff8-44a6-a84d-b1c5275e3445"}}, "__type__": "1"}, "69bb24f0-3ff8-44a6-a84d-b1c5275e3445": {"__data__": {"text": "then that hypothesis\ncan be rejected while maintaining a FWER of no more than \u03b1. In other\nwords, the adjusted p-values resulting from the p.adjust() function can\nsimply be compared to the desired FWER in order to determine whether\nor not to reject each hypothesis.\nFor example, in the case of Bonferroni\u2019s method, the raw p-values are\nmultiplied by the total number of hypotheses, m, in order to obtain the\nadjusted p-values. (However, adjusted p-values are not allowed to exceed\n1.)\n13.6 Lab: Multiple Testing 585\n> p.adjust(fund.pvalue , method = \"bonferroni\")\n[1] 0.03101 1.00000 0.05800 1.00000 1.00000\n> pmin(fund.pvalue * 5, 1)\n[1] 0.03101 1.00000 0.05800 1.00000 1.00000\nTherefore, using Bonferroni\u2019s method, we are able to reject the null hypothesis\nonly for Manager One while controlling the FWER at 0.05.\nBy contrast, using Holm\u2019s method, the adjusted p-values indicate that\nwe can reject the null hypotheses for Managers One and Three at a FWER\nof 0.05.\n> p.adjust(fund.pvalue , method = \"holm\")\n[1] 0.03101 1.00000 0.04640 1.00000 1.00000\nAs discussed previously, Manager One seems to perform particularly well,\nwhereas Manager Two has poor performance.\n> apply(fund.mini , 2, mean)\nManager1 Manager2 Manager3 Manager4 Manager5\n3.0 -0.1 2.8 0.5 0.3\nIs there evidence of a meaningful difference in performance between these\ntwo managers? Performing a paired t-test using the t.test() function repaired\nt-test\nsults in a p-value of 0.038, suggesting a statistically significant difference.\n> t.test(fund.mini[, 1], fund.mini[, 2], paired = T)\nPaired t-test\ndata: fund.mini[, 1] and fund.mini[, 2]\nt = 2.13, df = 49, p-value = 0.038\nalternative hypothesis: true difference in means is not equal\nto 0\n95 percent confidence interval:\n0.1725 6.0275\nsample estimates:\nmean of the differences\n3.1\nHowever, we decided to perform this test only after examining the data\nand noting that Managers One and Two had the highest and lowest mean\n'performances. In a sense, this means that we have implicitly performed 5\n2\n(\n= 5(5 \u2212 1)/2 = 10 hypothesis tests, rather than just one, as discussed\nin Section 13.3.2. Hence, we use the TukeyHSD() function to apply Tukey\u2019s\nTukeyHSD()\nmethod in order to adjust for multiple testing. This function takes as input\nthe output of an ANOVA regression model, which is essentially just a linear\nANOVA\nregression in which all of the predictors are qualitative. In this case, the\nresponse consists of the monthly excess returns achieved by each manager,\nand the predictor indicates the manager to which each return corresponds.\n> returns <- as.vector(as.matrix(fund.mini))\n> manager <- rep(c(\"1\", \"2\", \"3\", \"4\", \"5\"), rep(50, 5))\n> a1 <- aov(returns \u223c manager)\n> TukeyHSD(x = a1)\nTukey multiple comparisons of means\n586 13. Multiple Testing\n95% family -wise confidence level\nFit: aov(formula = returns \u223c manager)\n$manager\ndiff lwr upr p adj\n2-1 -3.1 -6.9865 0.7865 0.1862\n3-1 -0.2 -4.0865 3.6865 0.9999\n4-1 -2.5 -6.3865 1.3865 0.3948\n5-1 -2.7 -6.5865 1.1865 0.3152\n3-2 2.9", "doc_id": "69bb24f0-3ff8-44a6-a84d-b1c5275e3445", "embedding": null, "doc_hash": "8cb5f1a9fd4d651ff94302a982584467852132fee054fa3356340c70cd216360", "extra_info": null, "node_info": {"start": 1321403, "end": 1324406, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "4bd165db-6de7-48f5-90d7-a35585bb153b", "3": "d9c2edc6-f2af-44cf-abba-6bf7ed0e38a3"}}, "__type__": "1"}, "d9c2edc6-f2af-44cf-abba-6bf7ed0e38a3": {"__data__": {"text": "-6.5865 1.1865 0.3152\n3-2 2.9 -0.9865 6.7865 0.2453\n4-2 0.6 -3.2865 4.4865 0.9932\n5-2 0.4 -3.4865 4.2865 0.9986\n4-3 -2.3 -6.1865 1.5865 0.4820\n5-3 -2.5 -6.3865 1.3865 0.3948\n5-4 -0.2 -4.0865 3.6865 0.9999\nThe TukeyHSD() function provides confidence intervals for the difference\nbetween each pair of managers (lwr and upr), as well as a p-value. All of\nthese quantities have been adjusted for multiple testing. Notice that the\np-value for the difference between Managers One and Two has increased\nfrom 0.038 to 0.186, so there is no longer clear evidence of a difference\nbetween the managers\u2019 performances. We can plot the confidence intervals\nfor the pairwise comparisons using the plot() function.\n> plot(TukeyHSD(x = a1))\nThe result can be seen in Figure 13.10.\n13.6.3 The False Discovery Rate\nNow we perform hypothesis tests for all 2,000 fund managers in the Fund\ndataset. We perform a one-sample t-test of H0j : \u03bcj = 0, which states that\nthe jth fund manager\u2019s mean return is zero.\n> fund.pvalues <- rep(0, 2000)\n> for (i in 1:2000)\n+ fund.pvalues[i] <- t.test(Fund[, i], mu = 0)$p.value\nThere are far too many managers to consider trying to control the FWER.\nInstead, we focus on controlling the FDR: that is, the expected fraction of\nrejected null hypotheses that are actually false positives. The p.adjust()\nfunction can be used to carry out the Benjamini-Hochberg procedure.\n> q.values.BH <- p.adjust(fund.pvalues , method = \"BH\")\n> q.values.BH[1:10]\n[1] 0.08989 0.99149 0.12212 0.92343 0.95604 0.07514 0.07670\n[8] 0.07514 0.07514 0.07514\nThe q-values output by the Benjamini-Hochberg procedure can be interq-\nvalues\npreted as the smallest FDR threshold at which we would reject a particular\nnull hypothesis. For instance, a q-value of 0.1 indicates that we can reject\n13.6 Lab: Multiple Testing 587\n\u22126 \u22124 \u22122 0 2 4 6\n5\u22124 5\u22123 4\u22123 5\u22122 4\u22122 3\u22122 5\u22121 4\u22121 3\u22121 2\u22121\n95% family\u2212wise confidence level\nDifferences in mean levels of manager\nFIGURE 13.10. 95% confidence intervals comparing each pair of managers on\nthe Fund data, using Tukey\u2019s method to adjust for multiple testing. All of the\nconfidence intervals overlap zero, so none of the differences among managers are\nstatistically significant when controlling the FWER at level 0.05.\nthe corresponding null hypothesis at an FDR of 10% or greater, but that\nwe cannot reject the null hypothesis at an FDR below 10%.\nIf we control the FDR at 10%, then for how many of the fund managers\ncan we reject H0j : \u03bcj = 0?\n> sum(q.values.BH <= .1)\n[1] 146\nWe find that 146 of the 2,000 fund managers have a q-value below 0.1;\ntherefore, we are able to conclude that 146 of the fund managers beat the\nmarket at an FDR of 10%. Only about 15 (10% of 146) of these fund\nmanagers are likely to be false discoveries. By contrast, if we had instead\nused Bonferroni\u2019s method to control the FWER at level \u03b1 = 0.1, then we\nwould have failed to reject any null hypotheses!\n> sum(fund.pvalues <= (0.1 / 2000))\n[1]", "doc_id": "d9c2edc6-f2af-44cf-abba-6bf7ed0e38a3", "embedding": null, "doc_hash": "9447919e7e87ff5c6fa7f5821e866648874a2fe0c1fec712faf08d5b653bf89f", "extra_info": null, "node_info": {"start": 1324442, "end": 1327385, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "69bb24f0-3ff8-44a6-a84d-b1c5275e3445", "3": "202abd6c-d6bb-45f2-865d-35ab4039e251"}}, "__type__": "1"}, "202abd6c-d6bb-45f2-865d-35ab4039e251": {"__data__": {"text": "sum(fund.pvalues <= (0.1 / 2000))\n[1] 0\nFigure 13.6 displays the ordered p-values, p(1) \u2264 p(2) \u2264 \u00b7 \u00b7 \u00b7 \u2264 p(2000), for\nthe Fund dataset, as well as the threshold for rejection by the Benjamini-\nHochberg procedure. Recall that the Benjamini-Hochberg procedure searches\nfor the largest p-value such that p(j) < qj/m, and rejects all hypotheses\nfor which the p-value is less than or equal to p(j). In the code below, we\nimplement the Benjamini-Hochberg procedure ourselves, in order to illustrate\nhow it works. We first order the p-values. We then identify all p-values\nthat satisfy p(j) < qj/m (wh.ps). Finally, wh indexes all p-values that are\n588 13. Multiple Testing\nless than or equal to the largest p-value in wh.ps. Therefore, wh indexes the\np-values rejected by the Benjamini-Hochberg procedure.\n> ps <- sort(fund.pvalues)\n> m <- length(fund.pvalues)\n> q <- 0.1\n> wh.ps <- which(ps < q * (1:m) / m)\n> if (length(wh.ps) >0) {\n+ wh <- 1:max(wh.ps)\n+ } else {\n+ wh <- numeric (0)\n+ }\nWe now reproduce the middle panel of Figure 13.6.\n> plot(ps , log = \"xy\", ylim = c(4e-6, 1), ylab = \"P-Value\",\nxlab = \"Index\", main = \"\")\n> points(wh, ps[wh], col = 4)\n> abline(a = 0, b = (q / m), col = 2, untf = TRUE)\n> abline(h = 0.1 / 2000, col = 3)\n13.6.4 A Re-Sampling Approach\nHere, we implement the re-sampling approach to hypothesis testing using\nthe Khan dataset, which we investigated in Section 13.5. First, we merge\nthe training and testing data, which results in observations on 83 patients\nfor 2,308 genes.\n> attach(Khan)\n> x <- rbind(xtrain , xtest)\n> y <- c(as.numeric(ytrain), as.numeric(ytest))\n> dim(x)\n[1] 83 2308\n> table(y)\ny\n1 2 3 4\n11 29 18 25\nThere are four classes of cancer. For each gene, we compare the mean expression\nin the second class (rhabdomyosarcoma) to the mean expression in\nthe fourth class (Burkitt\u2019s lymphoma). Performing a standard two-sample\nt-test on the 11th gene produces a test-statistic of \u22122.09 and an associated\np-value of 0.0412, suggesting modest evidence of a difference in mean\nexpression levels between the two cancer types.\n> x <- as.matrix(x)\n> x1 <- x[which(y == 2), ]\n> x2 <- x[which(y == 4), ]\n> n1 <- nrow(x1)\n> n2 <- nrow(x2)\n> t.out <- t.test(x1[, 11], x2[, 11], var.equal = TRUE)\n> TT <- t.out$statistic\n13.6 Lab: Multiple Testing 589\n> TT\nt\n-2.0936\n> t.out$p.value\n[1] 0.04118\nHowever, this p-value relies on the assumption that under the null hypothesis\nof no difference between the two groups, the test statistic follows a\nt-distribution with 29 + 25 \u2212 2 = 52 degrees of freedom. Instead of using\nthis theoretical null distribution, we can randomly split the 54 patients\ninto two groups of 29 and 25, and compute a new test statistic. Under the\nnull hypothesis of no difference between the groups, this new test statistic\nshould have the same distribution as our original", "doc_id": "202abd6c-d6bb-45f2-865d-35ab4039e251", "embedding": null, "doc_hash": "b7208463fc3b4c6c99f4c07745398b3c510a6c77e87a80a447eefaa06350f18b", "extra_info": null, "node_info": {"start": 1327379, "end": 1330201, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "d9c2edc6-f2af-44cf-abba-6bf7ed0e38a3", "3": "53f4eaca-59fe-43a5-929f-d38d27a7a4a0"}}, "__type__": "1"}, "53f4eaca-59fe-43a5-929f-d38d27a7a4a0": {"__data__": {"text": "between the groups, this new test statistic\nshould have the same distribution as our original one. Repeating this\nprocess 10,000 times allows us to approximate the null distribution of the\ntest statistic. We compute the fraction of the time that our observed test\nstatistic exceeds the test statistics obtained via re-sampling.\n> set.seed (1)\n> B <- 10000\n> Tbs <- rep(NA, B)\n> for (b in 1:B) {\n+ dat<-sample(c(x1[, 11], x2[, 11]))\n+ Tbs[b]<-t.test(dat[1:n1], dat[(n1 + 1):(n1 + n2)],\nvar.equal = TRUE\n)$statistic\n+ }\n> mean ((abs(Tbs) >= abs(TT)))\n[1] 0.0416\nThis fraction, 0.0416, is our re-sampling-based p-value. It is almost identical\nto the p-value of 0.0412 obtained using the theoretical null distribution.\nWe can plot a histogram of the re-sampling-based test statistics in order\nto reproduce Figure 13.7.\n> hist(Tbs , breaks = 100, xlim = c(-4.2, 4.2), main = \"\",\nxlab = \"Null Distribution of Test Statistic\", col = 7)\n> lines(seq(-4.2, 4.2, len = 1000),\ndt(seq(-4.2, 4.2, len = 1000),\ndf = (n1 + n2 - 2)\n) * 1000, col = 2, lwd = 3)\n> abline(v = TT, col = 4, lwd = 2)\n> text(TT + 0.5, 350, paste(\"T = \", round(TT, 4), sep = \"\"),\ncol = 4)\nThe re-sampling-based null distribution is almost identical to the theoretical\nnull distribution, which is displayed in red.\nFinally, we implement the plug-in re-sampling FDR approach outlined\nin Algorithm 13.4. Depending on the speed of your computer, calculating\nthe FDR for all 2,308 genes in the Khan dataset may take a while. Hence,\nwe will illustrate the approach on a random subset of 100 genes. For each\ngene, we first compute the observed test statistic, and then produce 10,000\n590 13. Multiple Testing\nre-sampled test statistics. This may take a few minutes to run. If you are\nin a rush, then you could set B equal to a smaller value (e.g. B = 500).\n> m <- 100\n> set.seed (1)\n> index <- sample(ncol(x1), m)\n> Ts <- rep(NA, m)\n> Ts.star <- matrix(NA, ncol = m, nrow = B)\n> for (j in 1:m) {\n+ k <- index[j]\n+ Ts[j] <- t.test(x1[, k], x2[, k],\nvar.equal = TRUE\n)$statistic\n+ for (b in 1:B) {\n+ dat <- sample(c(x1[, k], x2[, k]))\n+ Ts. star [b, j] <- t.test(dat[1:n1],\ndat[(n1 + 1):(n1 + n2)], var.equal = TRUE\n)$statistic\n+ }\n+ }\nNext, we compute the number of rejected null hypotheses R, the estimated\nnumber of false positives WV , and the estimated FDR, for a range of threshold\nvalues c in Algorithm 13.4. The threshold values are chosen using the\nabsolute values of the test statistics from the 100 genes.\n> cs <- sort(abs(Ts))\n> FDRs <- Rs <- Vs <- rep(NA, m)\n> for (j in 1:m) {\n+ R <- sum(abs(Ts) >= cs[j])\n+ V <- sum(abs(Ts.star) >= cs[j]) / B\n+ Rs[j] <- R\n+ Vs[j] <- V\n+", "doc_id": "53f4eaca-59fe-43a5-929f-d38d27a7a4a0", "embedding": null, "doc_hash": "d3d02e3373dd35c42f23893c883908a88b21470ae4f4926982dfb2cc60f76e8e", "extra_info": null, "node_info": {"start": 1330155, "end": 1332790, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "202abd6c-d6bb-45f2-865d-35ab4039e251", "3": "e351551e-68bd-40c0-af02-87294f4fdeaa"}}, "__type__": "1"}, "e351551e-68bd-40c0-af02-87294f4fdeaa": {"__data__": {"text": "Rs[j] <- R\n+ Vs[j] <- V\n+ FDRs[j] <- V / R\n+ }\nNow, for any given FDR, we can find the genes that will be rejected. For\nexample, with the FDR controlled at 0.1, we reject 15 of the 100 null\nhypotheses. On average, we would expect about one or two of these genes\n(i.e. 10% of 15) to be false discoveries. At an FDR of 0.2, we can reject\nthe null hypothesis for 28 genes, of which we expect around six to be\nfalse discoveries. The variable index is needed here since we restricted our\nanalysis to just 100 randomly-selected genes.\n> max(Rs[FDRs <= .1])\n[1] 15\n> sort(index[abs(Ts) >= min(cs[FDRs < .1])])\n[1] 29 465 501 554 573 729 733 1301 1317 1640 1646\n[12] 1706 1799 1942 2159\n> max(Rs[FDRs <= .2])\n[1] 28\n> sort(index[abs(Ts) >= min(cs[FDRs < .2])])\n[1] 29 40 287 361 369 465 501 554 573 679 729\n13.7 Exercises 591\n0 20 40 60 80 100\n0.0 0.2 0.4 0.6 0.8 1.0\nNumber of Rejections\nFalse Discovery Rate\nFIGURE 13.11. The estimated false discovery rate versus the number of rejected\nnull hypotheses, for 100 genes randomly selected from the Khan dataset.\n[12] 733 990 1069 1073 1301 1317 1414 1639 1640 1646 1706\n[23] 1799 1826 1942 1974 2087 2159\nThe next line generates Figure 13.11, which is similar to Figure 13.9, except\nthat it is based on only a subset of the genes.\n> plot(Rs , FDRs , xlab = \"Number of Rejections\", type = \"l\",\nylab = \"False Discovery Rate\", col = 4, lwd = 3)\nAs noted in the chapter, much more efficient implementations of the resampling\napproach to FDR calculation are available, using e.g. the samr\npackage in R.\n13.7 Exercises\nConceptual\n1. Suppose we test m null hypotheses, all of which are true. We control\nthe Type I error for each null hypothesis at level \u03b1. For each subproblem,\njustify your answer.\n(a) In total, how many Type I errors do we expect to make?\n(b) Suppose that the m tests that we perform are independent.\nWhat is the family-wise error rate associated with these m tests?\nHint: If two events A and B are independent, then Pr(A\u2229B) =\nPr(A) Pr(B).\n(c) Suppose that m = 2, and that the p-values for the two tests are\npositively correlated, so that if one is small then the other will\n592 13. Multiple Testing\nNull Hypothesis p-value\nH01 0.0011\nH02 0.031\nH03 0.017\nH04 0.32\nH05 0.11\nH06 0.90\nH07 0.07\nH08 0.006\nH09 0.004\nH10 0.0009\nTABLE 13.4. p-values for Exercise 4 in Section 13.6.\ntend to be small as well, and if one is large then the other will\ntend to be large. How does the family-wise error rate associated\nwith these m = 2 tests qualitatively compare to the answer in\n(b) with m = 2?\nHint: First, suppose that the two p-values are perfectly correlated.\n(d) Suppose again that m = 2, but that now the p-values for the\ntwo tests are negatively correlated, so that if one is large then\nthe other will tend to be small. How does the family-wise error\nrate associated with these m = 2 tests qualitatively compare to\nthe answer in (b) with m = 2?\nHint: First, suppose that whenever one p-value is less than \u03b1,\nthen the other will be greater than \u03b1. In other words, we", "doc_id": "e351551e-68bd-40c0-af02-87294f4fdeaa", "embedding": null, "doc_hash": "d19fd43035085fc1b8af1e3441d5ba0c7281d8f00bacd99a210447c72603f399", "extra_info": null, "node_info": {"start": 1332851, "end": 1335865, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "53f4eaca-59fe-43a5-929f-d38d27a7a4a0", "3": "6d02caea-439a-459a-a693-a491bccfc6b6"}}, "__type__": "1"}, "6d02caea-439a-459a-a693-a491bccfc6b6": {"__data__": {"text": "less than \u03b1,\nthen the other will be greater than \u03b1. In other words, we can\nnever reject both null hypotheses.\n2. Suppose that we test m hypotheses, and control the Type I error for\neach hypothesis at level \u03b1. Assume that all m p-values are independent,\nand that all null hypotheses are true.\n(a) Let the random variable Aj equal 1 if the jth null hypothesis is\nrejected, and 0 otherwise. What is the distribution of Aj?\n(b) What is the distribution of\n)m\nj=1 Aj?\n(c) What is the standard deviation of the number of Type I errors\nthat we will make?\n3. Suppose we test m null hypotheses, and control the Type I error for\nthe jth null hypothesis at level \u03b1j , for j = 1, . . . ,m. Argue that the\nfamily-wise error rate is no greater than\n)m\nj=1 \u03b1j .\n4. Suppose we test m = 10 hypotheses, and obtain the p-values shown\nin Table 13.4.\n13.7 Exercises 593\n(a) Suppose that we wish to control the Type I error for each null\nhypothesis at level \u03b1 = 0.05. Which null hypotheses will we\nreject?\n(b) Now suppose that we wish to control the FWER at level \u03b1 =\n0.05. Which null hypotheses will we reject? Justify your answer.\n(c) Now suppose that we wish to control the FDR at level q = 0.05.\nWhich null hypotheses will we reject? Justify your answer.\n(d) Now suppose that we wish to control the FDR at level q = 0.2.\nWhich null hypotheses will we reject? Justify your answer.\n(e) Of the null hypotheses rejected at FDR level q = 0.2, approximately\nhow many are false positives? Justify your answer.\n5. For this problem, you will make up p-values that lead to a certain\nnumber of rejections using the Bonferroni and Holm procedures.\n(a) Give an example of five p-values (i.e. five numbers between 0 and\n1 which, for the purpose of this problem, we will interpret as pvalues)\nfor which both Bonferroni\u2019s method and Holm\u2019s method\nreject exactly one null hypothesis when controlling the FWER\nat level 0.1.\n(b) Now give an example of five p-values for which Bonferroni rejects\none null hypothesis and Holm rejects more than one null\nhypothesis at level 0.1.\n6. For each of the three panels in Figure 13.3, answer the following\nquestions:\n(a) How many false positives, false negatives, true positives, true\nnegatives, Type I errors, and Type II errors result from applying\nthe Bonferroni procedure to control the FWER at level \u03b1 =\n0.05?\n(b) How many false positives, false negatives, true positives, true\nnegatives, Type I errors, and Type II errors result from applying\nthe Holm procedure to control the FWER at level \u03b1 = 0.05?\n(c) What is the false discovery rate associated with using the Bonferroni\nprocedure to control the FWER at level \u03b1 = 0.05?\n(d) What is the false discovery rate associated with using the Holm\nprocedure to control the FWER at level \u03b1 = 0.05?\n(e) How would the answers to (a) and (c) change if we instead used\nthe Bonferroni procedure to control the FWER at level \u03b1 =\n0.001?\n594 13. Multiple Testing\nApplied\n7. This problem makes use of the Carseats dataset in the ISLR2 package.\n(a) For each quantitative variable in the dataset besides Sales, fit\na linear model to predict Sales using that quantitative variable.\nReport the p-values associated with the coefficients for the variables.\nThat is, for each model of the form Y = \u03b20 + \u03b21X + \u03f5,\nreport the p-value associated with the coefficient \u03b21. Here, Y\nrepresents Sales and X represents one of the other", "doc_id": "6d02caea-439a-459a-a693-a491bccfc6b6", "embedding": null, "doc_hash": "dfe0270a564449e2c543b5c9f562bf4bc873ea497a055d830d7100fdf4f71ccd", "extra_info": null, "node_info": {"start": 1335829, "end": 1339189, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "e351551e-68bd-40c0-af02-87294f4fdeaa", "3": "c2f41606-0ecc-48d6-b0a0-175e07b78aa8"}}, "__type__": "1"}, "c2f41606-0ecc-48d6-b0a0-175e07b78aa8": {"__data__": {"text": "coefficient \u03b21. Here, Y\nrepresents Sales and X represents one of the other quantitative\nvariables.\n(b) Suppose we control the Type I error at level \u03b1 = 0.05 for the\np-values obtained in (a). Which null hypotheses do we reject?\n(c) Now suppose we control the FWER at level 0.05 for the p-values.\nWhich null hypotheses do we reject?\n(d) Finally, suppose we control the FDR at level 0.2 for the p-values.\nWhich null hypotheses do we reject?\n8. In this problem, we will simulate data from m = 100 fund managers.\n> set.seed (1)\n> n <- 20\n> m <- 100\n> X <- matrix(rnorm(n * m), ncol = m)\nThese data represent each fund manager\u2019s percentage returns for each\nof n = 20 months. We wish to test the null hypothesis that each\nfund manager\u2019s percentage returns have population mean equal to\nzero. Notice that we simulated the data in such a way that each fund\nmanager\u2019s percentage returns do have population mean zero; in other\nwords, all m null hypotheses are true.\n(a) Conduct a one-sample t-test for each fund manager, and plot a\nhistogram of the p-values obtained.\n(b) If we control Type I error for each null hypothesis at level \u03b1 =\n0.05, then how many null hypotheses do we reject?\n(c) If we control the FWER at level 0.05, then how many null hypotheses\ndo we reject?\n(d) If we control the FDR at level 0.05, then how many null hypotheses\ndo we reject?\n(e) Now suppose we \u201ccherry-pick\u201d the 10 fund managers who perform\nthe best in our data. If we control the FWER for just these\n10 fund managers at level 0.05, then how many null hypotheses\ndo we reject? If we control the FDR for just these 10 fund\nmanagers at level 0.05, then how many null hypotheses do we\nreject?\n13.7 Exercises 595\n(f) Explain why the analysis in (e) is misleading.\nHint: The standard approaches for controlling the FWER and\nFDR assume that all tested null hypotheses are adjusted for multiplicity,\nand that no \u201ccherry-picking\u201d of the smallest p-values\nhas occurred. What goes wrong if we cherry-pick?\n", "doc_id": "c2f41606-0ecc-48d6-b0a0-175e07b78aa8", "embedding": null, "doc_hash": "bc6ce989fe51ebfa298416de0bf5640796fdd6943622198354095a197d8b15ac", "extra_info": null, "node_info": {"start": 1339172, "end": 1341140, "_node_type": "1"}, "relationships": {"1": "a2db4d93-478d-41f9-854e-ac00ecdc385e", "2": "6d02caea-439a-459a-a693-a491bccfc6b6"}}, "__type__": "1"}}}